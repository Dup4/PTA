{"config":{"indexing":"full","lang":["ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"CCCC/L1-001-Hello%20World/","text":"L1-001 Hello World Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8457\u540d\u77ed\u53e5\u201cHello World!\u201d\u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Hello World! Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"Hello World! \\n \" ; }","title":"L1-001-Hello World"},{"location":"CCCC/L1-001-Hello%20World/#l1-001-hello-world","text":"","title":"L1-001 Hello World"},{"location":"CCCC/L1-001-Hello%20World/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8457\u540d\u77ed\u53e5\u201cHello World!\u201d\u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Hello World!","title":"Statement"},{"location":"CCCC/L1-001-Hello%20World/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"Hello World! \\n \" ; }","title":"Solution"},{"location":"CCCC/L1-002-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/","text":"L1-002 \u6253\u5370\u6c99\u6f0f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u628a\u7ed9\u5b9a\u7684\u7b26\u53f7\u6253\u5370\u6210\u6c99\u6f0f\u7684\u5f62\u72b6\u3002\u4f8b\u5982\u7ed9\u5b9a17\u4e2a\u201c*\u201d\uff0c\u8981\u6c42\u6309\u4e0b\u5217\u683c\u5f0f\u6253\u5370 ***** *** * *** ***** \u6240\u8c13\u201c\u6c99\u6f0f\u5f62\u72b6\u201d\uff0c\u662f\u6307\u6bcf\u884c\u8f93\u51fa\u5947\u6570\u4e2a\u7b26\u53f7\uff1b\u5404\u884c\u7b26\u53f7\u4e2d\u5fc3\u5bf9\u9f50\uff1b\u76f8\u90bb\u4e24\u884c\u7b26\u53f7\u6570\u5dee2\uff1b\u7b26\u53f7\u6570\u5148\u4ece\u5927\u5230\u5c0f\u987a\u5e8f\u9012\u51cf\u52301\uff0c\u518d\u4ece\u5c0f\u5230\u5927\u987a\u5e8f\u9012\u589e\uff1b\u9996\u5c3e\u7b26\u53f7\u6570\u76f8\u7b49\u3002 \u7ed9\u5b9a\u4efb\u610fN\u4e2a\u7b26\u53f7\uff0c\u4e0d\u4e00\u5b9a\u80fd\u6b63\u597d\u7ec4\u6210\u4e00\u4e2a\u6c99\u6f0f\u3002\u8981\u6c42\u6253\u5370\u51fa\u7684\u6c99\u6f0f\u80fd\u7528\u6389\u5c3d\u53ef\u80fd\u591a\u7684\u7b26\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa1\u4e2a\u6b63\u6574\u6570N\uff08 \\le \\le 1000\uff09\u548c\u4e00\u4e2a\u7b26\u53f7\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6253\u5370\u51fa\u7531\u7ed9\u5b9a\u7b26\u53f7\u7ec4\u6210\u7684\u6700\u5927\u7684\u6c99\u6f0f\u5f62\u72b6\uff0c\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5269\u4e0b\u6ca1\u7528\u6389\u7684\u7b26\u53f7\u6570\u3002 \u8f93\u5165\u6837\u4f8b 19 * \u8f93\u51fa\u6837\u4f8b ***** *** * *** ***** 2 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 * 5 + 5 ; const int MOD = 1e9 + 7 ; int a [ 23 ] = { 1 }; char c ; void print ( int n , int cur ) { if ( n == 1 ) { while ( cur -- ) printf ( \" \" ); printf ( \"%c \\n \" , c ); } else { for ( int i = 0 ; i < cur ; i ++ ) printf ( \" \" ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); print ( n - 2 , cur + 1 ); for ( int i = 0 ; i < cur ; i ++ ) printf ( \" \" ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } } int main () { int i , j ; for ( i = 1 , j = 3 ; i < 23 ; i ++ , j += 2 ) a [ i ] += j * 2 + a [ i - 1 ]; int n ; scanf ( \"%d %c\" , & n , & c ); int vis ; for ( i = 0 ; i < 23 ; i ++ ) { if ( a [ i ] > n ) { vis = i - 1 ; break ; } else if ( a [ i ] == n ) { vis = i ; break ; } } print (( vis + 1 ) * 2 - 1 , 0 ); cout << n - a [ vis ] << endl ; }","title":"L1-002-\u6253\u5370\u6c99\u6f0f"},{"location":"CCCC/L1-002-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#l1-002-\u6253\u5370\u6c99\u6f0f","text":"","title":"L1-002 \u6253\u5370\u6c99\u6f0f"},{"location":"CCCC/L1-002-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u628a\u7ed9\u5b9a\u7684\u7b26\u53f7\u6253\u5370\u6210\u6c99\u6f0f\u7684\u5f62\u72b6\u3002\u4f8b\u5982\u7ed9\u5b9a17\u4e2a\u201c*\u201d\uff0c\u8981\u6c42\u6309\u4e0b\u5217\u683c\u5f0f\u6253\u5370 ***** *** * *** ***** \u6240\u8c13\u201c\u6c99\u6f0f\u5f62\u72b6\u201d\uff0c\u662f\u6307\u6bcf\u884c\u8f93\u51fa\u5947\u6570\u4e2a\u7b26\u53f7\uff1b\u5404\u884c\u7b26\u53f7\u4e2d\u5fc3\u5bf9\u9f50\uff1b\u76f8\u90bb\u4e24\u884c\u7b26\u53f7\u6570\u5dee2\uff1b\u7b26\u53f7\u6570\u5148\u4ece\u5927\u5230\u5c0f\u987a\u5e8f\u9012\u51cf\u52301\uff0c\u518d\u4ece\u5c0f\u5230\u5927\u987a\u5e8f\u9012\u589e\uff1b\u9996\u5c3e\u7b26\u53f7\u6570\u76f8\u7b49\u3002 \u7ed9\u5b9a\u4efb\u610fN\u4e2a\u7b26\u53f7\uff0c\u4e0d\u4e00\u5b9a\u80fd\u6b63\u597d\u7ec4\u6210\u4e00\u4e2a\u6c99\u6f0f\u3002\u8981\u6c42\u6253\u5370\u51fa\u7684\u6c99\u6f0f\u80fd\u7528\u6389\u5c3d\u53ef\u80fd\u591a\u7684\u7b26\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa1\u4e2a\u6b63\u6574\u6570N\uff08 \\le \\le 1000\uff09\u548c\u4e00\u4e2a\u7b26\u53f7\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6253\u5370\u51fa\u7531\u7ed9\u5b9a\u7b26\u53f7\u7ec4\u6210\u7684\u6700\u5927\u7684\u6c99\u6f0f\u5f62\u72b6\uff0c\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5269\u4e0b\u6ca1\u7528\u6389\u7684\u7b26\u53f7\u6570\u3002 \u8f93\u5165\u6837\u4f8b 19 * \u8f93\u51fa\u6837\u4f8b ***** *** * *** ***** 2","title":"Statement"},{"location":"CCCC/L1-002-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 * 5 + 5 ; const int MOD = 1e9 + 7 ; int a [ 23 ] = { 1 }; char c ; void print ( int n , int cur ) { if ( n == 1 ) { while ( cur -- ) printf ( \" \" ); printf ( \"%c \\n \" , c ); } else { for ( int i = 0 ; i < cur ; i ++ ) printf ( \" \" ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); print ( n - 2 , cur + 1 ); for ( int i = 0 ; i < cur ; i ++ ) printf ( \" \" ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } } int main () { int i , j ; for ( i = 1 , j = 3 ; i < 23 ; i ++ , j += 2 ) a [ i ] += j * 2 + a [ i - 1 ]; int n ; scanf ( \"%d %c\" , & n , & c ); int vis ; for ( i = 0 ; i < 23 ; i ++ ) { if ( a [ i ] > n ) { vis = i - 1 ; break ; } else if ( a [ i ] == n ) { vis = i ; break ; } } print (( vis + 1 ) * 2 - 1 , 0 ); cout << n - a [ vis ] << endl ; }","title":"Solution"},{"location":"CCCC/L1-003-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/","text":"L1-003 \u4e2a\u4f4d\u6570\u7edf\u8ba1 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k k \u4f4d\u6574\u6570 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 ( 0\\le d_i \\le 9 0\\le d_i \\le 9 , i=0,\\cdots ,k-1 i=0,\\cdots ,k-1 , d_{k-1}>0 d_{k-1}>0 )\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u7edf\u8ba1\u6bcf\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a N = 100311 N = 100311 \uff0c\u5219\u6709 2 \u4e2a 0\uff0c3 \u4e2a 1\uff0c\u548c 1 \u4e2a 3\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9 N N \u4e2d\u6bcf\u4e00\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u4ee5 D:M \u7684\u683c\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u4f4d\u6570\u5b57 D \u53ca\u5176\u5728 N N \u4e2d\u51fa\u73b0\u7684\u6b21\u6570 M \u3002\u8981\u6c42\u6309 D \u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 100311 \u8f93\u51fa\u6837\u4f8b 0:2 1:3 3:1 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); map < char , int > m ; m . clear (); for ( int i = 0 ; i < len ; i ++ ) { m [ s [ i ]] ++ ; } map < char , int >:: iterator it ; for ( it = m . begin (); it != m . end (); it ++ ) cout << it -> first << \":\" << it -> second << endl ; }","title":"L1-003-\u4e2a\u4f4d\u6570\u7edf\u8ba1"},{"location":"CCCC/L1-003-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#l1-003-\u4e2a\u4f4d\u6570\u7edf\u8ba1","text":"","title":"L1-003 \u4e2a\u4f4d\u6570\u7edf\u8ba1"},{"location":"CCCC/L1-003-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k k \u4f4d\u6574\u6570 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 ( 0\\le d_i \\le 9 0\\le d_i \\le 9 , i=0,\\cdots ,k-1 i=0,\\cdots ,k-1 , d_{k-1}>0 d_{k-1}>0 )\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u7edf\u8ba1\u6bcf\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a N = 100311 N = 100311 \uff0c\u5219\u6709 2 \u4e2a 0\uff0c3 \u4e2a 1\uff0c\u548c 1 \u4e2a 3\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9 N N \u4e2d\u6bcf\u4e00\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u4ee5 D:M \u7684\u683c\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u4f4d\u6570\u5b57 D \u53ca\u5176\u5728 N N \u4e2d\u51fa\u73b0\u7684\u6b21\u6570 M \u3002\u8981\u6c42\u6309 D \u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 100311 \u8f93\u51fa\u6837\u4f8b 0:2 1:3 3:1","title":"Statement"},{"location":"CCCC/L1-003-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); map < char , int > m ; m . clear (); for ( int i = 0 ; i < len ; i ++ ) { m [ s [ i ]] ++ ; } map < char , int >:: iterator it ; for ( it = m . begin (); it != m . end (); it ++ ) cout << it -> first << \":\" << it -> second << endl ; }","title":"Solution"},{"location":"CCCC/L1-004-%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/","text":"L1-004 \u8ba1\u7b97\u6444\u6c0f\u6e29\u5ea6 Statement Metadata \u4f5c\u8005: \u9648\u5efa\u6d77 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u534e\u6c0f\u6e29\u5ea6 F F \uff0c\u672c\u9898\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\uff0c\u8ba1\u7b97\u5bf9\u5e94\u7684\u6444\u6c0f\u6e29\u5ea6 C C \u3002\u8ba1\u7b97\u516c\u5f0f\uff1a C = 5\\times (F-32)/9 C = 5\\times (F-32)/9 \u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u4e0e\u8f93\u51fa\u5747\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u534e\u6c0f\u6e29\u5ea6\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u683c\u5f0f\u201cCelsius = C\u201d\u8f93\u51fa\u5bf9\u5e94\u7684\u6444\u6c0f\u6e29\u5ea6C\u7684\u6574\u6570\u503c\u3002 \u8f93\u5165\u6837\u4f8b 150 \u8f93\u51fa\u6837\u4f8b Celsius = 65 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"Celsius = %d \\n \" , ( int )( 5.0 * ( n - 32 ) / 9 )); }","title":"L1-004-\u8ba1\u7b97\u6444\u6c0f\u6e29\u5ea6"},{"location":"CCCC/L1-004-%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/#l1-004-\u8ba1\u7b97\u6444\u6c0f\u6e29\u5ea6","text":"","title":"L1-004 \u8ba1\u7b97\u6444\u6c0f\u6e29\u5ea6"},{"location":"CCCC/L1-004-%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u5efa\u6d77 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u534e\u6c0f\u6e29\u5ea6 F F \uff0c\u672c\u9898\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\uff0c\u8ba1\u7b97\u5bf9\u5e94\u7684\u6444\u6c0f\u6e29\u5ea6 C C \u3002\u8ba1\u7b97\u516c\u5f0f\uff1a C = 5\\times (F-32)/9 C = 5\\times (F-32)/9 \u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u4e0e\u8f93\u51fa\u5747\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u534e\u6c0f\u6e29\u5ea6\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u683c\u5f0f\u201cCelsius = C\u201d\u8f93\u51fa\u5bf9\u5e94\u7684\u6444\u6c0f\u6e29\u5ea6C\u7684\u6574\u6570\u503c\u3002 \u8f93\u5165\u6837\u4f8b 150 \u8f93\u51fa\u6837\u4f8b Celsius = 65","title":"Statement"},{"location":"CCCC/L1-004-%E8%AE%A1%E7%AE%97%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"Celsius = %d \\n \" , ( int )( 5.0 * ( n - 32 ) / 9 )); }","title":"Solution"},{"location":"CCCC/L1-005-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/","text":"L1-005 \u8003\u8bd5\u5ea7\u4f4d\u53f7 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u4e2a PAT \u8003\u751f\u5728\u53c2\u52a0\u8003\u8bd5\u65f6\u90fd\u4f1a\u88ab\u5206\u914d\u4e24\u4e2a\u5ea7\u4f4d\u53f7\uff0c\u4e00\u4e2a\u662f\u8bd5\u673a\u5ea7\u4f4d\uff0c\u4e00\u4e2a\u662f\u8003\u8bd5\u5ea7\u4f4d\u3002\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u8003\u751f\u5728\u5165\u573a\u65f6\u5148\u5f97\u5230\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5165\u5ea7\u8fdb\u5165\u8bd5\u673a\u72b6\u6001\u540e\uff0c\u7cfb\u7edf\u4f1a\u663e\u793a\u8be5\u8003\u751f\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u8003\u8bd5\u65f6\u8003\u751f\u9700\u8981\u6362\u5230\u8003\u8bd5\u5ea7\u4f4d\u5c31\u5ea7\u3002\u4f46\u6709\u4e9b\u8003\u751f\u8fdf\u5230\u4e86\uff0c\u8bd5\u673a\u5df2\u7ecf\u7ed3\u675f\uff0c\u4ed6\u4eec\u53ea\u80fd\u62ff\u7740\u9886\u5230\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\u6c42\u52a9\u4e8e\u4f60\uff0c\u4ece\u540e\u53f0\u67e5\u51fa\u4ed6\u4eec\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u8bd5\u673a\u5ea7\u4f4d\u53f7 \u8003\u8bd5\u5ea7\u4f4d\u53f7 \u3002\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u7531 16 \u4f4d\u6570\u5b57\u7ec4\u6210\uff0c\u5ea7\u4f4d\u4ece 1 \u5230 N N \u7f16\u53f7\u3002\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u7684\u51c6\u8003\u8bc1\u53f7\u90fd\u4e0d\u540c\uff0c\u5e76\u4e14\u4efb\u4f55\u65f6\u5019\u90fd\u4e0d\u4f1a\u628a\u4e24\u4e2a\u4eba\u5206\u914d\u5230\u540c\u4e00\u4e2a\u5ea7\u4f4d\u4e0a\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le N \\le N \uff09\uff0c\u968f\u540e\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u4e2a\u5f85\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u6bcf\u4e2a\u9700\u8981\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u4e2d\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 \u8f93\u51fa\u6837\u4f8b 3310120150912002 2 3310120150912119 1 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct node { int num ; string ID ; } temp ; int main () { int n ; int i ; int vis ; map < int , node > m ; m . clear (); cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> temp . ID ; scanf ( \"%d%d\" , & vis , & temp . num ); m [ vis ] = temp ; } cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & vis ); cout << m [ vis ]. ID << \" \" << m [ vis ]. num << endl ; } }","title":"L1-005-\u8003\u8bd5\u5ea7\u4f4d\u53f7"},{"location":"CCCC/L1-005-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#l1-005-\u8003\u8bd5\u5ea7\u4f4d\u53f7","text":"","title":"L1-005 \u8003\u8bd5\u5ea7\u4f4d\u53f7"},{"location":"CCCC/L1-005-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u4e2a PAT \u8003\u751f\u5728\u53c2\u52a0\u8003\u8bd5\u65f6\u90fd\u4f1a\u88ab\u5206\u914d\u4e24\u4e2a\u5ea7\u4f4d\u53f7\uff0c\u4e00\u4e2a\u662f\u8bd5\u673a\u5ea7\u4f4d\uff0c\u4e00\u4e2a\u662f\u8003\u8bd5\u5ea7\u4f4d\u3002\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u8003\u751f\u5728\u5165\u573a\u65f6\u5148\u5f97\u5230\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5165\u5ea7\u8fdb\u5165\u8bd5\u673a\u72b6\u6001\u540e\uff0c\u7cfb\u7edf\u4f1a\u663e\u793a\u8be5\u8003\u751f\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u8003\u8bd5\u65f6\u8003\u751f\u9700\u8981\u6362\u5230\u8003\u8bd5\u5ea7\u4f4d\u5c31\u5ea7\u3002\u4f46\u6709\u4e9b\u8003\u751f\u8fdf\u5230\u4e86\uff0c\u8bd5\u673a\u5df2\u7ecf\u7ed3\u675f\uff0c\u4ed6\u4eec\u53ea\u80fd\u62ff\u7740\u9886\u5230\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\u6c42\u52a9\u4e8e\u4f60\uff0c\u4ece\u540e\u53f0\u67e5\u51fa\u4ed6\u4eec\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u8bd5\u673a\u5ea7\u4f4d\u53f7 \u8003\u8bd5\u5ea7\u4f4d\u53f7 \u3002\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u7531 16 \u4f4d\u6570\u5b57\u7ec4\u6210\uff0c\u5ea7\u4f4d\u4ece 1 \u5230 N N \u7f16\u53f7\u3002\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u7684\u51c6\u8003\u8bc1\u53f7\u90fd\u4e0d\u540c\uff0c\u5e76\u4e14\u4efb\u4f55\u65f6\u5019\u90fd\u4e0d\u4f1a\u628a\u4e24\u4e2a\u4eba\u5206\u914d\u5230\u540c\u4e00\u4e2a\u5ea7\u4f4d\u4e0a\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le N \\le N \uff09\uff0c\u968f\u540e\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u4e2a\u5f85\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u6bcf\u4e2a\u9700\u8981\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u4e2d\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 \u8f93\u51fa\u6837\u4f8b 3310120150912002 2 3310120150912119 1","title":"Statement"},{"location":"CCCC/L1-005-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct node { int num ; string ID ; } temp ; int main () { int n ; int i ; int vis ; map < int , node > m ; m . clear (); cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> temp . ID ; scanf ( \"%d%d\" , & vis , & temp . num ); m [ vis ] = temp ; } cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & vis ); cout << m [ vis ]. ID << \" \" << m [ vis ]. num << endl ; } }","title":"Solution"},{"location":"CCCC/L1-006-%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/","text":"L1-006 \u8fde\u7eed\u56e0\u5b50 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6b63\u6574\u6570 N N \u7684\u56e0\u5b50\u4e2d\u53ef\u80fd\u5b58\u5728\u82e5\u5e72\u8fde\u7eed\u7684\u6570\u5b57\u3002\u4f8b\u5982 630 \u53ef\u4ee5\u5206\u89e3\u4e3a 3 \\times \\times 5 \\times \\times 6 \\times \\times 7\uff0c\u5176\u4e2d 5\u30016\u30017 \u5c31\u662f 3 \u4e2a\u8fde\u7eed\u7684\u6570\u5b57\u3002\u7ed9\u5b9a\u4efb\u4e00\u6b63\u6574\u6570 N N \uff0c\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\u6c42\u51fa\u6700\u957f\u8fde\u7eed\u56e0\u5b50\u7684\u4e2a\u6570\uff0c\u5e76\u8f93\u51fa\u6700\u5c0f\u7684\u8fde\u7eed\u56e0\u5b50\u5e8f\u5217\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1<N<2^{31} 1<N<2^{31} \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c 1 \u884c\u8f93\u51fa\u6700\u957f\u8fde\u7eed\u56e0\u5b50\u7684\u4e2a\u6570\uff1b\u7136\u540e\u5728\u7b2c 2 \u884c\u4e2d\u6309 \u56e0\u5b501*\u56e0\u5b502*\u2026\u2026*\u56e0\u5b50k \u7684\u683c\u5f0f\u8f93\u51fa\u6700\u5c0f\u7684\u8fde\u7eed\u56e0\u5b50\u5e8f\u5217\uff0c\u5176\u4e2d\u56e0\u5b50\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\uff0c1 \u4e0d\u7b97\u5728\u5185\u3002 \u8f93\u5165\u6837\u4f8b 630 \u8f93\u51fa\u6837\u4f8b 3 5*6*7 \u9e23\u8c22\u7528\u6237 \u6f0f\u7a7f\u96ea \u8865\u5145\u6570\u636e\uff01 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int a [ maxn ]; int main () { int n ; cin >> n ; int i , j ; int vis = sqrt ( n ) + 1 ; memset ( a , 0 , sizeof ( a )); int temp ; for ( i = 2 , j = 0 ; i <= vis ; i ++ ) { if ( n % i == 0 ) a [ j ++ ] = i ; } int len = j ; int max = 0 , ans ; LL sum ; for ( i = 0 ; i < len ; i ++ ) { sum = a [ i ]; vis = 1 ; for ( j = 1 ;; j ++ ) { sum *= ( a [ i ] + j ); if ( n % sum != 0 ) break ; else vis ++ ; } if ( vis > max ) { max = vis ; ans = a [ i ]; } } if ( len == 0 ) { cout << 1 << endl ; cout << n << endl ; } else { printf ( \"%d \\n \" , max ); for ( i = 0 ; i < max ; i ++ ) { if ( i ) printf ( \"*\" ); printf ( \"%d\" , ans + i ); } cout << endl ; } }","title":"L1-006-\u8fde\u7eed\u56e0\u5b50"},{"location":"CCCC/L1-006-%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/#l1-006-\u8fde\u7eed\u56e0\u5b50","text":"","title":"L1-006 \u8fde\u7eed\u56e0\u5b50"},{"location":"CCCC/L1-006-%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6b63\u6574\u6570 N N \u7684\u56e0\u5b50\u4e2d\u53ef\u80fd\u5b58\u5728\u82e5\u5e72\u8fde\u7eed\u7684\u6570\u5b57\u3002\u4f8b\u5982 630 \u53ef\u4ee5\u5206\u89e3\u4e3a 3 \\times \\times 5 \\times \\times 6 \\times \\times 7\uff0c\u5176\u4e2d 5\u30016\u30017 \u5c31\u662f 3 \u4e2a\u8fde\u7eed\u7684\u6570\u5b57\u3002\u7ed9\u5b9a\u4efb\u4e00\u6b63\u6574\u6570 N N \uff0c\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\u6c42\u51fa\u6700\u957f\u8fde\u7eed\u56e0\u5b50\u7684\u4e2a\u6570\uff0c\u5e76\u8f93\u51fa\u6700\u5c0f\u7684\u8fde\u7eed\u56e0\u5b50\u5e8f\u5217\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1<N<2^{31} 1<N<2^{31} \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c 1 \u884c\u8f93\u51fa\u6700\u957f\u8fde\u7eed\u56e0\u5b50\u7684\u4e2a\u6570\uff1b\u7136\u540e\u5728\u7b2c 2 \u884c\u4e2d\u6309 \u56e0\u5b501*\u56e0\u5b502*\u2026\u2026*\u56e0\u5b50k \u7684\u683c\u5f0f\u8f93\u51fa\u6700\u5c0f\u7684\u8fde\u7eed\u56e0\u5b50\u5e8f\u5217\uff0c\u5176\u4e2d\u56e0\u5b50\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\uff0c1 \u4e0d\u7b97\u5728\u5185\u3002 \u8f93\u5165\u6837\u4f8b 630 \u8f93\u51fa\u6837\u4f8b 3 5*6*7 \u9e23\u8c22\u7528\u6237 \u6f0f\u7a7f\u96ea \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"CCCC/L1-006-%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int a [ maxn ]; int main () { int n ; cin >> n ; int i , j ; int vis = sqrt ( n ) + 1 ; memset ( a , 0 , sizeof ( a )); int temp ; for ( i = 2 , j = 0 ; i <= vis ; i ++ ) { if ( n % i == 0 ) a [ j ++ ] = i ; } int len = j ; int max = 0 , ans ; LL sum ; for ( i = 0 ; i < len ; i ++ ) { sum = a [ i ]; vis = 1 ; for ( j = 1 ;; j ++ ) { sum *= ( a [ i ] + j ); if ( n % sum != 0 ) break ; else vis ++ ; } if ( vis > max ) { max = vis ; ans = a [ i ]; } } if ( len == 0 ) { cout << 1 << endl ; cout << n << endl ; } else { printf ( \"%d \\n \" , max ); for ( i = 0 ; i < max ; i ++ ) { if ( i ) printf ( \"*\" ); printf ( \"%d\" , ans + i ); } cout << endl ; } }","title":"Solution"},{"location":"CCCC/L1-007-%E5%BF%B5%E6%95%B0%E5%AD%97/","text":"L1-007 \u5ff5\u6570\u5b57 Statement Metadata \u4f5c\u8005: \u7fc1\u607a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u8f93\u51fa\u6bcf\u4e2a\u6570\u5b57\u5bf9\u5e94\u7684\u62fc\u97f3\u3002\u5f53\u6574\u6570\u4e3a\u8d1f\u6570\u65f6\uff0c\u5148\u8f93\u51fa fu \u5b57\u3002\u5341\u4e2a\u6570\u5b57\u5bf9\u5e94\u7684\u62fc\u97f3\u5982\u4e0b\uff1a 0: ling 1: yi 2: er 3: san 4: si 5: wu 6: liu 7: qi 8: ba 9: jiu \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u5982\uff1a 1234 \u3002 \u63d0\u793a\uff1a\u6574\u6570\u5305\u62ec\u8d1f\u6570\u3001\u96f6\u548c\u6b63\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd9\u4e2a\u6574\u6570\u5bf9\u5e94\u7684\u62fc\u97f3\uff0c\u6bcf\u4e2a\u6570\u5b57\u7684\u62fc\u97f3\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u884c\u672b\u6ca1\u6709\u6700\u540e\u7684\u7a7a\u683c\u3002\u5982 yi er san si \u3002 \u8f93\u5165\u6837\u4f8b -600 \u8f93\u51fa\u6837\u4f8b fu liu ling ling Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < char , string > m ; m . clear (); m [ '0' ] = \"ling\" ; m [ '1' ] = \"yi\" ; m [ '2' ] = \"er\" ; m [ '3' ] = \"san\" ; m [ '4' ] = \"si\" ; m [ '5' ] = \"wu\" ; m [ '6' ] = \"liu\" ; m [ '7' ] = \"qi\" ; m [ '8' ] = \"ba\" ; m [ '9' ] = \"jiu\" ; m [ '-' ] = \"fu\" ; string s ; cin >> s ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) { if ( i ) cout << \" \" ; cout << m [ s [ i ]]; } cout << endl ; }","title":"L1-007-\u5ff5\u6570\u5b57"},{"location":"CCCC/L1-007-%E5%BF%B5%E6%95%B0%E5%AD%97/#l1-007-\u5ff5\u6570\u5b57","text":"","title":"L1-007 \u5ff5\u6570\u5b57"},{"location":"CCCC/L1-007-%E5%BF%B5%E6%95%B0%E5%AD%97/#statement","text":"Metadata \u4f5c\u8005: \u7fc1\u607a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u8f93\u51fa\u6bcf\u4e2a\u6570\u5b57\u5bf9\u5e94\u7684\u62fc\u97f3\u3002\u5f53\u6574\u6570\u4e3a\u8d1f\u6570\u65f6\uff0c\u5148\u8f93\u51fa fu \u5b57\u3002\u5341\u4e2a\u6570\u5b57\u5bf9\u5e94\u7684\u62fc\u97f3\u5982\u4e0b\uff1a 0: ling 1: yi 2: er 3: san 4: si 5: wu 6: liu 7: qi 8: ba 9: jiu \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u5982\uff1a 1234 \u3002 \u63d0\u793a\uff1a\u6574\u6570\u5305\u62ec\u8d1f\u6570\u3001\u96f6\u548c\u6b63\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd9\u4e2a\u6574\u6570\u5bf9\u5e94\u7684\u62fc\u97f3\uff0c\u6bcf\u4e2a\u6570\u5b57\u7684\u62fc\u97f3\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u884c\u672b\u6ca1\u6709\u6700\u540e\u7684\u7a7a\u683c\u3002\u5982 yi er san si \u3002 \u8f93\u5165\u6837\u4f8b -600 \u8f93\u51fa\u6837\u4f8b fu liu ling ling","title":"Statement"},{"location":"CCCC/L1-007-%E5%BF%B5%E6%95%B0%E5%AD%97/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < char , string > m ; m . clear (); m [ '0' ] = \"ling\" ; m [ '1' ] = \"yi\" ; m [ '2' ] = \"er\" ; m [ '3' ] = \"san\" ; m [ '4' ] = \"si\" ; m [ '5' ] = \"wu\" ; m [ '6' ] = \"liu\" ; m [ '7' ] = \"qi\" ; m [ '8' ] = \"ba\" ; m [ '9' ] = \"jiu\" ; m [ '-' ] = \"fu\" ; string s ; cin >> s ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) { if ( i ) cout << \" \" ; cout << m [ s [ i ]]; } cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-008-%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/","text":"L1-008 \u6c42\u6574\u6570\u6bb5\u548c Statement Metadata \u4f5c\u8005: \u6768\u8d77\u5e06 \u5355\u4f4d: \u6d59\u5927\u57ce\u5e02\u5b66\u9662 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff0c\u8f93\u51fa\u4ece A A \u5230 B B \u7684\u6240\u6709\u6574\u6570\u4ee5\u53ca\u8fd9\u4e9b\u6570\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa2\u4e2a\u6574\u6570 A A \u548c B B \uff0c\u5176\u4e2d -100\\le A\\le B\\le 100 -100\\le A\\le B\\le 100 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u987a\u5e8f\u8f93\u51fa\u4ece A A \u5230 B B \u7684\u6240\u6709\u6574\u6570\uff0c\u6bcf5\u4e2a\u6570\u5b57\u5360\u4e00\u884c\uff0c\u6bcf\u4e2a\u6570\u5b57\u53605\u4e2a\u5b57\u7b26\u5bbd\u5ea6\uff0c\u5411\u53f3\u5bf9\u9f50\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u6309 Sum = X \u7684\u683c\u5f0f\u8f93\u51fa\u5168\u90e8\u6570\u5b57\u7684\u548c X \u3002 \u8f93\u5165\u6837\u4f8b -3 8 \u8f93\u51fa\u6837\u4f8b -3 -2 -1 0 1 2 3 4 5 6 7 8 Sum = 30 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; int sum = 0 ; int vis ; for ( vis = 1 ; a <= b ; a ++ , vis ++ ) { printf ( \"%5d\" , a ); sum += a ; if ( vis % 5 == 0 ) cout << endl ; } if (( vis - 1 ) % 5 != 0 ) cout << endl ; printf ( \"Sum = %d \\n \" , sum ); }","title":"L1-008-\u6c42\u6574\u6570\u6bb5\u548c"},{"location":"CCCC/L1-008-%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/#l1-008-\u6c42\u6574\u6570\u6bb5\u548c","text":"","title":"L1-008 \u6c42\u6574\u6570\u6bb5\u548c"},{"location":"CCCC/L1-008-%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/#statement","text":"Metadata \u4f5c\u8005: \u6768\u8d77\u5e06 \u5355\u4f4d: \u6d59\u5927\u57ce\u5e02\u5b66\u9662 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff0c\u8f93\u51fa\u4ece A A \u5230 B B \u7684\u6240\u6709\u6574\u6570\u4ee5\u53ca\u8fd9\u4e9b\u6570\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa2\u4e2a\u6574\u6570 A A \u548c B B \uff0c\u5176\u4e2d -100\\le A\\le B\\le 100 -100\\le A\\le B\\le 100 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u987a\u5e8f\u8f93\u51fa\u4ece A A \u5230 B B \u7684\u6240\u6709\u6574\u6570\uff0c\u6bcf5\u4e2a\u6570\u5b57\u5360\u4e00\u884c\uff0c\u6bcf\u4e2a\u6570\u5b57\u53605\u4e2a\u5b57\u7b26\u5bbd\u5ea6\uff0c\u5411\u53f3\u5bf9\u9f50\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u6309 Sum = X \u7684\u683c\u5f0f\u8f93\u51fa\u5168\u90e8\u6570\u5b57\u7684\u548c X \u3002 \u8f93\u5165\u6837\u4f8b -3 8 \u8f93\u51fa\u6837\u4f8b -3 -2 -1 0 1 2 3 4 5 6 7 8 Sum = 30","title":"Statement"},{"location":"CCCC/L1-008-%E6%B1%82%E6%95%B4%E6%95%B0%E6%AE%B5%E5%92%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; int sum = 0 ; int vis ; for ( vis = 1 ; a <= b ; a ++ , vis ++ ) { printf ( \"%5d\" , a ); sum += a ; if ( vis % 5 == 0 ) cout << endl ; } if (( vis - 1 ) % 5 != 0 ) cout << endl ; printf ( \"Sum = %d \\n \" , sum ); }","title":"Solution"},{"location":"CCCC/L1-009-N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/","text":"L1-009 N\u4e2a\u6570\u6c42\u548c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u8981\u6c42\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6c42 N \u4e2a\u6570\u5b57\u7684\u548c\u3002\u9ebb\u70e6\u7684\u662f\uff0c\u8fd9\u4e9b\u6570\u5b57\u662f\u4ee5\u6709\u7406\u6570 \u5206\u5b50/\u5206\u6bcd \u7684\u5f62\u5f0f\u7ed9\u51fa\u7684\uff0c\u4f60\u8f93\u51fa\u7684\u548c\u4e5f\u5fc5\u987b\u662f\u6709\u7406\u6570\u7684\u5f62\u5f0f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 100\uff09\u3002\u968f\u540e\u4e00\u884c\u6309\u683c\u5f0f a1/b1 a2/b2 ... \u7ed9\u51fa N \u4e2a\u6709\u7406\u6570\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u5206\u5b50\u548c\u5206\u6bcd\u90fd\u5728\u957f\u6574\u578b\u8303\u56f4\u5185\u3002\u53e6\u5916\uff0c\u8d1f\u6570\u7684\u7b26\u53f7\u4e00\u5b9a\u51fa\u73b0\u5728\u5206\u5b50\u524d\u9762\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e0a\u8ff0\u6570\u5b57\u548c\u7684\u6700\u7b80\u5f62\u5f0f \u2014\u2014 \u5373\u5c06\u7ed3\u679c\u5199\u6210 \u6574\u6570\u90e8\u5206 \u5206\u6570\u90e8\u5206 \uff0c\u5176\u4e2d\u5206\u6570\u90e8\u5206\u5199\u6210 \u5206\u5b50/\u5206\u6bcd \uff0c\u8981\u6c42\u5206\u5b50\u5c0f\u4e8e\u5206\u6bcd\uff0c\u4e14\u5b83\u4eec\u6ca1\u6709\u516c\u56e0\u5b50\u3002\u5982\u679c\u7ed3\u679c\u7684\u6574\u6570\u90e8\u5206\u4e3a0\uff0c\u5219\u53ea\u8f93\u51fa\u5206\u6570\u90e8\u5206\u3002 \u8f93\u5165\u6837\u4f8b1 5 2/5 4/15 1/30 -2/60 8/3 \u8f93\u51fa\u6837\u4f8b1 3 1/3 \u8f93\u5165\u6837\u4f8b2 2 4/3 2/3 \u8f93\u51fa\u6837\u4f8b2 2 \u8f93\u5165\u6837\u4f8b3 3 1/3 -1/6 1/8 \u8f93\u51fa\u6837\u4f8b3 7/24 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; LL gcd ( LL x , LL y ) { LL r ; while ( 1 ) { r = x % y ; if ( r == 0 ) break ; x = y ; y = r ; } return y ; } int main () { int n ; cin >> n ; LL a , b , c , d ; scanf ( \"%lld/%lld\" , & a , & b ); for ( int i = 1 ; i < n ; i ++ ) { scanf ( \"%lld/%lld\" , & c , & d ); LL temp = b * d / gcd ( b , d ); a *= ( temp / b ); a += ( c * ( temp / d )); b = temp ; temp = gcd ( a , b ); a /= temp ; b /= temp ; } LL vis = a / b ; a %= b ; if ( vis ) { printf ( \"%lld\" , vis ); if ( a ) { if ( vis < 0 && a > 0 ) a *= -1 ; printf ( \" %lld/%lld\" , a , abs ( b )); } } else if ( a ) { if ( b < 0 && a > 0 ) a *= -1 , b *= -1 ; printf ( \"%lld/%lld\" , a , abs ( b )); } else cout << 0 ; cout << endl ; }","title":"L1-009-N\u4e2a\u6570\u6c42\u548c"},{"location":"CCCC/L1-009-N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/#l1-009-n\u4e2a\u6570\u6c42\u548c","text":"","title":"L1-009 N\u4e2a\u6570\u6c42\u548c"},{"location":"CCCC/L1-009-N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u8981\u6c42\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6c42 N \u4e2a\u6570\u5b57\u7684\u548c\u3002\u9ebb\u70e6\u7684\u662f\uff0c\u8fd9\u4e9b\u6570\u5b57\u662f\u4ee5\u6709\u7406\u6570 \u5206\u5b50/\u5206\u6bcd \u7684\u5f62\u5f0f\u7ed9\u51fa\u7684\uff0c\u4f60\u8f93\u51fa\u7684\u548c\u4e5f\u5fc5\u987b\u662f\u6709\u7406\u6570\u7684\u5f62\u5f0f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 100\uff09\u3002\u968f\u540e\u4e00\u884c\u6309\u683c\u5f0f a1/b1 a2/b2 ... \u7ed9\u51fa N \u4e2a\u6709\u7406\u6570\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u5206\u5b50\u548c\u5206\u6bcd\u90fd\u5728\u957f\u6574\u578b\u8303\u56f4\u5185\u3002\u53e6\u5916\uff0c\u8d1f\u6570\u7684\u7b26\u53f7\u4e00\u5b9a\u51fa\u73b0\u5728\u5206\u5b50\u524d\u9762\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4e0a\u8ff0\u6570\u5b57\u548c\u7684\u6700\u7b80\u5f62\u5f0f \u2014\u2014 \u5373\u5c06\u7ed3\u679c\u5199\u6210 \u6574\u6570\u90e8\u5206 \u5206\u6570\u90e8\u5206 \uff0c\u5176\u4e2d\u5206\u6570\u90e8\u5206\u5199\u6210 \u5206\u5b50/\u5206\u6bcd \uff0c\u8981\u6c42\u5206\u5b50\u5c0f\u4e8e\u5206\u6bcd\uff0c\u4e14\u5b83\u4eec\u6ca1\u6709\u516c\u56e0\u5b50\u3002\u5982\u679c\u7ed3\u679c\u7684\u6574\u6570\u90e8\u5206\u4e3a0\uff0c\u5219\u53ea\u8f93\u51fa\u5206\u6570\u90e8\u5206\u3002 \u8f93\u5165\u6837\u4f8b1 5 2/5 4/15 1/30 -2/60 8/3 \u8f93\u51fa\u6837\u4f8b1 3 1/3 \u8f93\u5165\u6837\u4f8b2 2 4/3 2/3 \u8f93\u51fa\u6837\u4f8b2 2 \u8f93\u5165\u6837\u4f8b3 3 1/3 -1/6 1/8 \u8f93\u51fa\u6837\u4f8b3 7/24","title":"Statement"},{"location":"CCCC/L1-009-N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; LL gcd ( LL x , LL y ) { LL r ; while ( 1 ) { r = x % y ; if ( r == 0 ) break ; x = y ; y = r ; } return y ; } int main () { int n ; cin >> n ; LL a , b , c , d ; scanf ( \"%lld/%lld\" , & a , & b ); for ( int i = 1 ; i < n ; i ++ ) { scanf ( \"%lld/%lld\" , & c , & d ); LL temp = b * d / gcd ( b , d ); a *= ( temp / b ); a += ( c * ( temp / d )); b = temp ; temp = gcd ( a , b ); a /= temp ; b /= temp ; } LL vis = a / b ; a %= b ; if ( vis ) { printf ( \"%lld\" , vis ); if ( a ) { if ( vis < 0 && a > 0 ) a *= -1 ; printf ( \" %lld/%lld\" , a , abs ( b )); } } else if ( a ) { if ( b < 0 && a > 0 ) a *= -1 , b *= -1 ; printf ( \"%lld/%lld\" , a , abs ( b )); } else cout << 0 ; cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-010-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/","text":"L1-010 \u6bd4\u8f83\u5927\u5c0f Statement Metadata \u4f5c\u8005: \u6768\u8d77\u5e06 \u5355\u4f4d: \u6d59\u5927\u57ce\u5e02\u5b66\u9662 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5c06\u8f93\u5165\u7684\u4efb\u610f3\u4e2a\u6574\u6570\u4ece\u5c0f\u5230\u5927\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa3\u4e2a\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5c063\u4e2a\u6574\u6570\u4ece\u5c0f\u5230\u5927\u8f93\u51fa\uff0c\u5176\u95f4\u4ee5\u201c->\u201d\u76f8\u8fde\u3002 \u8f93\u5165\u6837\u4f8b 4 2 8 \u8f93\u51fa\u6837\u4f8b 2->4->8 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a [ 3 ]; for ( int i = 0 ; i < 3 ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a , a + 3 ); for ( int i = 0 ; i < 3 ; i ++ ) { if ( i ) printf ( \"->\" ); printf ( \"%d\" , a [ i ]); } cout << endl ; }","title":"L1-010-\u6bd4\u8f83\u5927\u5c0f"},{"location":"CCCC/L1-010-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/#l1-010-\u6bd4\u8f83\u5927\u5c0f","text":"","title":"L1-010 \u6bd4\u8f83\u5927\u5c0f"},{"location":"CCCC/L1-010-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/#statement","text":"Metadata \u4f5c\u8005: \u6768\u8d77\u5e06 \u5355\u4f4d: \u6d59\u5927\u57ce\u5e02\u5b66\u9662 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5c06\u8f93\u5165\u7684\u4efb\u610f3\u4e2a\u6574\u6570\u4ece\u5c0f\u5230\u5927\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa3\u4e2a\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5c063\u4e2a\u6574\u6570\u4ece\u5c0f\u5230\u5927\u8f93\u51fa\uff0c\u5176\u95f4\u4ee5\u201c->\u201d\u76f8\u8fde\u3002 \u8f93\u5165\u6837\u4f8b 4 2 8 \u8f93\u51fa\u6837\u4f8b 2->4->8","title":"Statement"},{"location":"CCCC/L1-010-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a [ 3 ]; for ( int i = 0 ; i < 3 ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a , a + 3 ); for ( int i = 0 ; i < 3 ; i ++ ) { if ( i ) printf ( \"->\" ); printf ( \"%d\" , a [ i ]); } cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-011-A-B/","text":"L1-011 A-B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u8ba1\u7b97 A-B A-B \u3002\u4e0d\u8fc7\u9ebb\u70e6\u7684\u662f\uff0c A A \u548c B B \u90fd\u662f\u5b57\u7b26\u4e32 \u2014\u2014 \u5373\u4ece\u5b57\u7b26\u4e32 A A \u4e2d\u628a\u5b57\u7b26\u4e32 B B \u6240\u5305\u542b\u7684\u5b57\u7b26\u5168\u5220\u6389\uff0c\u5269\u4e0b\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u5c31\u662f\u5b57\u7b26\u4e32 A-B A-B \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u57282\u884c\u4e2d\u5148\u540e\u7ed9\u51fa\u5b57\u7b26\u4e32 A A \u548c B B \u3002\u4e24\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u90fd\u4e0d\u8d85\u8fc7 10^4 10^4 \uff0c\u5e76\u4e14\u4fdd\u8bc1\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u662f\u7531\u53ef\u89c1\u7684ASCII\u7801\u548c\u7a7a\u767d\u5b57\u7b26\u7ec4\u6210\uff0c\u6700\u540e\u4ee5\u6362\u884c\u7b26\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6253\u5370\u51fa A-B A-B \u7684\u7ed3\u679c\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u6837\u4f8b I love GPLT! It's a fun game! aeiou \u8f93\u51fa\u6837\u4f8b I lv GPLT! It's fn gm! Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; getline ( cin , s ); int len = s . size (); string temp ; getline ( cin , temp ); map < char , int > m ; m . clear (); int len_ = temp . size (); for ( int i = 0 ; i < len_ ; i ++ ) { m [ temp [ i ]] = 1 ; } for ( int i = 0 ; i < len ; i ++ ) { if ( m [ s [ i ]] == 0 ) cout << s [ i ]; } cout << endl ; }","title":"L1-011-A-B"},{"location":"CCCC/L1-011-A-B/#l1-011-a-b","text":"","title":"L1-011 A-B"},{"location":"CCCC/L1-011-A-B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u8ba1\u7b97 A-B A-B \u3002\u4e0d\u8fc7\u9ebb\u70e6\u7684\u662f\uff0c A A \u548c B B \u90fd\u662f\u5b57\u7b26\u4e32 \u2014\u2014 \u5373\u4ece\u5b57\u7b26\u4e32 A A \u4e2d\u628a\u5b57\u7b26\u4e32 B B \u6240\u5305\u542b\u7684\u5b57\u7b26\u5168\u5220\u6389\uff0c\u5269\u4e0b\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u5c31\u662f\u5b57\u7b26\u4e32 A-B A-B \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u57282\u884c\u4e2d\u5148\u540e\u7ed9\u51fa\u5b57\u7b26\u4e32 A A \u548c B B \u3002\u4e24\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u90fd\u4e0d\u8d85\u8fc7 10^4 10^4 \uff0c\u5e76\u4e14\u4fdd\u8bc1\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u662f\u7531\u53ef\u89c1\u7684ASCII\u7801\u548c\u7a7a\u767d\u5b57\u7b26\u7ec4\u6210\uff0c\u6700\u540e\u4ee5\u6362\u884c\u7b26\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6253\u5370\u51fa A-B A-B \u7684\u7ed3\u679c\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u6837\u4f8b I love GPLT! It's a fun game! aeiou \u8f93\u51fa\u6837\u4f8b I lv GPLT! It's fn gm!","title":"Statement"},{"location":"CCCC/L1-011-A-B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; getline ( cin , s ); int len = s . size (); string temp ; getline ( cin , temp ); map < char , int > m ; m . clear (); int len_ = temp . size (); for ( int i = 0 ; i < len_ ; i ++ ) { m [ temp [ i ]] = 1 ; } for ( int i = 0 ; i < len ; i ++ ) { if ( m [ s [ i ]] == 0 ) cout << s [ i ]; } cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-012-%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0/","text":"L1-012 \u8ba1\u7b97\u6307\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u771f\u7684\u6ca1\u9a97\u4f60\uff0c\u8fd9\u9053\u624d\u662f\u7b80\u5355\u9898 \u2014\u2014 \u5bf9\u4efb\u610f\u7ed9\u5b9a\u7684\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 n n \uff0c\u8981\u6c42\u4f60\u8f93\u51fa 2^n 2^n \u3002\u4e0d\u96be\u5427\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 n n \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u683c\u5f0f 2^n = \u8ba1\u7b97\u7ed3\u679c \u8f93\u51fa 2^n 2^n \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 5 \u8f93\u51fa\u6837\u4f8b 2^5 = 32 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"2^%d = %d \\n \" , n , 2 << ( n - 1 )); }","title":"L1-012-\u8ba1\u7b97\u6307\u6570"},{"location":"CCCC/L1-012-%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0/#l1-012-\u8ba1\u7b97\u6307\u6570","text":"","title":"L1-012 \u8ba1\u7b97\u6307\u6570"},{"location":"CCCC/L1-012-%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u771f\u7684\u6ca1\u9a97\u4f60\uff0c\u8fd9\u9053\u624d\u662f\u7b80\u5355\u9898 \u2014\u2014 \u5bf9\u4efb\u610f\u7ed9\u5b9a\u7684\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 n n \uff0c\u8981\u6c42\u4f60\u8f93\u51fa 2^n 2^n \u3002\u4e0d\u96be\u5427\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 n n \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u683c\u5f0f 2^n = \u8ba1\u7b97\u7ed3\u679c \u8f93\u51fa 2^n 2^n \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 5 \u8f93\u51fa\u6837\u4f8b 2^5 = 32","title":"Statement"},{"location":"CCCC/L1-012-%E8%AE%A1%E7%AE%97%E6%8C%87%E6%95%B0/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"2^%d = %d \\n \" , n , 2 << ( n - 1 )); }","title":"Solution"},{"location":"CCCC/L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/","text":"L1-013 \u8ba1\u7b97\u9636\u4e58\u548c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6b63\u6574\u6570 N N \uff0c\u9700\u8981\u4f60\u8ba1\u7b97 S = 1! + 2! + 3! + ... + N! S = 1! + 2! + 3! + ... + N! \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc710\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa S S \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 9 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; double fac ( int x ) { double sum = 1 ; for ( int i = 2 ; i <= x ; i ++ ) sum *= i ; return sum ; } int main () { int n ; cin >> n ; long double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += fac ( i ); } printf ( \"%.0Lf \\n \" , sum ); }","title":"L1-013-\u8ba1\u7b97\u9636\u4e58\u548c"},{"location":"CCCC/L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/#l1-013-\u8ba1\u7b97\u9636\u4e58\u548c","text":"","title":"L1-013 \u8ba1\u7b97\u9636\u4e58\u548c"},{"location":"CCCC/L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6b63\u6574\u6570 N N \uff0c\u9700\u8981\u4f60\u8ba1\u7b97 S = 1! + 2! + 3! + ... + N! S = 1! + 2! + 3! + ... + N! \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc710\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa S S \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 9","title":"Statement"},{"location":"CCCC/L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; double fac ( int x ) { double sum = 1 ; for ( int i = 2 ; i <= x ; i ++ ) sum *= i ; return sum ; } int main () { int n ; cin >> n ; long double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += fac ( i ); } printf ( \"%.0Lf \\n \" , sum ); }","title":"Solution"},{"location":"CCCC/L1-014-%E7%AE%80%E5%8D%95%E9%A2%98/","text":"L1-014 \u7b80\u5355\u9898 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u6b21\u771f\u7684\u6ca1\u9a97\u4f60 \u2014\u2014 \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e8b\u5b9e\uff1a This is a simple problem. \u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b This is a simple problem. Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"This is a simple problem. \\n \" ; }","title":"L1-014-\u7b80\u5355\u9898"},{"location":"CCCC/L1-014-%E7%AE%80%E5%8D%95%E9%A2%98/#l1-014-\u7b80\u5355\u9898","text":"","title":"L1-014 \u7b80\u5355\u9898"},{"location":"CCCC/L1-014-%E7%AE%80%E5%8D%95%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u6b21\u771f\u7684\u6ca1\u9a97\u4f60 \u2014\u2014 \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e8b\u5b9e\uff1a This is a simple problem. \u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b This is a simple problem.","title":"Statement"},{"location":"CCCC/L1-014-%E7%AE%80%E5%8D%95%E9%A2%98/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"This is a simple problem. \\n \" ; }","title":"Solution"},{"location":"CCCC/L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/","text":"L1-015 \u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u753b\u65b9\u5757 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f8e\u56fd\u603b\u7edf\u5965\u5df4\u9a6c\u4e0d\u4ec5\u547c\u5401\u6240\u6709\u4eba\u90fd\u5b66\u4e60\u7f16\u7a0b\uff0c\u751a\u81f3\u4ee5\u8eab\u4f5c\u5219\u7f16\u5199\u4ee3\u7801\uff0c\u6210\u4e3a\u7f8e\u56fd\u5386\u53f2\u4e0a\u9996\u4f4d\u7f16\u5199\u8ba1\u7b97\u673a\u4ee3\u7801\u7684\u603b\u7edf\u30022014\u5e74\u5e95\uff0c\u4e3a\u5e86\u795d\u201c\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u5468\u201d\u6b63\u5f0f\u542f\u52a8\uff0c\u5965\u5df4\u9a6c\u7f16\u5199\u4e86\u5f88\u7b80\u5355\u7684\u8ba1\u7b97\u673a\u4ee3\u7801\uff1a\u5728\u5c4f\u5e55\u4e0a\u753b\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002\u73b0\u5728\u4f60\u4e5f\u8ddf\u4ed6\u4e00\u8d77\u753b\u5427\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u65b9\u5f62\u8fb9\u957f N N \uff08 3\\le N\\le 21 3\\le N\\le 21 \uff09\u548c\u7ec4\u6210\u6b63\u65b9\u5f62\u8fb9\u7684\u67d0\u79cd\u5b57\u7b26 C \uff0c\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7531\u7ed9\u5b9a\u5b57\u7b26 C \u753b\u51fa\u7684\u6b63\u65b9\u5f62\u3002\u4f46\u662f\u6ce8\u610f\u5230\u884c\u95f4\u8ddd\u6bd4\u5217\u95f4\u8ddd\u5927\uff0c\u6240\u4ee5\u4e3a\u4e86\u8ba9\u7ed3\u679c\u770b\u4e0a\u53bb\u66f4\u50cf\u6b63\u65b9\u5f62\uff0c\u6211\u4eec\u8f93\u51fa\u7684\u884c\u6570\u5b9e\u9645\u4e0a\u662f\u5217\u6570\u768450%\uff08\u56db\u820d\u4e94\u5165\u53d6\u6574\uff09\u3002 \u8f93\u5165\u6837\u4f8b 10 a \u8f93\u51fa\u6837\u4f8b aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; char c ; scanf ( \"%d %c\" , & n , & c ); int m = ( int )( n * 1.0 / 2 + 0.5 ); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) printf ( \"%c\" , c ); cout << endl ; } }","title":"L1-015-\u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u753b\u65b9\u5757"},{"location":"CCCC/L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/#l1-015-\u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u753b\u65b9\u5757","text":"","title":"L1-015 \u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u753b\u65b9\u5757"},{"location":"CCCC/L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f8e\u56fd\u603b\u7edf\u5965\u5df4\u9a6c\u4e0d\u4ec5\u547c\u5401\u6240\u6709\u4eba\u90fd\u5b66\u4e60\u7f16\u7a0b\uff0c\u751a\u81f3\u4ee5\u8eab\u4f5c\u5219\u7f16\u5199\u4ee3\u7801\uff0c\u6210\u4e3a\u7f8e\u56fd\u5386\u53f2\u4e0a\u9996\u4f4d\u7f16\u5199\u8ba1\u7b97\u673a\u4ee3\u7801\u7684\u603b\u7edf\u30022014\u5e74\u5e95\uff0c\u4e3a\u5e86\u795d\u201c\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u5468\u201d\u6b63\u5f0f\u542f\u52a8\uff0c\u5965\u5df4\u9a6c\u7f16\u5199\u4e86\u5f88\u7b80\u5355\u7684\u8ba1\u7b97\u673a\u4ee3\u7801\uff1a\u5728\u5c4f\u5e55\u4e0a\u753b\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002\u73b0\u5728\u4f60\u4e5f\u8ddf\u4ed6\u4e00\u8d77\u753b\u5427\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u65b9\u5f62\u8fb9\u957f N N \uff08 3\\le N\\le 21 3\\le N\\le 21 \uff09\u548c\u7ec4\u6210\u6b63\u65b9\u5f62\u8fb9\u7684\u67d0\u79cd\u5b57\u7b26 C \uff0c\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7531\u7ed9\u5b9a\u5b57\u7b26 C \u753b\u51fa\u7684\u6b63\u65b9\u5f62\u3002\u4f46\u662f\u6ce8\u610f\u5230\u884c\u95f4\u8ddd\u6bd4\u5217\u95f4\u8ddd\u5927\uff0c\u6240\u4ee5\u4e3a\u4e86\u8ba9\u7ed3\u679c\u770b\u4e0a\u53bb\u66f4\u50cf\u6b63\u65b9\u5f62\uff0c\u6211\u4eec\u8f93\u51fa\u7684\u884c\u6570\u5b9e\u9645\u4e0a\u662f\u5217\u6570\u768450%\uff08\u56db\u820d\u4e94\u5165\u53d6\u6574\uff09\u3002 \u8f93\u5165\u6837\u4f8b 10 a \u8f93\u51fa\u6837\u4f8b aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa aaaaaaaaaa","title":"Statement"},{"location":"CCCC/L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; char c ; scanf ( \"%d %c\" , & n , & c ); int m = ( int )( n * 1.0 / 2 + 0.5 ); for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) printf ( \"%c\" , c ); cout << endl ; } }","title":"Solution"},{"location":"CCCC/L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/","text":"L1-016 \u67e5\u9a8c\u8eab\u4efd\u8bc1 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5408\u6cd5\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u753117\u4f4d\u5730\u533a\u3001\u65e5\u671f\u7f16\u53f7\u548c\u987a\u5e8f\u7f16\u53f7\u52a01\u4f4d\u6821\u9a8c\u7801\u7ec4\u6210\u3002\u6821\u9a8c\u7801\u7684\u8ba1\u7b97\u89c4\u5219\u5982\u4e0b\uff1a \u9996\u5148\u5bf9\u524d17\u4f4d\u6570\u5b57\u52a0\u6743\u6c42\u548c\uff0c\u6743\u91cd\u5206\u914d\u4e3a\uff1a{7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2\uff0c1\uff0c6\uff0c3\uff0c7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2}\uff1b\u7136\u540e\u5c06\u8ba1\u7b97\u7684\u548c\u5bf911\u53d6\u6a21\u5f97\u5230\u503c Z \uff1b\u6700\u540e\u6309\u7167\u4ee5\u4e0b\u5173\u7cfb\u5bf9\u5e94 Z \u503c\u4e0e\u6821\u9a8c\u7801 M \u7684\u503c\uff1a Z\uff1a0 1 2 3 4 5 6 7 8 9 10 M\uff1a1 0 X 9 8 7 6 5 4 3 2 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u8eab\u4efd\u8bc1\u53f7\u7801\uff0c\u8bf7\u4f60\u9a8c\u8bc1\u6821\u9a8c\u7801\u7684\u6709\u6548\u6027\uff0c\u5e76\u8f93\u51fa\u6709\u95ee\u9898\u7684\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u662f\u8f93\u5165\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa1\u4e2a18\u4f4d\u8eab\u4efd\u8bc1\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u6bcf\u884c\u8f93\u51fa1\u4e2a\u6709\u95ee\u9898\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u3002\u8fd9\u91cc\u5e76\u4e0d\u68c0\u9a8c\u524d17\u4f4d\u662f\u5426\u5408\u7406\uff0c\u53ea\u68c0\u67e5\u524d17\u4f4d\u662f\u5426\u5168\u4e3a\u6570\u5b57\u4e14\u6700\u540e1\u4f4d\u6821\u9a8c\u7801\u8ba1\u7b97\u51c6\u786e\u3002\u5982\u679c\u6240\u6709\u53f7\u7801\u90fd\u6b63\u5e38\uff0c\u5219\u8f93\u51fa All passed \u3002 \u8f93\u5165\u6837\u4f8b1 4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u51fa\u6837\u4f8b1 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u5165\u6837\u4f8b2 2 320124198808240056 110108196711301862 \u8f93\u51fa\u6837\u4f8b2 All passed Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int vis [] = { 7 , 9 , 10 , 5 , 8 , 4 , 2 , 1 , 6 , 3 , 7 , 9 , 10 , 5 , 8 , 4 , 2 }; char c [] = { '1' , '0' , 'X' , '9' , '8' , '7' , '6' , '5' , '4' , '3' , '2' }; bool f ( string s ) { int num = 0 ; int len = s . size (); for ( int i = 0 ; i < len - 1 ; i ++ ) { num += ( s [ i ] - '0' ) * vis [ i ]; num %= 11 ; } if ( s [ len - 1 ] == c [ num ]) return false ; return true ; } int main () { int n ; cin >> n ; string s ; int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s ; if ( f ( s )) { cout << s << endl ; flag = 0 ; } } if ( flag ) cout << \"All passed \\n \" ; }","title":"L1-016-\u67e5\u9a8c\u8eab\u4efd\u8bc1"},{"location":"CCCC/L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#l1-016-\u67e5\u9a8c\u8eab\u4efd\u8bc1","text":"","title":"L1-016 \u67e5\u9a8c\u8eab\u4efd\u8bc1"},{"location":"CCCC/L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5408\u6cd5\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u753117\u4f4d\u5730\u533a\u3001\u65e5\u671f\u7f16\u53f7\u548c\u987a\u5e8f\u7f16\u53f7\u52a01\u4f4d\u6821\u9a8c\u7801\u7ec4\u6210\u3002\u6821\u9a8c\u7801\u7684\u8ba1\u7b97\u89c4\u5219\u5982\u4e0b\uff1a \u9996\u5148\u5bf9\u524d17\u4f4d\u6570\u5b57\u52a0\u6743\u6c42\u548c\uff0c\u6743\u91cd\u5206\u914d\u4e3a\uff1a{7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2\uff0c1\uff0c6\uff0c3\uff0c7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2}\uff1b\u7136\u540e\u5c06\u8ba1\u7b97\u7684\u548c\u5bf911\u53d6\u6a21\u5f97\u5230\u503c Z \uff1b\u6700\u540e\u6309\u7167\u4ee5\u4e0b\u5173\u7cfb\u5bf9\u5e94 Z \u503c\u4e0e\u6821\u9a8c\u7801 M \u7684\u503c\uff1a Z\uff1a0 1 2 3 4 5 6 7 8 9 10 M\uff1a1 0 X 9 8 7 6 5 4 3 2 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u8eab\u4efd\u8bc1\u53f7\u7801\uff0c\u8bf7\u4f60\u9a8c\u8bc1\u6821\u9a8c\u7801\u7684\u6709\u6548\u6027\uff0c\u5e76\u8f93\u51fa\u6709\u95ee\u9898\u7684\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u662f\u8f93\u5165\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa1\u4e2a18\u4f4d\u8eab\u4efd\u8bc1\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u6bcf\u884c\u8f93\u51fa1\u4e2a\u6709\u95ee\u9898\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u3002\u8fd9\u91cc\u5e76\u4e0d\u68c0\u9a8c\u524d17\u4f4d\u662f\u5426\u5408\u7406\uff0c\u53ea\u68c0\u67e5\u524d17\u4f4d\u662f\u5426\u5168\u4e3a\u6570\u5b57\u4e14\u6700\u540e1\u4f4d\u6821\u9a8c\u7801\u8ba1\u7b97\u51c6\u786e\u3002\u5982\u679c\u6240\u6709\u53f7\u7801\u90fd\u6b63\u5e38\uff0c\u5219\u8f93\u51fa All passed \u3002 \u8f93\u5165\u6837\u4f8b1 4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u51fa\u6837\u4f8b1 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u5165\u6837\u4f8b2 2 320124198808240056 110108196711301862 \u8f93\u51fa\u6837\u4f8b2 All passed","title":"Statement"},{"location":"CCCC/L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int vis [] = { 7 , 9 , 10 , 5 , 8 , 4 , 2 , 1 , 6 , 3 , 7 , 9 , 10 , 5 , 8 , 4 , 2 }; char c [] = { '1' , '0' , 'X' , '9' , '8' , '7' , '6' , '5' , '4' , '3' , '2' }; bool f ( string s ) { int num = 0 ; int len = s . size (); for ( int i = 0 ; i < len - 1 ; i ++ ) { num += ( s [ i ] - '0' ) * vis [ i ]; num %= 11 ; } if ( s [ len - 1 ] == c [ num ]) return false ; return true ; } int main () { int n ; cin >> n ; string s ; int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s ; if ( f ( s )) { cout << s << endl ; flag = 0 ; } } if ( flag ) cout << \"All passed \\n \" ; }","title":"Solution"},{"location":"CCCC/L1-017-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/","text":"L1-017 \u5230\u5e95\u6709\u591a\u4e8c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6574\u6570\u201c \u72af\u4e8c\u7684\u7a0b\u5ea6 \u201d\u5b9a\u4e49\u4e3a\u8be5\u6570\u5b57\u4e2d\u5305\u542b2\u7684\u4e2a\u6570\u4e0e\u5176\u4f4d\u6570\u7684\u6bd4\u503c\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u662f\u8d1f\u6570\uff0c\u5219\u7a0b\u5ea6\u589e\u52a00.5\u500d\uff1b\u5982\u679c\u8fd8\u662f\u4e2a\u5076\u6570\uff0c\u5219\u518d\u589e\u52a01\u500d\u3002\u4f8b\u5982\u6570\u5b57 -13142223336 \u662f\u4e2a11\u4f4d\u6570\uff0c\u5176\u4e2d\u67093\u4e2a2\uff0c\u5e76\u4e14\u662f\u8d1f\u6570\uff0c\u4e5f\u662f\u5076\u6570\uff0c\u5219\u5b83\u7684\u72af\u4e8c\u7a0b\u5ea6\u8ba1\u7b97\u4e3a\uff1a 3/11\\times 1.5\\times 2\\times 100\\% 3/11\\times 1.5\\times 2\\times 100\\% \uff0c\u7ea6\u4e3a81.82%\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u8ba1\u7b97\u4e00\u4e2a\u7ed9\u5b9a\u6574\u6570\u5230\u5e95\u6709\u591a\u4e8c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc750\u4f4d\u7684\u6574\u6570 N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa N \u72af\u4e8c\u7684\u7a0b\u5ea6\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b -13142223336 \u8f93\u51fa\u6837\u4f8b 81.82% \u9e23\u8c22\u5b89\u9633\u5e08\u8303\u5b66\u9662\u6bb5\u6653\u4e91\u8001\u5e08\u548c\u8f6f\u4ef6\u5de5\u7a0b\u4e94\u73ed\u674e\u5bcc\u9f99\u540c\u5b66\u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); int flag [ 2 ] = { 0 }; int vis = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '-' ) { flag [ 0 ] = 1 ; } else { if ( s [ i ] == '2' ) vis ++ ; if ( i == len - 1 && s [ i ] % 2 == 0 ) flag [ 1 ] = 1 ; } } double ans = 0.0 ; if ( flag [ 0 ]) ans = vis * 1.0 / ( len - 1 ) * 1.5 ; else ans = vis * 1.0 / len ; if ( flag [ 1 ]) ans *= 2 ; printf ( \"%.2lf%% \\n \" , ans * 100 ); }","title":"L1-017-\u5230\u5e95\u6709\u591a\u4e8c"},{"location":"CCCC/L1-017-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/#l1-017-\u5230\u5e95\u6709\u591a\u4e8c","text":"","title":"L1-017 \u5230\u5e95\u6709\u591a\u4e8c"},{"location":"CCCC/L1-017-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6574\u6570\u201c \u72af\u4e8c\u7684\u7a0b\u5ea6 \u201d\u5b9a\u4e49\u4e3a\u8be5\u6570\u5b57\u4e2d\u5305\u542b2\u7684\u4e2a\u6570\u4e0e\u5176\u4f4d\u6570\u7684\u6bd4\u503c\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u662f\u8d1f\u6570\uff0c\u5219\u7a0b\u5ea6\u589e\u52a00.5\u500d\uff1b\u5982\u679c\u8fd8\u662f\u4e2a\u5076\u6570\uff0c\u5219\u518d\u589e\u52a01\u500d\u3002\u4f8b\u5982\u6570\u5b57 -13142223336 \u662f\u4e2a11\u4f4d\u6570\uff0c\u5176\u4e2d\u67093\u4e2a2\uff0c\u5e76\u4e14\u662f\u8d1f\u6570\uff0c\u4e5f\u662f\u5076\u6570\uff0c\u5219\u5b83\u7684\u72af\u4e8c\u7a0b\u5ea6\u8ba1\u7b97\u4e3a\uff1a 3/11\\times 1.5\\times 2\\times 100\\% 3/11\\times 1.5\\times 2\\times 100\\% \uff0c\u7ea6\u4e3a81.82%\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u8ba1\u7b97\u4e00\u4e2a\u7ed9\u5b9a\u6574\u6570\u5230\u5e95\u6709\u591a\u4e8c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc750\u4f4d\u7684\u6574\u6570 N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa N \u72af\u4e8c\u7684\u7a0b\u5ea6\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b -13142223336 \u8f93\u51fa\u6837\u4f8b 81.82% \u9e23\u8c22\u5b89\u9633\u5e08\u8303\u5b66\u9662\u6bb5\u6653\u4e91\u8001\u5e08\u548c\u8f6f\u4ef6\u5de5\u7a0b\u4e94\u73ed\u674e\u5bcc\u9f99\u540c\u5b66\u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01","title":"Statement"},{"location":"CCCC/L1-017-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); int flag [ 2 ] = { 0 }; int vis = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '-' ) { flag [ 0 ] = 1 ; } else { if ( s [ i ] == '2' ) vis ++ ; if ( i == len - 1 && s [ i ] % 2 == 0 ) flag [ 1 ] = 1 ; } } double ans = 0.0 ; if ( flag [ 0 ]) ans = vis * 1.0 / ( len - 1 ) * 1.5 ; else ans = vis * 1.0 / len ; if ( flag [ 1 ]) ans *= 2 ; printf ( \"%.2lf%% \\n \" , ans * 100 ); }","title":"Solution"},{"location":"CCCC/L1-018-%E5%A4%A7%E7%AC%A8%E9%92%9F/","text":"L1-018 \u5927\u7b28\u949f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u81ea\u79f0\u201c\u5927\u7b28\u949fV\u201d\u7684\u5bb6\u4f19\uff0c\u6bcf\u5929\u6572\u949f\u50ac\u4fc3\u7801\u519c\u4eec\u7231\u60dc\u8eab\u4f53\u65e9\u70b9\u7761\u89c9\u3002\u4e0d\u8fc7\u7531\u4e8e\u7b28\u949f\u81ea\u5df1\u4f5c\u606f\u4e5f\u4e0d\u662f\u5f88\u89c4\u5f8b\uff0c\u6240\u4ee5\u6572\u949f\u5e76\u4e0d\u5b9a\u65f6\u3002\u4e00\u822c\u6572\u949f\u7684\u70b9\u6570\u662f\u6839\u636e\u6572\u949f\u65f6\u95f4\u800c\u5b9a\u7684\uff0c\u5982\u679c\u6b63\u597d\u5728\u67d0\u4e2a\u6574\u70b9\u6572\uff0c\u90a3\u4e48\u201c\u5f53\u201d\u6570\u5c31\u7b49\u4e8e\u90a3\u4e2a\u6574\u70b9\u6570\uff1b\u5982\u679c\u8fc7\u4e86\u6574\u70b9\uff0c\u5c31\u6572\u4e0b\u4e00\u4e2a\u6574\u70b9\u6570\u3002\u53e6\u5916\uff0c\u867d\u7136\u4e00\u5929\u670924\u5c0f\u65f6\uff0c\u949f\u5374\u662f\u53ea\u5728\u540e\u534a\u5929\u65721~12\u4e0b\u3002\u4f8b\u5982\u572823:00\u6572\u949f\uff0c\u5c31\u662f\u201c\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u201d\uff0c\u800c\u5230\u4e8623:01\u5c31\u4f1a\u662f\u201c\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u201d\u3002\u5728\u5348\u591c00:00\u5230\u4e2d\u534812:00\u671f\u95f4\uff08\u7aef\u70b9\u65f6\u95f4\u5305\u62ec\u5728\u5185\uff09\uff0c\u7b28\u949f\u662f\u4e0d\u6572\u7684\u3002 \u4e0b\u9762\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u6839\u636e\u5f53\u524d\u65f6\u95f4\u66ff\u5927\u7b28\u949f\u6572\u949f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u6309\u7167 hh:mm \u7684\u683c\u5f0f\u7ed9\u51fa\u5f53\u524d\u65f6\u95f4\u3002\u5176\u4e2d hh \u662f\u5c0f\u65f6\uff0c\u572800\u523023\u4e4b\u95f4\uff1b mm \u662f\u5206\u949f\uff0c\u572800\u523059\u4e4b\u95f4\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u5f53\u524d\u65f6\u95f4\u66ff\u5927\u7b28\u949f\u6572\u949f\uff0c\u5373\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u6570\u91cf\u4e2a Dang \u3002\u5982\u679c\u4e0d\u662f\u6572\u949f\u671f\uff0c\u5219\u8f93\u51fa\uff1a Only hh:mm. Too early to Dang. \u5176\u4e2d hh:mm \u662f\u8f93\u5165\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u6837\u4f8b1 19:05 \u8f93\u51fa\u6837\u4f8b1 DangDangDangDangDangDangDangDang \u8f93\u5165\u6837\u4f8b2 07:05 \u8f93\u51fa\u6837\u4f8b2 Only 07:05. Too early to Dang. Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d:%d\" , & a , & b ); if ( a < 12 || ( a == 12 && b == 0 )) printf ( \"Only %02d:%02d. Too early to Dang. \\n \" , a , b ); else { a -= 12 ; for ( int i = 0 ; i < a ; i ++ ) printf ( \"Dang\" ); if ( b ) printf ( \"Dang\" ); cout << endl ; } }","title":"L1-018-\u5927\u7b28\u949f"},{"location":"CCCC/L1-018-%E5%A4%A7%E7%AC%A8%E9%92%9F/#l1-018-\u5927\u7b28\u949f","text":"","title":"L1-018 \u5927\u7b28\u949f"},{"location":"CCCC/L1-018-%E5%A4%A7%E7%AC%A8%E9%92%9F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u81ea\u79f0\u201c\u5927\u7b28\u949fV\u201d\u7684\u5bb6\u4f19\uff0c\u6bcf\u5929\u6572\u949f\u50ac\u4fc3\u7801\u519c\u4eec\u7231\u60dc\u8eab\u4f53\u65e9\u70b9\u7761\u89c9\u3002\u4e0d\u8fc7\u7531\u4e8e\u7b28\u949f\u81ea\u5df1\u4f5c\u606f\u4e5f\u4e0d\u662f\u5f88\u89c4\u5f8b\uff0c\u6240\u4ee5\u6572\u949f\u5e76\u4e0d\u5b9a\u65f6\u3002\u4e00\u822c\u6572\u949f\u7684\u70b9\u6570\u662f\u6839\u636e\u6572\u949f\u65f6\u95f4\u800c\u5b9a\u7684\uff0c\u5982\u679c\u6b63\u597d\u5728\u67d0\u4e2a\u6574\u70b9\u6572\uff0c\u90a3\u4e48\u201c\u5f53\u201d\u6570\u5c31\u7b49\u4e8e\u90a3\u4e2a\u6574\u70b9\u6570\uff1b\u5982\u679c\u8fc7\u4e86\u6574\u70b9\uff0c\u5c31\u6572\u4e0b\u4e00\u4e2a\u6574\u70b9\u6570\u3002\u53e6\u5916\uff0c\u867d\u7136\u4e00\u5929\u670924\u5c0f\u65f6\uff0c\u949f\u5374\u662f\u53ea\u5728\u540e\u534a\u5929\u65721~12\u4e0b\u3002\u4f8b\u5982\u572823:00\u6572\u949f\uff0c\u5c31\u662f\u201c\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u201d\uff0c\u800c\u5230\u4e8623:01\u5c31\u4f1a\u662f\u201c\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u5f53\u201d\u3002\u5728\u5348\u591c00:00\u5230\u4e2d\u534812:00\u671f\u95f4\uff08\u7aef\u70b9\u65f6\u95f4\u5305\u62ec\u5728\u5185\uff09\uff0c\u7b28\u949f\u662f\u4e0d\u6572\u7684\u3002 \u4e0b\u9762\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u6839\u636e\u5f53\u524d\u65f6\u95f4\u66ff\u5927\u7b28\u949f\u6572\u949f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u6309\u7167 hh:mm \u7684\u683c\u5f0f\u7ed9\u51fa\u5f53\u524d\u65f6\u95f4\u3002\u5176\u4e2d hh \u662f\u5c0f\u65f6\uff0c\u572800\u523023\u4e4b\u95f4\uff1b mm \u662f\u5206\u949f\uff0c\u572800\u523059\u4e4b\u95f4\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u5f53\u524d\u65f6\u95f4\u66ff\u5927\u7b28\u949f\u6572\u949f\uff0c\u5373\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u6570\u91cf\u4e2a Dang \u3002\u5982\u679c\u4e0d\u662f\u6572\u949f\u671f\uff0c\u5219\u8f93\u51fa\uff1a Only hh:mm. Too early to Dang. \u5176\u4e2d hh:mm \u662f\u8f93\u5165\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u6837\u4f8b1 19:05 \u8f93\u51fa\u6837\u4f8b1 DangDangDangDangDangDangDangDang \u8f93\u5165\u6837\u4f8b2 07:05 \u8f93\u51fa\u6837\u4f8b2 Only 07:05. Too early to Dang.","title":"Statement"},{"location":"CCCC/L1-018-%E5%A4%A7%E7%AC%A8%E9%92%9F/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d:%d\" , & a , & b ); if ( a < 12 || ( a == 12 && b == 0 )) printf ( \"Only %02d:%02d. Too early to Dang. \\n \" , a , b ); else { a -= 12 ; for ( int i = 0 ; i < a ; i ++ ) printf ( \"Dang\" ); if ( b ) printf ( \"Dang\" ); cout << endl ; } }","title":"Solution"},{"location":"CCCC/L1-019-%E8%B0%81%E5%85%88%E5%80%92/","text":"L1-019 \u8c01\u5148\u5012 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5212\u62f3\u662f\u53e4\u8001\u4e2d\u56fd\u9152\u6587\u5316\u7684\u4e00\u4e2a\u6709\u8da3\u7684\u7ec4\u6210\u90e8\u5206\u3002\u9152\u684c\u4e0a\u4e24\u4eba\u5212\u62f3\u7684\u65b9\u6cd5\u4e3a\uff1a\u6bcf\u4eba\u53e3\u4e2d\u558a\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u540c\u65f6\u7528\u624b\u6bd4\u5212\u51fa\u4e00\u4e2a\u6570\u5b57\u3002\u5982\u679c\u8c01\u6bd4\u5212\u51fa\u7684\u6570\u5b57\u6b63\u597d\u7b49\u4e8e\u4e24\u4eba\u558a\u51fa\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u8c01\u5c31\u8f93\u4e86\uff0c\u8f93\u5bb6\u7f5a\u4e00\u676f\u9152\u3002\u4e24\u4eba\u540c\u8d62\u6216\u4e24\u4eba\u540c\u8f93\u5219\u7ee7\u7eed\u4e0b\u4e00\u8f6e\uff0c\u76f4\u5230\u552f\u4e00\u7684\u8d62\u5bb6\u51fa\u73b0\u3002 \u4e0b\u9762\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u9152\u91cf\uff08\u6700\u591a\u80fd\u559d\u591a\u5c11\u676f\u4e0d\u5012\uff09\u548c\u5212\u62f3\u8bb0\u5f55\uff0c\u8bf7\u4f60\u5224\u65ad\u4e24\u4e2a\u4eba\u8c01\u5148\u5012\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u5148\u540e\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u9152\u91cf\uff08\u4e0d\u8d85\u8fc7100\u7684\u975e\u8d1f\u6574\u6570\uff09\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u4e0b\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u8f6e\u5212\u62f3\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u4e3a\uff1a \u7532\u558a \u7532\u5212 \u4e59\u558a \u4e59\u5212 \u5176\u4e2d \u558a \u662f\u558a\u51fa\u7684\u6570\u5b57\uff0c \u5212 \u662f\u5212\u51fa\u7684\u6570\u5b57\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff08\u4e24\u53ea\u624b\u4e00\u8d77\u5212\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u5148\u5012\u4e0b\u7684\u90a3\u4e2a\u4eba\uff1a A \u4ee3\u8868\u7532\uff0c B \u4ee3\u8868\u4e59\u3002\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u6ca1\u5012\u7684\u90a3\u4e2a\u4eba\u559d\u4e86\u591a\u5c11\u676f\u3002\u9898\u76ee\u4fdd\u8bc1\u6709\u4e00\u4e2a\u4eba\u5012\u4e0b\u3002\u6ce8\u610f\u7a0b\u5e8f\u5904\u7406\u5230\u6709\u4eba\u5012\u4e0b\u5c31\u7ec8\u6b62\uff0c\u540e\u9762\u7684\u6570\u636e\u4e0d\u5fc5\u5904\u7406\u3002 \u8f93\u5165\u6837\u4f8b 1 1 6 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 15 1 1 16 \u8f93\u51fa\u6837\u4f8b A 1 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int arr [ 2 ] = { 0 }; cin >> arr [ 0 ] >> arr [ 1 ]; int q = arr [ 0 ], w = arr [ 1 ]; int n ; cin >> n ; int a , b , c , d ; int flag = 1 ; while ( n -- ) { scanf ( \"%d%d%d%d\" , & a , & b , & c , & d ); if ( flag ) { if ( a + c == b && a + c != d ) { arr [ 0 ] -- ; if ( arr [ 0 ] < 0 ) flag = 0 ; } if ( a + c == d && a + c != b ) { arr [ 1 ] -- ; if ( arr [ 1 ] < 0 ) flag = 0 ; } } else continue ; } if ( arr [ 0 ] < 0 ) printf ( \"A \\n %d \\n \" , w - arr [ 1 ]); else printf ( \"B \\n %d \\n \" , q - arr [ 0 ]); }","title":"L1-019-\u8c01\u5148\u5012"},{"location":"CCCC/L1-019-%E8%B0%81%E5%85%88%E5%80%92/#l1-019-\u8c01\u5148\u5012","text":"","title":"L1-019 \u8c01\u5148\u5012"},{"location":"CCCC/L1-019-%E8%B0%81%E5%85%88%E5%80%92/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5212\u62f3\u662f\u53e4\u8001\u4e2d\u56fd\u9152\u6587\u5316\u7684\u4e00\u4e2a\u6709\u8da3\u7684\u7ec4\u6210\u90e8\u5206\u3002\u9152\u684c\u4e0a\u4e24\u4eba\u5212\u62f3\u7684\u65b9\u6cd5\u4e3a\uff1a\u6bcf\u4eba\u53e3\u4e2d\u558a\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u540c\u65f6\u7528\u624b\u6bd4\u5212\u51fa\u4e00\u4e2a\u6570\u5b57\u3002\u5982\u679c\u8c01\u6bd4\u5212\u51fa\u7684\u6570\u5b57\u6b63\u597d\u7b49\u4e8e\u4e24\u4eba\u558a\u51fa\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u8c01\u5c31\u8f93\u4e86\uff0c\u8f93\u5bb6\u7f5a\u4e00\u676f\u9152\u3002\u4e24\u4eba\u540c\u8d62\u6216\u4e24\u4eba\u540c\u8f93\u5219\u7ee7\u7eed\u4e0b\u4e00\u8f6e\uff0c\u76f4\u5230\u552f\u4e00\u7684\u8d62\u5bb6\u51fa\u73b0\u3002 \u4e0b\u9762\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u9152\u91cf\uff08\u6700\u591a\u80fd\u559d\u591a\u5c11\u676f\u4e0d\u5012\uff09\u548c\u5212\u62f3\u8bb0\u5f55\uff0c\u8bf7\u4f60\u5224\u65ad\u4e24\u4e2a\u4eba\u8c01\u5148\u5012\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u5148\u540e\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u9152\u91cf\uff08\u4e0d\u8d85\u8fc7100\u7684\u975e\u8d1f\u6574\u6570\uff09\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u4e0b\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u8f6e\u5212\u62f3\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u4e3a\uff1a \u7532\u558a \u7532\u5212 \u4e59\u558a \u4e59\u5212 \u5176\u4e2d \u558a \u662f\u558a\u51fa\u7684\u6570\u5b57\uff0c \u5212 \u662f\u5212\u51fa\u7684\u6570\u5b57\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff08\u4e24\u53ea\u624b\u4e00\u8d77\u5212\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u5148\u5012\u4e0b\u7684\u90a3\u4e2a\u4eba\uff1a A \u4ee3\u8868\u7532\uff0c B \u4ee3\u8868\u4e59\u3002\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u6ca1\u5012\u7684\u90a3\u4e2a\u4eba\u559d\u4e86\u591a\u5c11\u676f\u3002\u9898\u76ee\u4fdd\u8bc1\u6709\u4e00\u4e2a\u4eba\u5012\u4e0b\u3002\u6ce8\u610f\u7a0b\u5e8f\u5904\u7406\u5230\u6709\u4eba\u5012\u4e0b\u5c31\u7ec8\u6b62\uff0c\u540e\u9762\u7684\u6570\u636e\u4e0d\u5fc5\u5904\u7406\u3002 \u8f93\u5165\u6837\u4f8b 1 1 6 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 15 1 1 16 \u8f93\u51fa\u6837\u4f8b A 1","title":"Statement"},{"location":"CCCC/L1-019-%E8%B0%81%E5%85%88%E5%80%92/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int arr [ 2 ] = { 0 }; cin >> arr [ 0 ] >> arr [ 1 ]; int q = arr [ 0 ], w = arr [ 1 ]; int n ; cin >> n ; int a , b , c , d ; int flag = 1 ; while ( n -- ) { scanf ( \"%d%d%d%d\" , & a , & b , & c , & d ); if ( flag ) { if ( a + c == b && a + c != d ) { arr [ 0 ] -- ; if ( arr [ 0 ] < 0 ) flag = 0 ; } if ( a + c == d && a + c != b ) { arr [ 1 ] -- ; if ( arr [ 1 ] < 0 ) flag = 0 ; } } else continue ; } if ( arr [ 0 ] < 0 ) printf ( \"A \\n %d \\n \" , w - arr [ 1 ]); else printf ( \"B \\n %d \\n \" , q - arr [ 0 ]); }","title":"Solution"},{"location":"CCCC/L1-020-%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/","text":"L1-020 \u5e05\u5230\u6ca1\u670b\u53cb Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u82b8\u82b8\u4f17\u751f\u5fd9\u7740\u5728\u670b\u53cb\u5708\u4e2d\u53d1\u7167\u7247\u7684\u65f6\u5019\uff0c\u603b\u6709\u4e00\u4e9b\u4eba\u56e0\u4e3a\u592a\u5e05\u800c\u6ca1\u6709\u670b\u53cb\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u627e\u51fa\u90a3\u4e9b\u5e05\u5230\u6ca1\u6709\u670b\u53cb\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 100 \\le 100 \uff09\uff0c\u662f\u5df2\u77e5\u670b\u53cb\u5708\u7684\u4e2a\u6570\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u670b\u53cb\u5708\u4e2d\u7684\u4eba\u6570\uff0c\u7136\u540e\u5217\u51fa\u4e00\u4e2a\u670b\u53cb\u5708\u5185\u7684\u6240\u6709\u4eba\u2014\u2014\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6bcf\u4eba\u5bf9\u5e94\u4e00\u4e2aID\u53f7\uff0c\u4e3a5\u4f4d\u6570\u5b57\uff08\u4ece00000\u523099999\uff09\uff0cID\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff1b\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M \uff08 \\le 10000 \\le 10000 \uff09\uff0c\u4e3a\u5f85\u67e5\u8be2\u7684\u4eba\u6570\uff1b\u968f\u540e\u4e00\u884c\u4e2d\u5217\u51fa M \u4e2a\u5f85\u67e5\u8be2\u7684ID\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u6ce8\u610f\uff1a\u6ca1\u6709\u670b\u53cb\u7684\u4eba\u53ef\u4ee5\u662f\u6839\u672c\u6ca1\u5b89\u88c5\u201c\u670b\u53cb\u5708\u201d\uff0c\u4e5f\u53ef\u4ee5\u662f\u53ea\u6709\u81ea\u5df1\u4e00\u4e2a\u4eba\u5728\u670b\u53cb\u5708\u7684\u4eba\u3002\u867d\u7136\u6709\u4e2a\u522b\u81ea\u604b\u72c2\u4f1a\u81ea\u5df1\u628a\u81ea\u5df1\u53cd\u590d\u52a0\u8fdb\u670b\u53cb\u5708\uff0c\u4f46\u9898\u76ee\u4fdd\u8bc1\u6240\u6709 K \u8d85\u8fc71\u7684\u670b\u53cb\u5708\u91cc\u90fd\u81f3\u5c11\u67092\u4e2a\u4e0d\u540c\u7684\u4eba\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u90a3\u4e9b\u5e05\u5230\u6ca1\u670b\u53cb\u7684\u4eba\u3002ID\u95f4\u75281\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6ca1\u6709\u4eba\u592a\u5e05\uff0c\u5219\u8f93\u51fa No one is handsome \u3002 \u6ce8\u610f\uff1a\u540c\u4e00\u4e2a\u4eba\u53ef\u4ee5\u88ab\u67e5\u8be2\u591a\u6b21\uff0c\u4f46\u53ea\u8f93\u51fa\u4e00\u6b21\u3002 \u8f93\u5165\u6837\u4f8b1 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 8 55555 44444 10000 88888 22222 11111 23333 88888 \u8f93\u51fa\u6837\u4f8b1 10000 88888 23333 \u8f93\u5165\u6837\u4f8b2 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 4 55555 44444 22222 11111 \u8f93\u51fa\u6837\u4f8b2 No one is handsome Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; map < int , int > M ; M . clear (); for ( int i = 0 ; i < n ; i ++ ) { int m ; cin >> m ; if ( m >= 2 ) { for ( int j = 0 ; j < m ; j ++ ) { int num ; cin >> num ; M [ num ] = 1 ; } } else { int num ; cin >> num ; } } int m ; cin >> m ; int i , j ; for ( i = 0 , j = 0 ; i < m ; i ++ ) { int num ; cin >> num ; if ( M [ num ] == 0 ) { if ( j ) printf ( \" \" ); else j ++ ; printf ( \"%05d\" , num ); M [ num ] = 1 ; } } if ( j == 0 ) printf ( \"No one is handsome\" ); cout << endl ; }","title":"L1-020-\u5e05\u5230\u6ca1\u670b\u53cb"},{"location":"CCCC/L1-020-%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/#l1-020-\u5e05\u5230\u6ca1\u670b\u53cb","text":"","title":"L1-020 \u5e05\u5230\u6ca1\u670b\u53cb"},{"location":"CCCC/L1-020-%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u82b8\u82b8\u4f17\u751f\u5fd9\u7740\u5728\u670b\u53cb\u5708\u4e2d\u53d1\u7167\u7247\u7684\u65f6\u5019\uff0c\u603b\u6709\u4e00\u4e9b\u4eba\u56e0\u4e3a\u592a\u5e05\u800c\u6ca1\u6709\u670b\u53cb\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u627e\u51fa\u90a3\u4e9b\u5e05\u5230\u6ca1\u6709\u670b\u53cb\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 100 \\le 100 \uff09\uff0c\u662f\u5df2\u77e5\u670b\u53cb\u5708\u7684\u4e2a\u6570\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u670b\u53cb\u5708\u4e2d\u7684\u4eba\u6570\uff0c\u7136\u540e\u5217\u51fa\u4e00\u4e2a\u670b\u53cb\u5708\u5185\u7684\u6240\u6709\u4eba\u2014\u2014\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6bcf\u4eba\u5bf9\u5e94\u4e00\u4e2aID\u53f7\uff0c\u4e3a5\u4f4d\u6570\u5b57\uff08\u4ece00000\u523099999\uff09\uff0cID\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff1b\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M \uff08 \\le 10000 \\le 10000 \uff09\uff0c\u4e3a\u5f85\u67e5\u8be2\u7684\u4eba\u6570\uff1b\u968f\u540e\u4e00\u884c\u4e2d\u5217\u51fa M \u4e2a\u5f85\u67e5\u8be2\u7684ID\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u6ce8\u610f\uff1a\u6ca1\u6709\u670b\u53cb\u7684\u4eba\u53ef\u4ee5\u662f\u6839\u672c\u6ca1\u5b89\u88c5\u201c\u670b\u53cb\u5708\u201d\uff0c\u4e5f\u53ef\u4ee5\u662f\u53ea\u6709\u81ea\u5df1\u4e00\u4e2a\u4eba\u5728\u670b\u53cb\u5708\u7684\u4eba\u3002\u867d\u7136\u6709\u4e2a\u522b\u81ea\u604b\u72c2\u4f1a\u81ea\u5df1\u628a\u81ea\u5df1\u53cd\u590d\u52a0\u8fdb\u670b\u53cb\u5708\uff0c\u4f46\u9898\u76ee\u4fdd\u8bc1\u6240\u6709 K \u8d85\u8fc71\u7684\u670b\u53cb\u5708\u91cc\u90fd\u81f3\u5c11\u67092\u4e2a\u4e0d\u540c\u7684\u4eba\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u90a3\u4e9b\u5e05\u5230\u6ca1\u670b\u53cb\u7684\u4eba\u3002ID\u95f4\u75281\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6ca1\u6709\u4eba\u592a\u5e05\uff0c\u5219\u8f93\u51fa No one is handsome \u3002 \u6ce8\u610f\uff1a\u540c\u4e00\u4e2a\u4eba\u53ef\u4ee5\u88ab\u67e5\u8be2\u591a\u6b21\uff0c\u4f46\u53ea\u8f93\u51fa\u4e00\u6b21\u3002 \u8f93\u5165\u6837\u4f8b1 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 8 55555 44444 10000 88888 22222 11111 23333 88888 \u8f93\u51fa\u6837\u4f8b1 10000 88888 23333 \u8f93\u5165\u6837\u4f8b2 3 3 11111 22222 55555 2 33333 44444 4 55555 66666 99999 77777 4 55555 44444 22222 11111 \u8f93\u51fa\u6837\u4f8b2 No one is handsome","title":"Statement"},{"location":"CCCC/L1-020-%E5%B8%85%E5%88%B0%E6%B2%A1%E6%9C%8B%E5%8F%8B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; map < int , int > M ; M . clear (); for ( int i = 0 ; i < n ; i ++ ) { int m ; cin >> m ; if ( m >= 2 ) { for ( int j = 0 ; j < m ; j ++ ) { int num ; cin >> num ; M [ num ] = 1 ; } } else { int num ; cin >> num ; } } int m ; cin >> m ; int i , j ; for ( i = 0 , j = 0 ; i < m ; i ++ ) { int num ; cin >> num ; if ( M [ num ] == 0 ) { if ( j ) printf ( \" \" ); else j ++ ; printf ( \"%05d\" , num ); M [ num ] = 1 ; } } if ( j == 0 ) printf ( \"No one is handsome\" ); cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-021-%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D/","text":"L1-021 \u91cd\u8981\u7684\u8bdd\u8bf4\u4e09\u904d Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u628a\u8fd9\u53e5\u5f88\u91cd\u8981\u7684\u8bdd \u2014\u2014 \u201cI'm gonna WIN!\u201d\u2014\u2014\u8fde\u7eed\u8f93\u51fa\u4e09\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u6ce8\u610f\u6bcf\u904d\u5360\u4e00\u884c\uff0c\u9664\u4e86\u6bcf\u884c\u7684\u56de\u8f66\u4e0d\u80fd\u6709\u4efb\u4f55\u591a\u4f59\u5b57\u7b26\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b I'm gonna WIN! I'm gonna WIN! I'm gonna WIN! Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { for ( int i = 0 ; i < 3 ; i ++ ) printf ( \"I'm gonna WIN! \\n \" ); }","title":"L1-021-\u91cd\u8981\u7684\u8bdd\u8bf4\u4e09\u904d"},{"location":"CCCC/L1-021-%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D/#l1-021-\u91cd\u8981\u7684\u8bdd\u8bf4\u4e09\u904d","text":"","title":"L1-021 \u91cd\u8981\u7684\u8bdd\u8bf4\u4e09\u904d"},{"location":"CCCC/L1-021-%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u628a\u8fd9\u53e5\u5f88\u91cd\u8981\u7684\u8bdd \u2014\u2014 \u201cI'm gonna WIN!\u201d\u2014\u2014\u8fde\u7eed\u8f93\u51fa\u4e09\u904d\u5c31\u53ef\u4ee5\u4e86\u3002 \u6ce8\u610f\u6bcf\u904d\u5360\u4e00\u884c\uff0c\u9664\u4e86\u6bcf\u884c\u7684\u56de\u8f66\u4e0d\u80fd\u6709\u4efb\u4f55\u591a\u4f59\u5b57\u7b26\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b I'm gonna WIN! I'm gonna WIN! I'm gonna WIN!","title":"Statement"},{"location":"CCCC/L1-021-%E9%87%8D%E8%A6%81%E7%9A%84%E8%AF%9D%E8%AF%B4%E4%B8%89%E9%81%8D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { for ( int i = 0 ; i < 3 ; i ++ ) printf ( \"I'm gonna WIN! \\n \" ); }","title":"Solution"},{"location":"CCCC/L1-022-%E5%A5%87%E5%81%B6%E5%88%86%E5%AE%B6/","text":"L1-022 \u5947\u5076\u5206\u5bb6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u4e2a\u6b63\u6574\u6570\uff0c\u8bf7\u7edf\u8ba1\u5947\u6570\u548c\u5076\u6570\u5404\u6709\u591a\u5c11\u4e2a\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574 N \uff08 \\le 1000 \\le 1000 \uff09\uff1b\u7b2c2\u884c\u7ed9\u51fa N \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa\u5947\u6570\u7684\u4e2a\u6570\u3001\u5076\u6570\u7684\u4e2a\u6570\u3002\u4e2d\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 9 88 74 101 26 15 0 34 22 77 \u8f93\u51fa\u6837\u4f8b 3 6 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; int num ; int a [ 2 ] = { 0 }; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); if ( num & 1 ) a [ 0 ] ++ ; else a [ 1 ] ++ ; } printf ( \"%d %d \\n \" , a [ 0 ], a [ 1 ]); }","title":"L1-022-\u5947\u5076\u5206\u5bb6"},{"location":"CCCC/L1-022-%E5%A5%87%E5%81%B6%E5%88%86%E5%AE%B6/#l1-022-\u5947\u5076\u5206\u5bb6","text":"","title":"L1-022 \u5947\u5076\u5206\u5bb6"},{"location":"CCCC/L1-022-%E5%A5%87%E5%81%B6%E5%88%86%E5%AE%B6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u4e2a\u6b63\u6574\u6570\uff0c\u8bf7\u7edf\u8ba1\u5947\u6570\u548c\u5076\u6570\u5404\u6709\u591a\u5c11\u4e2a\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574 N \uff08 \\le 1000 \\le 1000 \uff09\uff1b\u7b2c2\u884c\u7ed9\u51fa N \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa\u5947\u6570\u7684\u4e2a\u6570\u3001\u5076\u6570\u7684\u4e2a\u6570\u3002\u4e2d\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 9 88 74 101 26 15 0 34 22 77 \u8f93\u51fa\u6837\u4f8b 3 6","title":"Statement"},{"location":"CCCC/L1-022-%E5%A5%87%E5%81%B6%E5%88%86%E5%AE%B6/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; int num ; int a [ 2 ] = { 0 }; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); if ( num & 1 ) a [ 0 ] ++ ; else a [ 1 ] ++ ; } printf ( \"%d %d \\n \" , a [ 0 ], a [ 1 ]); }","title":"Solution"},{"location":"CCCC/L1-023-%E8%BE%93%E5%87%BAGPLT/","text":"L1-023 \u8f93\u51faGPLT Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc710000\u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 GPLTGPLT.... \u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u56db\u79cd\u5b57\u7b26\uff08\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff09\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 GPLT \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc710000\u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b pcTclnGloRgLrtLhgljkLhGFauPewSKgt \u8f93\u51fa\u6837\u4f8b GPLTGPLTGLTGLGLL Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); int i ; int a [ 4 ] = { 0 }; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] == 'G' || s [ i ] == 'g' ) a [ 0 ] ++ ; else if ( s [ i ] == 'P' || s [ i ] == 'p' ) a [ 1 ] ++ ; else if ( s [ i ] == 'L' || s [ i ] == 'l' ) a [ 2 ] ++ ; else if ( s [ i ] == 'T' || s [ i ] == 't' ) a [ 3 ] ++ ; } while ( a [ 0 ] || a [ 1 ] || a [ 2 ] || a [ 3 ]) { if ( a [ 0 ]) { printf ( \"G\" ); a [ 0 ] -- ; } if ( a [ 1 ]) { printf ( \"P\" ); a [ 1 ] -- ; } if ( a [ 2 ]) { printf ( \"L\" ); a [ 2 ] -- ; } if ( a [ 3 ]) { printf ( \"T\" ); a [ 3 ] -- ; } } cout << endl ; }","title":"L1-023-\u8f93\u51faGPLT"},{"location":"CCCC/L1-023-%E8%BE%93%E5%87%BAGPLT/#l1-023-\u8f93\u51fagplt","text":"","title":"L1-023 \u8f93\u51faGPLT"},{"location":"CCCC/L1-023-%E8%BE%93%E5%87%BAGPLT/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc710000\u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 GPLTGPLT.... \u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u56db\u79cd\u5b57\u7b26\uff08\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff09\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 GPLT \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc710000\u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b pcTclnGloRgLrtLhgljkLhGFauPewSKgt \u8f93\u51fa\u6837\u4f8b GPLTGPLTGLTGLGLL","title":"Statement"},{"location":"CCCC/L1-023-%E8%BE%93%E5%87%BAGPLT/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; int len = s . size (); int i ; int a [ 4 ] = { 0 }; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] == 'G' || s [ i ] == 'g' ) a [ 0 ] ++ ; else if ( s [ i ] == 'P' || s [ i ] == 'p' ) a [ 1 ] ++ ; else if ( s [ i ] == 'L' || s [ i ] == 'l' ) a [ 2 ] ++ ; else if ( s [ i ] == 'T' || s [ i ] == 't' ) a [ 3 ] ++ ; } while ( a [ 0 ] || a [ 1 ] || a [ 2 ] || a [ 3 ]) { if ( a [ 0 ]) { printf ( \"G\" ); a [ 0 ] -- ; } if ( a [ 1 ]) { printf ( \"P\" ); a [ 1 ] -- ; } if ( a [ 2 ]) { printf ( \"L\" ); a [ 2 ] -- ; } if ( a [ 3 ]) { printf ( \"T\" ); a [ 3 ] -- ; } } cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-024-%E5%90%8E%E5%A4%A9/","text":"L1-024 \u540e\u5929 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4eca\u5929\u662f\u661f\u671f\u4e09\uff0c\u540e\u5929\u5c31\u662f\u661f\u671f\u4e94\uff1b\u5982\u679c\u4eca\u5929\u662f\u661f\u671f\u516d\uff0c\u540e\u5929\u5c31\u662f\u661f\u671f\u4e00\u3002\u6211\u4eec\u7528\u6570\u5b571\u52307\u5bf9\u5e94\u661f\u671f\u4e00\u5230\u661f\u671f\u65e5\u3002\u7ed9\u5b9a\u67d0\u4e00\u5929\uff0c\u8bf7\u4f60\u8f93\u51fa\u90a3\u5929\u7684\u201c\u540e\u5929\u201d\u662f\u661f\u671f\u51e0\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 D \uff081 \\le \\le D \\le \\le 7\uff09\uff0c\u4ee3\u8868\u661f\u671f\u91cc\u7684\u67d0\u4e00\u5929\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa D \u5929\u7684\u540e\u5929\u662f\u661f\u671f\u51e0\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 5 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; n = ( n + 1 ) % 7 + 1 ; cout << n << endl ; }","title":"L1-024-\u540e\u5929"},{"location":"CCCC/L1-024-%E5%90%8E%E5%A4%A9/#l1-024-\u540e\u5929","text":"","title":"L1-024 \u540e\u5929"},{"location":"CCCC/L1-024-%E5%90%8E%E5%A4%A9/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4eca\u5929\u662f\u661f\u671f\u4e09\uff0c\u540e\u5929\u5c31\u662f\u661f\u671f\u4e94\uff1b\u5982\u679c\u4eca\u5929\u662f\u661f\u671f\u516d\uff0c\u540e\u5929\u5c31\u662f\u661f\u671f\u4e00\u3002\u6211\u4eec\u7528\u6570\u5b571\u52307\u5bf9\u5e94\u661f\u671f\u4e00\u5230\u661f\u671f\u65e5\u3002\u7ed9\u5b9a\u67d0\u4e00\u5929\uff0c\u8bf7\u4f60\u8f93\u51fa\u90a3\u5929\u7684\u201c\u540e\u5929\u201d\u662f\u661f\u671f\u51e0\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 D \uff081 \\le \\le D \\le \\le 7\uff09\uff0c\u4ee3\u8868\u661f\u671f\u91cc\u7684\u67d0\u4e00\u5929\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa D \u5929\u7684\u540e\u5929\u662f\u661f\u671f\u51e0\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 5","title":"Statement"},{"location":"CCCC/L1-024-%E5%90%8E%E5%A4%A9/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; n = ( n + 1 ) % 7 + 1 ; cout << n << endl ; }","title":"Solution"},{"location":"CCCC/L1-025-%E6%AD%A3%E6%95%B4%E6%95%B0A%2BB/","text":"L1-025 \u6b63\u6574\u6570A+B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u9898\u7684\u76ee\u6807\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6c42\u4e24\u4e2a\u6b63\u6574\u6570 A \u548c B \u7684\u548c\uff0c\u5176\u4e2d A \u548c B \u90fd\u5728\u533a\u95f4[1,1000]\u3002\u7a0d\u5fae\u6709\u70b9\u9ebb\u70e6\u7684\u662f\uff0c\u8f93\u5165\u5e76\u4e0d\u4fdd\u8bc1\u662f\u4e24\u4e2a\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa A \u548c B \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u5f00\u3002\u95ee\u9898\u662f A \u548c B \u4e0d\u4e00\u5b9a\u662f\u6ee1\u8db3\u8981\u6c42\u7684\u6b63\u6574\u6570\uff0c\u6709\u65f6\u5019\u53ef\u80fd\u662f\u8d85\u51fa\u8303\u56f4\u7684\u6570\u5b57\u3001\u8d1f\u6570\u3001\u5e26\u5c0f\u6570\u70b9\u7684\u5b9e\u6570\u3001\u751a\u81f3\u662f\u4e00\u5806\u4e71\u7801\u3002 \u6ce8\u610f\uff1a\u6211\u4eec\u628a\u8f93\u5165\u4e2d\u51fa\u73b0\u7684\u7b2c1\u4e2a\u7a7a\u683c\u8ba4\u4e3a\u662f A \u548c B \u7684\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u7a7a\u683c\uff0c\u5e76\u4e14 B \u4e0d\u662f\u4e00\u4e2a\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u8f93\u5165\u7684\u786e\u662f\u4e24\u4e2a\u6b63\u6574\u6570\uff0c\u5219\u6309\u683c\u5f0f A + B = \u548c \u8f93\u51fa\u3002\u5982\u679c\u67d0\u4e2a\u8f93\u5165\u4e0d\u5408\u8981\u6c42\uff0c\u5219\u5728\u76f8\u5e94\u4f4d\u7f6e\u8f93\u51fa ? \uff0c\u663e\u7136\u6b64\u65f6\u548c\u4e5f\u662f ? \u3002 \u8f93\u5165\u6837\u4f8b1 123 456 \u8f93\u51fa\u6837\u4f8b1 123 + 456 = 579 \u8f93\u5165\u6837\u4f8b2 22. 18 \u8f93\u51fa\u6837\u4f8b2 ? + 18 = ? \u8f93\u5165\u6837\u4f8b3 -100 blabla bla...33 \u8f93\u51fa\u6837\u4f8b3 ? + ? = ? Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int f ( string s ) { int len = s . size (); int i ; int num = 0 ; if ( s [ 0 ] == '0' ) return -1 ; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] <= '9' && s [ i ] >= '0' ) num = num * 10 + ( s [ i ] - '0' ); else { return -1 ; } } return num ; } int main () { string a , b ; cin >> a ; getchar (); getline ( cin , b ); // cout << b << endl; int n = f ( a ); int m = f ( b ); if ( n >= 1 && n <= 1000 && m >= 1 && m <= 1000 ) printf ( \"%d + %d = %d \\n \" , n , m , n + m ); else if ( n <= 1000 && n >= 1 ) printf ( \"%d + ? = ? \\n \" , n ); else if ( m <= 1000 && m >= 1 ) printf ( \"? + %d = ? \\n \" , m ); else printf ( \"? + ? = ? \\n \" ); }","title":"L1-025-\u6b63\u6574\u6570A+B"},{"location":"CCCC/L1-025-%E6%AD%A3%E6%95%B4%E6%95%B0A%2BB/#l1-025-\u6b63\u6574\u6570ab","text":"","title":"L1-025 \u6b63\u6574\u6570A+B"},{"location":"CCCC/L1-025-%E6%AD%A3%E6%95%B4%E6%95%B0A%2BB/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u9898\u7684\u76ee\u6807\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6c42\u4e24\u4e2a\u6b63\u6574\u6570 A \u548c B \u7684\u548c\uff0c\u5176\u4e2d A \u548c B \u90fd\u5728\u533a\u95f4[1,1000]\u3002\u7a0d\u5fae\u6709\u70b9\u9ebb\u70e6\u7684\u662f\uff0c\u8f93\u5165\u5e76\u4e0d\u4fdd\u8bc1\u662f\u4e24\u4e2a\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa A \u548c B \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u5f00\u3002\u95ee\u9898\u662f A \u548c B \u4e0d\u4e00\u5b9a\u662f\u6ee1\u8db3\u8981\u6c42\u7684\u6b63\u6574\u6570\uff0c\u6709\u65f6\u5019\u53ef\u80fd\u662f\u8d85\u51fa\u8303\u56f4\u7684\u6570\u5b57\u3001\u8d1f\u6570\u3001\u5e26\u5c0f\u6570\u70b9\u7684\u5b9e\u6570\u3001\u751a\u81f3\u662f\u4e00\u5806\u4e71\u7801\u3002 \u6ce8\u610f\uff1a\u6211\u4eec\u628a\u8f93\u5165\u4e2d\u51fa\u73b0\u7684\u7b2c1\u4e2a\u7a7a\u683c\u8ba4\u4e3a\u662f A \u548c B \u7684\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u7a7a\u683c\uff0c\u5e76\u4e14 B \u4e0d\u662f\u4e00\u4e2a\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u8f93\u5165\u7684\u786e\u662f\u4e24\u4e2a\u6b63\u6574\u6570\uff0c\u5219\u6309\u683c\u5f0f A + B = \u548c \u8f93\u51fa\u3002\u5982\u679c\u67d0\u4e2a\u8f93\u5165\u4e0d\u5408\u8981\u6c42\uff0c\u5219\u5728\u76f8\u5e94\u4f4d\u7f6e\u8f93\u51fa ? \uff0c\u663e\u7136\u6b64\u65f6\u548c\u4e5f\u662f ? \u3002 \u8f93\u5165\u6837\u4f8b1 123 456 \u8f93\u51fa\u6837\u4f8b1 123 + 456 = 579 \u8f93\u5165\u6837\u4f8b2 22. 18 \u8f93\u51fa\u6837\u4f8b2 ? + 18 = ? \u8f93\u5165\u6837\u4f8b3 -100 blabla bla...33 \u8f93\u51fa\u6837\u4f8b3 ? + ? = ?","title":"Statement"},{"location":"CCCC/L1-025-%E6%AD%A3%E6%95%B4%E6%95%B0A%2BB/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int f ( string s ) { int len = s . size (); int i ; int num = 0 ; if ( s [ 0 ] == '0' ) return -1 ; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] <= '9' && s [ i ] >= '0' ) num = num * 10 + ( s [ i ] - '0' ); else { return -1 ; } } return num ; } int main () { string a , b ; cin >> a ; getchar (); getline ( cin , b ); // cout << b << endl; int n = f ( a ); int m = f ( b ); if ( n >= 1 && n <= 1000 && m >= 1 && m <= 1000 ) printf ( \"%d + %d = %d \\n \" , n , m , n + m ); else if ( n <= 1000 && n >= 1 ) printf ( \"%d + ? = ? \\n \" , n ); else if ( m <= 1000 && m >= 1 ) printf ( \"? + %d = ? \\n \" , m ); else printf ( \"? + ? = ? \\n \" ); }","title":"Solution"},{"location":"CCCC/L1-026-I%20Love%20GPLT/","text":"L1-026 I Love GPLT Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u628a\u8fd9\u53e5\u5f88\u91cd\u8981\u7684\u8bdd \u2014\u2014 \u201cI Love GPLT\u201d\u2014\u2014\u7ad6\u7740\u8f93\u51fa\u5c31\u53ef\u4ee5\u4e86\u3002 \u6240\u8c13\u201c\u7ad6\u7740\u8f93\u51fa\u201d\uff0c\u662f\u6307\u6bcf\u4e2a\u5b57\u7b26\u5360\u4e00\u884c\uff08\u5305\u62ec\u7a7a\u683c\uff09\uff0c\u5373\u6bcf\u884c\u53ea\u80fd\u67091\u4e2a\u5b57\u7b26\u548c\u56de\u8f66\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b I L o v e G P L T \u6ce8\u610f\uff1a\u8f93\u51fa\u7684\u4e24\u4e2a\u7a7a\u884c\u4e2d\u5404\u6709\u4e00\u4e2a\u7a7a\u683c\u3002 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s = \"I Love GPLT\" ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) cout << s [ i ] << endl ; }","title":"L1-026-I Love GPLT"},{"location":"CCCC/L1-026-I%20Love%20GPLT/#l1-026-i-love-gplt","text":"","title":"L1-026 I Love GPLT"},{"location":"CCCC/L1-026-I%20Love%20GPLT/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u628a\u8fd9\u53e5\u5f88\u91cd\u8981\u7684\u8bdd \u2014\u2014 \u201cI Love GPLT\u201d\u2014\u2014\u7ad6\u7740\u8f93\u51fa\u5c31\u53ef\u4ee5\u4e86\u3002 \u6240\u8c13\u201c\u7ad6\u7740\u8f93\u51fa\u201d\uff0c\u662f\u6307\u6bcf\u4e2a\u5b57\u7b26\u5360\u4e00\u884c\uff08\u5305\u62ec\u7a7a\u683c\uff09\uff0c\u5373\u6bcf\u884c\u53ea\u80fd\u67091\u4e2a\u5b57\u7b26\u548c\u56de\u8f66\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b I L o v e G P L T \u6ce8\u610f\uff1a\u8f93\u51fa\u7684\u4e24\u4e2a\u7a7a\u884c\u4e2d\u5404\u6709\u4e00\u4e2a\u7a7a\u683c\u3002","title":"Statement"},{"location":"CCCC/L1-026-I%20Love%20GPLT/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s = \"I Love GPLT\" ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) cout << s [ i ] << endl ; }","title":"Solution"},{"location":"CCCC/L1-027-%E5%87%BA%E7%A7%9F/","text":"L1-027 \u51fa\u79df Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u9762\u662f\u65b0\u6d6a\u5fae\u535a\u4e0a\u66fe\u7ecf\u5f88\u706b\u7684\u4e00\u5f20\u56fe\uff1a \u4e00\u65f6\u95f4\u7f51\u4e0a\u4e00\u7247\u6c42\u6551\u58f0\uff0c\u6025\u95ee\u8fd9\u4e2a\u600e\u4e48\u7834\u3002\u5176\u5b9e\u8fd9\u6bb5\u4ee3\u7801\u5f88\u7b80\u5355\uff0c index \u6570\u7ec4\u5c31\u662f arr \u6570\u7ec4\u7684\u4e0b\u6807\uff0c index[0]=2 \u5bf9\u5e94 arr[2]=1 \uff0c index[1]=0 \u5bf9\u5e94 arr[0]=8 \uff0c index[2]=3 \u5bf9\u5e94 arr[3]=0 \uff0c\u4ee5\u6b64\u7c7b\u63a8\u2026\u2026 \u5f88\u5bb9\u6613\u5f97\u5230\u7535\u8bdd\u53f7\u7801\u662f 18013820100 \u3002 \u672c\u9898\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u4e3a\u4efb\u4f55\u4e00\u4e2a\u7535\u8bdd\u53f7\u7801\u751f\u6210\u8fd9\u6bb5\u4ee3\u7801 \u2014\u2014 \u4e8b\u5b9e\u4e0a\uff0c\u53ea\u8981\u751f\u6210\u6700\u524d\u9762\u4e24\u884c\u5c31\u53ef\u4ee5\u4e86\uff0c\u540e\u9762\u5185\u5bb9\u662f\u4e0d\u53d8\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u753111\u4f4d\u6570\u5b57\u7ec4\u6210\u7684\u624b\u673a\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u8f93\u5165\u7684\u53f7\u7801\u751f\u6210\u4ee3\u7801\u7684\u524d\u4e24\u884c\uff0c\u5176\u4e2d arr \u4e2d\u7684\u6570\u5b57\u5fc5\u987b\u6309\u9012\u51cf\u987a\u5e8f\u7ed9\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 18013820100 \u8f93\u51fa\u6837\u4f8b int[] arr = new int[]{8,3,2,1,0}; int[] index = new int[]{3,0,4,3,1,0,2,4,3,4,4}; Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int arr [ 10 ] = { 0 }; int main () { string s ; cin >> s ; int len = s . size (); int i , j ; for ( i = 0 ; i < len ; i ++ ) { arr [ s [ i ] - '0' ] ++ ; } map < int , int > m ; m . clear (); printf ( \"int[] arr = new int[]{\" ); for ( i = 9 , j = 0 ; i >= 0 ; i -- ) { if ( arr [ i ]) { if ( j ) printf ( \",\" ); printf ( \"%d\" , i ); m [ i ] = j ; j ++ ; } } printf ( \"}; \\n \" ); printf ( \"int[] index = new int[]{\" ); for ( i = 0 ; i < len ; i ++ ) { if ( i ) printf ( \",\" ); printf ( \"%d\" , m [ s [ i ] - '0' ]); } printf ( \"}; \\n \" ); }","title":"L1-027-\u51fa\u79df"},{"location":"CCCC/L1-027-%E5%87%BA%E7%A7%9F/#l1-027-\u51fa\u79df","text":"","title":"L1-027 \u51fa\u79df"},{"location":"CCCC/L1-027-%E5%87%BA%E7%A7%9F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u9762\u662f\u65b0\u6d6a\u5fae\u535a\u4e0a\u66fe\u7ecf\u5f88\u706b\u7684\u4e00\u5f20\u56fe\uff1a \u4e00\u65f6\u95f4\u7f51\u4e0a\u4e00\u7247\u6c42\u6551\u58f0\uff0c\u6025\u95ee\u8fd9\u4e2a\u600e\u4e48\u7834\u3002\u5176\u5b9e\u8fd9\u6bb5\u4ee3\u7801\u5f88\u7b80\u5355\uff0c index \u6570\u7ec4\u5c31\u662f arr \u6570\u7ec4\u7684\u4e0b\u6807\uff0c index[0]=2 \u5bf9\u5e94 arr[2]=1 \uff0c index[1]=0 \u5bf9\u5e94 arr[0]=8 \uff0c index[2]=3 \u5bf9\u5e94 arr[3]=0 \uff0c\u4ee5\u6b64\u7c7b\u63a8\u2026\u2026 \u5f88\u5bb9\u6613\u5f97\u5230\u7535\u8bdd\u53f7\u7801\u662f 18013820100 \u3002 \u672c\u9898\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u4e3a\u4efb\u4f55\u4e00\u4e2a\u7535\u8bdd\u53f7\u7801\u751f\u6210\u8fd9\u6bb5\u4ee3\u7801 \u2014\u2014 \u4e8b\u5b9e\u4e0a\uff0c\u53ea\u8981\u751f\u6210\u6700\u524d\u9762\u4e24\u884c\u5c31\u53ef\u4ee5\u4e86\uff0c\u540e\u9762\u5185\u5bb9\u662f\u4e0d\u53d8\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u753111\u4f4d\u6570\u5b57\u7ec4\u6210\u7684\u624b\u673a\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u8f93\u5165\u7684\u53f7\u7801\u751f\u6210\u4ee3\u7801\u7684\u524d\u4e24\u884c\uff0c\u5176\u4e2d arr \u4e2d\u7684\u6570\u5b57\u5fc5\u987b\u6309\u9012\u51cf\u987a\u5e8f\u7ed9\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 18013820100 \u8f93\u51fa\u6837\u4f8b int[] arr = new int[]{8,3,2,1,0}; int[] index = new int[]{3,0,4,3,1,0,2,4,3,4,4};","title":"Statement"},{"location":"CCCC/L1-027-%E5%87%BA%E7%A7%9F/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int arr [ 10 ] = { 0 }; int main () { string s ; cin >> s ; int len = s . size (); int i , j ; for ( i = 0 ; i < len ; i ++ ) { arr [ s [ i ] - '0' ] ++ ; } map < int , int > m ; m . clear (); printf ( \"int[] arr = new int[]{\" ); for ( i = 9 , j = 0 ; i >= 0 ; i -- ) { if ( arr [ i ]) { if ( j ) printf ( \",\" ); printf ( \"%d\" , i ); m [ i ] = j ; j ++ ; } } printf ( \"}; \\n \" ); printf ( \"int[] index = new int[]{\" ); for ( i = 0 ; i < len ; i ++ ) { if ( i ) printf ( \",\" ); printf ( \"%d\" , m [ s [ i ] - '0' ]); } printf ( \"}; \\n \" ); }","title":"Solution"},{"location":"CCCC/L1-028-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/","text":"L1-028 \u5224\u65ad\u7d20\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u76ee\u6807\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5224\u65ad\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\u662f\u5426\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 10\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u4e8e 2^{31} 2^{31} \u7684\u9700\u8981\u5224\u65ad\u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u5224\u65ad\u7684\u6b63\u6574\u6570\uff0c\u5982\u679c\u5b83\u662f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 2 11 111 \u8f93\u51fa\u6837\u4f8b Yes No Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int isPrime ( int x ) { int flag ; int n , m ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 || x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { m = sqrt ( x ) + 1 ; for ( n = 3 ; n <= m ; n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { int n ; cin >> n ; int num ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); if ( isPrime ( num )) cout << \"Yes \\n \" ; else cout << \"No \\n \" ; } }","title":"L1-028-\u5224\u65ad\u7d20\u6570"},{"location":"CCCC/L1-028-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/#l1-028-\u5224\u65ad\u7d20\u6570","text":"","title":"L1-028 \u5224\u65ad\u7d20\u6570"},{"location":"CCCC/L1-028-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u76ee\u6807\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5224\u65ad\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\u662f\u5426\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 10\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u4e8e 2^{31} 2^{31} \u7684\u9700\u8981\u5224\u65ad\u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u5224\u65ad\u7684\u6b63\u6574\u6570\uff0c\u5982\u679c\u5b83\u662f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 2 11 111 \u8f93\u51fa\u6837\u4f8b Yes No","title":"Statement"},{"location":"CCCC/L1-028-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int isPrime ( int x ) { int flag ; int n , m ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 || x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { m = sqrt ( x ) + 1 ; for ( n = 3 ; n <= m ; n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { int n ; cin >> n ; int num ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); if ( isPrime ( num )) cout << \"Yes \\n \" ; else cout << \"No \\n \" ; } }","title":"Solution"},{"location":"CCCC/L1-029-%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/","text":"L1-029 \u662f\u4e0d\u662f\u592a\u80d6\u4e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u4e00\u4e2a\u4eba\u7684\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u5176\u8eab\u9ad8\uff08\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u51cf\u53bb100\u3001\u518d\u4e58\u4ee50.9\u6240\u5f97\u5230\u7684\u516c\u65a4\u6570\u3002\u5df2\u77e5\u5e02\u65a4\u7684\u6570\u503c\u662f\u516c\u65a4\u6570\u503c\u7684\u4e24\u500d\u3002\u73b0\u7ed9\u5b9a\u67d0\u4eba\u8eab\u9ad8\uff0c\u8bf7\u4f60\u8ba1\u7b97\u5176\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u591a\u5c11\uff1f\uff08\u987a\u4fbf\u4e5f\u6084\u6084\u7ed9\u81ea\u5df1\u7b97\u4e00\u4e0b\u5427\u2026\u2026\uff09 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 H \uff08100 < < H \\le \\le 300\uff09\uff0c\u4e3a\u67d0\u4eba\u8eab\u9ad8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u7684\u6807\u51c6\u4f53\u91cd\uff0c\u5355\u4f4d\u4e3a\u5e02\u65a4\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 169 \u8f93\u51fa\u6837\u4f8b 124.2 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"%.1lf \\n \" , ( n - 100 ) * 0.9 * 2 ); }","title":"L1-029-\u662f\u4e0d\u662f\u592a\u80d6\u4e86"},{"location":"CCCC/L1-029-%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#l1-029-\u662f\u4e0d\u662f\u592a\u80d6\u4e86","text":"","title":"L1-029 \u662f\u4e0d\u662f\u592a\u80d6\u4e86"},{"location":"CCCC/L1-029-%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u4e00\u4e2a\u4eba\u7684\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u5176\u8eab\u9ad8\uff08\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u51cf\u53bb100\u3001\u518d\u4e58\u4ee50.9\u6240\u5f97\u5230\u7684\u516c\u65a4\u6570\u3002\u5df2\u77e5\u5e02\u65a4\u7684\u6570\u503c\u662f\u516c\u65a4\u6570\u503c\u7684\u4e24\u500d\u3002\u73b0\u7ed9\u5b9a\u67d0\u4eba\u8eab\u9ad8\uff0c\u8bf7\u4f60\u8ba1\u7b97\u5176\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u591a\u5c11\uff1f\uff08\u987a\u4fbf\u4e5f\u6084\u6084\u7ed9\u81ea\u5df1\u7b97\u4e00\u4e0b\u5427\u2026\u2026\uff09 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 H \uff08100 < < H \\le \\le 300\uff09\uff0c\u4e3a\u67d0\u4eba\u8eab\u9ad8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u7684\u6807\u51c6\u4f53\u91cd\uff0c\u5355\u4f4d\u4e3a\u5e02\u65a4\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 169 \u8f93\u51fa\u6837\u4f8b 124.2","title":"Statement"},{"location":"CCCC/L1-029-%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; printf ( \"%.1lf \\n \" , ( n - 100 ) * 0.9 * 2 ); }","title":"Solution"},{"location":"CCCC/L1-030-%E4%B8%80%E5%B8%AE%E4%B8%80/","text":"L1-030 \u4e00\u5e2e\u4e00 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u4e00\u5e2e\u4e00\u5b66\u4e60\u5c0f\u7ec4\u201d\u662f\u4e2d\u5c0f\u5b66\u4e2d\u5e38\u89c1\u7684\u5b66\u4e60\u7ec4\u7ec7\u65b9\u5f0f\uff0c\u8001\u5e08\u628a\u5b66\u4e60\u6210\u7ee9\u9760\u524d\u7684\u5b66\u751f\u8ddf\u5b66\u4e60\u6210\u7ee9\u9760\u540e\u7684\u5b66\u751f\u6392\u5728\u4e00\u7ec4\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u81ea\u52a8\u5b8c\u6210\u8fd9\u4e2a\u5206\u914d\u5de5\u4f5c\uff0c\u5373\u5728\u5f97\u5230\u5168\u73ed\u5b66\u751f\u7684\u6392\u540d\u540e\uff0c\u5728\u5f53\u524d\u5c1a\u672a\u5206\u7ec4\u7684\u5b66\u751f\u4e2d\uff0c\u5c06\u540d\u6b21\u6700\u9760\u524d\u7684\u5b66\u751f\u4e0e\u540d\u6b21\u6700\u9760\u540e\u7684 \u5f02\u6027 \u5b66\u751f\u5206\u4e3a\u4e00\u7ec4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u5076\u6570 N \uff08 \\le \\le 50\uff09\uff0c\u5373\u5168\u73ed\u5b66\u751f\u7684\u4eba\u6570\u3002\u6b64\u540e N \u884c\uff0c\u6309\u7167\u540d\u6b21\u4ece\u9ad8\u5230\u4f4e\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u6027\u522b\uff080\u4ee3\u8868\u5973\u751f\uff0c1\u4ee3\u8868\u7537\u751f\uff09\u548c\u59d3\u540d\uff08\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u8fd9\u91cc\u4fdd\u8bc1\u672c\u73ed\u7537\u5973\u6bd4\u4f8b\u662f1:1\uff0c\u5e76\u4e14\u6ca1\u6709\u5e76\u5217\u540d\u6b21\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u884c\u8f93\u51fa\u4e00\u7ec4\u4e24\u4e2a\u5b66\u751f\u7684\u59d3\u540d\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u540d\u6b21\u9ad8\u7684\u5b66\u751f\u5728\u524d\uff0c\u540d\u6b21\u4f4e\u7684\u5b66\u751f\u5728\u540e\u3002\u5c0f\u7ec4\u7684\u8f93\u51fa\u987a\u5e8f\u6309\u7167\u524d\u9762\u5b66\u751f\u7684\u540d\u6b21\u4ece\u9ad8\u5230\u4f4e\u6392\u5217\u3002 \u8f93\u5165\u6837\u4f8b 8 0 Amy 1 Tom 1 Bill 0 Cindy 0 Maya 1 John 1 Jack 0 Linda \u8f93\u51fa\u6837\u4f8b Amy Jack Tom Linda Bill Maya Cindy John Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { string name ; int sex ; } temp ; int main () { int n ; cin >> n ; vector < Node > F , M , V ; F . clear (); M . clear (); V . clear (); for ( int i = 0 ; i < n ; i ++ ) { cin >> temp . sex >> temp . name ; if ( temp . sex == 1 ) M . push_back ( temp ); else F . push_back ( temp ); V . push_back ( temp ); } n /= 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( V [ i ]. sex == 1 ) { cout << V [ i ]. name << \" \" << F [ F . size () - 1 ]. name << endl ; F . pop_back (); } else { cout << V [ i ]. name << \" \" << M [ M . size () - 1 ]. name << endl ; M . pop_back (); } } }","title":"L1-030-\u4e00\u5e2e\u4e00"},{"location":"CCCC/L1-030-%E4%B8%80%E5%B8%AE%E4%B8%80/#l1-030-\u4e00\u5e2e\u4e00","text":"","title":"L1-030 \u4e00\u5e2e\u4e00"},{"location":"CCCC/L1-030-%E4%B8%80%E5%B8%AE%E4%B8%80/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u4e00\u5e2e\u4e00\u5b66\u4e60\u5c0f\u7ec4\u201d\u662f\u4e2d\u5c0f\u5b66\u4e2d\u5e38\u89c1\u7684\u5b66\u4e60\u7ec4\u7ec7\u65b9\u5f0f\uff0c\u8001\u5e08\u628a\u5b66\u4e60\u6210\u7ee9\u9760\u524d\u7684\u5b66\u751f\u8ddf\u5b66\u4e60\u6210\u7ee9\u9760\u540e\u7684\u5b66\u751f\u6392\u5728\u4e00\u7ec4\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u81ea\u52a8\u5b8c\u6210\u8fd9\u4e2a\u5206\u914d\u5de5\u4f5c\uff0c\u5373\u5728\u5f97\u5230\u5168\u73ed\u5b66\u751f\u7684\u6392\u540d\u540e\uff0c\u5728\u5f53\u524d\u5c1a\u672a\u5206\u7ec4\u7684\u5b66\u751f\u4e2d\uff0c\u5c06\u540d\u6b21\u6700\u9760\u524d\u7684\u5b66\u751f\u4e0e\u540d\u6b21\u6700\u9760\u540e\u7684 \u5f02\u6027 \u5b66\u751f\u5206\u4e3a\u4e00\u7ec4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u5076\u6570 N \uff08 \\le \\le 50\uff09\uff0c\u5373\u5168\u73ed\u5b66\u751f\u7684\u4eba\u6570\u3002\u6b64\u540e N \u884c\uff0c\u6309\u7167\u540d\u6b21\u4ece\u9ad8\u5230\u4f4e\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u6027\u522b\uff080\u4ee3\u8868\u5973\u751f\uff0c1\u4ee3\u8868\u7537\u751f\uff09\u548c\u59d3\u540d\uff08\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u8fd9\u91cc\u4fdd\u8bc1\u672c\u73ed\u7537\u5973\u6bd4\u4f8b\u662f1:1\uff0c\u5e76\u4e14\u6ca1\u6709\u5e76\u5217\u540d\u6b21\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u884c\u8f93\u51fa\u4e00\u7ec4\u4e24\u4e2a\u5b66\u751f\u7684\u59d3\u540d\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u540d\u6b21\u9ad8\u7684\u5b66\u751f\u5728\u524d\uff0c\u540d\u6b21\u4f4e\u7684\u5b66\u751f\u5728\u540e\u3002\u5c0f\u7ec4\u7684\u8f93\u51fa\u987a\u5e8f\u6309\u7167\u524d\u9762\u5b66\u751f\u7684\u540d\u6b21\u4ece\u9ad8\u5230\u4f4e\u6392\u5217\u3002 \u8f93\u5165\u6837\u4f8b 8 0 Amy 1 Tom 1 Bill 0 Cindy 0 Maya 1 John 1 Jack 0 Linda \u8f93\u51fa\u6837\u4f8b Amy Jack Tom Linda Bill Maya Cindy John","title":"Statement"},{"location":"CCCC/L1-030-%E4%B8%80%E5%B8%AE%E4%B8%80/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { string name ; int sex ; } temp ; int main () { int n ; cin >> n ; vector < Node > F , M , V ; F . clear (); M . clear (); V . clear (); for ( int i = 0 ; i < n ; i ++ ) { cin >> temp . sex >> temp . name ; if ( temp . sex == 1 ) M . push_back ( temp ); else F . push_back ( temp ); V . push_back ( temp ); } n /= 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( V [ i ]. sex == 1 ) { cout << V [ i ]. name << \" \" << F [ F . size () - 1 ]. name << endl ; F . pop_back (); } else { cout << V [ i ]. name << \" \" << M [ M . size () - 1 ]. name << endl ; M . pop_back (); } } }","title":"Solution"},{"location":"CCCC/L1-031-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/","text":"L1-031 \u5230\u5e95\u662f\u4e0d\u662f\u592a\u80d6\u4e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u4e00\u4e2a\u4eba\u7684\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u5176\u8eab\u9ad8\uff08\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u51cf\u53bb100\u3001\u518d\u4e58\u4ee50.9\u6240\u5f97\u5230\u7684\u516c\u65a4\u6570\u3002\u771f\u5b9e\u4f53\u91cd\u4e0e\u6807\u51c6\u4f53\u91cd\u8bef\u5dee\u572810%\u4ee5\u5185\u90fd\u662f\u5b8c\u7f8e\u8eab\u6750\uff08\u5373 | \u771f\u5b9e\u4f53\u91cd - - \u6807\u51c6\u4f53\u91cd | < < \u6807\u51c6\u4f53\u91cd \\times 10\\% \\times 10\\% \uff09\u3002\u5df2\u77e5\u5e02\u65a4\u662f\u516c\u65a4\u7684\u4e24\u500d\u3002\u73b0\u7ed9\u5b9a\u4e00\u7fa4\u4eba\u7684\u8eab\u9ad8\u548c\u5b9e\u9645\u4f53\u91cd\uff0c\u8bf7\u4f60\u544a\u8bc9\u4ed6\u4eec\u662f\u5426\u592a\u80d6\u6216\u592a\u7626\u4e86\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 20\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f\u4e00\u4e2a\u4eba\u7684\u8eab\u9ad8 H \uff08120 < < H < < 200\uff1b\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u548c\u771f\u5b9e\u4f53\u91cd W \uff0850 < < W \\le \\le 300\uff1b\u5355\u4f4d\uff1a\u5e02\u65a4\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u6bcf\u4e2a\u4eba\u8f93\u51fa\u4e00\u884c\u7ed3\u8bba\uff1a\u5982\u679c\u662f\u5b8c\u7f8e\u8eab\u6750\uff0c\u8f93\u51fa You are wan mei! \uff1b\u5982\u679c\u592a\u80d6\u4e86\uff0c\u8f93\u51fa You are tai pang le! \uff1b\u5426\u5219\u8f93\u51fa You are tai shou le! \u3002 \u8f93\u5165\u6837\u4f8b 3 169 136 150 81 178 155 \u8f93\u51fa\u6837\u4f8b You are wan mei! You are tai shou le! You are tai pang le! Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; while ( n -- ) { double a , b ; cin >> a >> b ; double temp ; temp = ( a - 100 ) * 0.9 * 2 ; if ( fabs ( b - temp ) < temp * 0.1 ) printf ( \"You are wan mei! \\n \" ); else if ( b < temp ) printf ( \"You are tai shou le! \\n \" ); else printf ( \"You are tai pang le! \\n \" ); } }","title":"L1-031-\u5230\u5e95\u662f\u4e0d\u662f\u592a\u80d6\u4e86"},{"location":"CCCC/L1-031-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#l1-031-\u5230\u5e95\u662f\u4e0d\u662f\u592a\u80d6\u4e86","text":"","title":"L1-031 \u5230\u5e95\u662f\u4e0d\u662f\u592a\u80d6\u4e86"},{"location":"CCCC/L1-031-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u4e00\u4e2a\u4eba\u7684\u6807\u51c6\u4f53\u91cd\u5e94\u8be5\u662f\u5176\u8eab\u9ad8\uff08\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u51cf\u53bb100\u3001\u518d\u4e58\u4ee50.9\u6240\u5f97\u5230\u7684\u516c\u65a4\u6570\u3002\u771f\u5b9e\u4f53\u91cd\u4e0e\u6807\u51c6\u4f53\u91cd\u8bef\u5dee\u572810%\u4ee5\u5185\u90fd\u662f\u5b8c\u7f8e\u8eab\u6750\uff08\u5373 | \u771f\u5b9e\u4f53\u91cd - - \u6807\u51c6\u4f53\u91cd | < < \u6807\u51c6\u4f53\u91cd \\times 10\\% \\times 10\\% \uff09\u3002\u5df2\u77e5\u5e02\u65a4\u662f\u516c\u65a4\u7684\u4e24\u500d\u3002\u73b0\u7ed9\u5b9a\u4e00\u7fa4\u4eba\u7684\u8eab\u9ad8\u548c\u5b9e\u9645\u4f53\u91cd\uff0c\u8bf7\u4f60\u544a\u8bc9\u4ed6\u4eec\u662f\u5426\u592a\u80d6\u6216\u592a\u7626\u4e86\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 20\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f\u4e00\u4e2a\u4eba\u7684\u8eab\u9ad8 H \uff08120 < < H < < 200\uff1b\u5355\u4f4d\uff1a\u5398\u7c73\uff09\u548c\u771f\u5b9e\u4f53\u91cd W \uff0850 < < W \\le \\le 300\uff1b\u5355\u4f4d\uff1a\u5e02\u65a4\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u6bcf\u4e2a\u4eba\u8f93\u51fa\u4e00\u884c\u7ed3\u8bba\uff1a\u5982\u679c\u662f\u5b8c\u7f8e\u8eab\u6750\uff0c\u8f93\u51fa You are wan mei! \uff1b\u5982\u679c\u592a\u80d6\u4e86\uff0c\u8f93\u51fa You are tai pang le! \uff1b\u5426\u5219\u8f93\u51fa You are tai shou le! \u3002 \u8f93\u5165\u6837\u4f8b 3 169 136 150 81 178 155 \u8f93\u51fa\u6837\u4f8b You are wan mei! You are tai shou le! You are tai pang le!","title":"Statement"},{"location":"CCCC/L1-031-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%A4%AA%E8%83%96%E4%BA%86/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; while ( n -- ) { double a , b ; cin >> a >> b ; double temp ; temp = ( a - 100 ) * 0.9 * 2 ; if ( fabs ( b - temp ) < temp * 0.1 ) printf ( \"You are wan mei! \\n \" ); else if ( b < temp ) printf ( \"You are tai shou le! \\n \" ); else printf ( \"You are tai pang le! \\n \" ); } }","title":"Solution"},{"location":"CCCC/L1-032-Left-pad/","text":"L1-032 Left-pad Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u65b0\u6d6a\u5fae\u535a\u4e0a\u7684\u6d88\u606f\uff0c\u6709\u4e00\u4f4d\u5f00\u53d1\u8005\u4e0d\u6ee1NPM\uff08Node Package Manager\uff09\u7684\u505a\u6cd5\uff0c\u6536\u56de\u4e86\u81ea\u5df1\u7684\u5f00\u6e90\u4ee3\u7801\uff0c\u5176\u4e2d\u5305\u62ec\u4e00\u4e2a\u53ebleft-pad\u7684\u6a21\u5757\uff0c\u5c31\u662f\u8fd9\u4e2a\u6a21\u5757\u628ajavascript\u91cc\u9762\u7684React/Babel\u5e72\u762b\u75ea\u4e86\u3002\u8fd9\u662f\u4e2a\u4ec0\u4e48\u6837\u7684\u6a21\u5757\uff1f\u5c31\u662f\u5728\u5b57\u7b26\u4e32\u524d\u586b\u5145\u4e00\u4e9b\u4e1c\u897f\u5230\u4e00\u5b9a\u7684\u957f\u5ea6\u3002\u4f8b\u5982\u7528 * \u53bb\u586b\u5145\u5b57\u7b26\u4e32 GPLT \uff0c\u4f7f\u4e4b\u957f\u5ea6\u4e3a10\uff0c\u8c03\u7528left-pad\u7684\u7ed3\u679c\u5c31\u5e94\u8be5\u662f ******GPLT \u3002Node\u793e\u533a\u66fe\u7ecf\u5bf9left-pad\u7d27\u6025\u53d1\u5e03\u4e86\u4e00\u4e2a\u66ff\u4ee3\uff0c\u88ab\u4e25\u91cd\u5410\u69fd\u3002\u4e0b\u9762\u5c31\u8bf7\u4f60\u6765\u5b9e\u73b0\u4e00\u4e0b\u8fd9\u4e2a\u6a21\u5757\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c\u4e00\u4e2a\u5b57\u7b26\uff0c\u5206\u522b\u662f\u586b\u5145\u7ed3\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u548c\u7528\u4e8e\u586b\u5145\u7684\u5b57\u7b26\uff0c\u4e2d\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u5f00\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u539f\u59cb\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u6837\u4f8b1 15 _ I love GPLT \u8f93\u51fa\u6837\u4f8b1 ____I love GPLT \u8f93\u5165\u6837\u4f8b2 4 * this is a sample for cut \u8f93\u51fa\u6837\u4f8b2 cut Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; int n ; char vis ; scanf ( \"%d %c \" , & n , & vis ); getline ( cin , s ); int len = s . size (); if ( len <= n ) { n -= len ; while ( n -- ) cout << vis ; cout << s << endl ; } else { for ( int i = len - n ; i < len ; i ++ ) cout << s [ i ]; cout << endl ; } }","title":"L1-032-Left-pad"},{"location":"CCCC/L1-032-Left-pad/#l1-032-left-pad","text":"","title":"L1-032 Left-pad"},{"location":"CCCC/L1-032-Left-pad/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u65b0\u6d6a\u5fae\u535a\u4e0a\u7684\u6d88\u606f\uff0c\u6709\u4e00\u4f4d\u5f00\u53d1\u8005\u4e0d\u6ee1NPM\uff08Node Package Manager\uff09\u7684\u505a\u6cd5\uff0c\u6536\u56de\u4e86\u81ea\u5df1\u7684\u5f00\u6e90\u4ee3\u7801\uff0c\u5176\u4e2d\u5305\u62ec\u4e00\u4e2a\u53ebleft-pad\u7684\u6a21\u5757\uff0c\u5c31\u662f\u8fd9\u4e2a\u6a21\u5757\u628ajavascript\u91cc\u9762\u7684React/Babel\u5e72\u762b\u75ea\u4e86\u3002\u8fd9\u662f\u4e2a\u4ec0\u4e48\u6837\u7684\u6a21\u5757\uff1f\u5c31\u662f\u5728\u5b57\u7b26\u4e32\u524d\u586b\u5145\u4e00\u4e9b\u4e1c\u897f\u5230\u4e00\u5b9a\u7684\u957f\u5ea6\u3002\u4f8b\u5982\u7528 * \u53bb\u586b\u5145\u5b57\u7b26\u4e32 GPLT \uff0c\u4f7f\u4e4b\u957f\u5ea6\u4e3a10\uff0c\u8c03\u7528left-pad\u7684\u7ed3\u679c\u5c31\u5e94\u8be5\u662f ******GPLT \u3002Node\u793e\u533a\u66fe\u7ecf\u5bf9left-pad\u7d27\u6025\u53d1\u5e03\u4e86\u4e00\u4e2a\u66ff\u4ee3\uff0c\u88ab\u4e25\u91cd\u5410\u69fd\u3002\u4e0b\u9762\u5c31\u8bf7\u4f60\u6765\u5b9e\u73b0\u4e00\u4e0b\u8fd9\u4e2a\u6a21\u5757\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c\u4e00\u4e2a\u5b57\u7b26\uff0c\u5206\u522b\u662f\u586b\u5145\u7ed3\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u548c\u7528\u4e8e\u586b\u5145\u7684\u5b57\u7b26\uff0c\u4e2d\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u5f00\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u539f\u59cb\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u6837\u4f8b1 15 _ I love GPLT \u8f93\u51fa\u6837\u4f8b1 ____I love GPLT \u8f93\u5165\u6837\u4f8b2 4 * this is a sample for cut \u8f93\u51fa\u6837\u4f8b2 cut","title":"Statement"},{"location":"CCCC/L1-032-Left-pad/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; int n ; char vis ; scanf ( \"%d %c \" , & n , & vis ); getline ( cin , s ); int len = s . size (); if ( len <= n ) { n -= len ; while ( n -- ) cout << vis ; cout << s << endl ; } else { for ( int i = len - n ; i < len ; i ++ ) cout << s [ i ]; cout << endl ; } }","title":"Solution"},{"location":"CCCC/L1-033-%E5%87%BA%E7%94%9F%E5%B9%B4/","text":"L1-033 \u51fa\u751f\u5e74 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u65b0\u6d6a\u5fae\u535a\u4e2d\u4e00\u5947\u8469\u8d34\uff1a\u201c\u6211\u51fa\u751f\u4e8e1988\u5e74\uff0c\u76f4\u523025\u5c81\u624d\u9047\u52304\u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u7684\u5e74\u4efd\u3002\u201d\u4e5f\u5c31\u662f\u8bf4\uff0c\u76f4\u52302013\u5e74\u624d\u8fbe\u5230\u201c4\u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u201d\u7684\u8981\u6c42\u3002\u672c\u9898\u8bf7\u4f60\u6839\u636e\u8981\u6c42\uff0c\u81ea\u52a8\u586b\u5145\u201c\u6211\u51fa\u751f\u4e8e y \u5e74\uff0c\u76f4\u5230 x \u5c81\u624d\u9047\u5230 n \u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u7684\u5e74\u4efd\u201d\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u51fa\u751f\u5e74\u4efd y \u548c\u76ee\u6807\u5e74\u4efd\u4e2d\u4e0d\u540c\u6570\u5b57\u7684\u4e2a\u6570 n \uff0c\u5176\u4e2d y \u5728[1, 3000]\u4e4b\u95f4\uff0c n \u53ef\u4ee5\u662f2\u3001\u62163\u3001\u62164\u3002\u6ce8\u610f\u4e0d\u8db34\u4f4d\u7684\u5e74\u4efd\u8981\u5728\u524d\u9762\u8865\u96f6\uff0c\u4f8b\u5982\u516c\u51431\u5e74\u88ab\u8ba4\u4e3a\u662f0001\u5e74\uff0c\u67092\u4e2a\u4e0d\u540c\u7684\u6570\u5b570\u548c1\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8f93\u5165\uff0c\u8f93\u51fa x \u548c\u80fd\u8fbe\u5230\u8981\u6c42\u7684\u5e74\u4efd\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5e74\u4efd\u8981\u63094\u4f4d\u8f93\u51fa\u3002\u6ce8\u610f\uff1a\u6240\u8c13\u201c n \u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u201d\u662f\u6307\u4e0d\u540c\u7684\u6570\u5b57\u6b63\u597d\u662f n \u4e2a\u3002\u5982\u201c2013\u201d\u88ab\u89c6\u4e3a\u6ee1\u8db3\u201c4\u4f4d\u6570\u5b57\u90fd\u4e0d\u540c\u201d\u7684\u6761\u4ef6\uff0c\u4f46\u4e0d\u88ab\u89c6\u4e3a\u6ee1\u8db32\u4f4d\u62163\u4f4d\u6570\u5b57\u4e0d\u540c\u7684\u6761\u4ef6\u3002 \u8f93\u5165\u6837\u4f8b1 1988 4 \u8f93\u51fa\u6837\u4f8b1 25 2013 \u8f93\u5165\u6837\u4f8b2 1 2 \u8f93\u51fa\u6837\u4f8b2 0 0001 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int f ( int y ) { map < int , int > m ; m . clear (); if ( y < 1000 ) m [ 0 ] = 1 ; while ( y ) { m [ y % 10 ] = 1 ; y /= 10 ; } return m . size (); } int main () { int y , n ; cin >> y >> n ; int ans = 0 ; while ( 1 ) { if ( f ( y ) == n ) break ; y ++ ; ans ++ ; } printf ( \"%d %04d \\n \" , ans , y ); }","title":"L1-033-\u51fa\u751f\u5e74"},{"location":"CCCC/L1-033-%E5%87%BA%E7%94%9F%E5%B9%B4/#l1-033-\u51fa\u751f\u5e74","text":"","title":"L1-033 \u51fa\u751f\u5e74"},{"location":"CCCC/L1-033-%E5%87%BA%E7%94%9F%E5%B9%B4/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u65b0\u6d6a\u5fae\u535a\u4e2d\u4e00\u5947\u8469\u8d34\uff1a\u201c\u6211\u51fa\u751f\u4e8e1988\u5e74\uff0c\u76f4\u523025\u5c81\u624d\u9047\u52304\u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u7684\u5e74\u4efd\u3002\u201d\u4e5f\u5c31\u662f\u8bf4\uff0c\u76f4\u52302013\u5e74\u624d\u8fbe\u5230\u201c4\u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u201d\u7684\u8981\u6c42\u3002\u672c\u9898\u8bf7\u4f60\u6839\u636e\u8981\u6c42\uff0c\u81ea\u52a8\u586b\u5145\u201c\u6211\u51fa\u751f\u4e8e y \u5e74\uff0c\u76f4\u5230 x \u5c81\u624d\u9047\u5230 n \u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u7684\u5e74\u4efd\u201d\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u51fa\u751f\u5e74\u4efd y \u548c\u76ee\u6807\u5e74\u4efd\u4e2d\u4e0d\u540c\u6570\u5b57\u7684\u4e2a\u6570 n \uff0c\u5176\u4e2d y \u5728[1, 3000]\u4e4b\u95f4\uff0c n \u53ef\u4ee5\u662f2\u3001\u62163\u3001\u62164\u3002\u6ce8\u610f\u4e0d\u8db34\u4f4d\u7684\u5e74\u4efd\u8981\u5728\u524d\u9762\u8865\u96f6\uff0c\u4f8b\u5982\u516c\u51431\u5e74\u88ab\u8ba4\u4e3a\u662f0001\u5e74\uff0c\u67092\u4e2a\u4e0d\u540c\u7684\u6570\u5b570\u548c1\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8f93\u5165\uff0c\u8f93\u51fa x \u548c\u80fd\u8fbe\u5230\u8981\u6c42\u7684\u5e74\u4efd\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5e74\u4efd\u8981\u63094\u4f4d\u8f93\u51fa\u3002\u6ce8\u610f\uff1a\u6240\u8c13\u201c n \u4e2a\u6570\u5b57\u90fd\u4e0d\u76f8\u540c\u201d\u662f\u6307\u4e0d\u540c\u7684\u6570\u5b57\u6b63\u597d\u662f n \u4e2a\u3002\u5982\u201c2013\u201d\u88ab\u89c6\u4e3a\u6ee1\u8db3\u201c4\u4f4d\u6570\u5b57\u90fd\u4e0d\u540c\u201d\u7684\u6761\u4ef6\uff0c\u4f46\u4e0d\u88ab\u89c6\u4e3a\u6ee1\u8db32\u4f4d\u62163\u4f4d\u6570\u5b57\u4e0d\u540c\u7684\u6761\u4ef6\u3002 \u8f93\u5165\u6837\u4f8b1 1988 4 \u8f93\u51fa\u6837\u4f8b1 25 2013 \u8f93\u5165\u6837\u4f8b2 1 2 \u8f93\u51fa\u6837\u4f8b2 0 0001","title":"Statement"},{"location":"CCCC/L1-033-%E5%87%BA%E7%94%9F%E5%B9%B4/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int f ( int y ) { map < int , int > m ; m . clear (); if ( y < 1000 ) m [ 0 ] = 1 ; while ( y ) { m [ y % 10 ] = 1 ; y /= 10 ; } return m . size (); } int main () { int y , n ; cin >> y >> n ; int ans = 0 ; while ( 1 ) { if ( f ( y ) == n ) break ; y ++ ; ans ++ ; } printf ( \"%d %04d \\n \" , ans , y ); }","title":"Solution"},{"location":"CCCC/L1-034-%E7%82%B9%E8%B5%9E/","text":"L1-034 \u70b9\u8d5e Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u70b9\u8d5e\u201d\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u559c\u6b22\u7684\u535a\u6587\u70b9\u4e2a\u8d5e\u8868\u793a\u652f\u6301\u3002\u6bcf\u7bc7\u535a\u6587\u90fd\u6709\u4e00\u4e9b\u523b\u753b\u5176\u7279\u6027\u7684\u6807\u7b7e\uff0c\u800c\u4f60\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7c7b\u578b\uff0c\u4e5f\u95f4\u63a5\u523b\u753b\u4e86\u4f60\u7684\u7279\u6027\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u7edf\u8ba1\u4e00\u4e2a\u4eba\u70b9\u8d5e\u7684\u7eaa\u5f55\uff0c\u5206\u6790\u8fd9\u4e2a\u4eba\u7684\u7279\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u662f\u8be5\u7528\u6237\u70b9\u8d5e\u7684\u535a\u6587\u6570\u91cf\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7bc7\u88ab\u5176\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7279\u6027\u63cf\u8ff0\uff0c\u683c\u5f0f\u4e3a\u201c K K F_1\\cdots F_K F_1\\cdots F_K \u201d\uff0c\u5176\u4e2d 1\\le K\\le 10 1\\le K\\le 10 \uff0c F_i F_i \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u7279\u6027\u6807\u7b7e\u7684\u7f16\u53f7\uff0c\u6211\u4eec\u5c06\u6240\u6709\u7279\u6027\u6807\u7b7e\u4ece1\u52301000\u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u7edf\u8ba1\u6240\u6709\u88ab\u70b9\u8d5e\u7684\u535a\u6587\u4e2d\u6700\u5e38\u51fa\u73b0\u7684\u90a3\u4e2a\u7279\u6027\u6807\u7b7e\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b83\u7684\u7f16\u53f7\u548c\u51fa\u73b0\u6b21\u6570\uff0c\u6570\u5b57\u95f4\u96941\u4e2a\u7a7a\u683c\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5927\u7684\u90a3\u4e2a\u3002 \u8f93\u5165\u6837\u4f8b 4 3 889 233 2 5 100 3 233 2 73 4 3 73 889 2 2 233 123 \u8f93\u51fa\u6837\u4f8b 233 3 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; map < int , int > M ; M . clear (); for ( int i = 0 ; i < n ; i ++ ) { int m ; cin >> m ; for ( int j = 0 ; j < m ; j ++ ) { int num ; cin >> num ; M [ num ] ++ ; } } map < int , int >:: iterator it ; int MAX = MINN , ans = 0 ; for ( it = M . begin (); it != M . end (); it ++ ) { if ( it -> second >= MAX ) { MAX = it -> second ; ans = it -> first ; } } printf ( \"%d %d \\n \" , ans , MAX ); }","title":"L1-034-\u70b9\u8d5e"},{"location":"CCCC/L1-034-%E7%82%B9%E8%B5%9E/#l1-034-\u70b9\u8d5e","text":"","title":"L1-034 \u70b9\u8d5e"},{"location":"CCCC/L1-034-%E7%82%B9%E8%B5%9E/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u70b9\u8d5e\u201d\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u559c\u6b22\u7684\u535a\u6587\u70b9\u4e2a\u8d5e\u8868\u793a\u652f\u6301\u3002\u6bcf\u7bc7\u535a\u6587\u90fd\u6709\u4e00\u4e9b\u523b\u753b\u5176\u7279\u6027\u7684\u6807\u7b7e\uff0c\u800c\u4f60\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7c7b\u578b\uff0c\u4e5f\u95f4\u63a5\u523b\u753b\u4e86\u4f60\u7684\u7279\u6027\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u7edf\u8ba1\u4e00\u4e2a\u4eba\u70b9\u8d5e\u7684\u7eaa\u5f55\uff0c\u5206\u6790\u8fd9\u4e2a\u4eba\u7684\u7279\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u662f\u8be5\u7528\u6237\u70b9\u8d5e\u7684\u535a\u6587\u6570\u91cf\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7bc7\u88ab\u5176\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7279\u6027\u63cf\u8ff0\uff0c\u683c\u5f0f\u4e3a\u201c K K F_1\\cdots F_K F_1\\cdots F_K \u201d\uff0c\u5176\u4e2d 1\\le K\\le 10 1\\le K\\le 10 \uff0c F_i F_i \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u7279\u6027\u6807\u7b7e\u7684\u7f16\u53f7\uff0c\u6211\u4eec\u5c06\u6240\u6709\u7279\u6027\u6807\u7b7e\u4ece1\u52301000\u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u7edf\u8ba1\u6240\u6709\u88ab\u70b9\u8d5e\u7684\u535a\u6587\u4e2d\u6700\u5e38\u51fa\u73b0\u7684\u90a3\u4e2a\u7279\u6027\u6807\u7b7e\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b83\u7684\u7f16\u53f7\u548c\u51fa\u73b0\u6b21\u6570\uff0c\u6570\u5b57\u95f4\u96941\u4e2a\u7a7a\u683c\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5927\u7684\u90a3\u4e2a\u3002 \u8f93\u5165\u6837\u4f8b 4 3 889 233 2 5 100 3 233 2 73 4 3 73 889 2 2 233 123 \u8f93\u51fa\u6837\u4f8b 233 3","title":"Statement"},{"location":"CCCC/L1-034-%E7%82%B9%E8%B5%9E/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; map < int , int > M ; M . clear (); for ( int i = 0 ; i < n ; i ++ ) { int m ; cin >> m ; for ( int j = 0 ; j < m ; j ++ ) { int num ; cin >> num ; M [ num ] ++ ; } } map < int , int >:: iterator it ; int MAX = MINN , ans = 0 ; for ( it = M . begin (); it != M . end (); it ++ ) { if ( it -> second >= MAX ) { MAX = it -> second ; ans = it -> first ; } } printf ( \"%d %d \\n \" , ans , MAX ); }","title":"Solution"},{"location":"CCCC/L1-035-%E6%83%85%E4%BA%BA%E8%8A%82/","text":"L1-035 \u60c5\u4eba\u8282 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u670b\u53cb\u5708\u4e2d\u4e00\u5947\u8469\u8d34\uff1a\u201c2\u670814\u60c5\u4eba\u8282\u4e86\uff0c\u6211\u51b3\u5b9a\u9020\u798f\u5927\u5bb6\u3002\u7b2c2\u4e2a\u8d5e\u548c\u7b2c14\u4e2a\u8d5e\u7684\uff0c\u6211\u4ecb\u7ecd\u4f60\u4fe9\u8ba4\u8bc6\u2026\u2026\u2026\u2026\u54b1\u4e09\u5403\u996d\u2026\u4f60\u4fe9\u8bf7\u2026\u201d\u3002\u73b0\u7ed9\u51fa\u6b64\u8d34\u4e0b\u70b9\u8d5e\u7684\u670b\u53cb\u540d\u5355\uff0c\u8bf7\u4f60\u627e\u51fa\u90a3\u4e24\u4f4d\u8981\u8bf7\u5ba2\u7684\u5012\u9709\u86cb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u6309\u7167\u70b9\u8d5e\u7684\u5148\u540e\u987a\u5e8f\u7ed9\u51fa\u4e0d\u77e5\u9053\u591a\u5c11\u4e2a\u70b9\u8d5e\u7684\u4eba\u540d\uff0c\u6bcf\u4e2a\u4eba\u540d\u5360\u4e00\u884c\uff0c\u4e3a\u4e0d\u8d85\u8fc710\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u975e\u7a7a\u5355\u8bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u4e00\u4e2a\u82f1\u6587\u53e5\u70b9 . \u6807\u5fd7\u8f93\u5165\u7684\u7ed3\u675f\uff0c\u8fd9\u4e2a\u7b26\u53f7\u4e0d\u7b97\u5728\u70b9\u8d5e\u540d\u5355\u91cc\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u70b9\u8d5e\u60c5\u51b5\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u8bba\uff1a\u82e5\u5b58\u5728\u7b2c2\u4e2a\u4ebaA\u548c\u7b2c14\u4e2a\u4ebaB\uff0c\u5219\u8f93\u51fa\u201cA and B are inviting you to dinner\u2026\u201d\uff1b\u82e5\u53ea\u6709A\u6ca1\u6709B\uff0c\u5219\u8f93\u51fa\u201cA is the only one for you\u2026\u201d\uff1b\u82e5\u8fdeA\u90fd\u6ca1\u6709\uff0c\u5219\u8f93\u51fa\u201cMomo\u2026 No one is for you \u2026\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 GaoXZh Magi Einst Quark LaoLao FatMouse ZhaShen fantacy latesum SenSen QuanQuan whatever whenever Potaty hahaha . \u8f93\u51fa\u6837\u4f8b1 Magi and Potaty are inviting you to dinner... \u8f93\u5165\u6837\u4f8b2 LaoLao FatMouse whoever . \u8f93\u51fa\u6837\u4f8b2 FatMouse is the only one for you... \u8f93\u5165\u6837\u4f8b3 LaoLao . \u8f93\u51fa\u6837\u4f8b3 Momo... No one is for you ... Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { string l = \"\" , r = \"\" , s ; for ( int i = 1 ;; i ++ ) { cin >> s ; if ( s == \".\" ) break ; else if ( i == 2 ) l = s ; else if ( i == 14 ) r = s ; } if ( l != \"\" && r != \"\" ) { cout << l ; printf ( \" and \" ); cout << r ; printf ( \" are inviting you to dinner... \\n \" ); } else if ( l != \"\" ) { cout << l ; printf ( \" is the only one for you... \\n \" ); } else printf ( \"Momo... No one is for you ... \\n \" ); }","title":"L1-035-\u60c5\u4eba\u8282"},{"location":"CCCC/L1-035-%E6%83%85%E4%BA%BA%E8%8A%82/#l1-035-\u60c5\u4eba\u8282","text":"","title":"L1-035 \u60c5\u4eba\u8282"},{"location":"CCCC/L1-035-%E6%83%85%E4%BA%BA%E8%8A%82/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u670b\u53cb\u5708\u4e2d\u4e00\u5947\u8469\u8d34\uff1a\u201c2\u670814\u60c5\u4eba\u8282\u4e86\uff0c\u6211\u51b3\u5b9a\u9020\u798f\u5927\u5bb6\u3002\u7b2c2\u4e2a\u8d5e\u548c\u7b2c14\u4e2a\u8d5e\u7684\uff0c\u6211\u4ecb\u7ecd\u4f60\u4fe9\u8ba4\u8bc6\u2026\u2026\u2026\u2026\u54b1\u4e09\u5403\u996d\u2026\u4f60\u4fe9\u8bf7\u2026\u201d\u3002\u73b0\u7ed9\u51fa\u6b64\u8d34\u4e0b\u70b9\u8d5e\u7684\u670b\u53cb\u540d\u5355\uff0c\u8bf7\u4f60\u627e\u51fa\u90a3\u4e24\u4f4d\u8981\u8bf7\u5ba2\u7684\u5012\u9709\u86cb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u6309\u7167\u70b9\u8d5e\u7684\u5148\u540e\u987a\u5e8f\u7ed9\u51fa\u4e0d\u77e5\u9053\u591a\u5c11\u4e2a\u70b9\u8d5e\u7684\u4eba\u540d\uff0c\u6bcf\u4e2a\u4eba\u540d\u5360\u4e00\u884c\uff0c\u4e3a\u4e0d\u8d85\u8fc710\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u975e\u7a7a\u5355\u8bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u4e00\u4e2a\u82f1\u6587\u53e5\u70b9 . \u6807\u5fd7\u8f93\u5165\u7684\u7ed3\u675f\uff0c\u8fd9\u4e2a\u7b26\u53f7\u4e0d\u7b97\u5728\u70b9\u8d5e\u540d\u5355\u91cc\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u70b9\u8d5e\u60c5\u51b5\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u8bba\uff1a\u82e5\u5b58\u5728\u7b2c2\u4e2a\u4ebaA\u548c\u7b2c14\u4e2a\u4ebaB\uff0c\u5219\u8f93\u51fa\u201cA and B are inviting you to dinner\u2026\u201d\uff1b\u82e5\u53ea\u6709A\u6ca1\u6709B\uff0c\u5219\u8f93\u51fa\u201cA is the only one for you\u2026\u201d\uff1b\u82e5\u8fdeA\u90fd\u6ca1\u6709\uff0c\u5219\u8f93\u51fa\u201cMomo\u2026 No one is for you \u2026\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 GaoXZh Magi Einst Quark LaoLao FatMouse ZhaShen fantacy latesum SenSen QuanQuan whatever whenever Potaty hahaha . \u8f93\u51fa\u6837\u4f8b1 Magi and Potaty are inviting you to dinner... \u8f93\u5165\u6837\u4f8b2 LaoLao FatMouse whoever . \u8f93\u51fa\u6837\u4f8b2 FatMouse is the only one for you... \u8f93\u5165\u6837\u4f8b3 LaoLao . \u8f93\u51fa\u6837\u4f8b3 Momo... No one is for you ...","title":"Statement"},{"location":"CCCC/L1-035-%E6%83%85%E4%BA%BA%E8%8A%82/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { string l = \"\" , r = \"\" , s ; for ( int i = 1 ;; i ++ ) { cin >> s ; if ( s == \".\" ) break ; else if ( i == 2 ) l = s ; else if ( i == 14 ) r = s ; } if ( l != \"\" && r != \"\" ) { cout << l ; printf ( \" and \" ); cout << r ; printf ( \" are inviting you to dinner... \\n \" ); } else if ( l != \"\" ) { cout << l ; printf ( \" is the only one for you... \\n \" ); } else printf ( \"Momo... No one is for you ... \\n \" ); }","title":"Solution"},{"location":"CCCC/L1-036-A%E4%B9%98%E4%BB%A5B/","text":"L1-036 A\u4e58\u4ee5B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u770b\u6211\u6ca1\u9a97\u4f60\u5427 \u2014\u2014 \u8fd9\u662f\u4e00\u9053\u4f60\u53ef\u4ee5\u5728 10 \u79d2\u5185\u5b8c\u6210\u7684\u9898\uff1a\u7ed9\u5b9a\u4e24\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 100 \u7684\u6574\u6570 A A \u548c B B \uff0c\u8f93\u51fa A A \u4e58\u4ee5 B B \u7684\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff08 -100 \\le A, B \\le 100 -100 \\le A, B \\le 100 \uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa A A \u4e58\u4ee5 B B \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b -8 13 \u8f93\u51fa\u6837\u4f8b -104 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; cout << a * b << endl ; }","title":"L1-036-A\u4e58\u4ee5B"},{"location":"CCCC/L1-036-A%E4%B9%98%E4%BB%A5B/#l1-036-a\u4e58\u4ee5b","text":"","title":"L1-036 A\u4e58\u4ee5B"},{"location":"CCCC/L1-036-A%E4%B9%98%E4%BB%A5B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u770b\u6211\u6ca1\u9a97\u4f60\u5427 \u2014\u2014 \u8fd9\u662f\u4e00\u9053\u4f60\u53ef\u4ee5\u5728 10 \u79d2\u5185\u5b8c\u6210\u7684\u9898\uff1a\u7ed9\u5b9a\u4e24\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 100 \u7684\u6574\u6570 A A \u548c B B \uff0c\u8f93\u51fa A A \u4e58\u4ee5 B B \u7684\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff08 -100 \\le A, B \\le 100 -100 \\le A, B \\le 100 \uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa A A \u4e58\u4ee5 B B \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b -8 13 \u8f93\u51fa\u6837\u4f8b -104","title":"Statement"},{"location":"CCCC/L1-036-A%E4%B9%98%E4%BB%A5B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; cout << a * b << endl ; }","title":"Solution"},{"location":"CCCC/L1-037-A%E9%99%A4%E4%BB%A5B/","text":"L1-037 A\u9664\u4ee5B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u771f\u7684\u662f\u7b80\u5355\u9898\u54c8 \u2014\u2014 \u7ed9\u5b9a\u4e24\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7100\u7684\u6574\u6570 A A \u548c B B \uff0c\u8981\u6c42\u4f60\u6309\u7167\u201c A/B= A/B= \u5546\u201d\u7684\u683c\u5f0f\u8f93\u51fa\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff08 -100 \\le A, B \\le 100 -100 \\le A, B \\le 100 \uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\uff1a\u5982\u679c\u5206\u6bcd\u662f\u6b63\u6570\uff0c\u5219\u8f93\u51fa\u201c A/B= A/B= \u5546\u201d\uff1b\u5982\u679c\u5206\u6bcd\u662f\u8d1f\u6570\uff0c\u5219\u8981\u7528\u62ec\u53f7\u628a\u5206\u6bcd\u62ec\u8d77\u6765\u8f93\u51fa\uff1b\u5982\u679c\u5206\u6bcd\u4e3a\u96f6\uff0c\u5219\u8f93\u51fa\u7684\u5546\u5e94\u4e3a Error \u3002\u8f93\u51fa\u7684\u5546\u5e94\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b1 -1 2 \u8f93\u51fa\u6837\u4f8b1 -1/2=-0.50 \u8f93\u5165\u6837\u4f8b2 1 -3 \u8f93\u51fa\u6837\u4f8b2 1/(-3)=-0.33 \u8f93\u5165\u6837\u4f8b3 5 0 \u8f93\u51fa\u6837\u4f8b3 5/0=Error Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; double ans = a * 1.0 / b ; if ( b > 0 ) printf ( \"%d/%d=%.2lf \\n \" , a , b , ans ); else if ( b == 0 ) printf ( \"%d/0=Error \\n \" , a ); else printf ( \"%d/(%d)=%.2lf \\n \" , a , b , ans ); }","title":"L1-037-A\u9664\u4ee5B"},{"location":"CCCC/L1-037-A%E9%99%A4%E4%BB%A5B/#l1-037-a\u9664\u4ee5b","text":"","title":"L1-037 A\u9664\u4ee5B"},{"location":"CCCC/L1-037-A%E9%99%A4%E4%BB%A5B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u771f\u7684\u662f\u7b80\u5355\u9898\u54c8 \u2014\u2014 \u7ed9\u5b9a\u4e24\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7100\u7684\u6574\u6570 A A \u548c B B \uff0c\u8981\u6c42\u4f60\u6309\u7167\u201c A/B= A/B= \u5546\u201d\u7684\u683c\u5f0f\u8f93\u51fa\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 A A \u548c B B \uff08 -100 \\le A, B \\le 100 -100 \\le A, B \\le 100 \uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\uff1a\u5982\u679c\u5206\u6bcd\u662f\u6b63\u6570\uff0c\u5219\u8f93\u51fa\u201c A/B= A/B= \u5546\u201d\uff1b\u5982\u679c\u5206\u6bcd\u662f\u8d1f\u6570\uff0c\u5219\u8981\u7528\u62ec\u53f7\u628a\u5206\u6bcd\u62ec\u8d77\u6765\u8f93\u51fa\uff1b\u5982\u679c\u5206\u6bcd\u4e3a\u96f6\uff0c\u5219\u8f93\u51fa\u7684\u5546\u5e94\u4e3a Error \u3002\u8f93\u51fa\u7684\u5546\u5e94\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b1 -1 2 \u8f93\u51fa\u6837\u4f8b1 -1/2=-0.50 \u8f93\u5165\u6837\u4f8b2 1 -3 \u8f93\u51fa\u6837\u4f8b2 1/(-3)=-0.33 \u8f93\u5165\u6837\u4f8b3 5 0 \u8f93\u51fa\u6837\u4f8b3 5/0=Error","title":"Statement"},{"location":"CCCC/L1-037-A%E9%99%A4%E4%BB%A5B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; cin >> a >> b ; double ans = a * 1.0 / b ; if ( b > 0 ) printf ( \"%d/%d=%.2lf \\n \" , a , b , ans ); else if ( b == 0 ) printf ( \"%d/0=Error \\n \" , a ); else printf ( \"%d/(%d)=%.2lf \\n \" , a , b , ans ); }","title":"Solution"},{"location":"CCCC/L1-038-%E6%96%B0%E4%B8%96%E7%95%8C/","text":"L1-038 \u65b0\u4e16\u754c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u7a0b\u5e8f\u5458\u94a6\u5b9a\u540d\u8a00\u201cHello World\u201d\uff0c\u5e76\u4e14\u5728\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u66f4\u65b0\u7248\u7684\u201cHello New World\u201d\u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Hello World Hello New World Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { printf ( \"Hello World \\n \" ); printf ( \"Hello New World \\n \" ); }","title":"L1-038-\u65b0\u4e16\u754c"},{"location":"CCCC/L1-038-%E6%96%B0%E4%B8%96%E7%95%8C/#l1-038-\u65b0\u4e16\u754c","text":"","title":"L1-038 \u65b0\u4e16\u754c"},{"location":"CCCC/L1-038-%E6%96%B0%E4%B8%96%E7%95%8C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u9053\u8d85\u7ea7\u7b80\u5355\u7684\u9898\u76ee\u6ca1\u6709\u4efb\u4f55\u8f93\u5165\u3002 \u4f60\u53ea\u9700\u8981\u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u7a0b\u5e8f\u5458\u94a6\u5b9a\u540d\u8a00\u201cHello World\u201d\uff0c\u5e76\u4e14\u5728\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u66f4\u65b0\u7248\u7684\u201cHello New World\u201d\u5c31\u53ef\u4ee5\u4e86\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Hello World Hello New World","title":"Statement"},{"location":"CCCC/L1-038-%E6%96%B0%E4%B8%96%E7%95%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { printf ( \"Hello World \\n \" ); printf ( \"Hello New World \\n \" ); }","title":"Solution"},{"location":"CCCC/L1-039-%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/","text":"L1-039 \u53e4\u98ce\u6392\u7248 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e2d\u56fd\u7684\u53e4\u4eba\u5199\u6587\u5b57\uff0c\u662f\u4ece\u53f3\u5411\u5de6\u7ad6\u5411\u6392\u7248\u7684\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u4e00\u6bb5\u6587\u5b57\u6309\u53e4\u98ce\u6392\u7248\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 <100 <100 \uff09\uff0c\u662f\u6bcf\u4e00\u5217\u7684\u5b57\u7b26\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc71000\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u53e4\u98ce\u683c\u5f0f\u6392\u7248\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u5217 N N \u4e2a\u5b57\u7b26\uff08\u9664\u4e86\u6700\u540e\u4e00\u5217\u53ef\u80fd\u4e0d\u8db3 N N \u4e2a\uff09\u3002 \u8f93\u5165\u6837\u4f8b 4 This is a test case \u8f93\u51fa\u6837\u4f8b asa T st ih e tsi ce s Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; string ans [ maxn ]; int main () { int n ; scanf ( \"%d\" , & n ); getchar (); string s ; getline ( cin , s ); int len = s . size (); if ( len <= n ) { int i ; for ( i = 0 ; i < len ; i ++ ) cout << s [ i ] << endl ; for (; i < n ; i ++ ) printf ( \" \\n \" ); } else { int cur = len / n ; if ( len % n ) cur ++ ; int count = 0 ; string temp ; for ( int i = 0 ; i < n ; i ++ ) { temp . clear (); temp += s [ count ]; ans [ i ]. insert ( 0 , temp ); count ++ ; } for ( int j = 1 ; j < cur - 1 ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { string temp = \"\" ; temp += s [ count ++ ]; ans [ i ]. insert ( 0 , temp ); } } for ( int i = 0 ; i < n ; i ++ ) { if ( count < s . size ()) { temp . clear (); temp += s [ count ]; ans [ i ]. insert ( 0 , temp ); count ++ ; } else ans [ i ]. insert ( 0 , \" \" ); } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << endl ; } } }","title":"L1-039-\u53e4\u98ce\u6392\u7248"},{"location":"CCCC/L1-039-%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/#l1-039-\u53e4\u98ce\u6392\u7248","text":"","title":"L1-039 \u53e4\u98ce\u6392\u7248"},{"location":"CCCC/L1-039-%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e2d\u56fd\u7684\u53e4\u4eba\u5199\u6587\u5b57\uff0c\u662f\u4ece\u53f3\u5411\u5de6\u7ad6\u5411\u6392\u7248\u7684\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u4e00\u6bb5\u6587\u5b57\u6309\u53e4\u98ce\u6392\u7248\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 <100 <100 \uff09\uff0c\u662f\u6bcf\u4e00\u5217\u7684\u5b57\u7b26\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc71000\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u53e4\u98ce\u683c\u5f0f\u6392\u7248\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u6bcf\u5217 N N \u4e2a\u5b57\u7b26\uff08\u9664\u4e86\u6700\u540e\u4e00\u5217\u53ef\u80fd\u4e0d\u8db3 N N \u4e2a\uff09\u3002 \u8f93\u5165\u6837\u4f8b 4 This is a test case \u8f93\u51fa\u6837\u4f8b asa T st ih e tsi ce s","title":"Statement"},{"location":"CCCC/L1-039-%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; string ans [ maxn ]; int main () { int n ; scanf ( \"%d\" , & n ); getchar (); string s ; getline ( cin , s ); int len = s . size (); if ( len <= n ) { int i ; for ( i = 0 ; i < len ; i ++ ) cout << s [ i ] << endl ; for (; i < n ; i ++ ) printf ( \" \\n \" ); } else { int cur = len / n ; if ( len % n ) cur ++ ; int count = 0 ; string temp ; for ( int i = 0 ; i < n ; i ++ ) { temp . clear (); temp += s [ count ]; ans [ i ]. insert ( 0 , temp ); count ++ ; } for ( int j = 1 ; j < cur - 1 ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { string temp = \"\" ; temp += s [ count ++ ]; ans [ i ]. insert ( 0 , temp ); } } for ( int i = 0 ; i < n ; i ++ ) { if ( count < s . size ()) { temp . clear (); temp += s [ count ]; ans [ i ]. insert ( 0 , temp ); count ++ ; } else ans [ i ]. insert ( 0 , \" \" ); } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << endl ; } } }","title":"Solution"},{"location":"CCCC/L1-040-%E6%9C%80%E4%BD%B3%E6%83%85%E4%BE%A3%E8%BA%AB%E9%AB%98%E5%B7%AE/","text":"L1-040 \u6700\u4f73\u60c5\u4fa3\u8eab\u9ad8\u5dee Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e13\u5bb6\u901a\u8fc7\u591a\u7ec4\u60c5\u4fa3\u7814\u7a76\u6570\u636e\u53d1\u73b0\uff0c\u6700\u4f73\u7684\u60c5\u4fa3\u8eab\u9ad8\u5dee\u9075\u5faa\u7740\u4e00\u4e2a\u516c\u5f0f\uff1a\uff08\u5973\u65b9\u7684\u8eab\u9ad8\uff09 \\times \\times 1.09 =\uff08\u7537\u65b9\u7684\u8eab\u9ad8\uff09\u3002\u5982\u679c\u7b26\u5408\uff0c\u4f60\u4fe9\u7684\u8eab\u9ad8\u5dee\u4e0d\u7ba1\u662f\u7275\u624b\u3001\u62e5\u62b1\u3001\u63a5\u543b\uff0c\u90fd\u662f\u6700\u548c\u8c10\u7684\u5dee\u5ea6\u3002 \u4e0b\u9762\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u4e3a\u4efb\u610f\u4e00\u4f4d\u7528\u6237\u8ba1\u7b97\u4ed6/\u5979\u7684\u60c5\u4fa3\u7684\u6700\u4f73\u8eab\u9ad8\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\uff0c\u4e3a\u524d\u6765\u67e5\u8be2\u7684\u7528\u6237\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u7167\u201c\u6027\u522b \u8eab\u9ad8\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u524d\u6765\u67e5\u8be2\u7684\u7528\u6237\u7684\u6027\u522b\u548c\u8eab\u9ad8\uff0c\u5176\u4e2d\u201c\u6027\u522b\u201d\u4e3a\u201cF\u201d\u8868\u793a\u5973\u6027\u3001\u201cM\u201d\u8868\u793a\u7537\u6027\uff1b\u201c\u8eab\u9ad8\u201d\u4e3a\u533a\u95f4 [1.0, 3.0] \u4e4b\u95f4\u7684\u5b9e\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u67e5\u8be2\uff0c\u5728\u4e00\u884c\u4e2d\u4e3a\u8be5\u7528\u6237\u8ba1\u7b97\u51fa\u5176\u60c5\u4fa3\u7684\u6700\u4f73\u8eab\u9ad8\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 2 M 1.75 F 1.8 \u8f93\u51fa\u6837\u4f8b 1.61 1.96 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; while ( t -- ) { char c ; double h ; scanf ( \" %c %lf\" , & c , & h ); if ( c == 'M' ) printf ( \"%.2lf \\n \" , h / 1.09 ); else printf ( \"%.2lf \\n \" , h * 1.09 ); } }","title":"L1-040-\u6700\u4f73\u60c5\u4fa3\u8eab\u9ad8\u5dee"},{"location":"CCCC/L1-040-%E6%9C%80%E4%BD%B3%E6%83%85%E4%BE%A3%E8%BA%AB%E9%AB%98%E5%B7%AE/#l1-040-\u6700\u4f73\u60c5\u4fa3\u8eab\u9ad8\u5dee","text":"","title":"L1-040 \u6700\u4f73\u60c5\u4fa3\u8eab\u9ad8\u5dee"},{"location":"CCCC/L1-040-%E6%9C%80%E4%BD%B3%E6%83%85%E4%BE%A3%E8%BA%AB%E9%AB%98%E5%B7%AE/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e13\u5bb6\u901a\u8fc7\u591a\u7ec4\u60c5\u4fa3\u7814\u7a76\u6570\u636e\u53d1\u73b0\uff0c\u6700\u4f73\u7684\u60c5\u4fa3\u8eab\u9ad8\u5dee\u9075\u5faa\u7740\u4e00\u4e2a\u516c\u5f0f\uff1a\uff08\u5973\u65b9\u7684\u8eab\u9ad8\uff09 \\times \\times 1.09 =\uff08\u7537\u65b9\u7684\u8eab\u9ad8\uff09\u3002\u5982\u679c\u7b26\u5408\uff0c\u4f60\u4fe9\u7684\u8eab\u9ad8\u5dee\u4e0d\u7ba1\u662f\u7275\u624b\u3001\u62e5\u62b1\u3001\u63a5\u543b\uff0c\u90fd\u662f\u6700\u548c\u8c10\u7684\u5dee\u5ea6\u3002 \u4e0b\u9762\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u4e3a\u4efb\u610f\u4e00\u4f4d\u7528\u6237\u8ba1\u7b97\u4ed6/\u5979\u7684\u60c5\u4fa3\u7684\u6700\u4f73\u8eab\u9ad8\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\uff0c\u4e3a\u524d\u6765\u67e5\u8be2\u7684\u7528\u6237\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u7167\u201c\u6027\u522b \u8eab\u9ad8\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u524d\u6765\u67e5\u8be2\u7684\u7528\u6237\u7684\u6027\u522b\u548c\u8eab\u9ad8\uff0c\u5176\u4e2d\u201c\u6027\u522b\u201d\u4e3a\u201cF\u201d\u8868\u793a\u5973\u6027\u3001\u201cM\u201d\u8868\u793a\u7537\u6027\uff1b\u201c\u8eab\u9ad8\u201d\u4e3a\u533a\u95f4 [1.0, 3.0] \u4e4b\u95f4\u7684\u5b9e\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u67e5\u8be2\uff0c\u5728\u4e00\u884c\u4e2d\u4e3a\u8be5\u7528\u6237\u8ba1\u7b97\u51fa\u5176\u60c5\u4fa3\u7684\u6700\u4f73\u8eab\u9ad8\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 2 M 1.75 F 1.8 \u8f93\u51fa\u6837\u4f8b 1.61 1.96","title":"Statement"},{"location":"CCCC/L1-040-%E6%9C%80%E4%BD%B3%E6%83%85%E4%BE%A3%E8%BA%AB%E9%AB%98%E5%B7%AE/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; while ( t -- ) { char c ; double h ; scanf ( \" %c %lf\" , & c , & h ); if ( c == 'M' ) printf ( \"%.2lf \\n \" , h / 1.09 ); else printf ( \"%.2lf \\n \" , h * 1.09 ); } }","title":"Solution"},{"location":"CCCC/L1-041-%E5%AF%BB%E6%89%BE250/","text":"L1-041 \u5bfb\u627e250 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u65b9\u4e0d\u60f3\u548c\u4f60\u8bf4\u8bdd\uff0c\u5e76\u5411\u4f60\u6254\u4e86\u4e00\u4e32\u6570\u2026\u2026 \u800c\u4f60\u5fc5\u987b\u4ece\u8fd9\u4e00\u4e32\u6570\u5b57\u4e2d\u627e\u5230\u201c250\u201d\u8fd9\u4e2a\u9ad8\u5927\u4e0a\u7684\u611f\u4eba\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e0d\u77e5\u9053\u591a\u5c11\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc71000\u7684\u6574\u6570\uff0c\u5176\u4e2d\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u201c250\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u201c250\u201d\u662f\u5bf9\u65b9\u6254\u8fc7\u6765\u7684\u7b2c\u51e0\u4e2a\u6570\u5b57\uff08\u8ba1\u6570\u4ece1\u5f00\u59cb\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u7684\u6570\u5b57\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u5165\u6837\u4f8b 888 666 123 -233 250 13 250 -222 \u8f93\u51fa\u6837\u4f8b 5 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; int flag = 0 ; int vis = 1 ; while ( ~ scanf ( \"%d\" , & n )) { if ( n == 250 ) flag = 1 ; else if ( flag == 0 ) vis ++ ; } cout << vis << endl ; }","title":"L1-041-\u5bfb\u627e250"},{"location":"CCCC/L1-041-%E5%AF%BB%E6%89%BE250/#l1-041-\u5bfb\u627e250","text":"","title":"L1-041 \u5bfb\u627e250"},{"location":"CCCC/L1-041-%E5%AF%BB%E6%89%BE250/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u65b9\u4e0d\u60f3\u548c\u4f60\u8bf4\u8bdd\uff0c\u5e76\u5411\u4f60\u6254\u4e86\u4e00\u4e32\u6570\u2026\u2026 \u800c\u4f60\u5fc5\u987b\u4ece\u8fd9\u4e00\u4e32\u6570\u5b57\u4e2d\u627e\u5230\u201c250\u201d\u8fd9\u4e2a\u9ad8\u5927\u4e0a\u7684\u611f\u4eba\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e0d\u77e5\u9053\u591a\u5c11\u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc71000\u7684\u6574\u6570\uff0c\u5176\u4e2d\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u201c250\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u201c250\u201d\u662f\u5bf9\u65b9\u6254\u8fc7\u6765\u7684\u7b2c\u51e0\u4e2a\u6570\u5b57\uff08\u8ba1\u6570\u4ece1\u5f00\u59cb\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u7684\u6570\u5b57\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u5165\u6837\u4f8b 888 666 123 -233 250 13 250 -222 \u8f93\u51fa\u6837\u4f8b 5","title":"Statement"},{"location":"CCCC/L1-041-%E5%AF%BB%E6%89%BE250/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; int flag = 0 ; int vis = 1 ; while ( ~ scanf ( \"%d\" , & n )) { if ( n == 250 ) flag = 1 ; else if ( flag == 0 ) vis ++ ; } cout << vis << endl ; }","title":"Solution"},{"location":"CCCC/L1-042-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/","text":"L1-042 \u65e5\u671f\u683c\u5f0f\u5316 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e16\u754c\u4e0a\u4e0d\u540c\u56fd\u5bb6\u6709\u4e0d\u540c\u7684\u5199\u65e5\u671f\u7684\u4e60\u60ef\u3002\u6bd4\u5982\u7f8e\u56fd\u4eba\u4e60\u60ef\u5199\u6210\u201c\u6708-\u65e5-\u5e74\u201d\uff0c\u800c\u4e2d\u56fd\u4eba\u4e60\u60ef\u5199\u6210\u201c\u5e74-\u6708-\u65e5\u201d\u3002\u4e0b\u9762\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u81ea\u52a8\u628a\u8bfb\u5165\u7684\u7f8e\u56fd\u683c\u5f0f\u7684\u65e5\u671f\u6539\u5199\u6210\u4e2d\u56fd\u4e60\u60ef\u7684\u65e5\u671f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309\u7167\u201cmm-dd-yyyy\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u6708\u3001\u65e5\u3001\u5e74\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u65e5\u671f\u662f1900\u5e74\u5143\u65e6\u81f3\u4eca\u5408\u6cd5\u7684\u65e5\u671f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u201cyyyy-mm-dd\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u5e74\u3001\u6708\u3001\u65e5\u3002 \u8f93\u5165\u6837\u4f8b 03-15-2017 \u8f93\u51fa\u6837\u4f8b 2017-03-15 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b , c ; scanf ( \"%02d-%02d-%04d\" , & a , & b , & c ); printf ( \"%04d-%02d-%02d \\n \" , c , a , b ); }","title":"L1-042-\u65e5\u671f\u683c\u5f0f\u5316"},{"location":"CCCC/L1-042-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/#l1-042-\u65e5\u671f\u683c\u5f0f\u5316","text":"","title":"L1-042 \u65e5\u671f\u683c\u5f0f\u5316"},{"location":"CCCC/L1-042-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e16\u754c\u4e0a\u4e0d\u540c\u56fd\u5bb6\u6709\u4e0d\u540c\u7684\u5199\u65e5\u671f\u7684\u4e60\u60ef\u3002\u6bd4\u5982\u7f8e\u56fd\u4eba\u4e60\u60ef\u5199\u6210\u201c\u6708-\u65e5-\u5e74\u201d\uff0c\u800c\u4e2d\u56fd\u4eba\u4e60\u60ef\u5199\u6210\u201c\u5e74-\u6708-\u65e5\u201d\u3002\u4e0b\u9762\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u81ea\u52a8\u628a\u8bfb\u5165\u7684\u7f8e\u56fd\u683c\u5f0f\u7684\u65e5\u671f\u6539\u5199\u6210\u4e2d\u56fd\u4e60\u60ef\u7684\u65e5\u671f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309\u7167\u201cmm-dd-yyyy\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u6708\u3001\u65e5\u3001\u5e74\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u65e5\u671f\u662f1900\u5e74\u5143\u65e6\u81f3\u4eca\u5408\u6cd5\u7684\u65e5\u671f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u201cyyyy-mm-dd\u201d\u7684\u683c\u5f0f\u7ed9\u51fa\u5e74\u3001\u6708\u3001\u65e5\u3002 \u8f93\u5165\u6837\u4f8b 03-15-2017 \u8f93\u51fa\u6837\u4f8b 2017-03-15","title":"Statement"},{"location":"CCCC/L1-042-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b , c ; scanf ( \"%02d-%02d-%04d\" , & a , & b , & c ); printf ( \"%04d-%02d-%02d \\n \" , c , a , b ); }","title":"Solution"},{"location":"CCCC/L1-043-%E9%98%85%E8%A7%88%E5%AE%A4/","text":"L1-043 \u9605\u89c8\u5ba4 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u56fe\u4e66\u9605\u89c8\u5ba4\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u7b80\u5355\u7684\u56fe\u4e66\u501f\u9605\u7edf\u8ba1\u7a0b\u5e8f\u3002\u5f53\u8bfb\u8005\u501f\u4e66\u65f6\uff0c\u7ba1\u7406\u5458\u8f93\u5165\u4e66\u53f7\u5e76\u6309\u4e0b S \u952e\uff0c\u7a0b\u5e8f\u5f00\u59cb\u8ba1\u65f6\uff1b\u5f53\u8bfb\u8005\u8fd8\u4e66\u65f6\uff0c\u7ba1\u7406\u5458\u8f93\u5165\u4e66\u53f7\u5e76\u6309\u4e0b E \u952e\uff0c\u7a0b\u5e8f\u7ed3\u675f\u8ba1\u65f6\u3002\u4e66\u53f7\u4e3a\u4e0d\u8d85\u8fc71000\u7684\u6b63\u6574\u6570\u3002\u5f53\u7ba1\u7406\u5458\u5c060\u4f5c\u4e3a\u4e66\u53f7\u8f93\u5165\u65f6\uff0c\u8868\u793a\u4e00\u5929\u5de5\u4f5c\u7ed3\u675f\uff0c\u4f60\u7684\u7a0b\u5e8f\u5e94\u8f93\u51fa\u5f53\u5929\u7684\u8bfb\u8005\u501f\u4e66\u6b21\u6570\u548c\u5e73\u5747\u9605\u8bfb\u65f6\u95f4\u3002 \u6ce8\u610f\uff1a\u7531\u4e8e\u7ebf\u8def\u5076\u5c14\u4f1a\u6709\u6545\u969c\uff0c\u53ef\u80fd\u51fa\u73b0\u4e0d\u5b8c\u6574\u7684\u7eaa\u5f55\uff0c\u5373\u53ea\u6709 S \u6ca1\u6709 E \uff0c\u6216\u8005\u53ea\u6709 E \u6ca1\u6709 S \u7684\u7eaa\u5f55\uff0c\u7cfb\u7edf\u5e94\u80fd\u81ea\u52a8\u5ffd\u7565\u8fd9\u79cd\u65e0\u6548\u7eaa\u5f55\u3002\u53e6\u5916\uff0c\u9898\u76ee\u4fdd\u8bc1\u4e66\u53f7\u662f\u4e66\u7684\u552f\u4e00\u6807\u8bc6\uff0c\u540c\u4e00\u672c\u4e66\u5728\u4efb\u4f55\u65f6\u95f4\u533a\u95f4\u5185\u53ea\u53ef\u80fd\u88ab\u4e00\u4f4d\u8bfb\u8005\u501f\u9605\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e\u7ed9\u51fa N N \u5929\u7684\u7eaa\u5f55\u3002\u6bcf\u5929\u7684\u7eaa\u5f55\u7531\u82e5\u5e72\u6b21\u501f\u9605\u64cd\u4f5c\u7ec4\u6210\uff0c\u6bcf\u6b21\u64cd\u4f5c\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u4e66\u53f7 \uff08[1, 1000]\u5185\u7684\u6574\u6570\uff09 \u952e\u503c \uff08 S \u6216 E \uff09 \u53d1\u751f\u65f6\u95f4 \uff08 hh:mm \uff0c\u5176\u4e2d hh \u662f[0,23]\u5185\u7684\u6574\u6570\uff0c mm \u662f[0, 59]\u5185\u6574\u6570\uff09 \u6bcf\u4e00\u5929\u7684\u7eaa\u5f55\u4fdd\u8bc1\u6309\u65f6\u95f4\u9012\u589e\u7684\u987a\u5e8f\u7ed9\u51fa\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u5929\u7684\u7eaa\u5f55\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5f53\u5929\u7684\u8bfb\u8005\u501f\u4e66\u6b21\u6570\u548c\u5e73\u5747\u9605\u8bfb\u65f6\u95f4\uff08\u4ee5\u5206\u949f\u4e3a\u5355\u4f4d\u7684\u7cbe\u786e\u5230\u4e2a\u4f4d\u7684\u6574\u6570\u65f6\u95f4\uff09\u3002 \u8f93\u5165\u6837\u4f8b 3 1 S 08:10 2 S 08:35 1 E 10:00 2 E 13:16 0 S 17:00 0 S 17:00 3 E 08:10 1 S 08:20 2 S 09:00 1 E 09:20 0 E 17:00 \u8f93\u51fa\u6837\u4f8b 2 196 0 0 1 60 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct node { int time ; int flag ; }; int main () { int t ; cin >> t ; a : while ( t -- ) { map < string , node > m ; m . clear (); string ID ; char vis ; int h , mins ; int ans = 0 ; int time = 0 ; while ( cin >> ID ) { scanf ( \" %c %02d:%02d\" , & vis , & h , & mins ); if ( ID == \"0\" ) { if ( ans > 0 ) time = ( int )( time * 1.0 / ans + 0.5 ); printf ( \"%d %d \\n \" , ans , time ); goto a ; } else { if ( vis == 'S' ) { // if (m[ID].flag == 0) // { m [ ID ]. time = h * 60 + mins ; m [ ID ]. flag = 1 ; // } } else if ( vis == 'E' ) { if ( m [ ID ]. flag == 1 ) { ans ++ ; time += ( h * 60 + mins ) - m [ ID ]. time ; m . erase ( ID ); } } } } } }","title":"L1-043-\u9605\u89c8\u5ba4"},{"location":"CCCC/L1-043-%E9%98%85%E8%A7%88%E5%AE%A4/#l1-043-\u9605\u89c8\u5ba4","text":"","title":"L1-043 \u9605\u89c8\u5ba4"},{"location":"CCCC/L1-043-%E9%98%85%E8%A7%88%E5%AE%A4/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u56fe\u4e66\u9605\u89c8\u5ba4\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u7b80\u5355\u7684\u56fe\u4e66\u501f\u9605\u7edf\u8ba1\u7a0b\u5e8f\u3002\u5f53\u8bfb\u8005\u501f\u4e66\u65f6\uff0c\u7ba1\u7406\u5458\u8f93\u5165\u4e66\u53f7\u5e76\u6309\u4e0b S \u952e\uff0c\u7a0b\u5e8f\u5f00\u59cb\u8ba1\u65f6\uff1b\u5f53\u8bfb\u8005\u8fd8\u4e66\u65f6\uff0c\u7ba1\u7406\u5458\u8f93\u5165\u4e66\u53f7\u5e76\u6309\u4e0b E \u952e\uff0c\u7a0b\u5e8f\u7ed3\u675f\u8ba1\u65f6\u3002\u4e66\u53f7\u4e3a\u4e0d\u8d85\u8fc71000\u7684\u6b63\u6574\u6570\u3002\u5f53\u7ba1\u7406\u5458\u5c060\u4f5c\u4e3a\u4e66\u53f7\u8f93\u5165\u65f6\uff0c\u8868\u793a\u4e00\u5929\u5de5\u4f5c\u7ed3\u675f\uff0c\u4f60\u7684\u7a0b\u5e8f\u5e94\u8f93\u51fa\u5f53\u5929\u7684\u8bfb\u8005\u501f\u4e66\u6b21\u6570\u548c\u5e73\u5747\u9605\u8bfb\u65f6\u95f4\u3002 \u6ce8\u610f\uff1a\u7531\u4e8e\u7ebf\u8def\u5076\u5c14\u4f1a\u6709\u6545\u969c\uff0c\u53ef\u80fd\u51fa\u73b0\u4e0d\u5b8c\u6574\u7684\u7eaa\u5f55\uff0c\u5373\u53ea\u6709 S \u6ca1\u6709 E \uff0c\u6216\u8005\u53ea\u6709 E \u6ca1\u6709 S \u7684\u7eaa\u5f55\uff0c\u7cfb\u7edf\u5e94\u80fd\u81ea\u52a8\u5ffd\u7565\u8fd9\u79cd\u65e0\u6548\u7eaa\u5f55\u3002\u53e6\u5916\uff0c\u9898\u76ee\u4fdd\u8bc1\u4e66\u53f7\u662f\u4e66\u7684\u552f\u4e00\u6807\u8bc6\uff0c\u540c\u4e00\u672c\u4e66\u5728\u4efb\u4f55\u65f6\u95f4\u533a\u95f4\u5185\u53ea\u53ef\u80fd\u88ab\u4e00\u4f4d\u8bfb\u8005\u501f\u9605\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e\u7ed9\u51fa N N \u5929\u7684\u7eaa\u5f55\u3002\u6bcf\u5929\u7684\u7eaa\u5f55\u7531\u82e5\u5e72\u6b21\u501f\u9605\u64cd\u4f5c\u7ec4\u6210\uff0c\u6bcf\u6b21\u64cd\u4f5c\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u4e66\u53f7 \uff08[1, 1000]\u5185\u7684\u6574\u6570\uff09 \u952e\u503c \uff08 S \u6216 E \uff09 \u53d1\u751f\u65f6\u95f4 \uff08 hh:mm \uff0c\u5176\u4e2d hh \u662f[0,23]\u5185\u7684\u6574\u6570\uff0c mm \u662f[0, 59]\u5185\u6574\u6570\uff09 \u6bcf\u4e00\u5929\u7684\u7eaa\u5f55\u4fdd\u8bc1\u6309\u65f6\u95f4\u9012\u589e\u7684\u987a\u5e8f\u7ed9\u51fa\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u5929\u7684\u7eaa\u5f55\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5f53\u5929\u7684\u8bfb\u8005\u501f\u4e66\u6b21\u6570\u548c\u5e73\u5747\u9605\u8bfb\u65f6\u95f4\uff08\u4ee5\u5206\u949f\u4e3a\u5355\u4f4d\u7684\u7cbe\u786e\u5230\u4e2a\u4f4d\u7684\u6574\u6570\u65f6\u95f4\uff09\u3002 \u8f93\u5165\u6837\u4f8b 3 1 S 08:10 2 S 08:35 1 E 10:00 2 E 13:16 0 S 17:00 0 S 17:00 3 E 08:10 1 S 08:20 2 S 09:00 1 E 09:20 0 E 17:00 \u8f93\u51fa\u6837\u4f8b 2 196 0 0 1 60","title":"Statement"},{"location":"CCCC/L1-043-%E9%98%85%E8%A7%88%E5%AE%A4/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct node { int time ; int flag ; }; int main () { int t ; cin >> t ; a : while ( t -- ) { map < string , node > m ; m . clear (); string ID ; char vis ; int h , mins ; int ans = 0 ; int time = 0 ; while ( cin >> ID ) { scanf ( \" %c %02d:%02d\" , & vis , & h , & mins ); if ( ID == \"0\" ) { if ( ans > 0 ) time = ( int )( time * 1.0 / ans + 0.5 ); printf ( \"%d %d \\n \" , ans , time ); goto a ; } else { if ( vis == 'S' ) { // if (m[ID].flag == 0) // { m [ ID ]. time = h * 60 + mins ; m [ ID ]. flag = 1 ; // } } else if ( vis == 'E' ) { if ( m [ ID ]. flag == 1 ) { ans ++ ; time += ( h * 60 + mins ) - m [ ID ]. time ; m . erase ( ID ); } } } } } }","title":"Solution"},{"location":"CCCC/L1-044-%E7%A8%B3%E8%B5%A2/","text":"L1-044 \u7a33\u8d62 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5e94\u8be5\u90fd\u4f1a\u73a9\u201c\u9524\u5b50\u526a\u5200\u5e03\u201d\u7684\u6e38\u620f\uff1a\u4e24\u4eba\u540c\u65f6\u7ed9\u51fa\u624b\u52bf\uff0c\u80dc\u8d1f\u89c4\u5219\u5982\u56fe\u6240\u793a\uff1a \u73b0\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u7a33\u8d62\u4e0d\u8f93\u7684\u7a0b\u5e8f\uff0c\u6839\u636e\u5bf9\u65b9\u7684\u51fa\u62db\uff0c\u7ed9\u51fa\u5bf9\u5e94\u7684\u8d62\u62db\u3002\u4f46\u662f\uff01\u4e3a\u4e86\u4e0d\u8ba9\u5bf9\u65b9\u8f93\u5f97\u592a\u60e8\uff0c\u4f60\u9700\u8981\u6bcf\u9694 K K \u6b21\u5c31\u8ba9\u4e00\u4e2a\u5e73\u5c40\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u5373\u5e73\u5c40\u95f4\u9694\u7684\u6b21\u6570\u3002\u968f\u540e\u6bcf\u884c\u7ed9\u51fa\u5bf9\u65b9\u7684\u4e00\u6b21\u51fa\u62db\uff1a ChuiZi \u4ee3\u8868\u201c\u9524\u5b50\u201d\u3001 JianDao \u4ee3\u8868\u201c\u526a\u5200\u201d\u3001 Bu \u4ee3\u8868\u201c\u5e03\u201d\u3002 End \u4ee3\u8868\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e00\u884c\u4e0d\u8981\u4f5c\u4e3a\u51fa\u62db\u5904\u7406\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u8f93\u5165\u7684\u51fa\u62db\uff0c\u6309\u8981\u6c42\u8f93\u51fa\u7a33\u8d62\u6216\u5e73\u5c40\u7684\u62db\u5f0f\u3002\u6bcf\u62db\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 2 ChuiZi JianDao Bu JianDao Bu ChuiZi ChuiZi End \u8f93\u51fa\u6837\u4f8b Bu ChuiZi Bu ChuiZi JianDao ChuiZi Bu Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < string , string > m ; m [ \"ChuiZi\" ] = \"Bu\" ; m [ \"Bu\" ] = \"JianDao\" ; m [ \"JianDao\" ] = \"ChuiZi\" ; int k ; cin >> k ; k ++ ; string s ; for ( int i = 1 ;; i ++ ) { cin >> s ; if ( s == \"End\" ) break ; else { if ( i % k == 0 ) cout << s << endl ; else cout << m [ s ] << endl ; } } }","title":"L1-044-\u7a33\u8d62"},{"location":"CCCC/L1-044-%E7%A8%B3%E8%B5%A2/#l1-044-\u7a33\u8d62","text":"","title":"L1-044 \u7a33\u8d62"},{"location":"CCCC/L1-044-%E7%A8%B3%E8%B5%A2/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5e94\u8be5\u90fd\u4f1a\u73a9\u201c\u9524\u5b50\u526a\u5200\u5e03\u201d\u7684\u6e38\u620f\uff1a\u4e24\u4eba\u540c\u65f6\u7ed9\u51fa\u624b\u52bf\uff0c\u80dc\u8d1f\u89c4\u5219\u5982\u56fe\u6240\u793a\uff1a \u73b0\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u7a33\u8d62\u4e0d\u8f93\u7684\u7a0b\u5e8f\uff0c\u6839\u636e\u5bf9\u65b9\u7684\u51fa\u62db\uff0c\u7ed9\u51fa\u5bf9\u5e94\u7684\u8d62\u62db\u3002\u4f46\u662f\uff01\u4e3a\u4e86\u4e0d\u8ba9\u5bf9\u65b9\u8f93\u5f97\u592a\u60e8\uff0c\u4f60\u9700\u8981\u6bcf\u9694 K K \u6b21\u5c31\u8ba9\u4e00\u4e2a\u5e73\u5c40\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u5373\u5e73\u5c40\u95f4\u9694\u7684\u6b21\u6570\u3002\u968f\u540e\u6bcf\u884c\u7ed9\u51fa\u5bf9\u65b9\u7684\u4e00\u6b21\u51fa\u62db\uff1a ChuiZi \u4ee3\u8868\u201c\u9524\u5b50\u201d\u3001 JianDao \u4ee3\u8868\u201c\u526a\u5200\u201d\u3001 Bu \u4ee3\u8868\u201c\u5e03\u201d\u3002 End \u4ee3\u8868\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e00\u884c\u4e0d\u8981\u4f5c\u4e3a\u51fa\u62db\u5904\u7406\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u8f93\u5165\u7684\u51fa\u62db\uff0c\u6309\u8981\u6c42\u8f93\u51fa\u7a33\u8d62\u6216\u5e73\u5c40\u7684\u62db\u5f0f\u3002\u6bcf\u62db\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 2 ChuiZi JianDao Bu JianDao Bu ChuiZi ChuiZi End \u8f93\u51fa\u6837\u4f8b Bu ChuiZi Bu ChuiZi JianDao ChuiZi Bu","title":"Statement"},{"location":"CCCC/L1-044-%E7%A8%B3%E8%B5%A2/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < string , string > m ; m [ \"ChuiZi\" ] = \"Bu\" ; m [ \"Bu\" ] = \"JianDao\" ; m [ \"JianDao\" ] = \"ChuiZi\" ; int k ; cin >> k ; k ++ ; string s ; for ( int i = 1 ;; i ++ ) { cin >> s ; if ( s == \"End\" ) break ; else { if ( i % k == 0 ) cout << s << endl ; else cout << m [ s ] << endl ; } } }","title":"Solution"},{"location":"CCCC/L1-045-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%A4%A7%E6%8B%9B%E5%91%BC/","text":"L1-045 \u5b87\u5b99\u65e0\u654c\u5927\u62db\u547c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u6240\u6709\u7a0b\u5e8f\u5458\u5b66\u4e60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u90fd\u662f\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u4e00\u53e5\u201cHello World\u201d\uff0c\u8ddf\u8fd9\u4e2a\u4e16\u754c\u6253\u4e2a\u62db\u547c\u3002\u4f5c\u4e3a\u5929\u68af\u8d5b\u4e2d\u7684\u7a0b\u5e8f\u5458\uff0c\u4f60\u5199\u7684\u7a0b\u5e8f\u5f97\u9ad8\u7ea7\u4e00\u70b9\uff0c\u8981\u80fd\u8ddf\u4efb\u610f\u6307\u5b9a\u7684\u661f\u7403\u6253\u62db\u547c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u661f\u7403\u7684\u540d\u5b57 S \uff0c\u662f\u4e00\u4e2a\u7531\u4e0d\u8d85\u8fc77\u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5355\u8bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa Hello S \uff0c\u8ddf\u8f93\u5165\u7684 S \u661f\u7403\u6253\u4e2a\u62db\u547c\u3002 \u8f93\u5165\u6837\u4f8b Mars \u8f93\u51fa\u6837\u4f8b Hello Mars Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; printf ( \"Hello \" ); cout << s << endl ; }","title":"L1-045-\u5b87\u5b99\u65e0\u654c\u5927\u62db\u547c"},{"location":"CCCC/L1-045-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%A4%A7%E6%8B%9B%E5%91%BC/#l1-045-\u5b87\u5b99\u65e0\u654c\u5927\u62db\u547c","text":"","title":"L1-045 \u5b87\u5b99\u65e0\u654c\u5927\u62db\u547c"},{"location":"CCCC/L1-045-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%A4%A7%E6%8B%9B%E5%91%BC/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u6240\u6709\u7a0b\u5e8f\u5458\u5b66\u4e60\u7684\u7b2c\u4e00\u4e2a\u7a0b\u5e8f\u90fd\u662f\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u4e00\u53e5\u201cHello World\u201d\uff0c\u8ddf\u8fd9\u4e2a\u4e16\u754c\u6253\u4e2a\u62db\u547c\u3002\u4f5c\u4e3a\u5929\u68af\u8d5b\u4e2d\u7684\u7a0b\u5e8f\u5458\uff0c\u4f60\u5199\u7684\u7a0b\u5e8f\u5f97\u9ad8\u7ea7\u4e00\u70b9\uff0c\u8981\u80fd\u8ddf\u4efb\u610f\u6307\u5b9a\u7684\u661f\u7403\u6253\u62db\u547c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u661f\u7403\u7684\u540d\u5b57 S \uff0c\u662f\u4e00\u4e2a\u7531\u4e0d\u8d85\u8fc77\u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5355\u8bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa Hello S \uff0c\u8ddf\u8f93\u5165\u7684 S \u661f\u7403\u6253\u4e2a\u62db\u547c\u3002 \u8f93\u5165\u6837\u4f8b Mars \u8f93\u51fa\u6837\u4f8b Hello Mars","title":"Statement"},{"location":"CCCC/L1-045-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%A4%A7%E6%8B%9B%E5%91%BC/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; cin >> s ; printf ( \"Hello \" ); cout << s << endl ; }","title":"Solution"},{"location":"CCCC/L1-046-%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/","text":"L1-046 \u6574\u9664\u5149\u68cd Statement Metadata \u4f5c\u8005: \u7fc1\u607a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u91cc\u6240\u8c13\u7684\u201c\u5149\u68cd\u201d\uff0c\u5e76\u4e0d\u662f\u6307\u5355\u8eab\u6c6a\u5566~ \u8bf4\u7684\u662f\u5168\u90e8\u75311\u7ec4\u6210\u7684\u6570\u5b57\uff0c\u6bd4\u59821\u300111\u3001111\u30011111\u7b49\u3002\u4f20\u8bf4\u4efb\u4f55\u4e00\u4e2a\u5149\u68cd\u90fd\u80fd\u88ab\u4e00\u4e2a\u4e0d\u4ee55\u7ed3\u5c3e\u7684\u5947\u6570\u6574\u9664\u3002\u6bd4\u5982\uff0c111111\u5c31\u53ef\u4ee5\u88ab13\u6574\u9664\u3002 \u73b0\u5728\uff0c\u4f60\u7684\u7a0b\u5e8f\u8981\u8bfb\u5165\u4e00\u4e2a\u6574\u6570 x \uff0c\u8fd9\u4e2a\u6574\u6570\u4e00\u5b9a\u662f\u5947\u6570\u5e76\u4e14\u4e0d\u4ee55\u7ed3\u5c3e\u3002\u7136\u540e\uff0c\u7ecf\u8fc7\u8ba1\u7b97\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u5b57\uff1a\u7b2c\u4e00\u4e2a\u6570\u5b57 s \uff0c\u8868\u793a x \u4e58\u4ee5 s \u662f\u4e00\u4e2a\u5149\u68cd\uff0c\u7b2c\u4e8c\u4e2a\u6570\u5b57 n \u662f\u8fd9\u4e2a\u5149\u68cd\u7684\u4f4d\u6570\u3002\u8fd9\u6837\u7684\u89e3\u5f53\u7136\u4e0d\u662f\u552f\u4e00\u7684,\u9898\u76ee\u8981\u6c42\u4f60\u8f93\u51fa\u6700\u5c0f\u7684\u89e3\u3002 \u63d0\u793a\uff1a\u4e00\u4e2a\u663e\u7136\u7684\u529e\u6cd5\u662f\u9010\u6e10\u589e\u52a0\u5149\u68cd\u7684\u4f4d\u6570\uff0c\u76f4\u5230\u53ef\u4ee5\u6574\u9664 x \u4e3a\u6b62\u3002\u4f46\u96be\u70b9\u5728\u4e8e\uff0c s \u53ef\u80fd\u662f\u4e2a\u975e\u5e38\u5927\u7684\u6570 \u2014\u2014 \u6bd4\u5982\uff0c\u7a0b\u5e8f\u8f93\u516531\uff0c\u90a3\u4e48\u5c31\u8f93\u51fa3584229390681\u548c15\uff0c\u56e0\u4e3a31\u4e58\u4ee53584229390681\u7684\u7ed3\u679c\u662f111111111111111\uff0c\u4e00\u517115\u4e2a1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u4ee55\u7ed3\u5c3e\u7684\u6b63\u5947\u6570 x \uff08 < 1000 < 1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u7684\u6700\u5c0f\u7684 s \u548c n \uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 31 \u8f93\u51fa\u6837\u4f8b 3584229390681 15 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; LL ans ; int len = 1 ; for ( ans = 1 ; ans < n ; ans = ans * 10 + 1 ) len ++ ; while ( 1 ) { if ( ans % n == 0 ) { cout << ans / n ; break ; } else { cout << ans / n ; len ++ ; ans %= n ; ans = ans * 10 + 1 ; } } cout << \" \" << len << endl ; }","title":"L1-046-\u6574\u9664\u5149\u68cd"},{"location":"CCCC/L1-046-%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/#l1-046-\u6574\u9664\u5149\u68cd","text":"","title":"L1-046 \u6574\u9664\u5149\u68cd"},{"location":"CCCC/L1-046-%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/#statement","text":"Metadata \u4f5c\u8005: \u7fc1\u607a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u91cc\u6240\u8c13\u7684\u201c\u5149\u68cd\u201d\uff0c\u5e76\u4e0d\u662f\u6307\u5355\u8eab\u6c6a\u5566~ \u8bf4\u7684\u662f\u5168\u90e8\u75311\u7ec4\u6210\u7684\u6570\u5b57\uff0c\u6bd4\u59821\u300111\u3001111\u30011111\u7b49\u3002\u4f20\u8bf4\u4efb\u4f55\u4e00\u4e2a\u5149\u68cd\u90fd\u80fd\u88ab\u4e00\u4e2a\u4e0d\u4ee55\u7ed3\u5c3e\u7684\u5947\u6570\u6574\u9664\u3002\u6bd4\u5982\uff0c111111\u5c31\u53ef\u4ee5\u88ab13\u6574\u9664\u3002 \u73b0\u5728\uff0c\u4f60\u7684\u7a0b\u5e8f\u8981\u8bfb\u5165\u4e00\u4e2a\u6574\u6570 x \uff0c\u8fd9\u4e2a\u6574\u6570\u4e00\u5b9a\u662f\u5947\u6570\u5e76\u4e14\u4e0d\u4ee55\u7ed3\u5c3e\u3002\u7136\u540e\uff0c\u7ecf\u8fc7\u8ba1\u7b97\uff0c\u8f93\u51fa\u4e24\u4e2a\u6570\u5b57\uff1a\u7b2c\u4e00\u4e2a\u6570\u5b57 s \uff0c\u8868\u793a x \u4e58\u4ee5 s \u662f\u4e00\u4e2a\u5149\u68cd\uff0c\u7b2c\u4e8c\u4e2a\u6570\u5b57 n \u662f\u8fd9\u4e2a\u5149\u68cd\u7684\u4f4d\u6570\u3002\u8fd9\u6837\u7684\u89e3\u5f53\u7136\u4e0d\u662f\u552f\u4e00\u7684,\u9898\u76ee\u8981\u6c42\u4f60\u8f93\u51fa\u6700\u5c0f\u7684\u89e3\u3002 \u63d0\u793a\uff1a\u4e00\u4e2a\u663e\u7136\u7684\u529e\u6cd5\u662f\u9010\u6e10\u589e\u52a0\u5149\u68cd\u7684\u4f4d\u6570\uff0c\u76f4\u5230\u53ef\u4ee5\u6574\u9664 x \u4e3a\u6b62\u3002\u4f46\u96be\u70b9\u5728\u4e8e\uff0c s \u53ef\u80fd\u662f\u4e2a\u975e\u5e38\u5927\u7684\u6570 \u2014\u2014 \u6bd4\u5982\uff0c\u7a0b\u5e8f\u8f93\u516531\uff0c\u90a3\u4e48\u5c31\u8f93\u51fa3584229390681\u548c15\uff0c\u56e0\u4e3a31\u4e58\u4ee53584229390681\u7684\u7ed3\u679c\u662f111111111111111\uff0c\u4e00\u517115\u4e2a1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u4ee55\u7ed3\u5c3e\u7684\u6b63\u5947\u6570 x \uff08 < 1000 < 1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u7684\u6700\u5c0f\u7684 s \u548c n \uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 31 \u8f93\u51fa\u6837\u4f8b 3584229390681 15","title":"Statement"},{"location":"CCCC/L1-046-%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; LL ans ; int len = 1 ; for ( ans = 1 ; ans < n ; ans = ans * 10 + 1 ) len ++ ; while ( 1 ) { if ( ans % n == 0 ) { cout << ans / n ; break ; } else { cout << ans / n ; len ++ ; ans %= n ; ans = ans * 10 + 1 ; } } cout << \" \" << len << endl ; }","title":"Solution"},{"location":"CCCC/L1-047-%E8%A3%85%E7%9D%A1/","text":"L1-047 \u88c5\u7761 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4f60\u6c38\u8fdc\u53eb\u4e0d\u9192\u4e00\u4e2a\u88c5\u7761\u7684\u4eba \u2014\u2014 \u4f46\u662f\u901a\u8fc7\u5206\u6790\u4e00\u4e2a\u4eba\u7684\u547c\u5438\u9891\u7387\u548c\u8109\u640f\uff0c\u4f60\u53ef\u4ee5\u53d1\u73b0\u8c01\u5728\u88c5\u7761\uff01\u533b\u751f\u544a\u8bc9\u6211\u4eec\uff0c\u6b63\u5e38\u4eba\u7761\u7720\u65f6\u7684\u547c\u5438\u9891\u7387\u662f\u6bcf\u5206\u949f15-20\u6b21\uff0c\u8109\u640f\u662f\u6bcf\u5206\u949f50-70\u6b21\u3002\u4e0b\u9762\u7ed9\u5b9a\u4e00\u7cfb\u5217\u4eba\u7684\u547c\u5438\u9891\u7387\u4e0e\u8109\u640f\uff0c\u8bf7\u4f60\u627e\u51fa\u4ed6\u4eec\u4e2d\u95f4\u6709\u53ef\u80fd\u5728\u88c5\u7761\u7684\u4eba\uff0c\u5373\u81f3\u5c11\u4e00\u9879\u6307\u6807\u4e0d\u5728\u6b63\u5e38\u8303\u56f4\u5185\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u540d\u5b57\uff08\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc73\u4e2a\u5b57\u7b26\u7684\u4e32\uff09\u3001\u5176\u547c\u5438\u9891\u7387\u548c\u8109\u640f\uff08\u5747\u4e3a\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u987a\u5e8f\u68c0\u67e5\u6bcf\u4e2a\u4eba\uff0c\u5982\u679c\u5176\u81f3\u5c11\u4e00\u9879\u6307\u6807\u4e0d\u5728\u6b63\u5e38\u8303\u56f4\u5185\uff0c\u5219\u8f93\u51fa\u5176\u540d\u5b57\uff0c\u6bcf\u4e2a\u540d\u5b57\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 4 Amy 15 70 Tom 14 60 Joe 18 50 Zoe 21 71 \u8f93\u51fa\u6837\u4f8b Tom Zoe Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; while ( n -- ) { string s ; int a , b ; cin >> s >> a >> b ; if ( a > 20 || a < 15 || b > 70 || b < 50 ) cout << s << endl ; } }","title":"L1-047-\u88c5\u7761"},{"location":"CCCC/L1-047-%E8%A3%85%E7%9D%A1/#l1-047-\u88c5\u7761","text":"","title":"L1-047 \u88c5\u7761"},{"location":"CCCC/L1-047-%E8%A3%85%E7%9D%A1/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4f60\u6c38\u8fdc\u53eb\u4e0d\u9192\u4e00\u4e2a\u88c5\u7761\u7684\u4eba \u2014\u2014 \u4f46\u662f\u901a\u8fc7\u5206\u6790\u4e00\u4e2a\u4eba\u7684\u547c\u5438\u9891\u7387\u548c\u8109\u640f\uff0c\u4f60\u53ef\u4ee5\u53d1\u73b0\u8c01\u5728\u88c5\u7761\uff01\u533b\u751f\u544a\u8bc9\u6211\u4eec\uff0c\u6b63\u5e38\u4eba\u7761\u7720\u65f6\u7684\u547c\u5438\u9891\u7387\u662f\u6bcf\u5206\u949f15-20\u6b21\uff0c\u8109\u640f\u662f\u6bcf\u5206\u949f50-70\u6b21\u3002\u4e0b\u9762\u7ed9\u5b9a\u4e00\u7cfb\u5217\u4eba\u7684\u547c\u5438\u9891\u7387\u4e0e\u8109\u640f\uff0c\u8bf7\u4f60\u627e\u51fa\u4ed6\u4eec\u4e2d\u95f4\u6709\u53ef\u80fd\u5728\u88c5\u7761\u7684\u4eba\uff0c\u5373\u81f3\u5c11\u4e00\u9879\u6307\u6807\u4e0d\u5728\u6b63\u5e38\u8303\u56f4\u5185\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10 \\le 10 \uff09\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u540d\u5b57\uff08\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc73\u4e2a\u5b57\u7b26\u7684\u4e32\uff09\u3001\u5176\u547c\u5438\u9891\u7387\u548c\u8109\u640f\uff08\u5747\u4e3a\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u987a\u5e8f\u68c0\u67e5\u6bcf\u4e2a\u4eba\uff0c\u5982\u679c\u5176\u81f3\u5c11\u4e00\u9879\u6307\u6807\u4e0d\u5728\u6b63\u5e38\u8303\u56f4\u5185\uff0c\u5219\u8f93\u51fa\u5176\u540d\u5b57\uff0c\u6bcf\u4e2a\u540d\u5b57\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 4 Amy 15 70 Tom 14 60 Joe 18 50 Zoe 21 71 \u8f93\u51fa\u6837\u4f8b Tom Zoe","title":"Statement"},{"location":"CCCC/L1-047-%E8%A3%85%E7%9D%A1/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; while ( n -- ) { string s ; int a , b ; cin >> s >> a >> b ; if ( a > 20 || a < 15 || b > 70 || b < 50 ) cout << s << endl ; } }","title":"Solution"},{"location":"CCCC/L1-048-%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B/","text":"L1-048 \u77e9\u9635A\u4e58\u4ee5B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u77e9\u9635 A A \u548c B B \uff0c\u8981\u6c42\u4f60\u8ba1\u7b97\u5b83\u4eec\u7684\u4e58\u79ef\u77e9\u9635 AB AB \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u53ea\u6709\u89c4\u6a21\u5339\u914d\u7684\u77e9\u9635\u624d\u53ef\u4ee5\u76f8\u4e58\u3002\u5373\u82e5 A A \u6709 R_a R_a \u884c\u3001 C_a C_a \u5217\uff0c B B \u6709 R_b R_b \u884c\u3001 C_b C_b \u5217\uff0c\u5219\u53ea\u6709 C_a C_a \u4e0e R_b R_b \u76f8\u7b49\u65f6\uff0c\u4e24\u4e2a\u77e9\u9635\u624d\u80fd\u76f8\u4e58\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5148\u540e\u7ed9\u51fa\u4e24\u4e2a\u77e9\u9635 A A \u548c B B \u3002\u5bf9\u4e8e\u6bcf\u4e2a\u77e9\u9635\uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5176\u884c\u6570 R R \u548c\u5217\u6570 C C \uff0c\u968f\u540e R R \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa C C \u4e2a\u6574\u6570\uff0c\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u4e14\u884c\u9996\u5c3e\u6ca1\u6709\u591a\u4f59\u7684\u7a7a\u683c\u3002\u8f93\u5165\u4fdd\u8bc1\u4e24\u4e2a\u77e9\u9635\u7684 R R \u548c C C \u90fd\u662f\u6b63\u6570\uff0c\u5e76\u4e14\u6240\u6709\u6574\u6570\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7100\u3002 \u8f93\u51fa\u683c\u5f0f \u82e5\u8f93\u5165\u7684\u4e24\u4e2a\u77e9\u9635\u7684\u89c4\u6a21\u662f\u5339\u914d\u7684\uff0c\u5219\u6309\u7167\u8f93\u5165\u7684\u683c\u5f0f\u8f93\u51fa\u4e58\u79ef\u77e9\u9635 AB AB \uff0c\u5426\u5219\u8f93\u51fa Error: Ca != Rb \uff0c\u5176\u4e2d Ca \u662f A A \u7684\u5217\u6570\uff0c Rb \u662f B B \u7684\u884c\u6570\u3002 \u8f93\u5165\u6837\u4f8b1 2 3 1 2 3 4 5 6 3 4 7 8 9 0 -1 -2 -3 -4 5 6 7 8 \u8f93\u51fa\u6837\u4f8b1 2 4 20 22 24 16 53 58 63 28 \u8f93\u5165\u6837\u4f8b2 3 2 38 26 43 -5 0 17 3 2 -11 57 99 68 81 72 \u8f93\u51fa\u6837\u4f8b2 Error: 2 != 3 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int a [ maxn ][ maxn ], b [ maxn ][ maxn ], c [ maxn ][ maxn ]; int main () { int x1 , y1 ; int x2 , y2 ; cin >> x1 >> y1 ; int i , j , k ; memset ( a , 0 , sizeof ( a )); memset ( b , 0 , sizeof ( b )); memset ( c , 0 , sizeof ( c )); for ( i = 0 ; i < x1 ; i ++ ) { for ( j = 0 ; j < y1 ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } cin >> x2 >> y2 ; for ( i = 0 ; i < x2 ; i ++ ) { for ( j = 0 ; j < y2 ; j ++ ) { scanf ( \"%d\" , & b [ i ][ j ]); } } if ( y1 != x2 ) { printf ( \"Error: %d != %d \\n \" , y1 , x2 ); } else { printf ( \"%d %d \\n \" , x1 , y2 ); int num = 0 ; for ( i = 0 ; i < x1 ; i ++ ) { for ( j = 0 ; j < y2 ; j ++ ) { if ( j ) printf ( \" \" ); num = 0 ; for ( k = 0 ; k < x2 ; k ++ ) { num += a [ i ][ k ] * b [ k ][ j ]; } cout << num ; } cout << endl ; } } }","title":"L1-048-\u77e9\u9635A\u4e58\u4ee5B"},{"location":"CCCC/L1-048-%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B/#l1-048-\u77e9\u9635a\u4e58\u4ee5b","text":"","title":"L1-048 \u77e9\u9635A\u4e58\u4ee5B"},{"location":"CCCC/L1-048-%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u77e9\u9635 A A \u548c B B \uff0c\u8981\u6c42\u4f60\u8ba1\u7b97\u5b83\u4eec\u7684\u4e58\u79ef\u77e9\u9635 AB AB \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u53ea\u6709\u89c4\u6a21\u5339\u914d\u7684\u77e9\u9635\u624d\u53ef\u4ee5\u76f8\u4e58\u3002\u5373\u82e5 A A \u6709 R_a R_a \u884c\u3001 C_a C_a \u5217\uff0c B B \u6709 R_b R_b \u884c\u3001 C_b C_b \u5217\uff0c\u5219\u53ea\u6709 C_a C_a \u4e0e R_b R_b \u76f8\u7b49\u65f6\uff0c\u4e24\u4e2a\u77e9\u9635\u624d\u80fd\u76f8\u4e58\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5148\u540e\u7ed9\u51fa\u4e24\u4e2a\u77e9\u9635 A A \u548c B B \u3002\u5bf9\u4e8e\u6bcf\u4e2a\u77e9\u9635\uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5176\u884c\u6570 R R \u548c\u5217\u6570 C C \uff0c\u968f\u540e R R \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa C C \u4e2a\u6574\u6570\uff0c\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u4e14\u884c\u9996\u5c3e\u6ca1\u6709\u591a\u4f59\u7684\u7a7a\u683c\u3002\u8f93\u5165\u4fdd\u8bc1\u4e24\u4e2a\u77e9\u9635\u7684 R R \u548c C C \u90fd\u662f\u6b63\u6570\uff0c\u5e76\u4e14\u6240\u6709\u6574\u6570\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7100\u3002 \u8f93\u51fa\u683c\u5f0f \u82e5\u8f93\u5165\u7684\u4e24\u4e2a\u77e9\u9635\u7684\u89c4\u6a21\u662f\u5339\u914d\u7684\uff0c\u5219\u6309\u7167\u8f93\u5165\u7684\u683c\u5f0f\u8f93\u51fa\u4e58\u79ef\u77e9\u9635 AB AB \uff0c\u5426\u5219\u8f93\u51fa Error: Ca != Rb \uff0c\u5176\u4e2d Ca \u662f A A \u7684\u5217\u6570\uff0c Rb \u662f B B \u7684\u884c\u6570\u3002 \u8f93\u5165\u6837\u4f8b1 2 3 1 2 3 4 5 6 3 4 7 8 9 0 -1 -2 -3 -4 5 6 7 8 \u8f93\u51fa\u6837\u4f8b1 2 4 20 22 24 16 53 58 63 28 \u8f93\u5165\u6837\u4f8b2 3 2 38 26 43 -5 0 17 3 2 -11 57 99 68 81 72 \u8f93\u51fa\u6837\u4f8b2 Error: 2 != 3","title":"Statement"},{"location":"CCCC/L1-048-%E7%9F%A9%E9%98%B5A%E4%B9%98%E4%BB%A5B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int a [ maxn ][ maxn ], b [ maxn ][ maxn ], c [ maxn ][ maxn ]; int main () { int x1 , y1 ; int x2 , y2 ; cin >> x1 >> y1 ; int i , j , k ; memset ( a , 0 , sizeof ( a )); memset ( b , 0 , sizeof ( b )); memset ( c , 0 , sizeof ( c )); for ( i = 0 ; i < x1 ; i ++ ) { for ( j = 0 ; j < y1 ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); } } cin >> x2 >> y2 ; for ( i = 0 ; i < x2 ; i ++ ) { for ( j = 0 ; j < y2 ; j ++ ) { scanf ( \"%d\" , & b [ i ][ j ]); } } if ( y1 != x2 ) { printf ( \"Error: %d != %d \\n \" , y1 , x2 ); } else { printf ( \"%d %d \\n \" , x1 , y2 ); int num = 0 ; for ( i = 0 ; i < x1 ; i ++ ) { for ( j = 0 ; j < y2 ; j ++ ) { if ( j ) printf ( \" \" ); num = 0 ; for ( k = 0 ; k < x2 ; k ++ ) { num += a [ i ][ k ] * b [ k ][ j ]; } cout << num ; } cout << endl ; } } }","title":"Solution"},{"location":"CCCC/L1-049-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/","text":"L1-049 \u5929\u68af\u8d5b\u5ea7\u4f4d\u5206\u914d Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u8d5b\u6bcf\u5e74\u6709\u5927\u91cf\u53c2\u8d5b\u961f\u5458\uff0c\u8981\u4fdd\u8bc1\u540c\u4e00\u6240\u5b66\u6821\u7684\u6240\u6709\u961f\u5458\u90fd\u4e0d\u80fd\u76f8\u90bb\uff0c\u5206\u914d\u5ea7\u4f4d\u5c31\u6210\u4e3a\u4e00\u4ef6\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\u3002\u4e3a\u6b64\u6211\u4eec\u5236\u5b9a\u5982\u4e0b\u7b56\u7565\uff1a\u5047\u8bbe\u67d0\u8d5b\u573a\u6709 N \u6240\u5b66\u6821\u53c2\u8d5b\uff0c\u7b2c i \u6240\u5b66\u6821\u6709 M[i] \u652f\u961f\u4f0d\uff0c\u6bcf\u961f 10 \u4f4d\u53c2\u8d5b\u9009\u624b\u3002\u4ee4\u6bcf\u6821\u9009\u624b\u6392\u6210\u4e00\u5217\u7eb5\u961f\uff0c\u7b2c i+1 \u961f\u7684\u9009\u624b\u6392\u5728\u7b2c i \u961f\u9009\u624b\u4e4b\u540e\u3002\u4ece\u7b2c 1 \u6240\u5b66\u6821\u5f00\u59cb\uff0c\u5404\u6821\u7684\u7b2c 1 \u4f4d\u961f\u5458\u987a\u6b21\u5165\u5ea7\uff0c\u7136\u540e\u662f\u5404\u6821\u7684\u7b2c 2 \u4f4d\u961f\u5458\u2026\u2026 \u4ee5\u6b64\u7c7b\u63a8\u3002\u5982\u679c\u6700\u540e\u53ea\u5269\u4e0b 1 \u6240\u5b66\u6821\u7684\u961f\u4f0d\u8fd8\u6ca1\u6709\u5206\u914d\u5ea7\u4f4d\uff0c\u5219\u9700\u8981\u5b89\u6392\u4ed6\u4eec\u7684\u961f\u5458\u9694\u4f4d\u5c31\u5750\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u81ea\u52a8\u4e3a\u5404\u6821\u751f\u6210\u961f\u5458\u7684\u5ea7\u4f4d\u53f7\uff0c\u4ece 1 \u5f00\u59cb\u7f16\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u53c2\u8d5b\u7684\u9ad8\u6821\u6570 N \uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u4e0d\u8d85\u8fc710\u7684\u6b63\u6574\u6570\uff0c\u5176\u4e2d\u7b2c i \u4e2a\u6570\u5bf9\u5e94\u7b2c i \u6240\u9ad8\u6821\u7684\u53c2\u8d5b\u961f\u4f0d\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4ece\u7b2c 1 \u6240\u9ad8\u6821\u7684\u7b2c 1 \u652f\u961f\u4f0d\u5f00\u59cb\uff0c\u987a\u6b21\u8f93\u51fa\u961f\u5458\u7684\u5ea7\u4f4d\u53f7\u3002\u6bcf\u961f\u5360\u4e00\u884c\uff0c\u5ea7\u4f4d\u53f7\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u53e6\u5916\uff0c\u6bcf\u6240\u9ad8\u6821\u7684\u7b2c\u4e00\u884c\u6309\u201c#X\u201d\u8f93\u51fa\u8be5\u6821\u7684\u7f16\u53f7X\uff0c\u4ece 1 \u5f00\u59cb\u3002 \u8f93\u5165\u6837\u4f8b 3 3 4 2 \u8f93\u51fa\u6837\u4f8b #1 1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 63 65 67 69 71 73 75 77 79 #2 2 5 8 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 #3 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; vector < int > ans [ 100 ]; int vis [ 100 ]; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & vis [ i ]); vis [ i ] *= 10 ; } int count = 1 ; while ( 1 ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ]. size () < vis [ i ]) { if ( ans [ i ]. size () && count - ans [ i ][ ans [ i ]. size () - 1 ] == 1 ) count ++ ; ans [ i ]. pb ( count ++ ); if ( ans [ i ]. size () < vis [ i ]) flag = 1 ; } } if ( flag == 0 ) break ; } for ( int i = 0 ; i < n ; i ++ ) { printf ( \"#%d \\n \" , i + 1 ); for ( int j = 0 ; j < vis [ i ]; j ++ ) { printf ( \"%d\" , ans [ i ][ j ]); if ( j && ( j + 1 ) % 10 == 0 ) printf ( \" \\n \" ); else printf ( \" \" ); } } }","title":"L1-049-\u5929\u68af\u8d5b\u5ea7\u4f4d\u5206\u914d"},{"location":"CCCC/L1-049-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/#l1-049-\u5929\u68af\u8d5b\u5ea7\u4f4d\u5206\u914d","text":"","title":"L1-049 \u5929\u68af\u8d5b\u5ea7\u4f4d\u5206\u914d"},{"location":"CCCC/L1-049-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u8d5b\u6bcf\u5e74\u6709\u5927\u91cf\u53c2\u8d5b\u961f\u5458\uff0c\u8981\u4fdd\u8bc1\u540c\u4e00\u6240\u5b66\u6821\u7684\u6240\u6709\u961f\u5458\u90fd\u4e0d\u80fd\u76f8\u90bb\uff0c\u5206\u914d\u5ea7\u4f4d\u5c31\u6210\u4e3a\u4e00\u4ef6\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\u3002\u4e3a\u6b64\u6211\u4eec\u5236\u5b9a\u5982\u4e0b\u7b56\u7565\uff1a\u5047\u8bbe\u67d0\u8d5b\u573a\u6709 N \u6240\u5b66\u6821\u53c2\u8d5b\uff0c\u7b2c i \u6240\u5b66\u6821\u6709 M[i] \u652f\u961f\u4f0d\uff0c\u6bcf\u961f 10 \u4f4d\u53c2\u8d5b\u9009\u624b\u3002\u4ee4\u6bcf\u6821\u9009\u624b\u6392\u6210\u4e00\u5217\u7eb5\u961f\uff0c\u7b2c i+1 \u961f\u7684\u9009\u624b\u6392\u5728\u7b2c i \u961f\u9009\u624b\u4e4b\u540e\u3002\u4ece\u7b2c 1 \u6240\u5b66\u6821\u5f00\u59cb\uff0c\u5404\u6821\u7684\u7b2c 1 \u4f4d\u961f\u5458\u987a\u6b21\u5165\u5ea7\uff0c\u7136\u540e\u662f\u5404\u6821\u7684\u7b2c 2 \u4f4d\u961f\u5458\u2026\u2026 \u4ee5\u6b64\u7c7b\u63a8\u3002\u5982\u679c\u6700\u540e\u53ea\u5269\u4e0b 1 \u6240\u5b66\u6821\u7684\u961f\u4f0d\u8fd8\u6ca1\u6709\u5206\u914d\u5ea7\u4f4d\uff0c\u5219\u9700\u8981\u5b89\u6392\u4ed6\u4eec\u7684\u961f\u5458\u9694\u4f4d\u5c31\u5750\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u81ea\u52a8\u4e3a\u5404\u6821\u751f\u6210\u961f\u5458\u7684\u5ea7\u4f4d\u53f7\uff0c\u4ece 1 \u5f00\u59cb\u7f16\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u53c2\u8d5b\u7684\u9ad8\u6821\u6570 N \uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u4e0d\u8d85\u8fc710\u7684\u6b63\u6574\u6570\uff0c\u5176\u4e2d\u7b2c i \u4e2a\u6570\u5bf9\u5e94\u7b2c i \u6240\u9ad8\u6821\u7684\u53c2\u8d5b\u961f\u4f0d\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4ece\u7b2c 1 \u6240\u9ad8\u6821\u7684\u7b2c 1 \u652f\u961f\u4f0d\u5f00\u59cb\uff0c\u987a\u6b21\u8f93\u51fa\u961f\u5458\u7684\u5ea7\u4f4d\u53f7\u3002\u6bcf\u961f\u5360\u4e00\u884c\uff0c\u5ea7\u4f4d\u53f7\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u53e6\u5916\uff0c\u6bcf\u6240\u9ad8\u6821\u7684\u7b2c\u4e00\u884c\u6309\u201c#X\u201d\u8f93\u51fa\u8be5\u6821\u7684\u7f16\u53f7X\uff0c\u4ece 1 \u5f00\u59cb\u3002 \u8f93\u5165\u6837\u4f8b 3 3 4 2 \u8f93\u51fa\u6837\u4f8b #1 1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 63 65 67 69 71 73 75 77 79 #2 2 5 8 11 14 17 20 23 26 29 32 35 38 41 44 47 50 53 56 59 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100 #3 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60","title":"Statement"},{"location":"CCCC/L1-049-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; vector < int > ans [ 100 ]; int vis [ 100 ]; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & vis [ i ]); vis [ i ] *= 10 ; } int count = 1 ; while ( 1 ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ]. size () < vis [ i ]) { if ( ans [ i ]. size () && count - ans [ i ][ ans [ i ]. size () - 1 ] == 1 ) count ++ ; ans [ i ]. pb ( count ++ ); if ( ans [ i ]. size () < vis [ i ]) flag = 1 ; } } if ( flag == 0 ) break ; } for ( int i = 0 ; i < n ; i ++ ) { printf ( \"#%d \\n \" , i + 1 ); for ( int j = 0 ; j < vis [ i ]; j ++ ) { printf ( \"%d\" , ans [ i ][ j ]); if ( j && ( j + 1 ) % 10 == 0 ) printf ( \" \\n \" ); else printf ( \" \" ); } } }","title":"Solution"},{"location":"CCCC/L1-050-%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/","text":"L1-050 \u5012\u6570\u7b2cN\u4e2a\u5b57\u7b26\u4e32 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5b8c\u5168\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u7b49\u5dee\u9012\u589e\u5e8f\u5217\uff0c\u8be5\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u56fa\u5b9a\u4e3a L\uff0c\u4ece L \u4e2a a \u5f00\u59cb\uff0c\u4ee5 1 \u4e3a\u6b65\u957f\u9012\u589e\u3002\u4f8b\u5982\u5f53 L \u4e3a 3 \u65f6\uff0c\u5e8f\u5217\u4e3a { aaa, aab, aac, \u2026, aaz, aba, abb, \u2026, abz, \u2026, zzz }\u3002\u8fd9\u4e2a\u5e8f\u5217\u7684\u5012\u6570\u7b2c27\u4e2a\u5b57\u7b26\u4e32\u5c31\u662f zyz\u3002\u5bf9\u4e8e\u4efb\u610f\u7ed9\u5b9a\u7684 L\uff0c\u672c\u9898\u8981\u6c42\u4f60\u7ed9\u51fa\u5bf9\u5e94\u5e8f\u5217\u5012\u6570\u7b2c N \u4e2a\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 L\uff082 \\le \\le L \\le \\le 6\uff09\u548c N\uff08 \\le 10^5 \\le 10^5 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u5e8f\u5217\u5012\u6570\u7b2c N \u4e2a\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u5b58\u5728\u7684\u3002 \u8f93\u5165\u6837\u4f8b 3 7417 \u8f93\u51fa\u6837\u4f8b pat Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < int , char > m ; for ( int i = 'z' , j = 0 ; i >= 'a' ; i -- , j ++ ) m [ j ] = i ; int a , b ; scanf ( \"%d%d\" , & a , & b ); b -- ; int ans [ 6 ]; CLR ( ans ); for ( int i = 0 ; b ; i ++ ) { ans [ i ] = b % 26 ; b /= 26 ; } string s = \"\" ; for ( int i = 0 ; i < a ; i ++ ) s += m [ ans [ i ]]; reverse ( s . begin (), s . end ()); cout << s << endl ; }","title":"L1-050-\u5012\u6570\u7b2cN\u4e2a\u5b57\u7b26\u4e32"},{"location":"CCCC/L1-050-%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/#l1-050-\u5012\u6570\u7b2cn\u4e2a\u5b57\u7b26\u4e32","text":"","title":"L1-050 \u5012\u6570\u7b2cN\u4e2a\u5b57\u7b26\u4e32"},{"location":"CCCC/L1-050-%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5b8c\u5168\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u7b49\u5dee\u9012\u589e\u5e8f\u5217\uff0c\u8be5\u5e8f\u5217\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u56fa\u5b9a\u4e3a L\uff0c\u4ece L \u4e2a a \u5f00\u59cb\uff0c\u4ee5 1 \u4e3a\u6b65\u957f\u9012\u589e\u3002\u4f8b\u5982\u5f53 L \u4e3a 3 \u65f6\uff0c\u5e8f\u5217\u4e3a { aaa, aab, aac, \u2026, aaz, aba, abb, \u2026, abz, \u2026, zzz }\u3002\u8fd9\u4e2a\u5e8f\u5217\u7684\u5012\u6570\u7b2c27\u4e2a\u5b57\u7b26\u4e32\u5c31\u662f zyz\u3002\u5bf9\u4e8e\u4efb\u610f\u7ed9\u5b9a\u7684 L\uff0c\u672c\u9898\u8981\u6c42\u4f60\u7ed9\u51fa\u5bf9\u5e94\u5e8f\u5217\u5012\u6570\u7b2c N \u4e2a\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 L\uff082 \\le \\le L \\le \\le 6\uff09\u548c N\uff08 \\le 10^5 \\le 10^5 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u5e8f\u5217\u5012\u6570\u7b2c N \u4e2a\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u5b58\u5728\u7684\u3002 \u8f93\u5165\u6837\u4f8b 3 7417 \u8f93\u51fa\u6837\u4f8b pat","title":"Statement"},{"location":"CCCC/L1-050-%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < int , char > m ; for ( int i = 'z' , j = 0 ; i >= 'a' ; i -- , j ++ ) m [ j ] = i ; int a , b ; scanf ( \"%d%d\" , & a , & b ); b -- ; int ans [ 6 ]; CLR ( ans ); for ( int i = 0 ; b ; i ++ ) { ans [ i ] = b % 26 ; b /= 26 ; } string s = \"\" ; for ( int i = 0 ; i < a ; i ++ ) s += m [ ans [ i ]]; reverse ( s . begin (), s . end ()); cout << s << endl ; }","title":"Solution"},{"location":"CCCC/L1-051-%E6%89%93%E6%8A%98/","text":"L1-051 \u6253\u6298 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u53bb\u5546\u573a\u6dd8\u6253\u6298\u5546\u54c1\u65f6\uff0c\u8ba1\u7b97\u6253\u6298\u4ee5\u540e\u7684\u4ef7\u94b1\u662f\u4ef6\u9887\u8d39\u8111\u5b50\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u539f\u4ef7 \uffe5988\uff0c\u6807\u660e\u6253 7 \u6298\uff0c\u5219\u6298\u6263\u4ef7\u5e94\u8be5\u662f \uffe5988 x 70% = \uffe5691.60\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u66ff\u5ba2\u6237\u8ba1\u7b97\u6298\u6263\u4ef7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5546\u54c1\u7684\u539f\u4ef7\uff08\u4e0d\u8d85\u8fc71\u4e07\u5143\u7684\u6b63\u6574\u6570\uff09\u548c\u6298\u6263\uff08\u4e3a[1, 9]\u533a\u95f4\u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5546\u54c1\u7684\u6298\u6263\u4ef7\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 988 7 \u8f93\u51fa\u6837\u4f8b 691.60 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d%d\" , & a , & b ); printf ( \"%.2lf \\n \" , a * b * 0.1 ); }","title":"L1-051-\u6253\u6298"},{"location":"CCCC/L1-051-%E6%89%93%E6%8A%98/#l1-051-\u6253\u6298","text":"","title":"L1-051 \u6253\u6298"},{"location":"CCCC/L1-051-%E6%89%93%E6%8A%98/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u53bb\u5546\u573a\u6dd8\u6253\u6298\u5546\u54c1\u65f6\uff0c\u8ba1\u7b97\u6253\u6298\u4ee5\u540e\u7684\u4ef7\u94b1\u662f\u4ef6\u9887\u8d39\u8111\u5b50\u7684\u4e8b\u60c5\u3002\u4f8b\u5982\u539f\u4ef7 \uffe5988\uff0c\u6807\u660e\u6253 7 \u6298\uff0c\u5219\u6298\u6263\u4ef7\u5e94\u8be5\u662f \uffe5988 x 70% = \uffe5691.60\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u66ff\u5ba2\u6237\u8ba1\u7b97\u6298\u6263\u4ef7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5546\u54c1\u7684\u539f\u4ef7\uff08\u4e0d\u8d85\u8fc71\u4e07\u5143\u7684\u6b63\u6574\u6570\uff09\u548c\u6298\u6263\uff08\u4e3a[1, 9]\u533a\u95f4\u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5546\u54c1\u7684\u6298\u6263\u4ef7\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 988 7 \u8f93\u51fa\u6837\u4f8b 691.60","title":"Statement"},{"location":"CCCC/L1-051-%E6%89%93%E6%8A%98/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d%d\" , & a , & b ); printf ( \"%.2lf \\n \" , a * b * 0.1 ); }","title":"Solution"},{"location":"CCCC/L1-052-2018%E6%88%91%E4%BB%AC%E8%A6%81%E8%B5%A2/","text":"L1-052 2018\u6211\u4eec\u8981\u8d62 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB 2018\u5e74\u5929\u68af\u8d5b\u7684\u6ce8\u518c\u9080\u8bf7\u7801\u662f\u201c2018wmyy\u201d\uff0c\u610f\u601d\u5c31\u662f\u201c2018\u6211\u4eec\u8981\u8d62\u201d\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u6c49\u8bed\u62fc\u97f3\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\uff1a\u201c2018\u201d\uff1b\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\uff1a\u201cwo3 men2 yao4 ying2 !\u201d\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b 2018 wo3 men2 yao4 ying2 ! Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"2018 \\n \" ; cout << \"wo3 men2 yao4 ying2 ! \\n \" ; }","title":"L1-052-2018\u6211\u4eec\u8981\u8d62"},{"location":"CCCC/L1-052-2018%E6%88%91%E4%BB%AC%E8%A6%81%E8%B5%A2/#l1-052-2018\u6211\u4eec\u8981\u8d62","text":"","title":"L1-052 2018\u6211\u4eec\u8981\u8d62"},{"location":"CCCC/L1-052-2018%E6%88%91%E4%BB%AC%E8%A6%81%E8%B5%A2/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB 2018\u5e74\u5929\u68af\u8d5b\u7684\u6ce8\u518c\u9080\u8bf7\u7801\u662f\u201c2018wmyy\u201d\uff0c\u610f\u601d\u5c31\u662f\u201c2018\u6211\u4eec\u8981\u8d62\u201d\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u6c49\u8bed\u62fc\u97f3\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\uff1a\u201c2018\u201d\uff1b\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\uff1a\u201cwo3 men2 yao4 ying2 !\u201d\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b 2018 wo3 men2 yao4 ying2 !","title":"Statement"},{"location":"CCCC/L1-052-2018%E6%88%91%E4%BB%AC%E8%A6%81%E8%B5%A2/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { cout << \"2018 \\n \" ; cout << \"wo3 men2 yao4 ying2 ! \\n \" ; }","title":"Solution"},{"location":"CCCC/L1-053-%E7%94%B5%E5%AD%90%E6%B1%AA/","text":"L1-053 \u7535\u5b50\u6c6a Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u6c6a\u661f\u4eba\u7684\u667a\u5546\u80fd\u8fbe\u5230\u4eba\u7c7b 4 \u5c81\u513f\u7ae5\u7684\u6c34\u5e73\uff0c\u66f4\u6709\u4e9b\u806a\u660e\u6c6a\u4f1a\u505a\u52a0\u6cd5\u8ba1\u7b97\u3002\u6bd4\u5982\u4f60\u5728\u5730\u4e0a\u653e\u4e24\u5806\u5c0f\u7403\uff0c\u5206\u522b\u6709 1 \u53ea\u7403\u548c 2 \u53ea\u7403\uff0c\u806a\u660e\u6c6a\u5c31\u4f1a\u7528\u201c\u6c6a\uff01\u6c6a\uff01\u6c6a\uff01\u201d\u8868\u793a 1 \u52a0 2 \u7684\u7ed3\u679c\u662f 3\u3002 \u672c\u9898\u8981\u6c42\u4f60\u4e3a\u7535\u5b50\u5ba0\u7269\u6c6a\u505a\u4e00\u4e2a\u6a21\u62df\u7a0b\u5e8f\uff0c\u6839\u636e\u7535\u5b50\u773c\u8bc6\u522b\u51fa\u7684\u4e24\u5806\u5c0f\u7403\u7684\u4e2a\u6570\uff0c\u8ba1\u7b97\u51fa\u548c\uff0c\u5e76\u4e14\u7528\u6c6a\u661f\u4eba\u7684\u53eb\u58f0\u7ed9\u51fa\u7b54\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a [1, 9] \u533a\u95f4\u5185\u7684\u6b63\u6574\u6570 A \u548c B\uff0c\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa A + B \u4e2a Wang! \u3002 \u8f93\u5165\u6837\u4f8b 2 1 \u8f93\u51fa\u6837\u4f8b Wang!Wang!Wang! Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d%d\" , & a , & b ); int n = a + b ; while ( n -- ) printf ( \"Wang!\" ); cout << endl ; }","title":"L1-053-\u7535\u5b50\u6c6a"},{"location":"CCCC/L1-053-%E7%94%B5%E5%AD%90%E6%B1%AA/#l1-053-\u7535\u5b50\u6c6a","text":"","title":"L1-053 \u7535\u5b50\u6c6a"},{"location":"CCCC/L1-053-%E7%94%B5%E5%AD%90%E6%B1%AA/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u636e\u8bf4\u6c6a\u661f\u4eba\u7684\u667a\u5546\u80fd\u8fbe\u5230\u4eba\u7c7b 4 \u5c81\u513f\u7ae5\u7684\u6c34\u5e73\uff0c\u66f4\u6709\u4e9b\u806a\u660e\u6c6a\u4f1a\u505a\u52a0\u6cd5\u8ba1\u7b97\u3002\u6bd4\u5982\u4f60\u5728\u5730\u4e0a\u653e\u4e24\u5806\u5c0f\u7403\uff0c\u5206\u522b\u6709 1 \u53ea\u7403\u548c 2 \u53ea\u7403\uff0c\u806a\u660e\u6c6a\u5c31\u4f1a\u7528\u201c\u6c6a\uff01\u6c6a\uff01\u6c6a\uff01\u201d\u8868\u793a 1 \u52a0 2 \u7684\u7ed3\u679c\u662f 3\u3002 \u672c\u9898\u8981\u6c42\u4f60\u4e3a\u7535\u5b50\u5ba0\u7269\u6c6a\u505a\u4e00\u4e2a\u6a21\u62df\u7a0b\u5e8f\uff0c\u6839\u636e\u7535\u5b50\u773c\u8bc6\u522b\u51fa\u7684\u4e24\u5806\u5c0f\u7403\u7684\u4e2a\u6570\uff0c\u8ba1\u7b97\u51fa\u548c\uff0c\u5e76\u4e14\u7528\u6c6a\u661f\u4eba\u7684\u53eb\u58f0\u7ed9\u51fa\u7b54\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a [1, 9] \u533a\u95f4\u5185\u7684\u6b63\u6574\u6570 A \u548c B\uff0c\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa A + B \u4e2a Wang! \u3002 \u8f93\u5165\u6837\u4f8b 2 1 \u8f93\u51fa\u6837\u4f8b Wang!Wang!Wang!","title":"Statement"},{"location":"CCCC/L1-053-%E7%94%B5%E5%AD%90%E6%B1%AA/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int a , b ; scanf ( \"%d%d\" , & a , & b ); int n = a + b ; while ( n -- ) printf ( \"Wang!\" ); cout << endl ; }","title":"Solution"},{"location":"CCCC/L1-054-%E7%A6%8F%E5%88%B0%E4%BA%86/","text":"L1-054 \u798f\u5230\u4e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u798f\u201d\u5b57\u5012\u7740\u8d34\uff0c\u5bd3\u610f\u201c\u798f\u5230\u201d\u3002\u4e0d\u8bba\u5230\u5e95\u7b97\u4e0d\u7b97\u6c11\u4fd7\uff0c\u672c\u9898\u4e14\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u5404\u79cd\u6c49\u5b57\u5012\u8fc7\u6765\u8f93\u51fa\u3002\u8fd9\u91cc\u8981\u5904\u7406\u7684\u6bcf\u4e2a\u6c49\u5b57\u662f\u7531\u4e00\u4e2a N \\times \\times N \u7684\u7f51\u683c\u7ec4\u6210\u7684\uff0c\u7f51\u683c\u4e2d\u7684\u5143\u7d20\u6216\u8005\u4e3a\u5b57\u7b26 @ \u6216\u8005\u4e3a\u7a7a\u683c\u3002\u800c\u5012\u8fc7\u6765\u7684\u6c49\u5b57\u6240\u7528\u7684\u5b57\u7b26\u7531\u88c1\u5224\u6307\u5b9a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u5012\u8fc7\u6765\u7684\u6c49\u5b57\u6240\u7528\u7684\u5b57\u7b26\u3001\u4ee5\u53ca\u7f51\u683c\u7684\u89c4\u6a21 N \uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N \u4e2a\u5b57\u7b26\uff0c\u6216\u8005\u4e3a @ \u6216\u8005\u4e3a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u5012\u7f6e\u7684\u7f51\u683c\uff0c\u5982\u6837\u4f8b\u6240\u793a\u3002\u4f46\u662f\uff0c\u5982\u679c\u8fd9\u4e2a\u5b57\u6b63\u8fc7\u6765\u5012\u8fc7\u53bb\u662f\u4e00\u6837\u7684\uff0c\u5c31\u5148\u8f93\u51fa bu yong dao le \uff0c\u7136\u540e\u518d\u7528\u8f93\u5165\u6307\u5b9a\u7684\u5b57\u7b26\u5c06\u5176\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 $ 9 @ @@@@@ @@@ @@@ @ @ @ @@@ @@@ @@@ @@@@@ @@@ @ @ @ @@@ @@@@@ @ @ @ @ @ @@@@@ \u8f93\u51fa\u6837\u4f8b 1 $$$ $ $ $ $ $ $$$ $$ $ $ $ $$ $$$ $$ $$ $$ $ $ $ $$ $$ $$$ $ \u8f93\u5165\u6837\u4f8b 2 & 3 @@@ @ @@@ \u8f93\u51fa\u6837\u4f8b 2 bu yong dao le &&& & &&& Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; string in [ maxn ], tran [ maxn ]; string Reverse ( string s ) { string ans = \"\" ; int len = s . size (); for ( int i = len - 1 ; i >= 0 ; i -- ) ans += s [ i ]; return ans ; } int main () { char c ; int n ; scanf ( \" %c%d\" , & c , & n ); getchar (); for ( int i = 0 ; i < n ; i ++ ) { getline ( cin , in [ i ]); tran [ n - 1 - i ] = Reverse ( in [ i ]); } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( in [ i ] != tran [ i ]) { flag = 0 ; break ; } } if ( flag ) printf ( \"bu yong dao le \\n \" ); for ( int i = 0 ; i < n ; i ++ ) { int len = tran [ i ]. size (); for ( int j = 0 ; j < len ; j ++ ) { if ( tran [ i ][ j ] != ' ' ) printf ( \"%c\" , c ); else printf ( \" \" ); } printf ( \" \\n \" ); } }","title":"L1-054-\u798f\u5230\u4e86"},{"location":"CCCC/L1-054-%E7%A6%8F%E5%88%B0%E4%BA%86/#l1-054-\u798f\u5230\u4e86","text":"","title":"L1-054 \u798f\u5230\u4e86"},{"location":"CCCC/L1-054-%E7%A6%8F%E5%88%B0%E4%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u798f\u201d\u5b57\u5012\u7740\u8d34\uff0c\u5bd3\u610f\u201c\u798f\u5230\u201d\u3002\u4e0d\u8bba\u5230\u5e95\u7b97\u4e0d\u7b97\u6c11\u4fd7\uff0c\u672c\u9898\u4e14\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u5404\u79cd\u6c49\u5b57\u5012\u8fc7\u6765\u8f93\u51fa\u3002\u8fd9\u91cc\u8981\u5904\u7406\u7684\u6bcf\u4e2a\u6c49\u5b57\u662f\u7531\u4e00\u4e2a N \\times \\times N \u7684\u7f51\u683c\u7ec4\u6210\u7684\uff0c\u7f51\u683c\u4e2d\u7684\u5143\u7d20\u6216\u8005\u4e3a\u5b57\u7b26 @ \u6216\u8005\u4e3a\u7a7a\u683c\u3002\u800c\u5012\u8fc7\u6765\u7684\u6c49\u5b57\u6240\u7528\u7684\u5b57\u7b26\u7531\u88c1\u5224\u6307\u5b9a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u5012\u8fc7\u6765\u7684\u6c49\u5b57\u6240\u7528\u7684\u5b57\u7b26\u3001\u4ee5\u53ca\u7f51\u683c\u7684\u89c4\u6a21 N \uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N \u4e2a\u5b57\u7b26\uff0c\u6216\u8005\u4e3a @ \u6216\u8005\u4e3a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u5012\u7f6e\u7684\u7f51\u683c\uff0c\u5982\u6837\u4f8b\u6240\u793a\u3002\u4f46\u662f\uff0c\u5982\u679c\u8fd9\u4e2a\u5b57\u6b63\u8fc7\u6765\u5012\u8fc7\u53bb\u662f\u4e00\u6837\u7684\uff0c\u5c31\u5148\u8f93\u51fa bu yong dao le \uff0c\u7136\u540e\u518d\u7528\u8f93\u5165\u6307\u5b9a\u7684\u5b57\u7b26\u5c06\u5176\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 $ 9 @ @@@@@ @@@ @@@ @ @ @ @@@ @@@ @@@ @@@@@ @@@ @ @ @ @@@ @@@@@ @ @ @ @ @ @@@@@ \u8f93\u51fa\u6837\u4f8b 1 $$$ $ $ $ $ $ $$$ $$ $ $ $ $$ $$$ $$ $$ $$ $ $ $ $$ $$ $$$ $ \u8f93\u5165\u6837\u4f8b 2 & 3 @@@ @ @@@ \u8f93\u51fa\u6837\u4f8b 2 bu yong dao le &&& & &&&","title":"Statement"},{"location":"CCCC/L1-054-%E7%A6%8F%E5%88%B0%E4%BA%86/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; string in [ maxn ], tran [ maxn ]; string Reverse ( string s ) { string ans = \"\" ; int len = s . size (); for ( int i = len - 1 ; i >= 0 ; i -- ) ans += s [ i ]; return ans ; } int main () { char c ; int n ; scanf ( \" %c%d\" , & c , & n ); getchar (); for ( int i = 0 ; i < n ; i ++ ) { getline ( cin , in [ i ]); tran [ n - 1 - i ] = Reverse ( in [ i ]); } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( in [ i ] != tran [ i ]) { flag = 0 ; break ; } } if ( flag ) printf ( \"bu yong dao le \\n \" ); for ( int i = 0 ; i < n ; i ++ ) { int len = tran [ i ]. size (); for ( int j = 0 ; j < len ; j ++ ) { if ( tran [ i ][ j ] != ' ' ) printf ( \"%c\" , c ); else printf ( \" \" ); } printf ( \" \\n \" ); } }","title":"Solution"},{"location":"CCCC/L1-055-%E8%B0%81%E6%98%AF%E8%B5%A2%E5%AE%B6/","text":"L1-055 \u8c01\u662f\u8d62\u5bb6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u7535\u89c6\u53f0\u7684\u5a31\u4e50\u8282\u76ee\u6709\u4e2a\u8868\u6f14\u8bc4\u5ba1\u73af\u8282\uff0c\u6bcf\u6b21\u5b89\u6392\u4e24\u4f4d\u827a\u4eba\u8868\u6f14\uff0c\u4ed6\u4eec\u7684\u80dc\u8d1f\u7531\u89c2\u4f17\u6295\u7968\u548c 3 \u540d\u8bc4\u59d4\u6295\u7968\u4e24\u90e8\u5206\u5171\u540c\u51b3\u5b9a\u3002\u89c4\u5219\u4e3a\uff1a\u5982\u679c\u4e00\u4f4d\u827a\u4eba\u7684\u89c2\u4f17\u7968\u6570\u9ad8\uff0c\u4e14\u5f97\u5230\u81f3\u5c11 1 \u540d\u8bc4\u59d4\u7684\u8ba4\u53ef\uff0c\u8be5\u827a\u4eba\u5c31\u80dc\u51fa\uff1b\u6216\u827a\u4eba\u7684\u89c2\u4f17\u7968\u6570\u4f4e\uff0c\u4f46\u5f97\u5230\u5168\u90e8\u8bc4\u59d4\u7684\u8ba4\u53ef\uff0c\u4e5f\u53ef\u4ee5\u80dc\u51fa\u3002\u8282\u76ee\u4fdd\u8bc1\u6295\u7968\u7684\u89c2\u4f17\u4eba\u6570\u4e3a\u5947\u6570\uff0c\u6240\u4ee5\u4e0d\u5b58\u5728\u5e73\u7968\u7684\u60c5\u51b5\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u7a0b\u5e8f\u5224\u65ad\u8c01\u662f\u8d62\u5bb6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 Pa \u548c Pb\uff0c\u5206\u522b\u662f\u827a\u4eba a \u548c\u827a\u4eba b \u5f97\u5230\u7684\u89c2\u4f17\u7968\u6570\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e24\u4e2a\u6570\u5b57\u4e0d\u76f8\u7b49\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u7ed9\u51fa 3 \u540d\u8bc4\u59d4\u7684\u6295\u7968\u7ed3\u679c\u3002\u6570\u5b57 0 \u4ee3\u8868\u6295\u7968\u7ed9 a\uff0c\u6570\u5b57 1 \u4ee3\u8868\u6295\u7968\u7ed9 b\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u4ee5\u4e0b\u683c\u5f0f\u8f93\u51fa\u8d62\u5bb6\uff1a The winner is x: P1 + P2 \u5176\u4e2d x \u662f\u4ee3\u8868\u8d62\u5bb6\u7684\u5b57\u6bcd\uff0c P1 \u662f\u8d62\u5bb6\u5f97\u5230\u7684\u89c2\u4f17\u7968\u6570\uff0c P2 \u662f\u8d62\u5bb6\u5f97\u5230\u7684\u8bc4\u59d4\u7968\u6570\u3002 \u8f93\u5165\u6837\u4f8b 327 129 1 0 1 \u8f93\u51fa\u6837\u4f8b The winner is a: 327 + 1 \u9e23\u8c22\u5b89\u9633\u5e08\u8303\u5b66\u9662\u8f6f\u4ef6\u5b66\u9662\u674e\u680b\u540c\u5b66\u5b8c\u5584\u6d4b\u8bd5\u6570\u636e\u3002 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int p1 , p2 ; scanf ( \"%d%d\" , & p1 , & p2 ); int k [ 2 ] = { 0 , 0 }, num ; for ( int i = 0 ; i < 3 ; i ++ ) { scanf ( \"%d\" , & num ); k [ num ] ++ ; } if ( p1 > p2 ) { if ( k [ 0 ]) printf ( \"The winner is a: %d + %d \\n \" , p1 , k [ 0 ]); else printf ( \"The winner is b: %d + %d \\n \" , p2 , k [ 1 ]); } else { if ( k [ 1 ]) printf ( \"The winner is b: %d + %d \\n \" , p2 , k [ 1 ]); else printf ( \"The winner is a: %d + %d \\n \" , p1 , k [ 0 ]); } }","title":"L1-055-\u8c01\u662f\u8d62\u5bb6"},{"location":"CCCC/L1-055-%E8%B0%81%E6%98%AF%E8%B5%A2%E5%AE%B6/#l1-055-\u8c01\u662f\u8d62\u5bb6","text":"","title":"L1-055 \u8c01\u662f\u8d62\u5bb6"},{"location":"CCCC/L1-055-%E8%B0%81%E6%98%AF%E8%B5%A2%E5%AE%B6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u7535\u89c6\u53f0\u7684\u5a31\u4e50\u8282\u76ee\u6709\u4e2a\u8868\u6f14\u8bc4\u5ba1\u73af\u8282\uff0c\u6bcf\u6b21\u5b89\u6392\u4e24\u4f4d\u827a\u4eba\u8868\u6f14\uff0c\u4ed6\u4eec\u7684\u80dc\u8d1f\u7531\u89c2\u4f17\u6295\u7968\u548c 3 \u540d\u8bc4\u59d4\u6295\u7968\u4e24\u90e8\u5206\u5171\u540c\u51b3\u5b9a\u3002\u89c4\u5219\u4e3a\uff1a\u5982\u679c\u4e00\u4f4d\u827a\u4eba\u7684\u89c2\u4f17\u7968\u6570\u9ad8\uff0c\u4e14\u5f97\u5230\u81f3\u5c11 1 \u540d\u8bc4\u59d4\u7684\u8ba4\u53ef\uff0c\u8be5\u827a\u4eba\u5c31\u80dc\u51fa\uff1b\u6216\u827a\u4eba\u7684\u89c2\u4f17\u7968\u6570\u4f4e\uff0c\u4f46\u5f97\u5230\u5168\u90e8\u8bc4\u59d4\u7684\u8ba4\u53ef\uff0c\u4e5f\u53ef\u4ee5\u80dc\u51fa\u3002\u8282\u76ee\u4fdd\u8bc1\u6295\u7968\u7684\u89c2\u4f17\u4eba\u6570\u4e3a\u5947\u6570\uff0c\u6240\u4ee5\u4e0d\u5b58\u5728\u5e73\u7968\u7684\u60c5\u51b5\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u7a0b\u5e8f\u5224\u65ad\u8c01\u662f\u8d62\u5bb6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 Pa \u548c Pb\uff0c\u5206\u522b\u662f\u827a\u4eba a \u548c\u827a\u4eba b \u5f97\u5230\u7684\u89c2\u4f17\u7968\u6570\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e24\u4e2a\u6570\u5b57\u4e0d\u76f8\u7b49\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u7ed9\u51fa 3 \u540d\u8bc4\u59d4\u7684\u6295\u7968\u7ed3\u679c\u3002\u6570\u5b57 0 \u4ee3\u8868\u6295\u7968\u7ed9 a\uff0c\u6570\u5b57 1 \u4ee3\u8868\u6295\u7968\u7ed9 b\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u4ee5\u4e0b\u683c\u5f0f\u8f93\u51fa\u8d62\u5bb6\uff1a The winner is x: P1 + P2 \u5176\u4e2d x \u662f\u4ee3\u8868\u8d62\u5bb6\u7684\u5b57\u6bcd\uff0c P1 \u662f\u8d62\u5bb6\u5f97\u5230\u7684\u89c2\u4f17\u7968\u6570\uff0c P2 \u662f\u8d62\u5bb6\u5f97\u5230\u7684\u8bc4\u59d4\u7968\u6570\u3002 \u8f93\u5165\u6837\u4f8b 327 129 1 0 1 \u8f93\u51fa\u6837\u4f8b The winner is a: 327 + 1 \u9e23\u8c22\u5b89\u9633\u5e08\u8303\u5b66\u9662\u8f6f\u4ef6\u5b66\u9662\u674e\u680b\u540c\u5b66\u5b8c\u5584\u6d4b\u8bd5\u6570\u636e\u3002","title":"Statement"},{"location":"CCCC/L1-055-%E8%B0%81%E6%98%AF%E8%B5%A2%E5%AE%B6/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int p1 , p2 ; scanf ( \"%d%d\" , & p1 , & p2 ); int k [ 2 ] = { 0 , 0 }, num ; for ( int i = 0 ; i < 3 ; i ++ ) { scanf ( \"%d\" , & num ); k [ num ] ++ ; } if ( p1 > p2 ) { if ( k [ 0 ]) printf ( \"The winner is a: %d + %d \\n \" , p1 , k [ 0 ]); else printf ( \"The winner is b: %d + %d \\n \" , p2 , k [ 1 ]); } else { if ( k [ 1 ]) printf ( \"The winner is b: %d + %d \\n \" , p2 , k [ 1 ]); else printf ( \"The winner is a: %d + %d \\n \" , p1 , k [ 0 ]); } }","title":"Solution"},{"location":"CCCC/L1-056-%E7%8C%9C%E6%95%B0%E5%AD%97/","text":"L1-056 \u731c\u6570\u5b57 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u7fa4\u4eba\u5750\u5728\u4e00\u8d77\uff0c\u6bcf\u4eba\u731c\u4e00\u4e2a 100 \u4ee5\u5185\u7684\u6570\uff0c\u8c01\u7684\u6570\u5b57\u6700\u63a5\u8fd1\u5927\u5bb6\u5e73\u5747\u6570\u7684\u4e00\u534a\u5c31\u8d62\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u627e\u51fa\u5176\u4e2d\u7684\u8d62\u5bb6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\uff08 \\le 10^4 \\le 10^4 \uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u73a9\u5bb6\u7684\u540d\u5b57\uff08\u7531\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u548c\u5176\u731c\u7684\u6b63\u6574\u6570\uff08 \\le \\le 100\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\uff1a\u5927\u5bb6\u5e73\u5747\u6570\u7684\u4e00\u534a\uff08\u53ea\u8f93\u51fa\u6574\u6570\u90e8\u5206\uff09\u3001\u8d62\u5bb6\u7684\u540d\u5b57\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8d62\u5bb6\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 7 Bob 35 Amy 28 James 98 Alice 11 Jack 45 Smith 33 Chris 62 \u8f93\u51fa\u6837\u4f8b 22 Amy Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int n ; char name [ 10 ]; } q [ maxn ]; int main () { int n ; scanf ( \"%d\" , & n ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \" %s%d\" , & q [ i ]. name , & q [ i ]. n ); sum += q [ i ]. n ; } sum /= ( 2 * n ); int lim = INF ; int ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( q [ i ]. n - sum ) < lim ) { lim = abs ( q [ i ]. n - sum ); ans = i ; } } printf ( \"%d %s \\n \" , sum , q [ ans ]. name ); }","title":"L1-056-\u731c\u6570\u5b57"},{"location":"CCCC/L1-056-%E7%8C%9C%E6%95%B0%E5%AD%97/#l1-056-\u731c\u6570\u5b57","text":"","title":"L1-056 \u731c\u6570\u5b57"},{"location":"CCCC/L1-056-%E7%8C%9C%E6%95%B0%E5%AD%97/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u7fa4\u4eba\u5750\u5728\u4e00\u8d77\uff0c\u6bcf\u4eba\u731c\u4e00\u4e2a 100 \u4ee5\u5185\u7684\u6570\uff0c\u8c01\u7684\u6570\u5b57\u6700\u63a5\u8fd1\u5927\u5bb6\u5e73\u5747\u6570\u7684\u4e00\u534a\u5c31\u8d62\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u627e\u51fa\u5176\u4e2d\u7684\u8d62\u5bb6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570N\uff08 \\le 10^4 \\le 10^4 \uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u73a9\u5bb6\u7684\u540d\u5b57\uff08\u7531\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u548c\u5176\u731c\u7684\u6b63\u6574\u6570\uff08 \\le \\le 100\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\uff1a\u5927\u5bb6\u5e73\u5747\u6570\u7684\u4e00\u534a\uff08\u53ea\u8f93\u51fa\u6574\u6570\u90e8\u5206\uff09\u3001\u8d62\u5bb6\u7684\u540d\u5b57\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8d62\u5bb6\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 7 Bob 35 Amy 28 James 98 Alice 11 Jack 45 Smith 33 Chris 62 \u8f93\u51fa\u6837\u4f8b 22 Amy","title":"Statement"},{"location":"CCCC/L1-056-%E7%8C%9C%E6%95%B0%E5%AD%97/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int n ; char name [ 10 ]; } q [ maxn ]; int main () { int n ; scanf ( \"%d\" , & n ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \" %s%d\" , & q [ i ]. name , & q [ i ]. n ); sum += q [ i ]. n ; } sum /= ( 2 * n ); int lim = INF ; int ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( q [ i ]. n - sum ) < lim ) { lim = abs ( q [ i ]. n - sum ); ans = i ; } } printf ( \"%d %s \\n \" , sum , q [ ans ]. name ); }","title":"Solution"},{"location":"CCCC/L1-057-PTA%E4%BD%BF%E6%88%91%E7%B2%BE%E7%A5%9E%E7%84%95%E5%8F%91/","text":"L1-057 PTA\u4f7f\u6211\u7cbe\u795e\u7115\u53d1 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u6e56\u5317\u7ecf\u6d4e\u5b66\u9662\u540c\u5b66\u7684\u5927\u4f5c\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u6c49\u8bed\u62fc\u97f3\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u6837\u4f8b\u8f93\u51fa\uff0c\u4ee5\u60ca\u53f9\u53f7\u7ed3\u5c3e\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b PTA shi3 wo3 jing1 shen2 huan4 fa1 ! Solution Python 3 print ( \"PTA shi3 wo3 jing1 shen2 huan4 fa1 !\" )","title":"L1-057-PTA\u4f7f\u6211\u7cbe\u795e\u7115\u53d1"},{"location":"CCCC/L1-057-PTA%E4%BD%BF%E6%88%91%E7%B2%BE%E7%A5%9E%E7%84%95%E5%8F%91/#l1-057-pta\u4f7f\u6211\u7cbe\u795e\u7115\u53d1","text":"","title":"L1-057 PTA\u4f7f\u6211\u7cbe\u795e\u7115\u53d1"},{"location":"CCCC/L1-057-PTA%E4%BD%BF%E6%88%91%E7%B2%BE%E7%A5%9E%E7%84%95%E5%8F%91/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u662f\u6e56\u5317\u7ecf\u6d4e\u5b66\u9662\u540c\u5b66\u7684\u5927\u4f5c\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7528\u6c49\u8bed\u62fc\u97f3\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167\u6837\u4f8b\u8f93\u51fa\uff0c\u4ee5\u60ca\u53f9\u53f7\u7ed3\u5c3e\u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b PTA shi3 wo3 jing1 shen2 huan4 fa1 !","title":"Statement"},{"location":"CCCC/L1-057-PTA%E4%BD%BF%E6%88%91%E7%B2%BE%E7%A5%9E%E7%84%95%E5%8F%91/#solution","text":"Python 3 print ( \"PTA shi3 wo3 jing1 shen2 huan4 fa1 !\" )","title":"Solution"},{"location":"CCCC/L1-058-6%E7%BF%BB%E4%BA%86/","text":"L1-058 6\u7ffb\u4e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c666\u201d\u662f\u4e00\u79cd\u7f51\u7edc\u7528\u8bed\uff0c\u5927\u6982\u662f\u8868\u793a\u67d0\u4eba\u5f88\u5389\u5bb3\u3001\u6211\u4eec\u5f88\u4f69\u670d\u7684\u610f\u601d\u3002\u6700\u8fd1\u53c8\u884d\u751f\u51fa\u53e6\u4e00\u4e2a\u6570\u5b57\u201c9\u201d\uff0c\u610f\u601d\u662f\u201c6\u7ffb\u4e86\u201d\uff0c\u5b9e\u5728\u592a\u5389\u5bb3\u7684\u610f\u601d\u3002\u5982\u679c\u4f60\u4ee5\u4e3a\u8fd9\u5c31\u662f\u5389\u5bb3\u7684\u6700\u9ad8\u5883\u754c\uff0c\u90a3\u5c31\u9519\u5566 \u2014\u2014 \u76ee\u524d\u7684\u6700\u9ad8\u5883\u754c\u662f\u6570\u5b57\u201c27\u201d\uff0c\u56e0\u4e3a\u8fd9\u662f 3 \u4e2a \u201c9\u201d\uff01 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5c06\u90a3\u4e9b\u8fc7\u65f6\u7684\u3001\u53ea\u4f1a\u7528\u4e00\u8fde\u4e32\u201c6666\u2026\u20266\u201d\u8868\u8fbe\u4ef0\u6155\u7684\u53e5\u5b50\uff0c\u7ffb\u8bd1\u6210\u6700\u65b0\u7684\u9ad8\u7ea7\u8868\u8fbe\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u53e5\u8bdd\uff0c\u5373\u4e00\u4e2a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u7531\u4e0d\u8d85\u8fc7 1000 \u4e2a\u82f1\u6587\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u7a7a\u683c\u7ec4\u6210\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u4ece\u5de6\u5230\u53f3\u626b\u63cf\u8f93\u5165\u7684\u53e5\u5b50\uff1a\u5982\u679c\u53e5\u5b50\u4e2d\u6709\u8d85\u8fc7 3 \u4e2a\u8fde\u7eed\u7684 6\uff0c\u5219\u5c06\u8fd9\u4e32\u8fde\u7eed\u7684 6 \u66ff\u6362\u6210 9\uff1b\u4f46\u5982\u679c\u6709\u8d85\u8fc7 9 \u4e2a\u8fde\u7eed\u7684 6\uff0c\u5219\u5c06\u8fd9\u4e32\u8fde\u7eed\u7684 6 \u66ff\u6362\u6210 27\u3002\u5176\u4ed6\u5185\u5bb9\u4e0d\u53d7\u5f71\u54cd\uff0c\u539f\u6837\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b it is so 666 really 6666 what else can I say 6666666666 \u8f93\u51fa\u6837\u4f8b it is so 666 really 9 what else can I say 27 Solution C++ #include <bits/stdc++.h> using namespace std ; string get ( int num ) { string t = \"\" ; if ( num <= 3 ) t += string ( num , '6' ); else if ( num <= 9 ) t += '9' ; else t += \"27\" ; return t ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); string s ; getline ( cin , s ); string t = \"\" ; int num = 0 ; for ( auto & ch : s ) { if ( ch == '6' ) { ++ num ; } else { t += get ( num ); t += ch ; num = 0 ; } } t += get ( num ); cout << t << endl ; return 0 ; }","title":"L1-058-6\u7ffb\u4e86"},{"location":"CCCC/L1-058-6%E7%BF%BB%E4%BA%86/#l1-058-6\u7ffb\u4e86","text":"","title":"L1-058 6\u7ffb\u4e86"},{"location":"CCCC/L1-058-6%E7%BF%BB%E4%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c666\u201d\u662f\u4e00\u79cd\u7f51\u7edc\u7528\u8bed\uff0c\u5927\u6982\u662f\u8868\u793a\u67d0\u4eba\u5f88\u5389\u5bb3\u3001\u6211\u4eec\u5f88\u4f69\u670d\u7684\u610f\u601d\u3002\u6700\u8fd1\u53c8\u884d\u751f\u51fa\u53e6\u4e00\u4e2a\u6570\u5b57\u201c9\u201d\uff0c\u610f\u601d\u662f\u201c6\u7ffb\u4e86\u201d\uff0c\u5b9e\u5728\u592a\u5389\u5bb3\u7684\u610f\u601d\u3002\u5982\u679c\u4f60\u4ee5\u4e3a\u8fd9\u5c31\u662f\u5389\u5bb3\u7684\u6700\u9ad8\u5883\u754c\uff0c\u90a3\u5c31\u9519\u5566 \u2014\u2014 \u76ee\u524d\u7684\u6700\u9ad8\u5883\u754c\u662f\u6570\u5b57\u201c27\u201d\uff0c\u56e0\u4e3a\u8fd9\u662f 3 \u4e2a \u201c9\u201d\uff01 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5c06\u90a3\u4e9b\u8fc7\u65f6\u7684\u3001\u53ea\u4f1a\u7528\u4e00\u8fde\u4e32\u201c6666\u2026\u20266\u201d\u8868\u8fbe\u4ef0\u6155\u7684\u53e5\u5b50\uff0c\u7ffb\u8bd1\u6210\u6700\u65b0\u7684\u9ad8\u7ea7\u8868\u8fbe\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u53e5\u8bdd\uff0c\u5373\u4e00\u4e2a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u7531\u4e0d\u8d85\u8fc7 1000 \u4e2a\u82f1\u6587\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u7a7a\u683c\u7ec4\u6210\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u8f93\u51fa\u683c\u5f0f \u4ece\u5de6\u5230\u53f3\u626b\u63cf\u8f93\u5165\u7684\u53e5\u5b50\uff1a\u5982\u679c\u53e5\u5b50\u4e2d\u6709\u8d85\u8fc7 3 \u4e2a\u8fde\u7eed\u7684 6\uff0c\u5219\u5c06\u8fd9\u4e32\u8fde\u7eed\u7684 6 \u66ff\u6362\u6210 9\uff1b\u4f46\u5982\u679c\u6709\u8d85\u8fc7 9 \u4e2a\u8fde\u7eed\u7684 6\uff0c\u5219\u5c06\u8fd9\u4e32\u8fde\u7eed\u7684 6 \u66ff\u6362\u6210 27\u3002\u5176\u4ed6\u5185\u5bb9\u4e0d\u53d7\u5f71\u54cd\uff0c\u539f\u6837\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b it is so 666 really 6666 what else can I say 6666666666 \u8f93\u51fa\u6837\u4f8b it is so 666 really 9 what else can I say 27","title":"Statement"},{"location":"CCCC/L1-058-6%E7%BF%BB%E4%BA%86/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; string get ( int num ) { string t = \"\" ; if ( num <= 3 ) t += string ( num , '6' ); else if ( num <= 9 ) t += '9' ; else t += \"27\" ; return t ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); string s ; getline ( cin , s ); string t = \"\" ; int num = 0 ; for ( auto & ch : s ) { if ( ch == '6' ) { ++ num ; } else { t += get ( num ); t += ch ; num = 0 ; } } t += get ( num ); cout << t << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L1-059-%E6%95%B2%E7%AC%A8%E9%92%9F/","text":"L1-059 \u6572\u7b28\u949f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u81ea\u79f0\u201c\u5927\u7b28\u949fV\u201d\u7684\u5bb6\u4f19\uff0c\u6bcf\u5929\u6572\u949f\u50ac\u4fc3\u7801\u519c\u4eec\u7231\u60dc\u8eab\u4f53\u65e9\u70b9\u7761\u89c9\u3002\u4e3a\u4e86\u589e\u52a0\u6572\u949f\u7684\u8da3\u5473\u6027\uff0c\u8fd8\u4f1a\u7cdf\u6539\u51e0\u53e5\u53e4\u8bd7\u8bcd\u3002\u5176\u7cdf\u6539\u7684\u65b9\u6cd5\u4e3a\uff1a\u53bb\u7f51\u4e0a\u641c\u5bfb\u538b\u201cong\u201d\u97f5\u7684\u53e4\u8bd7\u8bcd\uff0c\u628a\u53e5\u5c3e\u7684\u4e09\u4e2a\u5b57\u6362\u6210\u201c\u6572\u7b28\u949f\u201d\u3002\u4f8b\u5982\u5510\u4ee3\u8bd7\u4eba\u674e\u8d3a\u6709\u540d\u53e5\u66f0\uff1a\u201c\u5bfb\u7ae0\u6458\u53e5\u8001\u96d5\u866b\uff0c\u6653\u6708\u5f53\u5e18\u6302\u7389\u5f13\u201d\uff0c\u5176\u4e2d\u201c\u866b\u201d\uff08chong\uff09\u548c\u201c\u5f13\u201d\uff08gong\uff09\u90fd\u538b\u4e86\u201cong\u201d\u97f5\u3002\u4e8e\u662f\u8fd9\u53e5\u8bd7\u5c31\u88ab\u7cdf\u6539\u4e3a\u201c\u5bfb\u7ae0\u6458\u53e5\u8001\u96d5\u866b\uff0c\u6653\u6708\u5f53\u5e18\u6572\u7b28\u949f\u201d\u3002 \u73b0\u5728\u7ed9\u4f60\u4e00\u5927\u5806\u53e4\u8bd7\u8bcd\u53e5\uff0c\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u81ea\u52a8\u5c06\u538b\u201cong\u201d\u97f5\u7684\u53e5\u5b50\u7cdf\u6539\u6210\u201c\u6572\u7b28\u949f\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 20 \u7684\u6b63\u6574\u6570 N\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7528\u6c49\u8bed\u62fc\u97f3\u7ed9\u51fa\u4e00\u53e5\u53e4\u8bd7\u8bcd\uff0c\u5206\u4e0a\u4e0b\u4e24\u534a\u53e5\uff0c\u7528\u9017\u53f7 , \u5206\u9694\uff0c\u53e5\u53f7 . \u7ed3\u5c3e\u3002\u76f8\u90bb\u4e24\u5b57\u7684\u62fc\u97f3\u4e4b\u95f4\u7528\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u5b57\u7684\u62fc\u97f3\u4e0d\u8d85\u8fc7 6 \u4e2a\u5b57\u7b26\uff0c\u6bcf\u884c\u5b57\u7b26\u7684\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7 100\uff0c\u5e76\u4e14\u4e0b\u534a\u53e5\u8bd7\u81f3\u5c11\u6709 3 \u4e2a\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u884c\u8bd7\u53e5\uff0c\u5224\u65ad\u5176\u662f\u5426\u538b\u201cong\u201d\u97f5\u3002\u5373\u4e0a\u4e0b\u4e24\u53e5\u672b\u5c3e\u7684\u5b57\u90fd\u662f\u201cong\u201d\u7ed3\u5c3e\u3002\u5982\u679c\u662f\u538b\u6b64\u97f5\u7684\uff0c\u5c31\u6309\u9898\u9762\u65b9\u6cd5\u7cdf\u6539\u4e4b\u540e\u8f93\u51fa\uff0c\u8f93\u51fa\u683c\u5f0f\u540c\u8f93\u5165\uff1b\u5426\u5219\u8f93\u51fa Skipped \uff0c\u5373\u8df3\u8fc7\u6b64\u53e5\u3002 \u8f93\u5165\u6837\u4f8b 5 xun zhang zhai ju lao diao chong, xiao yue dang lian gua yu gong. tian sheng wo cai bi you yong, qian jin san jin huan fu lai. xue zhui rou zhi leng wei rong, an xiao chen jing shu wei long. zuo ye xing chen zuo ye feng, hua lou xi pan gui tang dong. ren xian gui hua luo, ye jing chun shan kong. \u8f93\u51fa\u6837\u4f8b xun zhang zhai ju lao diao chong, xiao yue dang lian qiao ben zhong. Skipped xue zhui rou zhi leng wei rong, an xiao chen jing qiao ben zhong. Skipped Skipped Solution C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; bool equ ( string s , string t ) { if ( SZ ( s ) < SZ ( t )) return false ; for ( int i = 0 ; i < SZ ( t ); ++ i ) { if ( s . back () != t [ i ]) return false ; s . pop_back (); } return true ; } bool ok ( string s ) { if ( SZ ( s ) < 6 ) return false ; s . pop_back (); if ( ! equ ( s , \"gno\" )) return false ; while ( 1 ) { char ch = s . back (); s . pop_back (); if ( ch == ',' ) break ; } if ( ! equ ( s , \"gno\" )) return false ; return true ; } void run () { string s ; getline ( cin , s ); if ( ok ( s )) { int cnt = 0 ; while ( cnt < 3 ) { if ( s . back () == ' ' ) ++ cnt ; s . pop_back (); } s += \" qiao ben zhong.\" ; cout << s << endl ; } else { pt ( \"Skipped\" ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); string s ; getline ( cin , s ); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"L1-059-\u6572\u7b28\u949f"},{"location":"CCCC/L1-059-%E6%95%B2%E7%AC%A8%E9%92%9F/#l1-059-\u6572\u7b28\u949f","text":"","title":"L1-059 \u6572\u7b28\u949f"},{"location":"CCCC/L1-059-%E6%95%B2%E7%AC%A8%E9%92%9F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u81ea\u79f0\u201c\u5927\u7b28\u949fV\u201d\u7684\u5bb6\u4f19\uff0c\u6bcf\u5929\u6572\u949f\u50ac\u4fc3\u7801\u519c\u4eec\u7231\u60dc\u8eab\u4f53\u65e9\u70b9\u7761\u89c9\u3002\u4e3a\u4e86\u589e\u52a0\u6572\u949f\u7684\u8da3\u5473\u6027\uff0c\u8fd8\u4f1a\u7cdf\u6539\u51e0\u53e5\u53e4\u8bd7\u8bcd\u3002\u5176\u7cdf\u6539\u7684\u65b9\u6cd5\u4e3a\uff1a\u53bb\u7f51\u4e0a\u641c\u5bfb\u538b\u201cong\u201d\u97f5\u7684\u53e4\u8bd7\u8bcd\uff0c\u628a\u53e5\u5c3e\u7684\u4e09\u4e2a\u5b57\u6362\u6210\u201c\u6572\u7b28\u949f\u201d\u3002\u4f8b\u5982\u5510\u4ee3\u8bd7\u4eba\u674e\u8d3a\u6709\u540d\u53e5\u66f0\uff1a\u201c\u5bfb\u7ae0\u6458\u53e5\u8001\u96d5\u866b\uff0c\u6653\u6708\u5f53\u5e18\u6302\u7389\u5f13\u201d\uff0c\u5176\u4e2d\u201c\u866b\u201d\uff08chong\uff09\u548c\u201c\u5f13\u201d\uff08gong\uff09\u90fd\u538b\u4e86\u201cong\u201d\u97f5\u3002\u4e8e\u662f\u8fd9\u53e5\u8bd7\u5c31\u88ab\u7cdf\u6539\u4e3a\u201c\u5bfb\u7ae0\u6458\u53e5\u8001\u96d5\u866b\uff0c\u6653\u6708\u5f53\u5e18\u6572\u7b28\u949f\u201d\u3002 \u73b0\u5728\u7ed9\u4f60\u4e00\u5927\u5806\u53e4\u8bd7\u8bcd\u53e5\uff0c\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u81ea\u52a8\u5c06\u538b\u201cong\u201d\u97f5\u7684\u53e5\u5b50\u7cdf\u6539\u6210\u201c\u6572\u7b28\u949f\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 20 \u7684\u6b63\u6574\u6570 N\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7528\u6c49\u8bed\u62fc\u97f3\u7ed9\u51fa\u4e00\u53e5\u53e4\u8bd7\u8bcd\uff0c\u5206\u4e0a\u4e0b\u4e24\u534a\u53e5\uff0c\u7528\u9017\u53f7 , \u5206\u9694\uff0c\u53e5\u53f7 . \u7ed3\u5c3e\u3002\u76f8\u90bb\u4e24\u5b57\u7684\u62fc\u97f3\u4e4b\u95f4\u7528\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u5b57\u7684\u62fc\u97f3\u4e0d\u8d85\u8fc7 6 \u4e2a\u5b57\u7b26\uff0c\u6bcf\u884c\u5b57\u7b26\u7684\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7 100\uff0c\u5e76\u4e14\u4e0b\u534a\u53e5\u8bd7\u81f3\u5c11\u6709 3 \u4e2a\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u884c\u8bd7\u53e5\uff0c\u5224\u65ad\u5176\u662f\u5426\u538b\u201cong\u201d\u97f5\u3002\u5373\u4e0a\u4e0b\u4e24\u53e5\u672b\u5c3e\u7684\u5b57\u90fd\u662f\u201cong\u201d\u7ed3\u5c3e\u3002\u5982\u679c\u662f\u538b\u6b64\u97f5\u7684\uff0c\u5c31\u6309\u9898\u9762\u65b9\u6cd5\u7cdf\u6539\u4e4b\u540e\u8f93\u51fa\uff0c\u8f93\u51fa\u683c\u5f0f\u540c\u8f93\u5165\uff1b\u5426\u5219\u8f93\u51fa Skipped \uff0c\u5373\u8df3\u8fc7\u6b64\u53e5\u3002 \u8f93\u5165\u6837\u4f8b 5 xun zhang zhai ju lao diao chong, xiao yue dang lian gua yu gong. tian sheng wo cai bi you yong, qian jin san jin huan fu lai. xue zhui rou zhi leng wei rong, an xiao chen jing shu wei long. zuo ye xing chen zuo ye feng, hua lou xi pan gui tang dong. ren xian gui hua luo, ye jing chun shan kong. \u8f93\u51fa\u6837\u4f8b xun zhang zhai ju lao diao chong, xiao yue dang lian qiao ben zhong. Skipped xue zhui rou zhi leng wei rong, an xiao chen jing qiao ben zhong. Skipped Skipped","title":"Statement"},{"location":"CCCC/L1-059-%E6%95%B2%E7%AC%A8%E9%92%9F/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; bool equ ( string s , string t ) { if ( SZ ( s ) < SZ ( t )) return false ; for ( int i = 0 ; i < SZ ( t ); ++ i ) { if ( s . back () != t [ i ]) return false ; s . pop_back (); } return true ; } bool ok ( string s ) { if ( SZ ( s ) < 6 ) return false ; s . pop_back (); if ( ! equ ( s , \"gno\" )) return false ; while ( 1 ) { char ch = s . back (); s . pop_back (); if ( ch == ',' ) break ; } if ( ! equ ( s , \"gno\" )) return false ; return true ; } void run () { string s ; getline ( cin , s ); if ( ok ( s )) { int cnt = 0 ; while ( cnt < 3 ) { if ( s . back () == ' ' ) ++ cnt ; s . pop_back (); } s += \" qiao ben zhong.\" ; cout << s << endl ; } else { pt ( \"Skipped\" ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); string s ; getline ( cin , s ); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-060-%E5%BF%83%E7%90%86%E9%98%B4%E5%BD%B1%E9%9D%A2%E7%A7%AF/","text":"L1-060 \u5fc3\u7406\u9634\u5f71\u9762\u79ef Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u662f\u4e00\u5e45\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u56fe\u3002\u6211\u4eec\u90fd\u4ee5\u4e3a\u81ea\u5df1\u53ef\u4ee5\u5300\u901f\u524d\u8fdb\uff08\u56fe\u4e2d\u84dd\u8272\u76f4\u7ebf\uff09\uff0c\u800c\u62d6\u5ef6\u75c7\u665a\u671f\u7684\u6211\u4eec\u5f80\u5f80\u6267\u884c\u7684\u662f\u6700\u540e\u65f6\u523b\u7684\u75af\u72c2\u8d76\u5de5\uff08\u56fe\u4e2d\u7684\u7ea2\u8272\u6298\u7ebf\uff09\u3002\u7531\u7ea2\u3001\u84dd\u7ebf\u56f4\u51fa\u7684\u9762\u79ef\uff0c\u5c31\u662f\u6211\u4eec\u5728\u505a\u4f5c\u4e1a\u65f6\u7684\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u73b0\u7ed9\u51fa\u7ea2\u8272\u62d0\u70b9\u7684\u5750\u6807 (x,y) (x,y) \uff0c\u8981\u6c42\u4f60\u7b97\u51fa\u8fd9\u4e2a\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 x x \u548c y y \uff0c\u5e76\u4e14\u4fdd\u8bc1\u6709 x>y x>y \u3002\u8fd9\u91cc\u5047\u8bbe\u6a2a\u3001\u7eb5\u5750\u6807\u7684\u6700\u5927\u503c\uff08\u5373\u622a\u6b62\u65e5\u548c\u6700\u7ec8\u5b8c\u6210\u5ea6\uff09\u90fd\u662f 100\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u53cb\u60c5\u63d0\u9192\uff1a\u4e09\u89d2\u5f62\u7684\u9762\u79ef = \u5e95\u8fb9\u957f x \u9ad8 / 2\uff1b\u77e9\u5f62\u9762\u79ef = \u5e95\u8fb9\u957f x \u9ad8\u3002\u5ad1\u60f3\u5f97\u592a\u590d\u6742\uff0c\u8fd9\u662f\u4e00\u9053 5 \u5206\u8003\u51cf\u6cd5\u7684\u9898\u2026\u2026 \u8f93\u5165\u6837\u4f8b 90 10 \u8f93\u51fa\u6837\u4f8b 4000 Solution Python 3 x , y = map ( int , input () . split ()) print (( 100 * ( x - y )) // 2 )","title":"L1-060-\u5fc3\u7406\u9634\u5f71\u9762\u79ef"},{"location":"CCCC/L1-060-%E5%BF%83%E7%90%86%E9%98%B4%E5%BD%B1%E9%9D%A2%E7%A7%AF/#l1-060-\u5fc3\u7406\u9634\u5f71\u9762\u79ef","text":"","title":"L1-060 \u5fc3\u7406\u9634\u5f71\u9762\u79ef"},{"location":"CCCC/L1-060-%E5%BF%83%E7%90%86%E9%98%B4%E5%BD%B1%E9%9D%A2%E7%A7%AF/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u662f\u4e00\u5e45\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u56fe\u3002\u6211\u4eec\u90fd\u4ee5\u4e3a\u81ea\u5df1\u53ef\u4ee5\u5300\u901f\u524d\u8fdb\uff08\u56fe\u4e2d\u84dd\u8272\u76f4\u7ebf\uff09\uff0c\u800c\u62d6\u5ef6\u75c7\u665a\u671f\u7684\u6211\u4eec\u5f80\u5f80\u6267\u884c\u7684\u662f\u6700\u540e\u65f6\u523b\u7684\u75af\u72c2\u8d76\u5de5\uff08\u56fe\u4e2d\u7684\u7ea2\u8272\u6298\u7ebf\uff09\u3002\u7531\u7ea2\u3001\u84dd\u7ebf\u56f4\u51fa\u7684\u9762\u79ef\uff0c\u5c31\u662f\u6211\u4eec\u5728\u505a\u4f5c\u4e1a\u65f6\u7684\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u73b0\u7ed9\u51fa\u7ea2\u8272\u62d0\u70b9\u7684\u5750\u6807 (x,y) (x,y) \uff0c\u8981\u6c42\u4f60\u7b97\u51fa\u8fd9\u4e2a\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 x x \u548c y y \uff0c\u5e76\u4e14\u4fdd\u8bc1\u6709 x>y x>y \u3002\u8fd9\u91cc\u5047\u8bbe\u6a2a\u3001\u7eb5\u5750\u6807\u7684\u6700\u5927\u503c\uff08\u5373\u622a\u6b62\u65e5\u548c\u6700\u7ec8\u5b8c\u6210\u5ea6\uff09\u90fd\u662f 100\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5fc3\u7406\u9634\u5f71\u9762\u79ef\u3002 \u53cb\u60c5\u63d0\u9192\uff1a\u4e09\u89d2\u5f62\u7684\u9762\u79ef = \u5e95\u8fb9\u957f x \u9ad8 / 2\uff1b\u77e9\u5f62\u9762\u79ef = \u5e95\u8fb9\u957f x \u9ad8\u3002\u5ad1\u60f3\u5f97\u592a\u590d\u6742\uff0c\u8fd9\u662f\u4e00\u9053 5 \u5206\u8003\u51cf\u6cd5\u7684\u9898\u2026\u2026 \u8f93\u5165\u6837\u4f8b 90 10 \u8f93\u51fa\u6837\u4f8b 4000","title":"Statement"},{"location":"CCCC/L1-060-%E5%BF%83%E7%90%86%E9%98%B4%E5%BD%B1%E9%9D%A2%E7%A7%AF/#solution","text":"Python 3 x , y = map ( int , input () . split ()) print (( 100 * ( x - y )) // 2 )","title":"Solution"},{"location":"CCCC/L1-061-%E6%96%B0%E8%83%96%E5%AD%90%E5%85%AC%E5%BC%8F/","text":"L1-061 \u65b0\u80d6\u5b50\u516c\u5f0f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u94b1\u6c5f\u665a\u62a5\u5b98\u65b9\u5fae\u535a\u7684\u62a5\u5bfc\uff0c\u6700\u65b0\u7684\u80a5\u80d6\u8ba1\u7b97\u65b9\u6cd5\u4e3a\uff1a\u4f53\u91cd(kg) / \u8eab\u9ad8(m) \u7684\u5e73\u65b9\u3002\u5982\u679c\u8d85\u8fc7 25\uff0c\u4f60\u5c31\u662f\u80d6\u5b50\u3002\u4e8e\u662f\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u81ea\u52a8\u5224\u65ad\u4e00\u4e2a\u4eba\u5230\u5e95\u7b97\u4e0d\u7b97\u80d6\u5b50\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6570\uff0c\u4f9d\u6b21\u4e3a\u4e00\u4e2a\u4eba\u7684\u4f53\u91cd\uff08\u4ee5 kg \u4e3a\u5355\u4f4d\uff09\u548c\u8eab\u9ad8\uff08\u4ee5 m \u4e3a\u5355\u4f4d\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5176\u4e2d\u4f53\u91cd\u4e0d\u8d85\u8fc7 1000 kg\uff0c\u8eab\u9ad8\u4e0d\u8d85\u8fc7 3.0 m\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u5c06\u8be5\u4eba\u7684\u4f53\u91cd\u548c\u8eab\u9ad8\u4ee3\u5165\u80a5\u80d6\u516c\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u503c\u5927\u4e8e 25\uff0c\u5c31\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa PANG \uff0c\u5426\u5219\u8f93\u51fa Hai Xing \u3002 \u8f93\u5165\u6837\u4f8b 1 100.1 1.74 \u8f93\u51fa\u6837\u4f8b 1 33.1 PANG \u8f93\u5165\u6837\u4f8b 2 65 1.70 \u8f93\u51fa\u6837\u4f8b 2 22.5 Hai Xing Solution C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { db a , b ; rd ( a , b ); b *= b ; db x = a * 1.0 / b ; pt ( x ); if ( x > 25 ) pt ( \"PANG\" ); else pt ( \"Hai Xing\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 1 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"L1-061-\u65b0\u80d6\u5b50\u516c\u5f0f"},{"location":"CCCC/L1-061-%E6%96%B0%E8%83%96%E5%AD%90%E5%85%AC%E5%BC%8F/#l1-061-\u65b0\u80d6\u5b50\u516c\u5f0f","text":"","title":"L1-061 \u65b0\u80d6\u5b50\u516c\u5f0f"},{"location":"CCCC/L1-061-%E6%96%B0%E8%83%96%E5%AD%90%E5%85%AC%E5%BC%8F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u94b1\u6c5f\u665a\u62a5\u5b98\u65b9\u5fae\u535a\u7684\u62a5\u5bfc\uff0c\u6700\u65b0\u7684\u80a5\u80d6\u8ba1\u7b97\u65b9\u6cd5\u4e3a\uff1a\u4f53\u91cd(kg) / \u8eab\u9ad8(m) \u7684\u5e73\u65b9\u3002\u5982\u679c\u8d85\u8fc7 25\uff0c\u4f60\u5c31\u662f\u80d6\u5b50\u3002\u4e8e\u662f\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u81ea\u52a8\u5224\u65ad\u4e00\u4e2a\u4eba\u5230\u5e95\u7b97\u4e0d\u7b97\u80d6\u5b50\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6570\uff0c\u4f9d\u6b21\u4e3a\u4e00\u4e2a\u4eba\u7684\u4f53\u91cd\uff08\u4ee5 kg \u4e3a\u5355\u4f4d\uff09\u548c\u8eab\u9ad8\uff08\u4ee5 m \u4e3a\u5355\u4f4d\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5176\u4e2d\u4f53\u91cd\u4e0d\u8d85\u8fc7 1000 kg\uff0c\u8eab\u9ad8\u4e0d\u8d85\u8fc7 3.0 m\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u5c06\u8be5\u4eba\u7684\u4f53\u91cd\u548c\u8eab\u9ad8\u4ee3\u5165\u80a5\u80d6\u516c\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u503c\u5927\u4e8e 25\uff0c\u5c31\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa PANG \uff0c\u5426\u5219\u8f93\u51fa Hai Xing \u3002 \u8f93\u5165\u6837\u4f8b 1 100.1 1.74 \u8f93\u51fa\u6837\u4f8b 1 33.1 PANG \u8f93\u5165\u6837\u4f8b 2 65 1.70 \u8f93\u51fa\u6837\u4f8b 2 22.5 Hai Xing","title":"Statement"},{"location":"CCCC/L1-061-%E6%96%B0%E8%83%96%E5%AD%90%E5%85%AC%E5%BC%8F/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { db a , b ; rd ( a , b ); b *= b ; db x = a * 1.0 / b ; pt ( x ); if ( x > 25 ) pt ( \"PANG\" ); else pt ( \"Hai Xing\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 1 ); int _T = 1 ; // nextInt(); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-062-%E5%B9%B8%E8%BF%90%E5%BD%A9%E7%A5%A8/","text":"L1-062 \u5e78\u8fd0\u5f69\u7968 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f69\u7968\u7684\u53f7\u7801\u6709 6 \u4f4d\u6570\u5b57\uff0c\u82e5\u4e00\u5f20\u5f69\u7968\u7684\u524d 3 \u4f4d\u4e0a\u7684\u6570\u4e4b\u548c\u7b49\u4e8e\u540e 3 \u4f4d\u4e0a\u7684\u6570\u4e4b\u548c\uff0c\u5219\u79f0\u8fd9\u5f20\u5f69\u7968\u662f\u5e78\u8fd0\u7684\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u7ed9\u5b9a\u7684\u5f69\u7968\u662f\u4e0d\u662f\u5e78\u8fd0\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u5f69\u7968\u7684 6 \u4f4d\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u5f20\u5f69\u7968\uff0c\u5982\u679c\u5b83\u662f\u5e78\u8fd0\u7684\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa You are lucky! \uff1b\u5426\u5219\u8f93\u51fa Wish you good luck. \u3002 \u8f93\u5165\u6837\u4f8b 2 233008 123456 \u8f93\u51fa\u6837\u4f8b You are lucky! Wish you good luck. Solution C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { int x ; rd ( x ); vector < int > vec ( 6 , 0 ); for ( int i = 0 ; i < 6 ; ++ i ) { vec [ i ] = x % 10 ; x /= 10 ; } if ( vec [ 0 ] + vec [ 1 ] + vec [ 2 ] == vec [ 3 ] + vec [ 4 ] + vec [ 5 ]) pt ( \"You are lucky!\" ); else pt ( \"Wish you good luck.\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"L1-062-\u5e78\u8fd0\u5f69\u7968"},{"location":"CCCC/L1-062-%E5%B9%B8%E8%BF%90%E5%BD%A9%E7%A5%A8/#l1-062-\u5e78\u8fd0\u5f69\u7968","text":"","title":"L1-062 \u5e78\u8fd0\u5f69\u7968"},{"location":"CCCC/L1-062-%E5%B9%B8%E8%BF%90%E5%BD%A9%E7%A5%A8/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f69\u7968\u7684\u53f7\u7801\u6709 6 \u4f4d\u6570\u5b57\uff0c\u82e5\u4e00\u5f20\u5f69\u7968\u7684\u524d 3 \u4f4d\u4e0a\u7684\u6570\u4e4b\u548c\u7b49\u4e8e\u540e 3 \u4f4d\u4e0a\u7684\u6570\u4e4b\u548c\uff0c\u5219\u79f0\u8fd9\u5f20\u5f69\u7968\u662f\u5e78\u8fd0\u7684\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u7ed9\u5b9a\u7684\u5f69\u7968\u662f\u4e0d\u662f\u5e78\u8fd0\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u5f69\u7968\u7684 6 \u4f4d\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u5f20\u5f69\u7968\uff0c\u5982\u679c\u5b83\u662f\u5e78\u8fd0\u7684\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa You are lucky! \uff1b\u5426\u5219\u8f93\u51fa Wish you good luck. \u3002 \u8f93\u5165\u6837\u4f8b 2 233008 123456 \u8f93\u51fa\u6837\u4f8b You are lucky! Wish you good luck.","title":"Statement"},{"location":"CCCC/L1-062-%E5%B9%B8%E8%BF%90%E5%BD%A9%E7%A5%A8/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { int x ; rd ( x ); vector < int > vec ( 6 , 0 ); for ( int i = 0 ; i < 6 ; ++ i ) { vec [ i ] = x % 10 ; x /= 10 ; } if ( vec [ 0 ] + vec [ 1 ] + vec [ 2 ] == vec [ 3 ] + vec [ 4 ] + vec [ 5 ]) pt ( \"You are lucky!\" ); else pt ( \"Wish you good luck.\" ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-063-%E5%90%83%E9%B1%BC%E8%BF%98%E6%98%AF%E5%90%83%E8%82%89/","text":"L1-063 \u5403\u9c7c\u8fd8\u662f\u5403\u8089 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fd\u5bb6\u7ed9\u51fa\u4e86 8 \u5c81\u7537\u5b9d\u5b9d\u7684\u6807\u51c6\u8eab\u9ad8\u4e3a 130 \u5398\u7c73\u3001\u6807\u51c6\u4f53\u91cd\u4e3a 27 \u516c\u65a4\uff1b8 \u5c81\u5973\u5b9d\u5b9d\u7684\u6807\u51c6\u8eab\u9ad8\u4e3a 129 \u5398\u7c73\u3001\u6807\u51c6\u4f53\u91cd\u4e3a 25 \u516c\u65a4\u3002 \u73b0\u5728\u4f60\u8981\u6839\u636e\u5c0f\u5b9d\u5b9d\u7684\u8eab\u9ad8\u4f53\u91cd\uff0c\u7ed9\u51fa\u8865\u5145\u8425\u517b\u7684\u5efa\u8bae\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 N N \uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b9d\u5b9d\u7684\u8eab\u4f53\u6570\u636e\uff1a \u6027\u522b \u8eab\u9ad8 \u4f53\u91cd \u5176\u4e2d \u6027\u522b \u662f 1 \u8868\u793a\u7537\u751f\uff0c0 \u8868\u793a\u5973\u751f\u3002 \u8eab\u9ad8 \u548c \u4f53\u91cd \u90fd\u662f\u4e0d\u8d85\u8fc7 200 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u4f4d\u5b9d\u5b9d\uff0c\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4f60\u7684\u5efa\u8bae\uff1a \u5982\u679c\u592a\u77ee\u4e86\uff0c\u8f93\u51fa\uff1a duo chi yu! \uff08\u591a\u5403\u9c7c\uff09\uff1b \u5982\u679c\u592a\u7626\u4e86\uff0c\u8f93\u51fa\uff1a duo chi rou! \uff08\u591a\u5403\u8089\uff09\uff1b \u5982\u679c\u6b63\u6807\u51c6\uff0c\u8f93\u51fa\uff1a wan mei! \uff08\u5b8c\u7f8e\uff09\uff1b \u5982\u679c\u592a\u9ad8\u4e86\uff0c\u8f93\u51fa\uff1a ni li hai! \uff08\u4f60\u5389\u5bb3\uff09\uff1b \u5982\u679c\u592a\u80d6\u4e86\uff0c\u8f93\u51fa\uff1a shao chi rou! \uff08\u5c11\u5403\u8089\uff09\u3002 \u5148\u8bc4\u4ef7\u8eab\u9ad8\uff0c\u518d\u8bc4\u4ef7\u4f53\u91cd\u3002\u4e24\u53e5\u8bdd\u4e4b\u95f4\u8981\u6709 1 \u4e2a\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 4 0 130 23 1 129 27 1 130 30 0 128 27 \u8f93\u51fa\u6837\u4f8b ni li hai! duo chi rou! duo chi yu! wan mei! wan mei! shao chi rou! duo chi yu! shao chi rou! Solution C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { int a , b , c ; rd ( a , b , c ); int _b [ 2 ] = { 129 , 130 }; int _c [ 2 ] = { 25 , 27 }; string res = \"\" ; if ( b < _b [ a ]) res += \"duo chi yu!\" ; else if ( b == _b [ a ]) res += \"wan mei!\" ; else res += \"ni li hai!\" ; res += \" \" ; if ( c < _c [ a ]) res += \"duo chi rou!\" ; else if ( c == _c [ a ]) res += \"wan mei!\" ; else res += \"shao chi rou!\" ; cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"L1-063-\u5403\u9c7c\u8fd8\u662f\u5403\u8089"},{"location":"CCCC/L1-063-%E5%90%83%E9%B1%BC%E8%BF%98%E6%98%AF%E5%90%83%E8%82%89/#l1-063-\u5403\u9c7c\u8fd8\u662f\u5403\u8089","text":"","title":"L1-063 \u5403\u9c7c\u8fd8\u662f\u5403\u8089"},{"location":"CCCC/L1-063-%E5%90%83%E9%B1%BC%E8%BF%98%E6%98%AF%E5%90%83%E8%82%89/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fd\u5bb6\u7ed9\u51fa\u4e86 8 \u5c81\u7537\u5b9d\u5b9d\u7684\u6807\u51c6\u8eab\u9ad8\u4e3a 130 \u5398\u7c73\u3001\u6807\u51c6\u4f53\u91cd\u4e3a 27 \u516c\u65a4\uff1b8 \u5c81\u5973\u5b9d\u5b9d\u7684\u6807\u51c6\u8eab\u9ad8\u4e3a 129 \u5398\u7c73\u3001\u6807\u51c6\u4f53\u91cd\u4e3a 25 \u516c\u65a4\u3002 \u73b0\u5728\u4f60\u8981\u6839\u636e\u5c0f\u5b9d\u5b9d\u7684\u8eab\u9ad8\u4f53\u91cd\uff0c\u7ed9\u51fa\u8865\u5145\u8425\u517b\u7684\u5efa\u8bae\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 N N \uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b9d\u5b9d\u7684\u8eab\u4f53\u6570\u636e\uff1a \u6027\u522b \u8eab\u9ad8 \u4f53\u91cd \u5176\u4e2d \u6027\u522b \u662f 1 \u8868\u793a\u7537\u751f\uff0c0 \u8868\u793a\u5973\u751f\u3002 \u8eab\u9ad8 \u548c \u4f53\u91cd \u90fd\u662f\u4e0d\u8d85\u8fc7 200 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u4f4d\u5b9d\u5b9d\uff0c\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4f60\u7684\u5efa\u8bae\uff1a \u5982\u679c\u592a\u77ee\u4e86\uff0c\u8f93\u51fa\uff1a duo chi yu! \uff08\u591a\u5403\u9c7c\uff09\uff1b \u5982\u679c\u592a\u7626\u4e86\uff0c\u8f93\u51fa\uff1a duo chi rou! \uff08\u591a\u5403\u8089\uff09\uff1b \u5982\u679c\u6b63\u6807\u51c6\uff0c\u8f93\u51fa\uff1a wan mei! \uff08\u5b8c\u7f8e\uff09\uff1b \u5982\u679c\u592a\u9ad8\u4e86\uff0c\u8f93\u51fa\uff1a ni li hai! \uff08\u4f60\u5389\u5bb3\uff09\uff1b \u5982\u679c\u592a\u80d6\u4e86\uff0c\u8f93\u51fa\uff1a shao chi rou! \uff08\u5c11\u5403\u8089\uff09\u3002 \u5148\u8bc4\u4ef7\u8eab\u9ad8\uff0c\u518d\u8bc4\u4ef7\u4f53\u91cd\u3002\u4e24\u53e5\u8bdd\u4e4b\u95f4\u8981\u6709 1 \u4e2a\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 4 0 130 23 1 129 27 1 130 30 0 128 27 \u8f93\u51fa\u6837\u4f8b ni li hai! duo chi rou! duo chi yu! wan mei! wan mei! shao chi rou! duo chi yu! shao chi rou!","title":"Statement"},{"location":"CCCC/L1-063-%E5%90%83%E9%B1%BC%E8%BF%98%E6%98%AF%E5%90%83%E8%82%89/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; void run () { int a , b , c ; rd ( a , b , c ); int _b [ 2 ] = { 129 , 130 }; int _c [ 2 ] = { 25 , 27 }; string res = \"\" ; if ( b < _b [ a ]) res += \"duo chi yu!\" ; else if ( b == _b [ a ]) res += \"wan mei!\" ; else res += \"ni li hai!\" ; res += \" \" ; if ( c < _c [ a ]) res += \"duo chi rou!\" ; else if ( c == _c [ a ]) res += \"wan mei!\" ; else res += \"shao chi rou!\" ; cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-064-%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/","text":"L1-064 \u4f30\u503c\u4e00\u4ebf\u7684AI\u6838\u5fc3\u4ee3\u7801 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u56fe\u7247\u6765\u81ea\u65b0\u6d6a\u5fae\u535a\u3002 \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u7a0d\u5fae\u66f4\u503c\u94b1\u4e00\u70b9\u7684 AI \u82f1\u6587\u95ee\u7b54\u7a0b\u5e8f\uff0c\u89c4\u5219\u662f\uff1a \u65e0\u8bba\u7528\u6237\u8bf4\u4ec0\u4e48\uff0c\u9996\u5148\u628a\u5bf9\u65b9\u8bf4\u7684\u8bdd\u5728\u4e00\u884c\u4e2d\u539f\u6837\u6253\u5370\u51fa\u6765\uff1b \u6d88\u9664\u539f\u6587\u4e2d\u591a\u4f59\u7a7a\u683c\uff1a\u628a\u76f8\u90bb\u5355\u8bcd\u95f4\u7684\u591a\u4e2a\u7a7a\u683c\u6362\u6210 1 \u4e2a\u7a7a\u683c\uff0c\u628a\u884c\u9996\u5c3e\u7684\u7a7a\u683c\u5168\u90e8\u5220\u6389\uff0c\u628a\u6807\u70b9\u7b26\u53f7\u524d\u9762\u7684\u7a7a\u683c\u5220\u6389\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u53d8\u6210\u5c0f\u5199\uff0c\u9664\u4e86 I \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 can you \u3001 could you \u5bf9\u5e94\u5730\u6362\u6210 I can \u3001 I could \u2014\u2014 \u8fd9\u91cc\u201c\u72ec\u7acb\u201d\u662f\u6307\u88ab\u7a7a\u683c\u6216\u6807\u70b9\u7b26\u53f7\u5206\u9694\u5f00\u7684\u5355\u8bcd\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 I \u548c me \u6362\u6210 you \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u7684\u95ee\u53f7 ? \u6362\u6210\u60ca\u53f9\u53f7 ! \uff1b \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u66ff\u6362\u540e\u7684\u53e5\u5b50\u4f5c\u4e3a AI \u7684\u56de\u7b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 N\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u4e0d\u8d85\u8fc7 1000 \u4e2a\u5b57\u7b26\u7684\u3001\u4ee5\u56de\u8f66\u7ed3\u5c3e\u7684\u7528\u6237\u7684\u5bf9\u8bdd\uff0c\u5bf9\u8bdd\u4e3a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ec5\u5305\u62ec\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u7a7a\u683c\u3001\u53ef\u89c1\u7684\u534a\u89d2\u6807\u70b9\u7b26\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u9762\u8981\u6c42\u8f93\u51fa\uff0c\u6bcf\u4e2a AI \u7684\u56de\u7b54\u524d\u8981\u52a0\u4e0a AI: \u548c\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 Hello ? Good to chat with you can you speak Chinese? Really? Could you show me 5 What Is this prime? I,don 't know \u8f93\u51fa\u6837\u4f8b Hello ? AI: hello! Good to chat with you AI: good to chat with you can you speak Chinese? AI: I can speak chinese! Really? AI: really! Could you show me 5 AI: I could show you 5 What Is this prime? I,don 't know AI: what Is this prime! you,don't know Tutorial \u9898\u610f\uff1a \u7ed9\u4e00\u4e2a\u5b57\u7b26\u4e32 s s : \u65e0\u8bba\u7528\u6237\u8bf4\u4ec0\u4e48\uff0c\u9996\u5148\u628a\u5bf9\u65b9\u8bf4\u7684\u8bdd\u5728\u4e00\u884c\u4e2d\u539f\u6837\u6253\u5370\u51fa\u6765\uff1b \u6d88\u9664\u539f\u6587\u4e2d\u591a\u4f59\u7a7a\u683c\uff1a\u628a\u76f8\u90bb\u5355\u8bcd\u95f4\u7684\u591a\u4e2a\u7a7a\u683c\u6362\u6210 1 1 \u4e2a\u7a7a\u683c\uff0c\u628a\u884c\u9996\u5c3e\u7684\u7a7a\u683c\u5168\u90e8\u5220\u6389\uff0c\u628a\u6807\u70b9\u7b26\u53f7\u524d\u9762\u7684\u7a7a\u683c\u5220\u6389\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u53d8\u6210\u5c0f\u5199\uff0c\u9664\u4e86 I \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 can you \u3001 could you \u5bf9\u5e94\u5730\u6362\u6210 I can \u3001 I could \u2014\u2014 \u8fd9\u91cc\u201c\u72ec\u7acb\u201d\u662f\u6307\u88ab\u7a7a\u683c\u6216\u6807\u70b9\u7b26\u53f7\u5206\u9694\u5f00\u7684\u5355\u8bcd\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 I \u548c me \u6362\u6210 you \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u7684\u95ee\u53f7 ? \u6362\u6210\u60ca\u53f9\u53f7 ! \uff1b \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u66ff\u6362\u540e\u7684\u53e5\u5b50\u4f5c\u4e3a AI \u7684\u56de\u7b54\u3002 \u601d\u8def\uff1a \u6587\u672c\u66ff\u6362\u3002 \u6709\u95ee\u9898\u7684\u4e00\u70b9\u5c31\u662f\u8981\u660e\u767d\u8fd9\u4e2a\u66ff\u6362\u7684\u540c\u65f6\u8fdb\u884c\u7684\uff0c\u5e76\u6ca1\u6709\u5148\u540e\u5173\u7cfb\u3002 \u4f1a\u51fa\u95ee\u9898\u7684\u70b9\u5728\u4e8e\u7b2c 4, 5 4, 5 \u70b9\uff1a\u8fd9\u4e24\u4e2a\u4e0d\u80fd\u6709\u5148\u540e\u987a\u5e8f\u7684\u66ff\u6362\uff0c\u4e00\u4e2a\u53ef\u884c\u7684\u65b9\u6cd5\u662f\u5148\u66ff\u6362\u6210\u53e6\u4e00\u79cd\u5b57\u7b26. \u8b6c\u5982 I can -> @ can \uff0c I could -> @ could \uff0c\u8fd9\u6837\u52a0\u5165\u4e00\u6b65\u4e2d\u95f4\u72b6\u6001\uff0c\u90a3\u4e48\u5728\u7b2c 5 5 \u6b65\u7684\u65f6\u5019,\u5c31\u4e0d\u4f1a\u66ff\u6362\u6389 I can \u4e2d\u7684 I \uff0c\u7136\u540e\u6700\u540e\u5c06 @ \u66ff\u6362\u56de\u6765\u5373\u53ef\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; using pSS = pair < string , string > ; #define all(x) x.begin(), x.end() #define SZ(x) (int(x.size())) #define fi first #define se second #define endl \"\\n\" bool isPunc ( char ch ) { return ! isdigit ( ch ) && ! isalpha ( ch ) && ch != ' ' ; } bool match ( string & s , int l , int r , string & t ) { if ( SZ ( t ) != r - l + 1 || l < 0 || r >= SZ ( s )) return false ; for ( int i = l , j = 0 ; i <= r ; ++ i , ++ j ) { if ( s [ i ] != t [ j ]) return false ; } return true ; } string trim ( string & s ) { while ( s . end ()[ -1 ] == ' ' ) s . pop_back (); reverse ( all ( s )); while ( s . end ()[ -1 ] == ' ' ) s . pop_back (); reverse ( all ( s )); return s ; } string delSpace ( string & s ) { string res = \"\" ; int num = 0 ; for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( s [ i ] == ' ' ) { ++ num ; } else { if ( num && ! isPunc ( s [ i ])) res += \" \" ; res += s [ i ]; num = 0 ; } } return res ; } string toLower ( string & s ) { for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( isupper ( s [ i ]) && s [ i ] != 'I' ) { s [ i ] = s [ i ] - 'A' + 'a' ; } } return s ; } string change ( string & s , vector < pSS > vec ) { string res = \"\" ; for ( int i = -1 ; i < SZ ( s ); ++ i ) { if ( i == -1 || isPunc ( s [ i ]) || s [ i ] == ' ' ) { int ok = 0 ; for ( auto & it : vec ) { int len = SZ ( it . fi ); if ( match ( s , i + 1 , i + len , it . fi ) && ( i + len + 1 == SZ ( s ) || isPunc ( s [ i + len + 1 ]) || s [ i + len + 1 ] == ' ' )) { if ( i != -1 ) res += s [ i ]; res += it . se ; i += len ; ok = 1 ; break ; } } if ( ok ) continue ; } if ( i != -1 ) res += s [ i ]; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); int _T ; cin >> _T ; string s ; getline ( cin , s ); while ( _T -- ) { getline ( cin , s ); cout << s << endl ; s = trim ( s ); s = delSpace ( s ); s = toLower ( s ); s = change ( s , vector < pSS > ({ pSS ( \"can you\" , \"@ can\" ), pSS ( \"could you\" , \"@ could\" )})); s = change ( s , vector < pSS > ({ pSS ( \"I\" , \"you\" ), pSS ( \"me\" , \"you\" )})); for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( s [ i ] == '?' ) s [ i ] = '!' ; if ( s [ i ] == '@' ) s [ i ] = 'I' ; } cout << \"AI: \" + s << endl ; } return 0 ; }","title":"L1-064-\u4f30\u503c\u4e00\u4ebf\u7684AI\u6838\u5fc3\u4ee3\u7801"},{"location":"CCCC/L1-064-%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/#l1-064-\u4f30\u503c\u4e00\u4ebf\u7684ai\u6838\u5fc3\u4ee3\u7801","text":"","title":"L1-064 \u4f30\u503c\u4e00\u4ebf\u7684AI\u6838\u5fc3\u4ee3\u7801"},{"location":"CCCC/L1-064-%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u56fe\u7247\u6765\u81ea\u65b0\u6d6a\u5fae\u535a\u3002 \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u7a0d\u5fae\u66f4\u503c\u94b1\u4e00\u70b9\u7684 AI \u82f1\u6587\u95ee\u7b54\u7a0b\u5e8f\uff0c\u89c4\u5219\u662f\uff1a \u65e0\u8bba\u7528\u6237\u8bf4\u4ec0\u4e48\uff0c\u9996\u5148\u628a\u5bf9\u65b9\u8bf4\u7684\u8bdd\u5728\u4e00\u884c\u4e2d\u539f\u6837\u6253\u5370\u51fa\u6765\uff1b \u6d88\u9664\u539f\u6587\u4e2d\u591a\u4f59\u7a7a\u683c\uff1a\u628a\u76f8\u90bb\u5355\u8bcd\u95f4\u7684\u591a\u4e2a\u7a7a\u683c\u6362\u6210 1 \u4e2a\u7a7a\u683c\uff0c\u628a\u884c\u9996\u5c3e\u7684\u7a7a\u683c\u5168\u90e8\u5220\u6389\uff0c\u628a\u6807\u70b9\u7b26\u53f7\u524d\u9762\u7684\u7a7a\u683c\u5220\u6389\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u53d8\u6210\u5c0f\u5199\uff0c\u9664\u4e86 I \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 can you \u3001 could you \u5bf9\u5e94\u5730\u6362\u6210 I can \u3001 I could \u2014\u2014 \u8fd9\u91cc\u201c\u72ec\u7acb\u201d\u662f\u6307\u88ab\u7a7a\u683c\u6216\u6807\u70b9\u7b26\u53f7\u5206\u9694\u5f00\u7684\u5355\u8bcd\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 I \u548c me \u6362\u6210 you \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u7684\u95ee\u53f7 ? \u6362\u6210\u60ca\u53f9\u53f7 ! \uff1b \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u66ff\u6362\u540e\u7684\u53e5\u5b50\u4f5c\u4e3a AI \u7684\u56de\u7b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10 \u7684\u6b63\u6574\u6570 N\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u4e0d\u8d85\u8fc7 1000 \u4e2a\u5b57\u7b26\u7684\u3001\u4ee5\u56de\u8f66\u7ed3\u5c3e\u7684\u7528\u6237\u7684\u5bf9\u8bdd\uff0c\u5bf9\u8bdd\u4e3a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ec5\u5305\u62ec\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u7a7a\u683c\u3001\u53ef\u89c1\u7684\u534a\u89d2\u6807\u70b9\u7b26\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u9762\u8981\u6c42\u8f93\u51fa\uff0c\u6bcf\u4e2a AI \u7684\u56de\u7b54\u524d\u8981\u52a0\u4e0a AI: \u548c\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 Hello ? Good to chat with you can you speak Chinese? Really? Could you show me 5 What Is this prime? I,don 't know \u8f93\u51fa\u6837\u4f8b Hello ? AI: hello! Good to chat with you AI: good to chat with you can you speak Chinese? AI: I can speak chinese! Really? AI: really! Could you show me 5 AI: I could show you 5 What Is this prime? I,don 't know AI: what Is this prime! you,don't know","title":"Statement"},{"location":"CCCC/L1-064-%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/#tutorial","text":"\u9898\u610f\uff1a \u7ed9\u4e00\u4e2a\u5b57\u7b26\u4e32 s s : \u65e0\u8bba\u7528\u6237\u8bf4\u4ec0\u4e48\uff0c\u9996\u5148\u628a\u5bf9\u65b9\u8bf4\u7684\u8bdd\u5728\u4e00\u884c\u4e2d\u539f\u6837\u6253\u5370\u51fa\u6765\uff1b \u6d88\u9664\u539f\u6587\u4e2d\u591a\u4f59\u7a7a\u683c\uff1a\u628a\u76f8\u90bb\u5355\u8bcd\u95f4\u7684\u591a\u4e2a\u7a7a\u683c\u6362\u6210 1 1 \u4e2a\u7a7a\u683c\uff0c\u628a\u884c\u9996\u5c3e\u7684\u7a7a\u683c\u5168\u90e8\u5220\u6389\uff0c\u628a\u6807\u70b9\u7b26\u53f7\u524d\u9762\u7684\u7a7a\u683c\u5220\u6389\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u53d8\u6210\u5c0f\u5199\uff0c\u9664\u4e86 I \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 can you \u3001 could you \u5bf9\u5e94\u5730\u6362\u6210 I can \u3001 I could \u2014\u2014 \u8fd9\u91cc\u201c\u72ec\u7acb\u201d\u662f\u6307\u88ab\u7a7a\u683c\u6216\u6807\u70b9\u7b26\u53f7\u5206\u9694\u5f00\u7684\u5355\u8bcd\uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u72ec\u7acb\u7684 I \u548c me \u6362\u6210 you \uff1b \u628a\u539f\u6587\u4e2d\u6240\u6709\u7684\u95ee\u53f7 ? \u6362\u6210\u60ca\u53f9\u53f7 ! \uff1b \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u66ff\u6362\u540e\u7684\u53e5\u5b50\u4f5c\u4e3a AI \u7684\u56de\u7b54\u3002 \u601d\u8def\uff1a \u6587\u672c\u66ff\u6362\u3002 \u6709\u95ee\u9898\u7684\u4e00\u70b9\u5c31\u662f\u8981\u660e\u767d\u8fd9\u4e2a\u66ff\u6362\u7684\u540c\u65f6\u8fdb\u884c\u7684\uff0c\u5e76\u6ca1\u6709\u5148\u540e\u5173\u7cfb\u3002 \u4f1a\u51fa\u95ee\u9898\u7684\u70b9\u5728\u4e8e\u7b2c 4, 5 4, 5 \u70b9\uff1a\u8fd9\u4e24\u4e2a\u4e0d\u80fd\u6709\u5148\u540e\u987a\u5e8f\u7684\u66ff\u6362\uff0c\u4e00\u4e2a\u53ef\u884c\u7684\u65b9\u6cd5\u662f\u5148\u66ff\u6362\u6210\u53e6\u4e00\u79cd\u5b57\u7b26. \u8b6c\u5982 I can -> @ can \uff0c I could -> @ could \uff0c\u8fd9\u6837\u52a0\u5165\u4e00\u6b65\u4e2d\u95f4\u72b6\u6001\uff0c\u90a3\u4e48\u5728\u7b2c 5 5 \u6b65\u7684\u65f6\u5019,\u5c31\u4e0d\u4f1a\u66ff\u6362\u6389 I can \u4e2d\u7684 I \uff0c\u7136\u540e\u6700\u540e\u5c06 @ \u66ff\u6362\u56de\u6765\u5373\u53ef\u3002","title":"Tutorial"},{"location":"CCCC/L1-064-%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using pSS = pair < string , string > ; #define all(x) x.begin(), x.end() #define SZ(x) (int(x.size())) #define fi first #define se second #define endl \"\\n\" bool isPunc ( char ch ) { return ! isdigit ( ch ) && ! isalpha ( ch ) && ch != ' ' ; } bool match ( string & s , int l , int r , string & t ) { if ( SZ ( t ) != r - l + 1 || l < 0 || r >= SZ ( s )) return false ; for ( int i = l , j = 0 ; i <= r ; ++ i , ++ j ) { if ( s [ i ] != t [ j ]) return false ; } return true ; } string trim ( string & s ) { while ( s . end ()[ -1 ] == ' ' ) s . pop_back (); reverse ( all ( s )); while ( s . end ()[ -1 ] == ' ' ) s . pop_back (); reverse ( all ( s )); return s ; } string delSpace ( string & s ) { string res = \"\" ; int num = 0 ; for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( s [ i ] == ' ' ) { ++ num ; } else { if ( num && ! isPunc ( s [ i ])) res += \" \" ; res += s [ i ]; num = 0 ; } } return res ; } string toLower ( string & s ) { for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( isupper ( s [ i ]) && s [ i ] != 'I' ) { s [ i ] = s [ i ] - 'A' + 'a' ; } } return s ; } string change ( string & s , vector < pSS > vec ) { string res = \"\" ; for ( int i = -1 ; i < SZ ( s ); ++ i ) { if ( i == -1 || isPunc ( s [ i ]) || s [ i ] == ' ' ) { int ok = 0 ; for ( auto & it : vec ) { int len = SZ ( it . fi ); if ( match ( s , i + 1 , i + len , it . fi ) && ( i + len + 1 == SZ ( s ) || isPunc ( s [ i + len + 1 ]) || s [ i + len + 1 ] == ' ' )) { if ( i != -1 ) res += s [ i ]; res += it . se ; i += len ; ok = 1 ; break ; } } if ( ok ) continue ; } if ( i != -1 ) res += s [ i ]; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); int _T ; cin >> _T ; string s ; getline ( cin , s ); while ( _T -- ) { getline ( cin , s ); cout << s << endl ; s = trim ( s ); s = delSpace ( s ); s = toLower ( s ); s = change ( s , vector < pSS > ({ pSS ( \"can you\" , \"@ can\" ), pSS ( \"could you\" , \"@ could\" )})); s = change ( s , vector < pSS > ({ pSS ( \"I\" , \"you\" ), pSS ( \"me\" , \"you\" )})); for ( int i = 0 ; i < SZ ( s ); ++ i ) { if ( s [ i ] == '?' ) s [ i ] = '!' ; if ( s [ i ] == '@' ) s [ i ] = 'I' ; } cout << \"AI: \" + s << endl ; } return 0 ; }","title":"Solution"},{"location":"CCCC/L1-065-%E5%AB%91%E5%BA%9F%E8%AF%9D%E4%B8%8A%E4%BB%A3%E7%A0%81/","text":"L1-065 \u5ad1\u5e9f\u8bdd\u4e0a\u4ee3\u7801 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Linux \u4e4b\u7236 Linus Torvalds \u7684\u540d\u8a00\u662f\uff1a\u201cTalk is cheap. Show me the code.\u201d\uff08\u5ad1\u5e9f\u8bdd\uff0c\u4e0a\u4ee3\u7801\uff09\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u76f4\u63a5\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa Talk is cheap. Show me the code. \u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Talk is cheap. Show me the code. Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { cout << \"Talk is cheap. Show me the code. \\n \" ; return 0 ; }","title":"L1-065-\u5ad1\u5e9f\u8bdd\u4e0a\u4ee3\u7801"},{"location":"CCCC/L1-065-%E5%AB%91%E5%BA%9F%E8%AF%9D%E4%B8%8A%E4%BB%A3%E7%A0%81/#l1-065-\u5ad1\u5e9f\u8bdd\u4e0a\u4ee3\u7801","text":"","title":"L1-065 \u5ad1\u5e9f\u8bdd\u4e0a\u4ee3\u7801"},{"location":"CCCC/L1-065-%E5%AB%91%E5%BA%9F%E8%AF%9D%E4%B8%8A%E4%BB%A3%E7%A0%81/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Linux \u4e4b\u7236 Linus Torvalds \u7684\u540d\u8a00\u662f\uff1a\u201cTalk is cheap. Show me the code.\u201d\uff08\u5ad1\u5e9f\u8bdd\uff0c\u4e0a\u4ee3\u7801\uff09\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u76f4\u63a5\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa Talk is cheap. Show me the code. \u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b Talk is cheap. Show me the code.","title":"Statement"},{"location":"CCCC/L1-065-%E5%AB%91%E5%BA%9F%E8%AF%9D%E4%B8%8A%E4%BB%A3%E7%A0%81/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { cout << \"Talk is cheap. Show me the code. \\n \" ; return 0 ; }","title":"Solution"},{"location":"CCCC/L1-066-%E7%8C%AB%E6%98%AF%E6%B6%B2%E4%BD%93/","text":"L1-066 \u732b\u662f\u6db2\u4f53 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6d4b\u91cf\u4e00\u4e2a\u4eba\u7684\u4f53\u79ef\u662f\u5f88\u96be\u7684\uff0c\u4f46\u732b\u5c31\u4e0d\u4e00\u6837\u4e86\u3002\u56e0\u4e3a\u732b\u662f\u6db2\u4f53\uff0c\u6240\u4ee5\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u901a\u8fc7\u6d4b\u91cf\u4e00\u4e2a\u957f\u65b9\u4f53\u5bb9\u5668\u7684\u5bb9\u79ef\u6765\u5f97\u5230\u5bb9\u5668\u91cc\u732b\u7684\u4f53\u79ef\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b8c\u6210\u8fd9\u4e2a\u8ba1\u7b97\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u5bb9\u5668\u7684\u957f\u3001\u5bbd\u3001\u9ad8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u732b\u7684\u4f53\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 23 15 20 \u8f93\u51fa\u6837\u4f8b 6900 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; cout << a * b * c << endl ; return 0 ; }","title":"L1-066-\u732b\u662f\u6db2\u4f53"},{"location":"CCCC/L1-066-%E7%8C%AB%E6%98%AF%E6%B6%B2%E4%BD%93/#l1-066-\u732b\u662f\u6db2\u4f53","text":"","title":"L1-066 \u732b\u662f\u6db2\u4f53"},{"location":"CCCC/L1-066-%E7%8C%AB%E6%98%AF%E6%B6%B2%E4%BD%93/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6d4b\u91cf\u4e00\u4e2a\u4eba\u7684\u4f53\u79ef\u662f\u5f88\u96be\u7684\uff0c\u4f46\u732b\u5c31\u4e0d\u4e00\u6837\u4e86\u3002\u56e0\u4e3a\u732b\u662f\u6db2\u4f53\uff0c\u6240\u4ee5\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u901a\u8fc7\u6d4b\u91cf\u4e00\u4e2a\u957f\u65b9\u4f53\u5bb9\u5668\u7684\u5bb9\u79ef\u6765\u5f97\u5230\u5bb9\u5668\u91cc\u732b\u7684\u4f53\u79ef\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b8c\u6210\u8fd9\u4e2a\u8ba1\u7b97\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u5bb9\u5668\u7684\u957f\u3001\u5bbd\u3001\u9ad8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u732b\u7684\u4f53\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 23 15 20 \u8f93\u51fa\u6837\u4f8b 6900","title":"Statement"},{"location":"CCCC/L1-066-%E7%8C%AB%E6%98%AF%E6%B6%B2%E4%BD%93/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c ; cin >> a >> b >> c ; cout << a * b * c << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L1-067-%20%E6%B4%9B%E5%B8%8C%E6%9E%81%E9%99%90/","text":"L1-067 \u6d1b\u5e0c\u6781\u9650 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u79d1\u5e7b\u7535\u5f71\u300a\u6d41\u6d6a\u5730\u7403\u300b\u4e2d\u4e00\u4e2a\u91cd\u8981\u7684\u60c5\u8282\u662f\u5730\u7403\u8ddd\u79bb\u6728\u661f\u592a\u8fd1\u65f6\uff0c\u5927\u6c14\u5f00\u59cb\u88ab\u6728\u661f\u5438\u8d70\uff0c\u800c\u968f\u7740\u4e0d\u65ad\u63a5\u8fd1\u5730\u6728\u201c\u521a\u4f53\u6d1b\u5e0c\u6781\u9650\u201d\uff0c\u5730\u7403\u9762\u4e34\u88ab\u5f7b\u5e95\u6495\u788e\u7684\u5371\u9669\u3002\u4f46\u5b9e\u9645\u4e0a\uff0c\u8fd9\u4e2a\u8ba1\u7b97\u662f\u9519\u8bef\u7684\u3002 \u6d1b\u5e0c\u6781\u9650\uff08Roche limit\uff09\u662f\u4e00\u4e2a\u5929\u4f53\u81ea\u8eab\u7684\u5f15\u529b\u4e0e\u7b2c\u4e8c\u4e2a\u5929\u4f53\u9020\u6210\u7684\u6f6e\u6c50\u529b\u76f8\u7b49\u65f6\u7684\u8ddd\u79bb\u3002\u5f53\u4e24\u4e2a\u5929\u4f53\u7684\u8ddd\u79bb\u5c11\u4e8e\u6d1b\u5e0c\u6781\u9650\uff0c\u5929\u4f53\u5c31\u4f1a\u503e\u5411\u788e\u6563\uff0c\u7ee7\u800c\u6210\u4e3a\u7b2c\u4e8c\u4e2a\u5929\u4f53\u7684\u73af\u3002\u5b83\u4ee5\u9996\u4f4d\u8ba1\u7b97\u8fd9\u4e2a\u6781\u9650\u7684\u4eba\u7231\u5fb7\u534e\u00b7\u6d1b\u5e0c\u547d\u540d\u3002\uff08\u6458\u81ea\u767e\u5ea6\u767e\u79d1\uff09 \u5927\u5929\u4f53\u5bc6\u5ea6\u4e0e\u5c0f\u5929\u4f53\u7684\u5bc6\u5ea6\u7684\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u540e\uff0c\u518d\u4e58\u4ee5\u5927\u5929\u4f53\u7684\u534a\u5f84\u4ee5\u53ca\u4e00\u4e2a\u500d\u6570\uff08\u6d41\u4f53\u5bf9\u5e94\u7684\u500d\u6570\u662f 2.455\uff0c\u521a\u4f53\u5bf9\u5e94\u7684\u500d\u6570\u662f 1.26\uff09\uff0c\u5c31\u662f\u6d1b\u5e0c\u6781\u9650\u7684\u503c\u3002\u4f8b\u5982\u6728\u661f\u4e0e\u5730\u7403\u7684\u5bc6\u5ea6\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u662f 0.622\uff0c\u5982\u679c\u5047\u8bbe\u5730\u7403\u662f\u6d41\u4f53\uff0c\u90a3\u4e48\u6d1b\u5e0c\u6781\u9650\u5c31\u662f 0.622\\times 2.455=1.52701 0.622\\times 2.455=1.52701 \u500d\u6728\u661f\u534a\u5f84\uff1b\u4f46\u5730\u7403\u662f\u521a\u4f53\uff0c\u5bf9\u5e94\u7684\u6d1b\u5e0c\u6781\u9650\u662f 0.622\\times 1.26=0.78372 0.622\\times 1.26=0.78372 \u500d\u6728\u661f\u534a\u5f84\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u6bd4\u6728\u661f\u534a\u5f84\u5c0f\uff0c\u5373\u53ea\u6709\u5f53\u5730\u7403\u4f4d\u4e8e\u6728\u661f\u5185\u90e8\u7684\u65f6\u5019\u624d\u4f1a\u88ab\u6495\u788e\uff0c\u6362\u8a00\u4e4b\uff0c\u5c31\u662f\u5730\u7403\u4e0d\u53ef\u80fd\u88ab\u6495\u788e\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u4e00\u4e2a\u5c0f\u5929\u4f53\u4f1a\u4e0d\u4f1a\u88ab\u4e00\u4e2a\u5927\u5929\u4f53\u6495\u788e\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6570\u5b57\uff0c\u4f9d\u6b21\u4e3a\uff1a\u5927\u5929\u4f53\u5bc6\u5ea6\u4e0e\u5c0f\u5929\u4f53\u7684\u5bc6\u5ea6\u7684\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u540e\u8ba1\u7b97\u51fa\u7684\u503c\uff08 \\le 1 \\le 1 \uff09\u3001\u5c0f\u5929\u4f53\u7684\u5c5e\u6027\uff080 \u8868\u793a\u6d41\u4f53\u30011 \u8868\u793a\u521a\u4f53\uff09\u3001\u4e24\u4e2a\u5929\u4f53\u7684\u8ddd\u79bb\u4e0e\u5927\u5929\u4f53\u534a\u5f84\u7684\u6bd4\u503c\uff08 >1 >1 \u4f46\u4e0d\u8d85\u8fc7 10\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u5c0f\u5929\u4f53\u7684\u6d1b\u5e0c\u6781\u9650\u4e0e\u5927\u5929\u4f53\u534a\u5f84\u7684\u6bd4\u503c\uff08\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\uff09\uff1b\u968f\u540e\u7a7a\u4e00\u683c\uff1b\u6700\u540e\u8f93\u51fa ^_^ \u5982\u679c\u5c0f\u5929\u4f53\u4e0d\u4f1a\u88ab\u6495\u788e\uff0c\u5426\u5219\u8f93\u51fa T_T \u3002 \u8f93\u5165\u6837\u4f8b 1 0.622 0 1.4 \u8f93\u51fa\u6837\u4f8b 1 1.53 T_T \u8f93\u5165\u6837\u4f8b 2 0.622 1 1.4 \u8f93\u51fa\u6837\u4f8b 2 0.78 ^_^ Solution C++ #include <bits/stdc++.h> using namespace std ; using db = double ; const int N = 1e3 + 10 ; int main () { db a , c , d ; int b ; cin >> a >> b >> c ; if ( ! b ) d = a * 2.455 ; else d = a * 1.26 ; printf ( \"%.2f \" , d ); int _d = round ( d * 100 ); int _c = round ( c * 100 ); if ( _c < _d ) puts ( \"T_T\" ); else puts ( \"^_^\" ); return 0 ; }","title":"L1-067- \u6d1b\u5e0c\u6781\u9650"},{"location":"CCCC/L1-067-%20%E6%B4%9B%E5%B8%8C%E6%9E%81%E9%99%90/#l1-067--\u6d1b\u5e0c\u6781\u9650","text":"","title":"L1-067  \u6d1b\u5e0c\u6781\u9650"},{"location":"CCCC/L1-067-%20%E6%B4%9B%E5%B8%8C%E6%9E%81%E9%99%90/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u79d1\u5e7b\u7535\u5f71\u300a\u6d41\u6d6a\u5730\u7403\u300b\u4e2d\u4e00\u4e2a\u91cd\u8981\u7684\u60c5\u8282\u662f\u5730\u7403\u8ddd\u79bb\u6728\u661f\u592a\u8fd1\u65f6\uff0c\u5927\u6c14\u5f00\u59cb\u88ab\u6728\u661f\u5438\u8d70\uff0c\u800c\u968f\u7740\u4e0d\u65ad\u63a5\u8fd1\u5730\u6728\u201c\u521a\u4f53\u6d1b\u5e0c\u6781\u9650\u201d\uff0c\u5730\u7403\u9762\u4e34\u88ab\u5f7b\u5e95\u6495\u788e\u7684\u5371\u9669\u3002\u4f46\u5b9e\u9645\u4e0a\uff0c\u8fd9\u4e2a\u8ba1\u7b97\u662f\u9519\u8bef\u7684\u3002 \u6d1b\u5e0c\u6781\u9650\uff08Roche limit\uff09\u662f\u4e00\u4e2a\u5929\u4f53\u81ea\u8eab\u7684\u5f15\u529b\u4e0e\u7b2c\u4e8c\u4e2a\u5929\u4f53\u9020\u6210\u7684\u6f6e\u6c50\u529b\u76f8\u7b49\u65f6\u7684\u8ddd\u79bb\u3002\u5f53\u4e24\u4e2a\u5929\u4f53\u7684\u8ddd\u79bb\u5c11\u4e8e\u6d1b\u5e0c\u6781\u9650\uff0c\u5929\u4f53\u5c31\u4f1a\u503e\u5411\u788e\u6563\uff0c\u7ee7\u800c\u6210\u4e3a\u7b2c\u4e8c\u4e2a\u5929\u4f53\u7684\u73af\u3002\u5b83\u4ee5\u9996\u4f4d\u8ba1\u7b97\u8fd9\u4e2a\u6781\u9650\u7684\u4eba\u7231\u5fb7\u534e\u00b7\u6d1b\u5e0c\u547d\u540d\u3002\uff08\u6458\u81ea\u767e\u5ea6\u767e\u79d1\uff09 \u5927\u5929\u4f53\u5bc6\u5ea6\u4e0e\u5c0f\u5929\u4f53\u7684\u5bc6\u5ea6\u7684\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u540e\uff0c\u518d\u4e58\u4ee5\u5927\u5929\u4f53\u7684\u534a\u5f84\u4ee5\u53ca\u4e00\u4e2a\u500d\u6570\uff08\u6d41\u4f53\u5bf9\u5e94\u7684\u500d\u6570\u662f 2.455\uff0c\u521a\u4f53\u5bf9\u5e94\u7684\u500d\u6570\u662f 1.26\uff09\uff0c\u5c31\u662f\u6d1b\u5e0c\u6781\u9650\u7684\u503c\u3002\u4f8b\u5982\u6728\u661f\u4e0e\u5730\u7403\u7684\u5bc6\u5ea6\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u662f 0.622\uff0c\u5982\u679c\u5047\u8bbe\u5730\u7403\u662f\u6d41\u4f53\uff0c\u90a3\u4e48\u6d1b\u5e0c\u6781\u9650\u5c31\u662f 0.622\\times 2.455=1.52701 0.622\\times 2.455=1.52701 \u500d\u6728\u661f\u534a\u5f84\uff1b\u4f46\u5730\u7403\u662f\u521a\u4f53\uff0c\u5bf9\u5e94\u7684\u6d1b\u5e0c\u6781\u9650\u662f 0.622\\times 1.26=0.78372 0.622\\times 1.26=0.78372 \u500d\u6728\u661f\u534a\u5f84\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u6bd4\u6728\u661f\u534a\u5f84\u5c0f\uff0c\u5373\u53ea\u6709\u5f53\u5730\u7403\u4f4d\u4e8e\u6728\u661f\u5185\u90e8\u7684\u65f6\u5019\u624d\u4f1a\u88ab\u6495\u788e\uff0c\u6362\u8a00\u4e4b\uff0c\u5c31\u662f\u5730\u7403\u4e0d\u53ef\u80fd\u88ab\u6495\u788e\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u4e00\u4e2a\u5c0f\u5929\u4f53\u4f1a\u4e0d\u4f1a\u88ab\u4e00\u4e2a\u5927\u5929\u4f53\u6495\u788e\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6570\u5b57\uff0c\u4f9d\u6b21\u4e3a\uff1a\u5927\u5929\u4f53\u5bc6\u5ea6\u4e0e\u5c0f\u5929\u4f53\u7684\u5bc6\u5ea6\u7684\u6bd4\u503c\u5f00 3 \u6b21\u65b9\u540e\u8ba1\u7b97\u51fa\u7684\u503c\uff08 \\le 1 \\le 1 \uff09\u3001\u5c0f\u5929\u4f53\u7684\u5c5e\u6027\uff080 \u8868\u793a\u6d41\u4f53\u30011 \u8868\u793a\u521a\u4f53\uff09\u3001\u4e24\u4e2a\u5929\u4f53\u7684\u8ddd\u79bb\u4e0e\u5927\u5929\u4f53\u534a\u5f84\u7684\u6bd4\u503c\uff08 >1 >1 \u4f46\u4e0d\u8d85\u8fc7 10\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u5c0f\u5929\u4f53\u7684\u6d1b\u5e0c\u6781\u9650\u4e0e\u5927\u5929\u4f53\u534a\u5f84\u7684\u6bd4\u503c\uff08\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\uff09\uff1b\u968f\u540e\u7a7a\u4e00\u683c\uff1b\u6700\u540e\u8f93\u51fa ^_^ \u5982\u679c\u5c0f\u5929\u4f53\u4e0d\u4f1a\u88ab\u6495\u788e\uff0c\u5426\u5219\u8f93\u51fa T_T \u3002 \u8f93\u5165\u6837\u4f8b 1 0.622 0 1.4 \u8f93\u51fa\u6837\u4f8b 1 1.53 T_T \u8f93\u5165\u6837\u4f8b 2 0.622 1 1.4 \u8f93\u51fa\u6837\u4f8b 2 0.78 ^_^","title":"Statement"},{"location":"CCCC/L1-067-%20%E6%B4%9B%E5%B8%8C%E6%9E%81%E9%99%90/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = double ; const int N = 1e3 + 10 ; int main () { db a , c , d ; int b ; cin >> a >> b >> c ; if ( ! b ) d = a * 2.455 ; else d = a * 1.26 ; printf ( \"%.2f \" , d ); int _d = round ( d * 100 ); int _c = round ( c * 100 ); if ( _c < _d ) puts ( \"T_T\" ); else puts ( \"^_^\" ); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-068-%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87/","text":"L1-068 \u8c03\u548c\u5e73\u5747 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB N N \u4e2a\u6b63\u6570\u7684 \u7b97\u6570\u5e73\u5747 \u662f\u8fd9\u4e9b\u6570\u7684\u548c\u9664\u4ee5 N N \uff0c\u5b83\u4eec\u7684 \u8c03\u548c\u5e73\u5747 \u662f\u5b83\u4eec\u5012\u6570\u7684\u7b97\u6570\u5e73\u5747\u7684\u5012\u6570\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u8ba1\u7b97\u7ed9\u5b9a\u7684\u4e00\u7cfb\u5217\u6b63\u6570\u7684\u8c03\u548c\u5e73\u5747\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N ( \\le 1000 \\le 1000 )\uff1b\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\uff0c\u90fd\u5728\u533a\u95f4 [0.1, 100] [0.1, 100] \u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed9\u5b9a\u6570\u5217\u7684\u8c03\u548c\u5e73\u5747\u503c\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 8 10 15 12.7 0.3 4 13 1 15.6 \u8f93\u51fa\u6837\u4f8b 1.61 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = double ; int main () { int n ; cin >> n ; db sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { db x ; cin >> x ; sum += 1.0 / x ; } printf ( \"%.2f \\n \" , n * 1.0 / sum ); return 0 ; }","title":"L1-068-\u8c03\u548c\u5e73\u5747"},{"location":"CCCC/L1-068-%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87/#l1-068-\u8c03\u548c\u5e73\u5747","text":"","title":"L1-068 \u8c03\u548c\u5e73\u5747"},{"location":"CCCC/L1-068-%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB N N \u4e2a\u6b63\u6570\u7684 \u7b97\u6570\u5e73\u5747 \u662f\u8fd9\u4e9b\u6570\u7684\u548c\u9664\u4ee5 N N \uff0c\u5b83\u4eec\u7684 \u8c03\u548c\u5e73\u5747 \u662f\u5b83\u4eec\u5012\u6570\u7684\u7b97\u6570\u5e73\u5747\u7684\u5012\u6570\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u8ba1\u7b97\u7ed9\u5b9a\u7684\u4e00\u7cfb\u5217\u6b63\u6570\u7684\u8c03\u548c\u5e73\u5747\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N ( \\le 1000 \\le 1000 )\uff1b\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\uff0c\u90fd\u5728\u533a\u95f4 [0.1, 100] [0.1, 100] \u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed9\u5b9a\u6570\u5217\u7684\u8c03\u548c\u5e73\u5747\u503c\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 8 10 15 12.7 0.3 4 13 1 15.6 \u8f93\u51fa\u6837\u4f8b 1.61","title":"Statement"},{"location":"CCCC/L1-068-%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = double ; int main () { int n ; cin >> n ; db sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { db x ; cin >> x ; sum += 1.0 / x ; } printf ( \"%.2f \\n \" , n * 1.0 / sum ); return 0 ; }","title":"Solution"},{"location":"CCCC/L1-069-%E8%83%8E%E5%8E%8B%E7%9B%91%E6%B5%8B/","text":"L1-069 \u80ce\u538b\u76d1\u6d4b Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u8f7f\u8f66\u4e2d\u6709\u4e00\u4e2a\u7cfb\u7edf\u968f\u65f6\u76d1\u6d4b\u56db\u4e2a\u8f66\u8f6e\u7684\u80ce\u538b\uff0c\u5982\u679c\u56db\u8f6e\u80ce\u538b\u4e0d\u662f\u5f88\u5e73\u8861\uff0c\u5219\u53ef\u80fd\u5bf9\u884c\u8f66\u9020\u6210\u4e25\u91cd\u7684\u5f71\u54cd\u3002 \u8ba9\u6211\u4eec\u628a\u56db\u4e2a\u8f66\u8f6e \u2014\u2014 \u5de6\u524d\u8f6e\u3001\u53f3\u524d\u8f6e\u3001\u53f3\u540e\u8f6e\u3001\u5de6\u540e\u8f6e \u2014\u2014 \u987a\u6b21\u7f16\u53f7\u4e3a 1\u30012\u30013\u30014\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u76d1\u6d4b\u7a0b\u5e8f\uff0c\u968f\u65f6\u76d1\u6d4b\u56db\u8f6e\u7684\u80ce\u538b\uff0c\u5e76\u7ed9\u51fa\u6b63\u786e\u7684\u62a5\u8b66\u4fe1\u606f\u3002\u62a5\u8b66\u89c4\u5219\u5982\u4e0b\uff1a \u5982\u679c\u6240\u6709\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u5728\u4e00\u4e2a\u7ed9\u5b9a\u9608\u503c\u5185\uff0c\u5e76\u4e14\u90fd\u4e0d\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u8bf4\u660e\u60c5\u51b5\u6b63\u5e38\uff0c\u4e0d\u62a5\u8b66\uff1b \u5982\u679c\u5b58\u5728\u4e00\u4e2a\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u6216\u8005\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u4e0d\u4ec5\u8981\u62a5\u8b66\uff0c\u800c\u4e14\u8981\u7ed9\u51fa\u53ef\u80fd\u6f0f\u6c14\u7684\u8f6e\u80ce\u7684\u51c6\u786e\u4f4d\u7f6e\uff1b \u5982\u679c\u5b58\u5728\u4e24\u4e2a\u6216\u4e24\u4e2a\u4ee5\u4e0a\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u6216\u8005\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u62a5\u8b66\u8981\u6c42\u68c0\u67e5\u6240\u6709\u8f6e\u80ce\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 6 \u4e2a [0, 400] \u8303\u56f4\u5185\u7684\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a 1~4 \u53f7\u8f6e\u80ce\u7684\u80ce\u538b\u3001\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\u3001\u4ee5\u53ca\u80ce\u538b\u5dee\u7684\u9608\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8f93\u5165\u7684\u80ce\u538b\u503c\u7ed9\u51fa\u5bf9\u5e94\u4fe1\u606f\uff1a \u5982\u679c\u4e0d\u7528\u62a5\u8b66\uff0c\u8f93\u51fa Normal \uff1b \u5982\u679c\u6709\u4e00\u4e2a\u8f6e\u80ce\u9700\u8981\u62a5\u8b66\uff0c\u8f93\u51fa Warning: please check #X! \uff0c\u5176\u4e2d X \u662f\u51fa\u95ee\u9898\u7684\u8f6e\u80ce\u7684\u7f16\u53f7\uff1b \u5982\u679c\u9700\u8981\u68c0\u67e5\u6240\u6709\u8f6e\u80ce\uff0c\u8f93\u51fa Warning: please check all the tires! \u3002 \u8f93\u5165\u6837\u4f8b 1 242 251 231 248 230 20 \u8f93\u51fa\u6837\u4f8b 1 Normal \u8f93\u5165\u6837\u4f8b 2 242 251 232 248 230 10 \u8f93\u51fa\u6837\u4f8b 2 Warning: please check #3! \u8f93\u5165\u6837\u4f8b 3 240 251 232 248 240 10 \u8f93\u51fa\u6837\u4f8b 3 Warning: please check all the tires! Solution C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using pII = pair < int , int > ; #define fi first #define se second const int N = 1e3 + 10 ; int main () { pII a [ 10 ]; int b , c ; for ( int i = 1 ; i <= 4 ; ++ i ) { cin >> a [ i ]. fi ; a [ i ]. se = i ; } cin >> b >> c ; sort ( a + 1 , a + 5 ); int gap = a [ 4 ]. fi - a [ 1 ]. fi ; if ( gap <= c && a [ 1 ]. fi >= b ) { cout << \"Normal \\n \" ; } else { gap = a [ 4 ]. fi - a [ 2 ]. fi ; if ( gap > c || a [ 2 ]. fi < b ) { cout << \"Warning: please check all the tires! \\n \" ; } else { cout << \"Warning: please check #\" << a [ 1 ]. se << \"! \\n \" ; } } return 0 ; }","title":"L1-069-\u80ce\u538b\u76d1\u6d4b"},{"location":"CCCC/L1-069-%E8%83%8E%E5%8E%8B%E7%9B%91%E6%B5%8B/#l1-069-\u80ce\u538b\u76d1\u6d4b","text":"","title":"L1-069 \u80ce\u538b\u76d1\u6d4b"},{"location":"CCCC/L1-069-%E8%83%8E%E5%8E%8B%E7%9B%91%E6%B5%8B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u8f7f\u8f66\u4e2d\u6709\u4e00\u4e2a\u7cfb\u7edf\u968f\u65f6\u76d1\u6d4b\u56db\u4e2a\u8f66\u8f6e\u7684\u80ce\u538b\uff0c\u5982\u679c\u56db\u8f6e\u80ce\u538b\u4e0d\u662f\u5f88\u5e73\u8861\uff0c\u5219\u53ef\u80fd\u5bf9\u884c\u8f66\u9020\u6210\u4e25\u91cd\u7684\u5f71\u54cd\u3002 \u8ba9\u6211\u4eec\u628a\u56db\u4e2a\u8f66\u8f6e \u2014\u2014 \u5de6\u524d\u8f6e\u3001\u53f3\u524d\u8f6e\u3001\u53f3\u540e\u8f6e\u3001\u5de6\u540e\u8f6e \u2014\u2014 \u987a\u6b21\u7f16\u53f7\u4e3a 1\u30012\u30013\u30014\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u76d1\u6d4b\u7a0b\u5e8f\uff0c\u968f\u65f6\u76d1\u6d4b\u56db\u8f6e\u7684\u80ce\u538b\uff0c\u5e76\u7ed9\u51fa\u6b63\u786e\u7684\u62a5\u8b66\u4fe1\u606f\u3002\u62a5\u8b66\u89c4\u5219\u5982\u4e0b\uff1a \u5982\u679c\u6240\u6709\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u5728\u4e00\u4e2a\u7ed9\u5b9a\u9608\u503c\u5185\uff0c\u5e76\u4e14\u90fd\u4e0d\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u8bf4\u660e\u60c5\u51b5\u6b63\u5e38\uff0c\u4e0d\u62a5\u8b66\uff1b \u5982\u679c\u5b58\u5728\u4e00\u4e2a\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u6216\u8005\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u4e0d\u4ec5\u8981\u62a5\u8b66\uff0c\u800c\u4e14\u8981\u7ed9\u51fa\u53ef\u80fd\u6f0f\u6c14\u7684\u8f6e\u80ce\u7684\u51c6\u786e\u4f4d\u7f6e\uff1b \u5982\u679c\u5b58\u5728\u4e24\u4e2a\u6216\u4e24\u4e2a\u4ee5\u4e0a\u8f6e\u80ce\u7684\u538b\u529b\u503c\u4e0e\u5b83\u4eec\u4e2d\u7684\u6700\u5927\u503c\u8bef\u5dee\u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u6216\u8005\u4f4e\u4e8e\u7cfb\u7edf\u8bbe\u5b9a\u7684\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\uff0c\u5219\u62a5\u8b66\u8981\u6c42\u68c0\u67e5\u6240\u6709\u8f6e\u80ce\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 6 \u4e2a [0, 400] \u8303\u56f4\u5185\u7684\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a 1~4 \u53f7\u8f6e\u80ce\u7684\u80ce\u538b\u3001\u6700\u4f4e\u62a5\u8b66\u80ce\u538b\u3001\u4ee5\u53ca\u80ce\u538b\u5dee\u7684\u9608\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8f93\u5165\u7684\u80ce\u538b\u503c\u7ed9\u51fa\u5bf9\u5e94\u4fe1\u606f\uff1a \u5982\u679c\u4e0d\u7528\u62a5\u8b66\uff0c\u8f93\u51fa Normal \uff1b \u5982\u679c\u6709\u4e00\u4e2a\u8f6e\u80ce\u9700\u8981\u62a5\u8b66\uff0c\u8f93\u51fa Warning: please check #X! \uff0c\u5176\u4e2d X \u662f\u51fa\u95ee\u9898\u7684\u8f6e\u80ce\u7684\u7f16\u53f7\uff1b \u5982\u679c\u9700\u8981\u68c0\u67e5\u6240\u6709\u8f6e\u80ce\uff0c\u8f93\u51fa Warning: please check all the tires! \u3002 \u8f93\u5165\u6837\u4f8b 1 242 251 231 248 230 20 \u8f93\u51fa\u6837\u4f8b 1 Normal \u8f93\u5165\u6837\u4f8b 2 242 251 232 248 230 10 \u8f93\u51fa\u6837\u4f8b 2 Warning: please check #3! \u8f93\u5165\u6837\u4f8b 3 240 251 232 248 240 10 \u8f93\u51fa\u6837\u4f8b 3 Warning: please check all the tires!","title":"Statement"},{"location":"CCCC/L1-069-%E8%83%8E%E5%8E%8B%E7%9B%91%E6%B5%8B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using pII = pair < int , int > ; #define fi first #define se second const int N = 1e3 + 10 ; int main () { pII a [ 10 ]; int b , c ; for ( int i = 1 ; i <= 4 ; ++ i ) { cin >> a [ i ]. fi ; a [ i ]. se = i ; } cin >> b >> c ; sort ( a + 1 , a + 5 ); int gap = a [ 4 ]. fi - a [ 1 ]. fi ; if ( gap <= c && a [ 1 ]. fi >= b ) { cout << \"Normal \\n \" ; } else { gap = a [ 4 ]. fi - a [ 2 ]. fi ; if ( gap > c || a [ 2 ]. fi < b ) { cout << \"Warning: please check all the tires! \\n \" ; } else { cout << \"Warning: please check #\" << a [ 1 ]. se << \"! \\n \" ; } } return 0 ; }","title":"Solution"},{"location":"CCCC/L1-070-%E5%90%83%E7%81%AB%E9%94%85/","text":"L1-070 \u5403\u706b\u9505 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u56fe\u7247\u6765\u81ea\u5fae\u4fe1\u670b\u53cb\u5708\uff1a\u8fd9\u79cd\u5929\u6c14\u4f60\u6709\u4ec0\u4e48\u7834\u4e8b\u6253\u7535\u8bdd\u7ed9\u6211\u57fa\u672c\u6ca1\u7528\u3002\u4f46\u662f\u5982\u679c\u4f60\u8bf4\u201c\u5403\u706b\u9505\u201d\uff0c\u90a3\u5c31\u5389\u5bb3\u4e86\uff0c\u6211\u4eec\u7684\u6545\u4e8b\u5c31\u5f00\u59cb\u4e86\u3002 \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u81ea\u52a8\u68c0\u67e5\u4f60\u670b\u53cb\u7ed9\u4f60\u53d1\u6765\u7684\u4fe1\u606f\u91cc\u6709\u6ca1\u6709 chi1 huo3 guo1 \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u3001\u4ee5\u56de\u8f66\u7ed3\u5c3e\u7684\u670b\u53cb\u4fe1\u606f\uff0c\u4fe1\u606f\u4e3a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ec5\u5305\u62ec\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u7a7a\u683c\u3001\u53ef\u89c1\u7684\u534a\u89d2\u6807\u70b9\u7b26\u53f7\u3002\u5f53\u8bfb\u5230\u67d0\u4e00\u884c\u53ea\u6709\u4e00\u4e2a\u82f1\u6587\u53e5\u70b9 . \u65f6\uff0c\u8f93\u5165\u7ed3\u675f\uff0c\u6b64\u884c\u4e0d\u7b97\u5728\u670b\u53cb\u4fe1\u606f\u91cc\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u670b\u53cb\u4fe1\u606f\u7684\u603b\u6761\u6570\u3002\u7136\u540e\u5bf9\u670b\u53cb\u7684\u6bcf\u4e00\u884c\u4fe1\u606f\uff0c\u68c0\u67e5\u5176\u4e2d\u662f\u5426\u5305\u542b chi1 huo3 guo1 \uff0c\u5e76\u4e14\u7edf\u8ba1\u8fd9\u6837\u5389\u5bb3\u7684\u4fe1\u606f\u6709\u591a\u5c11\u6761\u3002\u5728\u7b2c\u4e8c\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u7b2c\u4e00\u6b21\u51fa\u73b0 chi1 huo3 guo1 \u7684\u4fe1\u606f\u662f\u7b2c\u51e0\u6761\uff08\u4ece 1 \u5f00\u59cb\u8ba1\u6570\uff09\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u7c7b\u4fe1\u606f\u7684\u603b\u6761\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u7684\u6240\u6709\u6570\u5b57\u4e0d\u8d85\u8fc7 100\u3002 \u5982\u679c\u670b\u53cb\u4ece\u5934\u5230\u5c3e\u90fd\u6ca1\u63d0 chi1 huo3 guo1 \u8fd9\u4e2a\u5173\u952e\u8bcd\uff0c\u5219\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u4e00\u4e2a\u8868\u60c5 -_-# \u3002 \u8f93\u5165\u6837\u4f8b 1 Hello! are you there? wantta chi1 huo3 guo1? that's so li hai le our story begins from chi1 huo3 guo1 le . \u8f93\u51fa\u6837\u4f8b 1 5 3 2 \u8f93\u5165\u6837\u4f8b 2 Hello! are you there? wantta qi huo3 guo1 chi1huo3guo1? that's so li hai le our story begins from ci1 huo4 guo2 le . \u8f93\u51fa\u6837\u4f8b 2 5 -_-# Solution C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; const int N = 1e3 + 10 ; vector < string > run ( string & s ) { string t = \"\" ; vector < string > vec ; for ( auto & c : s ) { if ( c == ' ' ) { if ( t . size () > 0 ) { vec . push_back ( t ); } t = \"\" ; } else { t += c ; } } if ( t . size () > 0 ) vec . push_back ( t ); return vec ; } bool gao ( string s ) { if ( s . find ( \"chi1 huo3 guo1\" ) != -1 ) return true ; return false ; cout << s << endl ; vector < string > vec ( run ( s )); for ( int i = 2 ; i < ( int ) vec . size (); ++ i ) { if ( vec [ i - 2 ] == \"chi1\" && vec [ i - 1 ] == \"huo3\" && vec [ i - 2 ] == \"guo1\" ) { return true ; } } return false ; } int main () { string s ; vector < string > vec ; while ( 1 ) { getline ( cin , s ); if ( s == \".\" ) break ; vec . push_back ( s ); } cout << vec . size () << endl ; int res = 0 , ix = 0 ; for ( auto & s : vec ) { if ( res < 1 ) ++ ix ; res += gao ( s ); } if ( res == 0 ) cout << \"-_-# \\n \" ; else cout << ix << ' ' << res << endl ; return 0 ; }","title":"L1-070-\u5403\u706b\u9505"},{"location":"CCCC/L1-070-%E5%90%83%E7%81%AB%E9%94%85/#l1-070-\u5403\u706b\u9505","text":"","title":"L1-070 \u5403\u706b\u9505"},{"location":"CCCC/L1-070-%E5%90%83%E7%81%AB%E9%94%85/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0a\u56fe\u7247\u6765\u81ea\u5fae\u4fe1\u670b\u53cb\u5708\uff1a\u8fd9\u79cd\u5929\u6c14\u4f60\u6709\u4ec0\u4e48\u7834\u4e8b\u6253\u7535\u8bdd\u7ed9\u6211\u57fa\u672c\u6ca1\u7528\u3002\u4f46\u662f\u5982\u679c\u4f60\u8bf4\u201c\u5403\u706b\u9505\u201d\uff0c\u90a3\u5c31\u5389\u5bb3\u4e86\uff0c\u6211\u4eec\u7684\u6545\u4e8b\u5c31\u5f00\u59cb\u4e86\u3002 \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u81ea\u52a8\u68c0\u67e5\u4f60\u670b\u53cb\u7ed9\u4f60\u53d1\u6765\u7684\u4fe1\u606f\u91cc\u6709\u6ca1\u6709 chi1 huo3 guo1 \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u3001\u4ee5\u56de\u8f66\u7ed3\u5c3e\u7684\u670b\u53cb\u4fe1\u606f\uff0c\u4fe1\u606f\u4e3a\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ec5\u5305\u62ec\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u7a7a\u683c\u3001\u53ef\u89c1\u7684\u534a\u89d2\u6807\u70b9\u7b26\u53f7\u3002\u5f53\u8bfb\u5230\u67d0\u4e00\u884c\u53ea\u6709\u4e00\u4e2a\u82f1\u6587\u53e5\u70b9 . \u65f6\uff0c\u8f93\u5165\u7ed3\u675f\uff0c\u6b64\u884c\u4e0d\u7b97\u5728\u670b\u53cb\u4fe1\u606f\u91cc\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u670b\u53cb\u4fe1\u606f\u7684\u603b\u6761\u6570\u3002\u7136\u540e\u5bf9\u670b\u53cb\u7684\u6bcf\u4e00\u884c\u4fe1\u606f\uff0c\u68c0\u67e5\u5176\u4e2d\u662f\u5426\u5305\u542b chi1 huo3 guo1 \uff0c\u5e76\u4e14\u7edf\u8ba1\u8fd9\u6837\u5389\u5bb3\u7684\u4fe1\u606f\u6709\u591a\u5c11\u6761\u3002\u5728\u7b2c\u4e8c\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u7b2c\u4e00\u6b21\u51fa\u73b0 chi1 huo3 guo1 \u7684\u4fe1\u606f\u662f\u7b2c\u51e0\u6761\uff08\u4ece 1 \u5f00\u59cb\u8ba1\u6570\uff09\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u7c7b\u4fe1\u606f\u7684\u603b\u6761\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u7684\u6240\u6709\u6570\u5b57\u4e0d\u8d85\u8fc7 100\u3002 \u5982\u679c\u670b\u53cb\u4ece\u5934\u5230\u5c3e\u90fd\u6ca1\u63d0 chi1 huo3 guo1 \u8fd9\u4e2a\u5173\u952e\u8bcd\uff0c\u5219\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u4e00\u4e2a\u8868\u60c5 -_-# \u3002 \u8f93\u5165\u6837\u4f8b 1 Hello! are you there? wantta chi1 huo3 guo1? that's so li hai le our story begins from chi1 huo3 guo1 le . \u8f93\u51fa\u6837\u4f8b 1 5 3 2 \u8f93\u5165\u6837\u4f8b 2 Hello! are you there? wantta qi huo3 guo1 chi1huo3guo1? that's so li hai le our story begins from ci1 huo4 guo2 le . \u8f93\u51fa\u6837\u4f8b 2 5 -_-#","title":"Statement"},{"location":"CCCC/L1-070-%E5%90%83%E7%81%AB%E9%94%85/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; const int N = 1e3 + 10 ; vector < string > run ( string & s ) { string t = \"\" ; vector < string > vec ; for ( auto & c : s ) { if ( c == ' ' ) { if ( t . size () > 0 ) { vec . push_back ( t ); } t = \"\" ; } else { t += c ; } } if ( t . size () > 0 ) vec . push_back ( t ); return vec ; } bool gao ( string s ) { if ( s . find ( \"chi1 huo3 guo1\" ) != -1 ) return true ; return false ; cout << s << endl ; vector < string > vec ( run ( s )); for ( int i = 2 ; i < ( int ) vec . size (); ++ i ) { if ( vec [ i - 2 ] == \"chi1\" && vec [ i - 1 ] == \"huo3\" && vec [ i - 2 ] == \"guo1\" ) { return true ; } } return false ; } int main () { string s ; vector < string > vec ; while ( 1 ) { getline ( cin , s ); if ( s == \".\" ) break ; vec . push_back ( s ); } cout << vec . size () << endl ; int res = 0 , ix = 0 ; for ( auto & s : vec ) { if ( res < 1 ) ++ ix ; res += gao ( s ); } if ( res == 0 ) cout << \"-_-# \\n \" ; else cout << ix << ' ' << res << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L1-071-%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/","text":"L1-071 \u524d\u4e16\u6863\u6848 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f51\u7edc\u4e16\u754c\u4e2d\u65f6\u5e38\u4f1a\u9047\u5230\u8fd9\u7c7b\u6ed1\u7a3d\u7684\u7b97\u547d\u5c0f\u7a0b\u5e8f\uff0c\u5b9e\u73b0\u539f\u7406\u5f88\u7b80\u5355\uff0c\u968f\u4fbf\u8bbe\u8ba1\u51e0\u4e2a\u95ee\u9898\uff0c\u6839\u636e\u73a9\u5bb6\u5bf9\u6bcf\u4e2a\u95ee\u9898\u7684\u56de\u7b54\u9009\u62e9\u4e00\u6761\u5224\u65ad\u6811\u4e2d\u7684\u8def\u5f84\uff08\u5982\u4e0b\u56fe\u6240\u793a\uff09\uff0c\u7ed3\u8bba\u5c31\u662f\u8def\u5f84\u7ec8\u70b9\u5bf9\u5e94\u7684\u90a3\u4e2a\u7ed3\u70b9\u3002 \u73b0\u5728\u6211\u4eec\u628a\u7ed3\u8bba\u4ece\u5de6\u5230\u53f3\u987a\u5e8f\u7f16\u53f7\uff0c\u7f16\u53f7\u4ece 1 \u5f00\u59cb\u3002\u8fd9\u91cc\u5047\u8bbe\u56de\u7b54\u90fd\u662f\u7b80\u5355\u7684\u201c\u662f\u201d\u6216\u201c\u5426\u201d\uff0c\u53c8\u5047\u8bbe\u56de\u7b54\u201c\u662f\u201d\u5bf9\u5e94\u5411\u5de6\u7684\u8def\u5f84\uff0c\u56de\u7b54\u201c\u5426\u201d\u5bf9\u5e94\u5411\u53f3\u7684\u8def\u5f84\u3002\u7ed9\u5b9a\u73a9\u5bb6\u7684\u4e00\u7cfb\u5217\u56de\u7b54\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u5f97\u5230\u7684\u7ed3\u8bba\u7684\u7f16\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 30 \\le 30 \uff09\u4e3a\u73a9\u5bb6\u505a\u4e00\u6b21\u6d4b\u8bd5\u8981\u56de\u7b54\u7684\u95ee\u9898\u6570\u91cf\uff1b M M \uff08 \\le 100 \\le 100 \uff09\u4e3a\u73a9\u5bb6\u4eba\u6570\u3002 \u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u73a9\u5bb6\u7684 N N \u4e2a\u56de\u7b54\u3002\u8fd9\u91cc\u7528 y \u4ee3\u8868\u201c\u662f\u201d\uff0c\u7528 n \u4ee3\u8868\u201c\u5426\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u73a9\u5bb6\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5176\u5bf9\u5e94\u7684\u7ed3\u8bba\u7684\u7f16\u53f7\u3002 \u8f93\u5165\u6837\u4f8b 3 4 yny nyy nyn yyn \u8f93\u51fa\u6837\u4f8b 3 5 6 2 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; const int N = 1e3 + 10 ; using ll = long long ; int n , q ; ll res ; void dfs ( string s , int dep ) { if ( s . empty ()) return ; char ch = s . back (); s . pop_back (); if ( ch == 'n' ) { res += ( 1l l << ( n - dep - 1 )); } dfs ( s , dep + 1 ); } ll gao ( string s ) { res = 0 ; reverse ( s . begin (), s . end ()); dfs ( s , 0 ); return res ; } int main () { string s ; cin >> n >> q ; for ( int i = 1 ; i <= q ; ++ i ) { cin >> s ; cout << gao ( s ) + 1 << '\\n' ; } return 0 ; }","title":"L1-071-\u524d\u4e16\u6863\u6848"},{"location":"CCCC/L1-071-%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/#l1-071-\u524d\u4e16\u6863\u6848","text":"","title":"L1-071 \u524d\u4e16\u6863\u6848"},{"location":"CCCC/L1-071-%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f51\u7edc\u4e16\u754c\u4e2d\u65f6\u5e38\u4f1a\u9047\u5230\u8fd9\u7c7b\u6ed1\u7a3d\u7684\u7b97\u547d\u5c0f\u7a0b\u5e8f\uff0c\u5b9e\u73b0\u539f\u7406\u5f88\u7b80\u5355\uff0c\u968f\u4fbf\u8bbe\u8ba1\u51e0\u4e2a\u95ee\u9898\uff0c\u6839\u636e\u73a9\u5bb6\u5bf9\u6bcf\u4e2a\u95ee\u9898\u7684\u56de\u7b54\u9009\u62e9\u4e00\u6761\u5224\u65ad\u6811\u4e2d\u7684\u8def\u5f84\uff08\u5982\u4e0b\u56fe\u6240\u793a\uff09\uff0c\u7ed3\u8bba\u5c31\u662f\u8def\u5f84\u7ec8\u70b9\u5bf9\u5e94\u7684\u90a3\u4e2a\u7ed3\u70b9\u3002 \u73b0\u5728\u6211\u4eec\u628a\u7ed3\u8bba\u4ece\u5de6\u5230\u53f3\u987a\u5e8f\u7f16\u53f7\uff0c\u7f16\u53f7\u4ece 1 \u5f00\u59cb\u3002\u8fd9\u91cc\u5047\u8bbe\u56de\u7b54\u90fd\u662f\u7b80\u5355\u7684\u201c\u662f\u201d\u6216\u201c\u5426\u201d\uff0c\u53c8\u5047\u8bbe\u56de\u7b54\u201c\u662f\u201d\u5bf9\u5e94\u5411\u5de6\u7684\u8def\u5f84\uff0c\u56de\u7b54\u201c\u5426\u201d\u5bf9\u5e94\u5411\u53f3\u7684\u8def\u5f84\u3002\u7ed9\u5b9a\u73a9\u5bb6\u7684\u4e00\u7cfb\u5217\u56de\u7b54\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u5f97\u5230\u7684\u7ed3\u8bba\u7684\u7f16\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 30 \\le 30 \uff09\u4e3a\u73a9\u5bb6\u505a\u4e00\u6b21\u6d4b\u8bd5\u8981\u56de\u7b54\u7684\u95ee\u9898\u6570\u91cf\uff1b M M \uff08 \\le 100 \\le 100 \uff09\u4e3a\u73a9\u5bb6\u4eba\u6570\u3002 \u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u73a9\u5bb6\u7684 N N \u4e2a\u56de\u7b54\u3002\u8fd9\u91cc\u7528 y \u4ee3\u8868\u201c\u662f\u201d\uff0c\u7528 n \u4ee3\u8868\u201c\u5426\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u73a9\u5bb6\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5176\u5bf9\u5e94\u7684\u7ed3\u8bba\u7684\u7f16\u53f7\u3002 \u8f93\u5165\u6837\u4f8b 3 4 yny nyy nyn yyn \u8f93\u51fa\u6837\u4f8b 3 5 6 2","title":"Statement"},{"location":"CCCC/L1-071-%E5%89%8D%E4%B8%96%E6%A1%A3%E6%A1%88/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; const int N = 1e3 + 10 ; using ll = long long ; int n , q ; ll res ; void dfs ( string s , int dep ) { if ( s . empty ()) return ; char ch = s . back (); s . pop_back (); if ( ch == 'n' ) { res += ( 1l l << ( n - dep - 1 )); } dfs ( s , dep + 1 ); } ll gao ( string s ) { res = 0 ; reverse ( s . begin (), s . end ()); dfs ( s , 0 ); return res ; } int main () { string s ; cin >> n >> q ; for ( int i = 1 ; i <= q ; ++ i ) { cin >> s ; cout << gao ( s ) + 1 << '\\n' ; } return 0 ; }","title":"Solution"},{"location":"CCCC/L1-072-%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/","text":"L1-072 \u522e\u522e\u5f69\u7968 Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u522e\u522e\u5f69\u7968\u201d\u662f\u4e00\u6b3e\u7f51\u7edc\u6e38\u620f\u91cc\u9762\u7684\u4e00\u4e2a\u5c0f\u6e38\u620f\u3002\u5982\u56fe\u6240\u793a\uff1a \u6bcf\u6b21\u6e38\u620f\u73a9\u5bb6\u4f1a\u62ff\u5230\u4e00\u5f20\u5f69\u7968\uff0c\u4e0a\u9762\u4f1a\u6709 9 \u4e2a\u6570\u5b57\uff0c\u5206\u522b\u4e3a\u6570\u5b57 1 \u5230\u6570\u5b57 9\uff0c\u6570\u5b57\u5404\u4e0d\u91cd\u590d\uff0c\u5e76\u4ee5 3\\times3 3\\times3 \u7684\u201c\u4e5d\u5bab\u683c\u201d\u5f62\u5f0f\u6392\u5e03\u5728\u5f69\u7968\u4e0a\u3002 \u5728\u6e38\u620f\u5f00\u59cb\u65f6\u80fd\u770b\u89c1\u4e00\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\uff0c\u5176\u4ed6\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u5747\u4e0d\u53ef\u89c1\u3002\u4f60\u53ef\u4ee5\u9009\u62e9\u4e09\u4e2a\u4f4d\u7f6e\u7684\u6570\u5b57\u522e\u5f00\uff0c\u8fd9\u6837\u73a9\u5bb6\u5c31\u80fd\u770b\u89c1\u56db\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u4e86\u3002\u6700\u540e\u73a9\u5bb6\u518d\u4ece 3 \u6a2a\u30013 \u7ad6\u30012 \u659c\u5171 8 \u4e2a\u65b9\u5411\u4e2d\u6311\u9009\u4e00\u4e2a\u65b9\u5411\uff0c\u65b9\u5411\u4e0a\u4e09\u4e2a\u6570\u5b57\u7684\u548c\u53ef\u6839\u636e\u4e0b\u5217\u8868\u683c\u8fdb\u884c\u5151\u5956\uff0c\u83b7\u5f97\u5bf9\u5e94\u6570\u989d\u7684\u91d1\u5e01\u3002 \u6570\u5b57\u5408\u8ba1 \u83b7\u5f97\u91d1\u5e01 \u6570\u5b57\u5408\u8ba1 \u83b7\u5f97\u91d1\u5e01 6 10,000 16 72 7 36 17 180 8 720 18 119 9 360 19 36 10 80 20 306 11 252 21 1,080 12 108 22 144 13 72 23 1,800 14 54 24 3,600 15 180 \u73b0\u5728\u8bf7\u4f60\u5199\u51fa\u4e00\u4e2a\u6a21\u62df\u7a0b\u5e8f\uff0c\u6a21\u62df\u73a9\u5bb6\u7684\u6e38\u620f\u8fc7\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u90e8\u5206\u7ed9\u51fa\u4e00\u5f20\u5408\u6cd5\u7684\u5f69\u7968\uff0c\u5373\u7528 3 \u884c 3 \u5217\u7ed9\u51fa 0 \u81f3 9 \u7684\u6570\u5b57\u3002 0 \u8868\u793a\u7684\u662f\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u521d\u59cb\u65f6\u5c31\u80fd\u770b\u89c1\u4e86 \uff0c\u800c\u4e0d\u662f\u5f69\u7968\u4e0a\u7684\u6570\u5b57\u4e3a 0\u3002 \u7b2c\u4e8c\u90e8\u7ed9\u51fa\u73a9\u5bb6\u522e\u5f00\u7684\u4e09\u4e2a\u4f4d\u7f6e\uff0c\u5206\u4e3a\u4e09\u884c\uff0c\u6bcf\u884c\u6309\u683c\u5f0f x y \u7ed9\u51fa\u73a9\u5bb6\u522e\u5f00\u7684\u4f4d\u7f6e\u7684\u884c\u53f7\u548c\u5217\u53f7\uff08\u9898\u76ee\u4e2d\u5b9a\u4e49\u5de6\u4e0a\u89d2\u7684\u4f4d\u7f6e\u4e3a\u7b2c 1 \u884c\u3001\u7b2c 1 \u5217\u3002\uff09\u3002\u6570\u636e\u4fdd\u8bc1\u73a9\u5bb6\u4e0d\u4f1a\u91cd\u590d\u522e\u5f00\u5df2\u522e\u5f00\u7684\u6570\u5b57\u3002 \u6700\u540e\u4e00\u90e8\u5206\u7ed9\u51fa\u73a9\u5bb6\u9009\u62e9\u7684\u65b9\u5411\uff0c\u5373\u4e00\u4e2a\u6574\u6570\uff1a 1 \u81f3 3 \u8868\u793a\u9009\u62e9\u6a2a\u5411\u7684\u7b2c\u4e00\u884c\u3001\u7b2c\u4e8c\u884c\u3001\u7b2c\u4e09\u884c\uff0c4 \u81f3 6 \u8868\u793a\u7eb5\u5411\u7684\u7b2c\u4e00\u5217\u3001\u7b2c\u4e8c\u5217\u3001\u7b2c\u4e09\u5217\uff0c7\u30018\u5206\u522b\u8868\u793a\u5de6\u4e0a\u5230\u53f3\u4e0b\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u53f3\u4e0a\u5230\u5de6\u4e0b\u7684\u526f\u5bf9\u89d2\u7ebf\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u522e\u5f00\u7684\u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u73a9\u5bb6\u80fd\u770b\u5230\u7684\u6570\u5b57\u3002\u6700\u540e\u5bf9\u4e8e\u9009\u62e9\u7684\u65b9\u5411\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u73a9\u5bb6\u83b7\u5f97\u7684\u91d1\u5e01\u6570\u91cf\u3002 \u8f93\u5165\u6837\u4f8b 1 2 3 4 5 6 7 8 0 1 1 2 2 2 3 7 \u8f93\u51fa\u6837\u4f8b 1 5 6 180 Solution C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second const int N = 1e3 + 10 ; int main () { int a [ 4 ][ 4 ], b [ 15 ], c [ 4 ][ 4 ]; for ( int i = 1 ; i <= 3 ; ++ i ) { for ( int j = 1 ; j <= 3 ; ++ j ) { cin >> a [ i ][ j ]; b [ a [ i ][ j ]] = 1 ; c [ i ][ j ] = 1 ; } } int x = -1 ; for ( int i = 1 ; i <= 9 ; ++ i ) { if ( ! b [ i ]) { x = i ; } } for ( int i = 1 ; i <= 3 ; ++ i ) { for ( int j = 1 ; j <= 3 ; ++ j ) { if ( ! a [ i ][ j ]) { a [ i ][ j ] = x ; c [ i ][ j ] = 1 ; } } } for ( int i = 1 , q , w ; i <= 3 ; ++ i ) { cin >> q >> w ; cout << a [ q ][ w ] << endl ; c [ q ][ w ] = 1 ; } int w [] = { 0 , 0 , 0 , 0 , 0 , 0 , 10000 , 36 , 720 , 360 , 80 , 252 , 108 , 72 , 54 , 180 , 72 , 180 , 119 , 36 , 306 , 1080 , 144 , 1800 , 3600 }; int _w ; cin >> _w ; int num = 0 ; if ( _w <= 3 ) { for ( auto & it : { pII ( _w , 1 ), pII ( _w , 2 ), pII ( _w , 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else if ( _w <= 6 ) { for ( auto & it : { pII ( 1 , _w - 3 ), pII ( 2 , _w - 3 ), pII ( 3 , _w - 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else if ( _w == 7 ) { for ( auto & it : { pII ( 1 , 1 ), pII ( 2 , 2 ), pII ( 3 , 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else { for ( auto & it : { pII ( 1 , 3 ), pII ( 2 , 2 ), pII ( 3 , 1 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } cout << w [ num ] << endl ; return 0 ; }","title":"L1-072-\u522e\u522e\u5f69\u7968"},{"location":"CCCC/L1-072-%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/#l1-072-\u522e\u522e\u5f69\u7968","text":"","title":"L1-072 \u522e\u522e\u5f69\u7968"},{"location":"CCCC/L1-072-%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u522e\u522e\u5f69\u7968\u201d\u662f\u4e00\u6b3e\u7f51\u7edc\u6e38\u620f\u91cc\u9762\u7684\u4e00\u4e2a\u5c0f\u6e38\u620f\u3002\u5982\u56fe\u6240\u793a\uff1a \u6bcf\u6b21\u6e38\u620f\u73a9\u5bb6\u4f1a\u62ff\u5230\u4e00\u5f20\u5f69\u7968\uff0c\u4e0a\u9762\u4f1a\u6709 9 \u4e2a\u6570\u5b57\uff0c\u5206\u522b\u4e3a\u6570\u5b57 1 \u5230\u6570\u5b57 9\uff0c\u6570\u5b57\u5404\u4e0d\u91cd\u590d\uff0c\u5e76\u4ee5 3\\times3 3\\times3 \u7684\u201c\u4e5d\u5bab\u683c\u201d\u5f62\u5f0f\u6392\u5e03\u5728\u5f69\u7968\u4e0a\u3002 \u5728\u6e38\u620f\u5f00\u59cb\u65f6\u80fd\u770b\u89c1\u4e00\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\uff0c\u5176\u4ed6\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u5747\u4e0d\u53ef\u89c1\u3002\u4f60\u53ef\u4ee5\u9009\u62e9\u4e09\u4e2a\u4f4d\u7f6e\u7684\u6570\u5b57\u522e\u5f00\uff0c\u8fd9\u6837\u73a9\u5bb6\u5c31\u80fd\u770b\u89c1\u56db\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u4e86\u3002\u6700\u540e\u73a9\u5bb6\u518d\u4ece 3 \u6a2a\u30013 \u7ad6\u30012 \u659c\u5171 8 \u4e2a\u65b9\u5411\u4e2d\u6311\u9009\u4e00\u4e2a\u65b9\u5411\uff0c\u65b9\u5411\u4e0a\u4e09\u4e2a\u6570\u5b57\u7684\u548c\u53ef\u6839\u636e\u4e0b\u5217\u8868\u683c\u8fdb\u884c\u5151\u5956\uff0c\u83b7\u5f97\u5bf9\u5e94\u6570\u989d\u7684\u91d1\u5e01\u3002 \u6570\u5b57\u5408\u8ba1 \u83b7\u5f97\u91d1\u5e01 \u6570\u5b57\u5408\u8ba1 \u83b7\u5f97\u91d1\u5e01 6 10,000 16 72 7 36 17 180 8 720 18 119 9 360 19 36 10 80 20 306 11 252 21 1,080 12 108 22 144 13 72 23 1,800 14 54 24 3,600 15 180 \u73b0\u5728\u8bf7\u4f60\u5199\u51fa\u4e00\u4e2a\u6a21\u62df\u7a0b\u5e8f\uff0c\u6a21\u62df\u73a9\u5bb6\u7684\u6e38\u620f\u8fc7\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u90e8\u5206\u7ed9\u51fa\u4e00\u5f20\u5408\u6cd5\u7684\u5f69\u7968\uff0c\u5373\u7528 3 \u884c 3 \u5217\u7ed9\u51fa 0 \u81f3 9 \u7684\u6570\u5b57\u3002 0 \u8868\u793a\u7684\u662f\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u521d\u59cb\u65f6\u5c31\u80fd\u770b\u89c1\u4e86 \uff0c\u800c\u4e0d\u662f\u5f69\u7968\u4e0a\u7684\u6570\u5b57\u4e3a 0\u3002 \u7b2c\u4e8c\u90e8\u7ed9\u51fa\u73a9\u5bb6\u522e\u5f00\u7684\u4e09\u4e2a\u4f4d\u7f6e\uff0c\u5206\u4e3a\u4e09\u884c\uff0c\u6bcf\u884c\u6309\u683c\u5f0f x y \u7ed9\u51fa\u73a9\u5bb6\u522e\u5f00\u7684\u4f4d\u7f6e\u7684\u884c\u53f7\u548c\u5217\u53f7\uff08\u9898\u76ee\u4e2d\u5b9a\u4e49\u5de6\u4e0a\u89d2\u7684\u4f4d\u7f6e\u4e3a\u7b2c 1 \u884c\u3001\u7b2c 1 \u5217\u3002\uff09\u3002\u6570\u636e\u4fdd\u8bc1\u73a9\u5bb6\u4e0d\u4f1a\u91cd\u590d\u522e\u5f00\u5df2\u522e\u5f00\u7684\u6570\u5b57\u3002 \u6700\u540e\u4e00\u90e8\u5206\u7ed9\u51fa\u73a9\u5bb6\u9009\u62e9\u7684\u65b9\u5411\uff0c\u5373\u4e00\u4e2a\u6574\u6570\uff1a 1 \u81f3 3 \u8868\u793a\u9009\u62e9\u6a2a\u5411\u7684\u7b2c\u4e00\u884c\u3001\u7b2c\u4e8c\u884c\u3001\u7b2c\u4e09\u884c\uff0c4 \u81f3 6 \u8868\u793a\u7eb5\u5411\u7684\u7b2c\u4e00\u5217\u3001\u7b2c\u4e8c\u5217\u3001\u7b2c\u4e09\u5217\uff0c7\u30018\u5206\u522b\u8868\u793a\u5de6\u4e0a\u5230\u53f3\u4e0b\u7684\u4e3b\u5bf9\u89d2\u7ebf\u548c\u53f3\u4e0a\u5230\u5de6\u4e0b\u7684\u526f\u5bf9\u89d2\u7ebf\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u522e\u5f00\u7684\u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u73a9\u5bb6\u80fd\u770b\u5230\u7684\u6570\u5b57\u3002\u6700\u540e\u5bf9\u4e8e\u9009\u62e9\u7684\u65b9\u5411\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u73a9\u5bb6\u83b7\u5f97\u7684\u91d1\u5e01\u6570\u91cf\u3002 \u8f93\u5165\u6837\u4f8b 1 2 3 4 5 6 7 8 0 1 1 2 2 2 3 7 \u8f93\u51fa\u6837\u4f8b 1 5 6 180","title":"Statement"},{"location":"CCCC/L1-072-%E5%88%AE%E5%88%AE%E5%BD%A9%E7%A5%A8/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second const int N = 1e3 + 10 ; int main () { int a [ 4 ][ 4 ], b [ 15 ], c [ 4 ][ 4 ]; for ( int i = 1 ; i <= 3 ; ++ i ) { for ( int j = 1 ; j <= 3 ; ++ j ) { cin >> a [ i ][ j ]; b [ a [ i ][ j ]] = 1 ; c [ i ][ j ] = 1 ; } } int x = -1 ; for ( int i = 1 ; i <= 9 ; ++ i ) { if ( ! b [ i ]) { x = i ; } } for ( int i = 1 ; i <= 3 ; ++ i ) { for ( int j = 1 ; j <= 3 ; ++ j ) { if ( ! a [ i ][ j ]) { a [ i ][ j ] = x ; c [ i ][ j ] = 1 ; } } } for ( int i = 1 , q , w ; i <= 3 ; ++ i ) { cin >> q >> w ; cout << a [ q ][ w ] << endl ; c [ q ][ w ] = 1 ; } int w [] = { 0 , 0 , 0 , 0 , 0 , 0 , 10000 , 36 , 720 , 360 , 80 , 252 , 108 , 72 , 54 , 180 , 72 , 180 , 119 , 36 , 306 , 1080 , 144 , 1800 , 3600 }; int _w ; cin >> _w ; int num = 0 ; if ( _w <= 3 ) { for ( auto & it : { pII ( _w , 1 ), pII ( _w , 2 ), pII ( _w , 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else if ( _w <= 6 ) { for ( auto & it : { pII ( 1 , _w - 3 ), pII ( 2 , _w - 3 ), pII ( 3 , _w - 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else if ( _w == 7 ) { for ( auto & it : { pII ( 1 , 1 ), pII ( 2 , 2 ), pII ( 3 , 3 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } else { for ( auto & it : { pII ( 1 , 3 ), pII ( 2 , 2 ), pII ( 3 , 1 )}) { num += a [ it . fi ][ it . se ] * c [ it . fi ][ it . se ]; } } cout << w [ num ] << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L1-073-%E4%BA%BA%E4%B8%8E%E7%A5%9E/","text":"L1-073 \u4eba\u4e0e\u795e Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8de8\u754c\u5927\u795e L. Peter Deutsch \u6709\u4e00\u53e5\u540d\u8a00\uff1a\u201cTo iterate is human, to recurse divine.\u201d\uff08\u8fed\u4ee3\u7684\u662f\u4eba\uff0c\u9012\u5f52\u7684\u662f\u795e\uff09\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u76f4\u63a5\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa To iterate is human, to recurse divine. \u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b To iterate is human, to recurse divine.","title":"L1-073-\u4eba\u4e0e\u795e"},{"location":"CCCC/L1-073-%E4%BA%BA%E4%B8%8E%E7%A5%9E/#l1-073-\u4eba\u4e0e\u795e","text":"","title":"L1-073 \u4eba\u4e0e\u795e"},{"location":"CCCC/L1-073-%E4%BA%BA%E4%B8%8E%E7%A5%9E/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8de8\u754c\u5927\u795e L. Peter Deutsch \u6709\u4e00\u53e5\u540d\u8a00\uff1a\u201cTo iterate is human, to recurse divine.\u201d\uff08\u8fed\u4ee3\u7684\u662f\u4eba\uff0c\u9012\u5f52\u7684\u662f\u795e\uff09\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u76f4\u63a5\u5728\u5c4f\u5e55\u4e0a\u8f93\u51fa\u8fd9\u53e5\u8bdd\u3002 \u8f93\u5165\u683c\u5f0f \u672c\u9898\u6ca1\u6709\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa To iterate is human, to recurse divine. \u3002 \u8f93\u5165\u6837\u4f8b \u65e0 \u8f93\u51fa\u6837\u4f8b To iterate is human, to recurse divine.","title":"Statement"},{"location":"CCCC/L1-074-%E4%B8%A4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8CC%E8%AF%AD%E8%A8%80/","text":"L1-074 \u4e24\u5c0f\u65f6\u5b66\u5b8cC\u8bed\u8a00 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u77e5\u4e4e\u4e0a\u6709\u4e2a\u5b9d\u5b9d\u95ee\uff1a\u201c\u4e24\u4e2a\u5c0f\u65f6\u5185\u5982\u4f55\u5b66\u5b8c C \u8bed\u8a00\uff1f\u201d\u5f53\u7136\uff0c\u95ee\u7684\u662f\u201c\u5b66\u5b8c\u201d\u5e76\u4e0d\u662f\u201c\u5b66\u4f1a\u201d\u3002 \u5047\u8bbe\u4e00\u672c C \u8bed\u8a00\u6559\u79d1\u4e66\u6709 N \u4e2a\u5b57\uff0c\u8fd9\u4e2a\u5b9d\u5b9d\u6bcf\u5206\u949f\u80fd\u770b K \u4e2a\u5b57\uff0c\u770b\u4e86 M \u5206\u949f\u3002\u8fd8\u5269\u591a\u5c11\u5b57\u6ca1\u6709\u770b\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f N\uff08\u4e0d\u8d85\u8fc7 400 000\uff09\uff0c\u6559\u79d1\u4e66\u7684\u603b\u5b57\u6570\uff1bK\uff08\u4e0d\u8d85\u8fc7 3 000\uff09\uff0c\u662f\u5b9d\u5b9d\u6bcf\u5206\u949f\u80fd\u770b\u7684\u5b57\u6570\uff1bM\uff08\u4e0d\u8d85\u8fc7 120\uff09\uff0c\u662f\u5b9d\u5b9d\u770b\u4e66\u7684\u5206\u949f\u6570\u3002 \u9898\u76ee\u4fdd\u8bc1\u5b9d\u5b9d\u770b\u5b8c\u7684\u5b57\u6570\u4e0d\u8d85\u8fc7 N\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b9d\u5b9d\u8fd8\u6ca1\u6709\u770b\u7684\u5b57\u6570\u3002 \u8f93\u5165\u6837\u4f8b 100000 1000 72 \u8f93\u51fa\u6837\u4f8b 28000","title":"L1-074-\u4e24\u5c0f\u65f6\u5b66\u5b8cC\u8bed\u8a00"},{"location":"CCCC/L1-074-%E4%B8%A4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8CC%E8%AF%AD%E8%A8%80/#l1-074-\u4e24\u5c0f\u65f6\u5b66\u5b8cc\u8bed\u8a00","text":"","title":"L1-074 \u4e24\u5c0f\u65f6\u5b66\u5b8cC\u8bed\u8a00"},{"location":"CCCC/L1-074-%E4%B8%A4%E5%B0%8F%E6%97%B6%E5%AD%A6%E5%AE%8CC%E8%AF%AD%E8%A8%80/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u77e5\u4e4e\u4e0a\u6709\u4e2a\u5b9d\u5b9d\u95ee\uff1a\u201c\u4e24\u4e2a\u5c0f\u65f6\u5185\u5982\u4f55\u5b66\u5b8c C \u8bed\u8a00\uff1f\u201d\u5f53\u7136\uff0c\u95ee\u7684\u662f\u201c\u5b66\u5b8c\u201d\u5e76\u4e0d\u662f\u201c\u5b66\u4f1a\u201d\u3002 \u5047\u8bbe\u4e00\u672c C \u8bed\u8a00\u6559\u79d1\u4e66\u6709 N \u4e2a\u5b57\uff0c\u8fd9\u4e2a\u5b9d\u5b9d\u6bcf\u5206\u949f\u80fd\u770b K \u4e2a\u5b57\uff0c\u770b\u4e86 M \u5206\u949f\u3002\u8fd8\u5269\u591a\u5c11\u5b57\u6ca1\u6709\u770b\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f N\uff08\u4e0d\u8d85\u8fc7 400 000\uff09\uff0c\u6559\u79d1\u4e66\u7684\u603b\u5b57\u6570\uff1bK\uff08\u4e0d\u8d85\u8fc7 3 000\uff09\uff0c\u662f\u5b9d\u5b9d\u6bcf\u5206\u949f\u80fd\u770b\u7684\u5b57\u6570\uff1bM\uff08\u4e0d\u8d85\u8fc7 120\uff09\uff0c\u662f\u5b9d\u5b9d\u770b\u4e66\u7684\u5206\u949f\u6570\u3002 \u9898\u76ee\u4fdd\u8bc1\u5b9d\u5b9d\u770b\u5b8c\u7684\u5b57\u6570\u4e0d\u8d85\u8fc7 N\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b9d\u5b9d\u8fd8\u6ca1\u6709\u770b\u7684\u5b57\u6570\u3002 \u8f93\u5165\u6837\u4f8b 100000 1000 72 \u8f93\u51fa\u6837\u4f8b 28000","title":"Statement"},{"location":"CCCC/L1-075-%E5%BC%BA%E8%BF%AB%E7%97%87/","text":"L1-075 \u5f3a\u8feb\u75c7 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u5f3a\u5728\u7edf\u8ba1\u4e00\u4e2a\u5c0f\u533a\u91cc\u5c45\u6c11\u7684\u51fa\u751f\u5e74\u6708\uff0c\u4f46\u662f\u53d1\u73b0\u5927\u5bb6\u586b\u5199\u7684\u751f\u65e5\u683c\u5f0f\u4e0d\u7edf\u4e00\uff0c\u4f8b\u5982\u6709\u7684\u4eba\u5199 199808 \uff0c\u6709\u7684\u4eba\u53ea\u5199 9808 \u3002\u6709\u5f3a\u8feb\u75c7\u7684\u5c0f\u5f3a\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u628a\u6240\u6709\u4eba\u7684\u51fa\u751f\u5e74\u6708\u90fd\u6574\u7406\u6210 \u5e74\u5e74\u5e74\u5e74-\u6708\u6708 \u683c\u5f0f\u3002\u5bf9\u4e8e\u90a3\u4e9b\u53ea\u5199\u4e86\u5e74\u4efd\u540e\u4e24\u4f4d\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u9ed8\u8ba4\u5c0f\u4e8e 22 \u90fd\u662f 20 \u5f00\u5934\u7684\uff0c\u5176\u4ed6\u90fd\u662f 19 \u5f00\u5934\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u51fa\u751f\u5e74\u6708\uff0c\u4e3a\u4e00\u4e2a 6 \u4f4d\u6216\u8005 4 \u4f4d\u6570\uff0c\u9898\u76ee\u4fdd\u8bc1\u662f 1000 \u5e74 1 \u6708\u5230 2021 \u5e74 12 \u6708\u4e4b\u95f4\u7684\u5408\u6cd5\u5e74\u6708\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u6807\u51c6\u683c\u5f0f \u5e74\u5e74\u5e74\u5e74-\u6708\u6708 \u5c06\u8f93\u5165\u7684\u4fe1\u606f\u6574\u7406\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 9808 \u8f93\u51fa\u6837\u4f8b 1 1998-08 \u8f93\u5165\u6837\u4f8b 2 0510 \u8f93\u51fa\u6837\u4f8b 2 2005-10 \u8f93\u5165\u6837\u4f8b 3 196711 \u8f93\u51fa\u6837\u4f8b 3 1967-11","title":"L1-075-\u5f3a\u8feb\u75c7"},{"location":"CCCC/L1-075-%E5%BC%BA%E8%BF%AB%E7%97%87/#l1-075-\u5f3a\u8feb\u75c7","text":"","title":"L1-075 \u5f3a\u8feb\u75c7"},{"location":"CCCC/L1-075-%E5%BC%BA%E8%BF%AB%E7%97%87/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u5f3a\u5728\u7edf\u8ba1\u4e00\u4e2a\u5c0f\u533a\u91cc\u5c45\u6c11\u7684\u51fa\u751f\u5e74\u6708\uff0c\u4f46\u662f\u53d1\u73b0\u5927\u5bb6\u586b\u5199\u7684\u751f\u65e5\u683c\u5f0f\u4e0d\u7edf\u4e00\uff0c\u4f8b\u5982\u6709\u7684\u4eba\u5199 199808 \uff0c\u6709\u7684\u4eba\u53ea\u5199 9808 \u3002\u6709\u5f3a\u8feb\u75c7\u7684\u5c0f\u5f3a\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u628a\u6240\u6709\u4eba\u7684\u51fa\u751f\u5e74\u6708\u90fd\u6574\u7406\u6210 \u5e74\u5e74\u5e74\u5e74-\u6708\u6708 \u683c\u5f0f\u3002\u5bf9\u4e8e\u90a3\u4e9b\u53ea\u5199\u4e86\u5e74\u4efd\u540e\u4e24\u4f4d\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u9ed8\u8ba4\u5c0f\u4e8e 22 \u90fd\u662f 20 \u5f00\u5934\u7684\uff0c\u5176\u4ed6\u90fd\u662f 19 \u5f00\u5934\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u51fa\u751f\u5e74\u6708\uff0c\u4e3a\u4e00\u4e2a 6 \u4f4d\u6216\u8005 4 \u4f4d\u6570\uff0c\u9898\u76ee\u4fdd\u8bc1\u662f 1000 \u5e74 1 \u6708\u5230 2021 \u5e74 12 \u6708\u4e4b\u95f4\u7684\u5408\u6cd5\u5e74\u6708\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u6807\u51c6\u683c\u5f0f \u5e74\u5e74\u5e74\u5e74-\u6708\u6708 \u5c06\u8f93\u5165\u7684\u4fe1\u606f\u6574\u7406\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 9808 \u8f93\u51fa\u6837\u4f8b 1 1998-08 \u8f93\u5165\u6837\u4f8b 2 0510 \u8f93\u51fa\u6837\u4f8b 2 2005-10 \u8f93\u5165\u6837\u4f8b 3 196711 \u8f93\u51fa\u6837\u4f8b 3 1967-11","title":"Statement"},{"location":"CCCC/L1-076-%E9%99%8D%E4%BB%B7%E6%8F%90%E9%86%92%E6%9C%BA%E5%99%A8%E4%BA%BA/","text":"L1-076 \u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f T \u60f3\u4e70\u4e00\u4e2a\u73a9\u5177\u5f88\u4e45\u4e86\uff0c\u4f46\u4ef7\u683c\u6709\u4e9b\u9ad8\uff0c\u4ed6\u6253\u7b97\u7b49\u4fbf\u5b9c\u4e9b\u518d\u4e70\u3002\u4f46\u5929\u5929\u76ef\u7740\u8d2d\u7269\u7f51\u7ad9\u5f88\u9ebb\u70e6\uff0c\u8bf7\u4f60\u5e2e\u5c0f T \u5199\u4e00\u4e2a\u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba\uff0c\u5f53\u73a9\u5177\u7684\u5f53\u524d\u4ef7\u683c\u6bd4\u4ed6\u8bbe\u5b9a\u7684\u4ef7\u683c\u4fbf\u5b9c\u65f6\u53d1\u51fa\u63d0\u9192\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M ( 1 \\le N \\le 100, 0 \\le M \\le 1000 1 \\le N \\le 100, 0 \\le M \\le 1000 )\uff0c\u8868\u793a\u6709 N N \u6761\u4ef7\u683c\u8bb0\u5f55\uff0c\u5c0f T \u8bbe\u7f6e\u7684\u4ef7\u683c\u4e3a M M \u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u6709\u4e00\u4e2a\u5b9e\u6570 P_i P_i \uff08 -1000.0 < P_i < 1000.0 -1000.0 < P_i < 1000.0 \uff09\uff0c\u8868\u793a\u4e00\u6761\u4ef7\u683c\u8bb0\u5f55\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6761\u6bd4\u8bbe\u5b9a\u4ef7\u683c M M \u4fbf\u5b9c\u7684\u4ef7\u683c\u8bb0\u5f55 P \uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa On Sale! P \uff0c\u5176\u4e2d P \u8f93\u51fa\u5230\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 4 99 98.0 97.0 100.2 98.9 \u8f93\u51fa\u6837\u4f8b On Sale! 98.0 On Sale! 97.0 On Sale! 98.9","title":"L1-076-\u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba"},{"location":"CCCC/L1-076-%E9%99%8D%E4%BB%B7%E6%8F%90%E9%86%92%E6%9C%BA%E5%99%A8%E4%BA%BA/#l1-076-\u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba","text":"","title":"L1-076 \u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba"},{"location":"CCCC/L1-076-%E9%99%8D%E4%BB%B7%E6%8F%90%E9%86%92%E6%9C%BA%E5%99%A8%E4%BA%BA/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f T \u60f3\u4e70\u4e00\u4e2a\u73a9\u5177\u5f88\u4e45\u4e86\uff0c\u4f46\u4ef7\u683c\u6709\u4e9b\u9ad8\uff0c\u4ed6\u6253\u7b97\u7b49\u4fbf\u5b9c\u4e9b\u518d\u4e70\u3002\u4f46\u5929\u5929\u76ef\u7740\u8d2d\u7269\u7f51\u7ad9\u5f88\u9ebb\u70e6\uff0c\u8bf7\u4f60\u5e2e\u5c0f T \u5199\u4e00\u4e2a\u964d\u4ef7\u63d0\u9192\u673a\u5668\u4eba\uff0c\u5f53\u73a9\u5177\u7684\u5f53\u524d\u4ef7\u683c\u6bd4\u4ed6\u8bbe\u5b9a\u7684\u4ef7\u683c\u4fbf\u5b9c\u65f6\u53d1\u51fa\u63d0\u9192\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M ( 1 \\le N \\le 100, 0 \\le M \\le 1000 1 \\le N \\le 100, 0 \\le M \\le 1000 )\uff0c\u8868\u793a\u6709 N N \u6761\u4ef7\u683c\u8bb0\u5f55\uff0c\u5c0f T \u8bbe\u7f6e\u7684\u4ef7\u683c\u4e3a M M \u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u6709\u4e00\u4e2a\u5b9e\u6570 P_i P_i \uff08 -1000.0 < P_i < 1000.0 -1000.0 < P_i < 1000.0 \uff09\uff0c\u8868\u793a\u4e00\u6761\u4ef7\u683c\u8bb0\u5f55\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6761\u6bd4\u8bbe\u5b9a\u4ef7\u683c M M \u4fbf\u5b9c\u7684\u4ef7\u683c\u8bb0\u5f55 P \uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa On Sale! P \uff0c\u5176\u4e2d P \u8f93\u51fa\u5230\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 4 99 98.0 97.0 100.2 98.9 \u8f93\u51fa\u6837\u4f8b On Sale! 98.0 On Sale! 97.0 On Sale! 98.9","title":"Statement"},{"location":"CCCC/L1-077-%E5%A4%A7%E7%AC%A8%E9%92%9F%E7%9A%84%E5%BF%83%E6%83%85/","text":"L1-077 \u5927\u7b28\u949f\u7684\u5fc3\u60c5 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6709\u7f51\u53cb\u95ee\uff1a\u672a\u6765\u8fd8\u4f1a\u6709\u66f4\u591a\u5927\u7b28\u949f\u9898\u5417\uff1f\u7b28\u949f\u56de\u590d\u8bf4\uff1a\u770b\u5fc3\u60c5\u2026\u2026 \u672c\u9898\u5c31\u8bf7\u4f60\u66ff\u5927\u7b28\u949f\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u6839\u636e\u5fc3\u60c5\u81ea\u52a8\u8f93\u51fa\u56de\u7b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 24 \u4e2a [0, 100] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u4f9d\u6b21\u4ee3\u8868\u5927\u7b28\u949f\u5728\u4e00\u5929 24 \u5c0f\u65f6\u4e2d\uff0c\u6bcf\u4e2a\u5c0f\u65f6\u7684\u5fc3\u60c5\u6307\u6570\u3002 \u968f\u540e\u82e5\u5e72\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a [0, 23] \u4e4b\u95f4\u7684\u6574\u6570\uff0c\u4ee3\u8868\u7f51\u53cb\u8be2\u95ee\u7b28\u949f\u8fd9\u4e2a\u95ee\u9898\u7684\u65f6\u95f4\u70b9\u3002\u5f53\u51fa\u73b0\u975e\u6cd5\u7684\u65f6\u95f4\u70b9\u65f6\uff0c\u8868\u793a\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e2a\u975e\u6cd5\u8f93\u5165\u4e0d\u8981\u5904\u7406\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u6b21\u8be2\u95ee\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u63d0\u95ee\uff0c\u5982\u679c\u5f53\u65f6\u7b28\u949f\u7684\u5fc3\u60c5\u6307\u6570\u5927\u4e8e 50\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa \u5fc3\u60c5\u6307\u6570 Yes \uff0c\u5426\u5219\u8f93\u51fa \u5fc3\u60c5\u6307\u6570 No \u3002 \u8f93\u5165\u6837\u4f8b 80 75 60 50 20 20 20 20 55 62 66 51 42 33 47 58 67 52 41 20 35 49 50 63 17 7 3 15 -1 \u8f93\u51fa\u6837\u4f8b 52 Yes 20 No 50 No 58 Yes","title":"L1-077-\u5927\u7b28\u949f\u7684\u5fc3\u60c5"},{"location":"CCCC/L1-077-%E5%A4%A7%E7%AC%A8%E9%92%9F%E7%9A%84%E5%BF%83%E6%83%85/#l1-077-\u5927\u7b28\u949f\u7684\u5fc3\u60c5","text":"","title":"L1-077 \u5927\u7b28\u949f\u7684\u5fc3\u60c5"},{"location":"CCCC/L1-077-%E5%A4%A7%E7%AC%A8%E9%92%9F%E7%9A%84%E5%BF%83%E6%83%85/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6709\u7f51\u53cb\u95ee\uff1a\u672a\u6765\u8fd8\u4f1a\u6709\u66f4\u591a\u5927\u7b28\u949f\u9898\u5417\uff1f\u7b28\u949f\u56de\u590d\u8bf4\uff1a\u770b\u5fc3\u60c5\u2026\u2026 \u672c\u9898\u5c31\u8bf7\u4f60\u66ff\u5927\u7b28\u949f\u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u6839\u636e\u5fc3\u60c5\u81ea\u52a8\u8f93\u51fa\u56de\u7b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 24 \u4e2a [0, 100] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u4f9d\u6b21\u4ee3\u8868\u5927\u7b28\u949f\u5728\u4e00\u5929 24 \u5c0f\u65f6\u4e2d\uff0c\u6bcf\u4e2a\u5c0f\u65f6\u7684\u5fc3\u60c5\u6307\u6570\u3002 \u968f\u540e\u82e5\u5e72\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a [0, 23] \u4e4b\u95f4\u7684\u6574\u6570\uff0c\u4ee3\u8868\u7f51\u53cb\u8be2\u95ee\u7b28\u949f\u8fd9\u4e2a\u95ee\u9898\u7684\u65f6\u95f4\u70b9\u3002\u5f53\u51fa\u73b0\u975e\u6cd5\u7684\u65f6\u95f4\u70b9\u65f6\uff0c\u8868\u793a\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e2a\u975e\u6cd5\u8f93\u5165\u4e0d\u8981\u5904\u7406\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u6b21\u8be2\u95ee\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u63d0\u95ee\uff0c\u5982\u679c\u5f53\u65f6\u7b28\u949f\u7684\u5fc3\u60c5\u6307\u6570\u5927\u4e8e 50\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa \u5fc3\u60c5\u6307\u6570 Yes \uff0c\u5426\u5219\u8f93\u51fa \u5fc3\u60c5\u6307\u6570 No \u3002 \u8f93\u5165\u6837\u4f8b 80 75 60 50 20 20 20 20 55 62 66 51 42 33 47 58 67 52 41 20 35 49 50 63 17 7 3 15 -1 \u8f93\u51fa\u6837\u4f8b 52 Yes 20 No 50 No 58 Yes","title":"Statement"},{"location":"CCCC/L1-078-%E5%90%89%E8%80%81%E5%B8%88%E7%9A%84%E5%9B%9E%E5%BD%92/","text":"L1-078 \u5409\u8001\u5e08\u7684\u56de\u5f52 Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u66fe\u7ecf\u5728\u5929\u68af\u8d5b\u5927\u6740\u56db\u65b9\u7684\u5409\u8001\u5e08\u51b3\u5b9a\u56de\u5f52\u5929\u68af\u8d5b\u8d5b\u573a\u5566\uff01 \u4e3a\u4e86\u7b80\u5316\u9898\u76ee\uff0c\u6211\u4eec\u4e0d\u59a8\u5047\u8bbe\u5929\u68af\u8d5b\u7684\u6bcf\u9053\u9898\u76ee\u53ef\u4ee5\u7528\u4e00\u4e2a\u4e0d\u8d85\u8fc7 500 \u7684\u3001\u53ea\u5305\u62ec\u53ef\u6253\u5370\u7b26\u53f7\u7684\u5b57\u7b26\u4e32\u63cf\u8ff0\u51fa\u6765\uff0c\u5982\uff1a Problem A: Print \"Hello world!\" \u3002 \u4f17\u6240\u5468\u77e5\uff0c\u5409\u8001\u5e08\u7684\u7ade\u8d5b\u6c34\u5e73\u975e\u5e38\u9ad8\u8d85\uff0c\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u4ed6\u6bcf\u9053\u9898\u76ee\u90fd\u4f1a\u505a\uff08\u4e8b\u5b9e\u4e0a\u4e5f\u662f\u2026\u2026\uff09\u3002\u56e0\u6b64\uff0c\u5409\u8001\u5e08\u4f1a\u6309\u7167\u987a\u5e8f\u770b\u9898\u5e76\u505a\u9898\u3002\u4f46\u5409\u8001\u5e08\u6c34\u5e73\u592a\u9ad8\u4e86\uff0c\u6240\u4ee5\u7b7e\u5230\u9898\u4ed6\u5c31\u61d2\u5f97\u505a\u4e86\uff08\u6d6a\u8d39\u65f6\u95f4\uff09\uff0c\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u5982\u9898\u76ee\u7684\u5b57\u7b26\u4e32\u91cc\u6709 qiandao \u6216\u8005 easy \uff08\u533a\u5206\u5927\u5c0f\u5199\uff09\u7684\u8bdd\uff0c\u5409\u8001\u5e08\u770b\u5b8c\u9898\u76ee\u5c31\u4f1a\u8df3\u8fc7\u8fd9\u9053\u9898\u76ee\u4e0d\u505a\u3002 \u73b0\u5728\u7ed9\u5b9a\u8fd9\u6b21\u5929\u68af\u8d5b\u603b\u5171\u6709\u51e0\u9053\u9898\u76ee\u4ee5\u53ca\u5409\u8001\u5e08\u5df2\u7ecf\u505a\u5b8c\u4e86\u51e0\u9053\u9898\u76ee\uff0c\u8bf7\u4f60\u544a\u8bc9\u5927\u5bb6\u5409\u8001\u5e08\u73b0\u5728\u6b63\u5728\u505a\u54ea\u4e2a\u9898\uff0c\u6216\u8005\u5409\u8001\u5e08\u5df2\u7ecf\u628a\u6240\u6709\u4ed6\u6253\u7b97\u505a\u7684\u9898\u76ee\u505a\u5b8c\u4e86\u3002 \u63d0\u9192\uff1a\u5929\u68af\u8d5b\u6709\u5206\u6570\u5347\u7ea7\u7684\u89c4\u5219\uff0c\u5982\u679c\u4e0d\u505a\u7b7e\u5230\u9898\u53ef\u80fd\u5bfc\u81f4\u56e2\u961f\u603b\u5206\u4e0d\u8db3\u4ee5\u5347\u7ea7\uff0c\u4e00\u822c\u7684\u9009\u624b\u8bf7\u5343\u4e07\u4e0d\u8981\u5b66\u4e60\u5409\u8001\u5e08\u7684\u9177\u70ab\u884c\u4e3a\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N, M N, M ( 1 \\le M\\le N \\le 30 1 \\le M\\le N \\le 30 )\uff0c\u8868\u793a\u672c\u6b21\u5929\u68af\u8d5b\u6709 N N \u9053\u9898\u76ee\uff0c\u5409\u8001\u5e08\u73b0\u5728\u505a\u5b8c\u4e86 M M \u9053\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u662f\u4e00\u4e2a\u7b26\u5408\u9898\u76ee\u63cf\u8ff0\u7684\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u5929\u68af\u8d5b\u7684\u9898\u76ee\u5185\u5bb9\u3002\u5409\u8001\u5e08\u4f1a\u6309\u7167\u7ed9\u51fa\u7684\u987a\u5e8f\u770b\u9898\u2014\u2014\u7b2c\u4e00\u884c\u5c31\u662f\u5409\u8001\u5e08\u770b\u7684\u7b2c\u4e00\u9053\u9898\uff0c\u7b2c\u4e8c\u884c\u5c31\u662f\u7b2c\u4e8c\u9053\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5409\u8001\u5e08\u5f53\u524d\u6b63\u5728\u505a\u7684\u9898\u76ee\u5bf9\u5e94\u7684\u9898\u9762\uff08\u5373\u505a\u5b8c\u4e86 M M \u9053\u9898\u76ee\u540e\uff0c\u5409\u8001\u5e08\u6b63\u5728\u505a\u54ea\u4e2a\u9898\uff09\u3002\u5982\u679c\u5409\u8001\u5e08\u5df2\u7ecf\u628a\u6240\u6709\u4ed6\u6253\u7b97\u505a\u7684\u9898\u76ee\u505a\u5b8c\u4e86\uff0c\u8f93\u51fa\u4e00\u884c Wo AK le \u3002 \u8f93\u5165\u6837\u4f8b 1 5 1 L1-1 is a qiandao problem. L1-2 is so...easy. L1-3 is Easy. L1-4 is qianDao. Wow, such L1-5, so easy. \u8f93\u51fa\u6837\u4f8b 1 L1-4 is qianDao. \u8f93\u5165\u6837\u4f8b 2 5 4 L1-1 is a-qiandao problem. L1-2 is so easy. L1-3 is Easy. L1-4 is qianDao. Wow, such L1-5, so!!easy. \u8f93\u51fa\u6837\u4f8b 2 Wo AK le","title":"L1-078-\u5409\u8001\u5e08\u7684\u56de\u5f52"},{"location":"CCCC/L1-078-%E5%90%89%E8%80%81%E5%B8%88%E7%9A%84%E5%9B%9E%E5%BD%92/#l1-078-\u5409\u8001\u5e08\u7684\u56de\u5f52","text":"","title":"L1-078 \u5409\u8001\u5e08\u7684\u56de\u5f52"},{"location":"CCCC/L1-078-%E5%90%89%E8%80%81%E5%B8%88%E7%9A%84%E5%9B%9E%E5%BD%92/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u66fe\u7ecf\u5728\u5929\u68af\u8d5b\u5927\u6740\u56db\u65b9\u7684\u5409\u8001\u5e08\u51b3\u5b9a\u56de\u5f52\u5929\u68af\u8d5b\u8d5b\u573a\u5566\uff01 \u4e3a\u4e86\u7b80\u5316\u9898\u76ee\uff0c\u6211\u4eec\u4e0d\u59a8\u5047\u8bbe\u5929\u68af\u8d5b\u7684\u6bcf\u9053\u9898\u76ee\u53ef\u4ee5\u7528\u4e00\u4e2a\u4e0d\u8d85\u8fc7 500 \u7684\u3001\u53ea\u5305\u62ec\u53ef\u6253\u5370\u7b26\u53f7\u7684\u5b57\u7b26\u4e32\u63cf\u8ff0\u51fa\u6765\uff0c\u5982\uff1a Problem A: Print \"Hello world!\" \u3002 \u4f17\u6240\u5468\u77e5\uff0c\u5409\u8001\u5e08\u7684\u7ade\u8d5b\u6c34\u5e73\u975e\u5e38\u9ad8\u8d85\uff0c\u4f60\u53ef\u4ee5\u8ba4\u4e3a\u4ed6\u6bcf\u9053\u9898\u76ee\u90fd\u4f1a\u505a\uff08\u4e8b\u5b9e\u4e0a\u4e5f\u662f\u2026\u2026\uff09\u3002\u56e0\u6b64\uff0c\u5409\u8001\u5e08\u4f1a\u6309\u7167\u987a\u5e8f\u770b\u9898\u5e76\u505a\u9898\u3002\u4f46\u5409\u8001\u5e08\u6c34\u5e73\u592a\u9ad8\u4e86\uff0c\u6240\u4ee5\u7b7e\u5230\u9898\u4ed6\u5c31\u61d2\u5f97\u505a\u4e86\uff08\u6d6a\u8d39\u65f6\u95f4\uff09\uff0c\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u5982\u9898\u76ee\u7684\u5b57\u7b26\u4e32\u91cc\u6709 qiandao \u6216\u8005 easy \uff08\u533a\u5206\u5927\u5c0f\u5199\uff09\u7684\u8bdd\uff0c\u5409\u8001\u5e08\u770b\u5b8c\u9898\u76ee\u5c31\u4f1a\u8df3\u8fc7\u8fd9\u9053\u9898\u76ee\u4e0d\u505a\u3002 \u73b0\u5728\u7ed9\u5b9a\u8fd9\u6b21\u5929\u68af\u8d5b\u603b\u5171\u6709\u51e0\u9053\u9898\u76ee\u4ee5\u53ca\u5409\u8001\u5e08\u5df2\u7ecf\u505a\u5b8c\u4e86\u51e0\u9053\u9898\u76ee\uff0c\u8bf7\u4f60\u544a\u8bc9\u5927\u5bb6\u5409\u8001\u5e08\u73b0\u5728\u6b63\u5728\u505a\u54ea\u4e2a\u9898\uff0c\u6216\u8005\u5409\u8001\u5e08\u5df2\u7ecf\u628a\u6240\u6709\u4ed6\u6253\u7b97\u505a\u7684\u9898\u76ee\u505a\u5b8c\u4e86\u3002 \u63d0\u9192\uff1a\u5929\u68af\u8d5b\u6709\u5206\u6570\u5347\u7ea7\u7684\u89c4\u5219\uff0c\u5982\u679c\u4e0d\u505a\u7b7e\u5230\u9898\u53ef\u80fd\u5bfc\u81f4\u56e2\u961f\u603b\u5206\u4e0d\u8db3\u4ee5\u5347\u7ea7\uff0c\u4e00\u822c\u7684\u9009\u624b\u8bf7\u5343\u4e07\u4e0d\u8981\u5b66\u4e60\u5409\u8001\u5e08\u7684\u9177\u70ab\u884c\u4e3a\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N, M N, M ( 1 \\le M\\le N \\le 30 1 \\le M\\le N \\le 30 )\uff0c\u8868\u793a\u672c\u6b21\u5929\u68af\u8d5b\u6709 N N \u9053\u9898\u76ee\uff0c\u5409\u8001\u5e08\u73b0\u5728\u505a\u5b8c\u4e86 M M \u9053\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u662f\u4e00\u4e2a\u7b26\u5408\u9898\u76ee\u63cf\u8ff0\u7684\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u5929\u68af\u8d5b\u7684\u9898\u76ee\u5185\u5bb9\u3002\u5409\u8001\u5e08\u4f1a\u6309\u7167\u7ed9\u51fa\u7684\u987a\u5e8f\u770b\u9898\u2014\u2014\u7b2c\u4e00\u884c\u5c31\u662f\u5409\u8001\u5e08\u770b\u7684\u7b2c\u4e00\u9053\u9898\uff0c\u7b2c\u4e8c\u884c\u5c31\u662f\u7b2c\u4e8c\u9053\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5409\u8001\u5e08\u5f53\u524d\u6b63\u5728\u505a\u7684\u9898\u76ee\u5bf9\u5e94\u7684\u9898\u9762\uff08\u5373\u505a\u5b8c\u4e86 M M \u9053\u9898\u76ee\u540e\uff0c\u5409\u8001\u5e08\u6b63\u5728\u505a\u54ea\u4e2a\u9898\uff09\u3002\u5982\u679c\u5409\u8001\u5e08\u5df2\u7ecf\u628a\u6240\u6709\u4ed6\u6253\u7b97\u505a\u7684\u9898\u76ee\u505a\u5b8c\u4e86\uff0c\u8f93\u51fa\u4e00\u884c Wo AK le \u3002 \u8f93\u5165\u6837\u4f8b 1 5 1 L1-1 is a qiandao problem. L1-2 is so...easy. L1-3 is Easy. L1-4 is qianDao. Wow, such L1-5, so easy. \u8f93\u51fa\u6837\u4f8b 1 L1-4 is qianDao. \u8f93\u5165\u6837\u4f8b 2 5 4 L1-1 is a-qiandao problem. L1-2 is so easy. L1-3 is Easy. L1-4 is qianDao. Wow, such L1-5, so!!easy. \u8f93\u51fa\u6837\u4f8b 2 Wo AK le","title":"Statement"},{"location":"CCCC/L1-079-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/","text":"L1-079 \u5929\u68af\u8d5b\u7684\u5584\u826f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u8d5b\u662f\u4e2a\u5584\u826f\u7684\u6bd4\u8d5b\u3002\u5584\u826f\u7684\u547d\u9898\u7ec4\u5e0c\u671b\u5c06\u9898\u76ee\u96be\u5ea6\u63a7\u5236\u5728\u4e00\u4e2a\u8303\u56f4\u5185\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u53c2\u8d5b\u7684\u5b66\u751f\u90fd\u6709\u80fd\u505a\u51fa\u6765\u7684\u9898\u76ee\uff0c\u5e76\u4e14\u6700\u5389\u5bb3\u7684\u5b66\u751f\u4e5f\u8981\u975e\u5e38\u52aa\u529b\u624d\u6709\u53ef\u80fd\u5f97\u5230\u9ad8\u5206\u3002 \u4e8e\u662f\u547d\u9898\u7ec4\u9996\u5148\u5c06\u7f16\u7a0b\u80fd\u529b\u5212\u5206\u6210\u4e86 10^6 10^6 \u4e2a\u7b49\u7ea7\uff08\u592a\u75af\u72c2\u4e86\uff0c\u8fd9\u662f\u5047\u7684\uff09\uff0c\u7136\u540e\u8c03\u67e5\u4e86\u6bcf\u4e2a\u53c2\u8d5b\u5b66\u751f\u7684\u7f16\u7a0b\u80fd\u529b\u3002\u73b0\u5728\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u627e\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5c0f\u548c\u6700\u5927\u80fd\u529b\u503c\uff0c\u7ed9\u547d\u9898\u7ec4\u4f5c\u4e3a\u51fa\u9898\u7684\u53c2\u8003\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 2\\times 10^4 \\le 2\\times 10^4 \uff09\uff0c\u5373\u53c2\u8d5b\u5b66\u751f\u7684\u603b\u6570\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u6b63\u6574\u6570\uff0c\u662f\u53c2\u8d5b\u5b66\u751f\u7684\u80fd\u529b\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5c0f\u80fd\u529b\u503c\uff0c\u4ee5\u53ca\u5177\u6709\u8fd9\u4e2a\u80fd\u529b\u503c\u7684\u5b66\u751f\u4eba\u6570\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5927\u80fd\u529b\u503c\uff0c\u4ee5\u53ca\u5177\u6709\u8fd9\u4e2a\u80fd\u529b\u503c\u7684\u5b66\u751f\u4eba\u6570\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 86 75 233 888 666 75 886 888 75 666 \u8f93\u51fa\u6837\u4f8b 75 3 888 2","title":"L1-079-\u5929\u68af\u8d5b\u7684\u5584\u826f"},{"location":"CCCC/L1-079-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/#l1-079-\u5929\u68af\u8d5b\u7684\u5584\u826f","text":"","title":"L1-079 \u5929\u68af\u8d5b\u7684\u5584\u826f"},{"location":"CCCC/L1-079-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5929\u68af\u8d5b\u662f\u4e2a\u5584\u826f\u7684\u6bd4\u8d5b\u3002\u5584\u826f\u7684\u547d\u9898\u7ec4\u5e0c\u671b\u5c06\u9898\u76ee\u96be\u5ea6\u63a7\u5236\u5728\u4e00\u4e2a\u8303\u56f4\u5185\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u53c2\u8d5b\u7684\u5b66\u751f\u90fd\u6709\u80fd\u505a\u51fa\u6765\u7684\u9898\u76ee\uff0c\u5e76\u4e14\u6700\u5389\u5bb3\u7684\u5b66\u751f\u4e5f\u8981\u975e\u5e38\u52aa\u529b\u624d\u6709\u53ef\u80fd\u5f97\u5230\u9ad8\u5206\u3002 \u4e8e\u662f\u547d\u9898\u7ec4\u9996\u5148\u5c06\u7f16\u7a0b\u80fd\u529b\u5212\u5206\u6210\u4e86 10^6 10^6 \u4e2a\u7b49\u7ea7\uff08\u592a\u75af\u72c2\u4e86\uff0c\u8fd9\u662f\u5047\u7684\uff09\uff0c\u7136\u540e\u8c03\u67e5\u4e86\u6bcf\u4e2a\u53c2\u8d5b\u5b66\u751f\u7684\u7f16\u7a0b\u80fd\u529b\u3002\u73b0\u5728\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u627e\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5c0f\u548c\u6700\u5927\u80fd\u529b\u503c\uff0c\u7ed9\u547d\u9898\u7ec4\u4f5c\u4e3a\u51fa\u9898\u7684\u53c2\u8003\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 2\\times 10^4 \\le 2\\times 10^4 \uff09\uff0c\u5373\u53c2\u8d5b\u5b66\u751f\u7684\u603b\u6570\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u6b63\u6574\u6570\uff0c\u662f\u53c2\u8d5b\u5b66\u751f\u7684\u80fd\u529b\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5c0f\u80fd\u529b\u503c\uff0c\u4ee5\u53ca\u5177\u6709\u8fd9\u4e2a\u80fd\u529b\u503c\u7684\u5b66\u751f\u4eba\u6570\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa\u6240\u6709\u53c2\u8d5b\u5b66\u751f\u7684\u6700\u5927\u80fd\u529b\u503c\uff0c\u4ee5\u53ca\u5177\u6709\u8fd9\u4e2a\u80fd\u529b\u503c\u7684\u5b66\u751f\u4eba\u6570\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 86 75 233 888 666 75 886 888 75 666 \u8f93\u51fa\u6837\u4f8b 75 3 888 2","title":"Statement"},{"location":"CCCC/L1-080-%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E6%95%B0%E5%88%97/","text":"L1-080 \u4e58\u6cd5\u53e3\u8bc0\u6570\u5217 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u4ece\u4efb\u610f\u7ed9\u5b9a\u7684\u4e24\u4e2a 1 \u4f4d\u6570\u5b57 a_1 a_1 \u548c a_2 a_2 \u5f00\u59cb\uff0c\u7528\u4e58\u6cd5\u53e3\u8bc0\u751f\u6210\u4e00\u4e2a\u6570\u5217 { a_n a_n }\uff0c\u89c4\u5219\u4e3a\u4ece a_1 a_1 \u5f00\u59cb\u987a\u6b21\u8fdb\u884c\uff0c\u6bcf\u6b21\u5c06\u5f53\u524d\u6570\u5b57\u4e0e\u540e\u9762\u4e00\u4e2a\u6570\u5b57\u76f8\u4e58\uff0c\u5c06\u7ed3\u679c\u8d34\u5728\u6570\u5217\u672b\u5c3e\u3002\u5982\u679c\u7ed3\u679c\u4e0d\u662f 1 \u4f4d\u6570\uff0c\u5219\u5176\u6bcf\u4e00\u4f4d\u90fd\u5e94\u6210\u4e3a\u6570\u5217\u7684\u4e00\u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a a_1 a_1 \u3001 a_2 a_2 \u548c n n \uff0c\u6ee1\u8db3 0\\le a_1,a_2\\le 9 0\\le a_1,a_2\\le 9 \uff0c 0<n\\le 10^3 0<n\\le 10^3 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6570\u5217\u7684\u524d n n \u9879\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 2 3 10 \u8f93\u51fa\u6837\u4f8b 2 3 6 1 8 6 8 4 8 4 \u6837\u4f8b\u89e3\u91ca \u6570\u5217\u524d 2 \u9879\u4e3a 2 \u548c 3\u3002\u4ece 2 \u5f00\u59cb\uff0c\u56e0\u4e3a 2\\times 3=6 2\\times 3=6 \uff0c\u6240\u4ee5\u7b2c 3 \u9879\u662f 6\u3002\u56e0\u4e3a 3\\times 6=18 3\\times 6=18 \uff0c\u6240\u4ee5\u7b2c 4\u30015 \u9879\u5206\u522b\u662f 1\u30018\u3002\u4f9d\u6b21\u7c7b\u63a8\u2026\u2026 \u6700\u540e\u56e0\u4e3a\u7b2c 6 \u9879\u6709 6\\times 8=48 6\\times 8=48 \uff0c\u5bf9\u5e94\u7b2c 10\u300111 \u9879\u5e94\u8be5\u662f 4\u30018\u3002\u800c\u56e0\u4e3a\u53ea\u8981\u6c42\u8f93\u51fa\u524d 10 \u9879\uff0c\u6240\u4ee5\u5728\u8f93\u51fa 4 \u540e\u7ed3\u675f\u3002","title":"L1-080-\u4e58\u6cd5\u53e3\u8bc0\u6570\u5217"},{"location":"CCCC/L1-080-%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E6%95%B0%E5%88%97/#l1-080-\u4e58\u6cd5\u53e3\u8bc0\u6570\u5217","text":"","title":"L1-080 \u4e58\u6cd5\u53e3\u8bc0\u6570\u5217"},{"location":"CCCC/L1-080-%E4%B9%98%E6%B3%95%E5%8F%A3%E8%AF%80%E6%95%B0%E5%88%97/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u4ece\u4efb\u610f\u7ed9\u5b9a\u7684\u4e24\u4e2a 1 \u4f4d\u6570\u5b57 a_1 a_1 \u548c a_2 a_2 \u5f00\u59cb\uff0c\u7528\u4e58\u6cd5\u53e3\u8bc0\u751f\u6210\u4e00\u4e2a\u6570\u5217 { a_n a_n }\uff0c\u89c4\u5219\u4e3a\u4ece a_1 a_1 \u5f00\u59cb\u987a\u6b21\u8fdb\u884c\uff0c\u6bcf\u6b21\u5c06\u5f53\u524d\u6570\u5b57\u4e0e\u540e\u9762\u4e00\u4e2a\u6570\u5b57\u76f8\u4e58\uff0c\u5c06\u7ed3\u679c\u8d34\u5728\u6570\u5217\u672b\u5c3e\u3002\u5982\u679c\u7ed3\u679c\u4e0d\u662f 1 \u4f4d\u6570\uff0c\u5219\u5176\u6bcf\u4e00\u4f4d\u90fd\u5e94\u6210\u4e3a\u6570\u5217\u7684\u4e00\u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 3 \u4e2a\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a a_1 a_1 \u3001 a_2 a_2 \u548c n n \uff0c\u6ee1\u8db3 0\\le a_1,a_2\\le 9 0\\le a_1,a_2\\le 9 \uff0c 0<n\\le 10^3 0<n\\le 10^3 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6570\u5217\u7684\u524d n n \u9879\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 2 3 10 \u8f93\u51fa\u6837\u4f8b 2 3 6 1 8 6 8 4 8 4 \u6837\u4f8b\u89e3\u91ca \u6570\u5217\u524d 2 \u9879\u4e3a 2 \u548c 3\u3002\u4ece 2 \u5f00\u59cb\uff0c\u56e0\u4e3a 2\\times 3=6 2\\times 3=6 \uff0c\u6240\u4ee5\u7b2c 3 \u9879\u662f 6\u3002\u56e0\u4e3a 3\\times 6=18 3\\times 6=18 \uff0c\u6240\u4ee5\u7b2c 4\u30015 \u9879\u5206\u522b\u662f 1\u30018\u3002\u4f9d\u6b21\u7c7b\u63a8\u2026\u2026 \u6700\u540e\u56e0\u4e3a\u7b2c 6 \u9879\u6709 6\\times 8=48 6\\times 8=48 \uff0c\u5bf9\u5e94\u7b2c 10\u300111 \u9879\u5e94\u8be5\u662f 4\u30018\u3002\u800c\u56e0\u4e3a\u53ea\u8981\u6c42\u8f93\u51fa\u524d 10 \u9879\uff0c\u6240\u4ee5\u5728\u8f93\u51fa 4 \u540e\u7ed3\u675f\u3002","title":"Statement"},{"location":"CCCC/L2-001-%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/","text":"L2-001 \u7d27\u6025\u6551\u63f4 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4f5c\u4e3a\u4e00\u4e2a\u57ce\u5e02\u7684\u5e94\u6025\u6551\u63f4\u961f\u4f0d\u7684\u8d1f\u8d23\u4eba\uff0c\u4f60\u6709\u4e00\u5f20\u7279\u6b8a\u7684\u5168\u56fd\u5730\u56fe\u3002\u5728\u5730\u56fe\u4e0a\u663e\u793a\u6709\u591a\u4e2a\u5206\u6563\u7684\u57ce\u5e02\u548c\u4e00\u4e9b\u8fde\u63a5\u57ce\u5e02\u7684\u5feb\u901f\u9053\u8def\u3002\u6bcf\u4e2a\u57ce\u5e02\u7684\u6551\u63f4\u961f\u6570\u91cf\u548c\u6bcf\u4e00\u6761\u8fde\u63a5\u4e24\u4e2a\u57ce\u5e02\u7684\u5feb\u901f\u9053\u8def\u957f\u5ea6\u90fd\u6807\u5728\u5730\u56fe\u4e0a\u3002\u5f53\u5176\u4ed6\u57ce\u5e02\u6709\u7d27\u6025\u6c42\u52a9\u7535\u8bdd\u7ed9\u4f60\u7684\u65f6\u5019\uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5e26\u9886\u4f60\u7684\u6551\u63f4\u961f\u5c3d\u5feb\u8d76\u5f80\u4e8b\u53d1\u5730\uff0c\u540c\u65f6\uff0c\u4e00\u8def\u4e0a\u53ec\u96c6\u5c3d\u53ef\u80fd\u591a\u7684\u6551\u63f4\u961f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570 N N \u3001 M M \u3001 S S \u3001 D D \uff0c\u5176\u4e2d N N \uff08 2\\le N\\le 500 2\\le N\\le 500 \uff09\u662f\u57ce\u5e02\u7684\u4e2a\u6570\uff0c\u987a\u4fbf\u5047\u8bbe\u57ce\u5e02\u7684\u7f16\u53f7\u4e3a0 ~ (N-1) (N-1) \uff1b M M \u662f\u5feb\u901f\u9053\u8def\u7684\u6761\u6570\uff1b S S \u662f\u51fa\u53d1\u5730\u7684\u57ce\u5e02\u7f16\u53f7\uff1b D D \u662f\u76ee\u7684\u5730\u7684\u57ce\u5e02\u7f16\u53f7\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5176\u4e2d\u7b2c i i \u4e2a\u6570\u662f\u7b2c i i \u4e2a\u57ce\u5e02\u7684\u6551\u63f4\u961f\u7684\u6570\u76ee\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u968f\u540e\u7684 M M \u884c\u4e2d\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u5feb\u901f\u9053\u8def\u7684\u4fe1\u606f\uff0c\u5206\u522b\u662f\uff1a\u57ce\u5e021\u3001\u57ce\u5e022\u3001\u5feb\u901f\u9053\u8def\u7684\u957f\u5ea6\uff0c\u4e2d\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u6570\u5b57\u5747\u4e3a\u6574\u6570\u4e14\u4e0d\u8d85\u8fc7500\u3002\u8f93\u5165\u4fdd\u8bc1\u6551\u63f4\u53ef\u884c\u4e14\u6700\u4f18\u89e3\u552f\u4e00\u3002 \u8f93\u51fa\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u51fa\u6700\u77ed\u8def\u5f84\u7684\u6761\u6570\u548c\u80fd\u591f\u53ec\u96c6\u7684\u6700\u591a\u7684\u6551\u63f4\u961f\u6570\u91cf\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa\u4ece S S \u5230 D D \u7684\u8def\u5f84\u4e2d\u7ecf\u8fc7\u7684\u57ce\u5e02\u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8f93\u51fa\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 4 5 0 3 20 30 40 10 0 1 1 1 3 2 0 3 3 0 2 2 2 3 2 \u8f93\u51fa\u6837\u4f8b 2 60 0 1 3 Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 510 #define INF 0x3f3f3f3f struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N * N ]; int head [ N ], pos ; void init () { memset ( head , -1 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; ~it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) int n , m , st , ed ; int val [ N ]; struct node { int u , a , b , fa ; node () {} node ( int u , int a , int b , int fa ) : u ( u ), a ( a ), b ( b ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; return b < other . b ; } }; int dist [ N ][ 2 ]; int tot [ N ], fa [ N ]; bool used [ N ]; void Dij () { for ( int i = 0 ; i < n ; ++ i ) { used [ i ] = 0 ; dist [ i ][ 0 ] = INF ; dist [ i ][ 1 ] = 0 ; tot [ i ] = 0 ; } tot [ st ] = 1 ; dist [ st ][ 0 ] = 0 ; dist [ st ][ 1 ] = val [ st ]; priority_queue < node > pq ; pq . push ( node ( st , dist [ st ][ 0 ], dist [ st ][ 1 ], -1 )); while ( ! pq . empty ()) { int u = pq . top (). u , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { vector < int > ord ; while ( u != -1 ) { ord . push_back ( u ); u = fa [ u ]; } reverse ( ord . begin (), ord . end ()); printf ( \"%d %d \\n \" , tot [ ed ], dist [ ed ][ 1 ]); for ( int i = 0 , len = ord . size (); i < len ; ++ i ) printf ( \"%d%c\" , ord [ i ], \" \\n \" [ i == len - 1 ]); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + w ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + w ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + val [ v ]; tot [ v ] = tot [ u ]; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + w ) { tot [ v ] += tot [ u ]; if ( dist [ v ][ 1 ] < dist [ u ][ 1 ] + val [ v ]) { dist [ v ][ 1 ] = dist [ u ][ 1 ] + val [ v ]; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & st , & ed ); for ( int i = 0 ; i < n ; ++ i ) scanf ( \"%d\" , val + i ); G . init (); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G . add ( u , v , w ); } Dij (); return 0 ; }","title":"L2-001-\u7d27\u6025\u6551\u63f4"},{"location":"CCCC/L2-001-%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/#l2-001-\u7d27\u6025\u6551\u63f4","text":"","title":"L2-001 \u7d27\u6025\u6551\u63f4"},{"location":"CCCC/L2-001-%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4f5c\u4e3a\u4e00\u4e2a\u57ce\u5e02\u7684\u5e94\u6025\u6551\u63f4\u961f\u4f0d\u7684\u8d1f\u8d23\u4eba\uff0c\u4f60\u6709\u4e00\u5f20\u7279\u6b8a\u7684\u5168\u56fd\u5730\u56fe\u3002\u5728\u5730\u56fe\u4e0a\u663e\u793a\u6709\u591a\u4e2a\u5206\u6563\u7684\u57ce\u5e02\u548c\u4e00\u4e9b\u8fde\u63a5\u57ce\u5e02\u7684\u5feb\u901f\u9053\u8def\u3002\u6bcf\u4e2a\u57ce\u5e02\u7684\u6551\u63f4\u961f\u6570\u91cf\u548c\u6bcf\u4e00\u6761\u8fde\u63a5\u4e24\u4e2a\u57ce\u5e02\u7684\u5feb\u901f\u9053\u8def\u957f\u5ea6\u90fd\u6807\u5728\u5730\u56fe\u4e0a\u3002\u5f53\u5176\u4ed6\u57ce\u5e02\u6709\u7d27\u6025\u6c42\u52a9\u7535\u8bdd\u7ed9\u4f60\u7684\u65f6\u5019\uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5e26\u9886\u4f60\u7684\u6551\u63f4\u961f\u5c3d\u5feb\u8d76\u5f80\u4e8b\u53d1\u5730\uff0c\u540c\u65f6\uff0c\u4e00\u8def\u4e0a\u53ec\u96c6\u5c3d\u53ef\u80fd\u591a\u7684\u6551\u63f4\u961f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570 N N \u3001 M M \u3001 S S \u3001 D D \uff0c\u5176\u4e2d N N \uff08 2\\le N\\le 500 2\\le N\\le 500 \uff09\u662f\u57ce\u5e02\u7684\u4e2a\u6570\uff0c\u987a\u4fbf\u5047\u8bbe\u57ce\u5e02\u7684\u7f16\u53f7\u4e3a0 ~ (N-1) (N-1) \uff1b M M \u662f\u5feb\u901f\u9053\u8def\u7684\u6761\u6570\uff1b S S \u662f\u51fa\u53d1\u5730\u7684\u57ce\u5e02\u7f16\u53f7\uff1b D D \u662f\u76ee\u7684\u5730\u7684\u57ce\u5e02\u7f16\u53f7\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5176\u4e2d\u7b2c i i \u4e2a\u6570\u662f\u7b2c i i \u4e2a\u57ce\u5e02\u7684\u6551\u63f4\u961f\u7684\u6570\u76ee\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u968f\u540e\u7684 M M \u884c\u4e2d\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u5feb\u901f\u9053\u8def\u7684\u4fe1\u606f\uff0c\u5206\u522b\u662f\uff1a\u57ce\u5e021\u3001\u57ce\u5e022\u3001\u5feb\u901f\u9053\u8def\u7684\u957f\u5ea6\uff0c\u4e2d\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u6570\u5b57\u5747\u4e3a\u6574\u6570\u4e14\u4e0d\u8d85\u8fc7500\u3002\u8f93\u5165\u4fdd\u8bc1\u6551\u63f4\u53ef\u884c\u4e14\u6700\u4f18\u89e3\u552f\u4e00\u3002 \u8f93\u51fa\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u51fa\u6700\u77ed\u8def\u5f84\u7684\u6761\u6570\u548c\u80fd\u591f\u53ec\u96c6\u7684\u6700\u591a\u7684\u6551\u63f4\u961f\u6570\u91cf\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa\u4ece S S \u5230 D D \u7684\u8def\u5f84\u4e2d\u7ecf\u8fc7\u7684\u57ce\u5e02\u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8f93\u51fa\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 4 5 0 3 20 30 40 10 0 1 1 1 3 2 0 3 3 0 2 2 2 3 2 \u8f93\u51fa\u6837\u4f8b 2 60 0 1 3","title":"Statement"},{"location":"CCCC/L2-001-%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 510 #define INF 0x3f3f3f3f struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N * N ]; int head [ N ], pos ; void init () { memset ( head , -1 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; ~it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) int n , m , st , ed ; int val [ N ]; struct node { int u , a , b , fa ; node () {} node ( int u , int a , int b , int fa ) : u ( u ), a ( a ), b ( b ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; return b < other . b ; } }; int dist [ N ][ 2 ]; int tot [ N ], fa [ N ]; bool used [ N ]; void Dij () { for ( int i = 0 ; i < n ; ++ i ) { used [ i ] = 0 ; dist [ i ][ 0 ] = INF ; dist [ i ][ 1 ] = 0 ; tot [ i ] = 0 ; } tot [ st ] = 1 ; dist [ st ][ 0 ] = 0 ; dist [ st ][ 1 ] = val [ st ]; priority_queue < node > pq ; pq . push ( node ( st , dist [ st ][ 0 ], dist [ st ][ 1 ], -1 )); while ( ! pq . empty ()) { int u = pq . top (). u , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { vector < int > ord ; while ( u != -1 ) { ord . push_back ( u ); u = fa [ u ]; } reverse ( ord . begin (), ord . end ()); printf ( \"%d %d \\n \" , tot [ ed ], dist [ ed ][ 1 ]); for ( int i = 0 , len = ord . size (); i < len ; ++ i ) printf ( \"%d%c\" , ord [ i ], \" \\n \" [ i == len - 1 ]); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + w ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + w ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + val [ v ]; tot [ v ] = tot [ u ]; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + w ) { tot [ v ] += tot [ u ]; if ( dist [ v ][ 1 ] < dist [ u ][ 1 ] + val [ v ]) { dist [ v ][ 1 ] = dist [ u ][ 1 ] + val [ v ]; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & st , & ed ); for ( int i = 0 ; i < n ; ++ i ) scanf ( \"%d\" , val + i ); G . init (); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G . add ( u , v , w ); } Dij (); return 0 ; }","title":"Solution"},{"location":"CCCC/L2-002-%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","text":"L2-002 \u94fe\u8868\u53bb\u91cd Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5e26\u6574\u6570\u952e\u503c\u7684\u94fe\u8868 L L \uff0c\u4f60\u9700\u8981\u628a\u5176\u4e2d\u7edd\u5bf9\u503c\u91cd\u590d\u7684\u952e\u503c\u7ed3\u70b9\u5220\u6389\u3002\u5373\u5bf9\u6bcf\u4e2a\u952e\u503c K K \uff0c\u53ea\u6709\u7b2c\u4e00\u4e2a\u7edd\u5bf9\u503c\u7b49\u4e8e K K \u7684\u7ed3\u70b9\u88ab\u4fdd\u7559\u3002\u540c\u65f6\uff0c\u6240\u6709\u88ab\u5220\u9664\u7684\u7ed3\u70b9\u987b\u88ab\u4fdd\u5b58\u5728\u53e6\u4e00\u4e2a\u94fe\u8868\u4e0a\u3002\u4f8b\u5982\u7ed9\u5b9a L L \u4e3a 21\u2192-15\u2192-15\u2192-7\u219215\uff0c\u4f60\u9700\u8981\u8f93\u51fa\u53bb\u91cd\u540e\u7684\u94fe\u8868 21\u2192-15\u2192-7\uff0c\u8fd8\u6709\u88ab\u5220\u9664\u7684\u94fe\u8868 -15\u219215\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa L \u7684\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u548c\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff0c\u4e3a\u7ed3\u70b9\u603b\u6570\uff09\u3002\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u662f\u975e\u8d1f\u7684 5 \u4f4d\u6574\u6570\uff0c\u7a7a\u5730\u5740 NULL \u7528 -1 -1 \u6765\u8868\u793a\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u4e00\u4e2a\u7ed3\u70b9\uff1a \u5730\u5740 \u952e\u503c \u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u5176\u4e2d \u5730\u5740 \u662f\u8be5\u7ed3\u70b9\u7684\u5730\u5740\uff0c \u952e\u503c \u662f\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u6574\u6570\uff0c \u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u662f\u4e0b\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u53bb\u91cd\u540e\u7684\u94fe\u8868\uff0c\u7136\u540e\u8f93\u51fa\u88ab\u5220\u9664\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u6309\u8f93\u5165\u7684\u683c\u5f0f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 00100 5 99999 -7 87654 23854 -15 00000 87654 15 -1 00000 -15 99999 00100 21 23854 \u8f93\u51fa\u6837\u4f8b 00100 21 23854 23854 -15 99999 99999 -7 -1 00000 -15 87654 87654 15 -1 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int add ; int value ; int next ; } temp ; map < int , Node > m ; map < int , int > vis ; vector < Node > v [ 2 ]; int ini , n ; void dfs ( int add ) { if ( vis [ abs ( m [ add ]. value )] == 0 ) { v [ 0 ][ v [ 0 ]. size () - 1 ]. next = m [ add ]. add ; v [ 0 ]. pb ( m [ add ]); vis [ abs ( m [ add ]. value )] = 1 ; } else { if ( v [ 1 ]. size ()) v [ 1 ][ v [ 1 ]. size () - 1 ]. next = m [ add ]. add ; v [ 1 ]. pb ( m [ add ]); } if ( m [ add ]. next != -1 ) dfs ( m [ add ]. next ); } int main () { scanf ( \"%d%d\" , & ini , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . value , & temp . next ); m [ temp . add ] = temp ; } v [ 0 ]. pb ( m [ ini ]); vis [ abs ( m [ ini ]. value )] = 1 ; ini = m [ ini ]. next ; if ( ini != -1 ) dfs ( ini ); if ( v [ 0 ]. size ()) { v [ 0 ][ v [ 0 ]. size () - 1 ]. next = -1 ; vector < Node >:: iterator it ; for ( it = v [ 0 ]. begin (); it != v [ 0 ]. end (); it ++ ) { printf ( \"%05d %d \" , ( * it ). add , ( * it ). value ); if (( * it ). next != -1 ) printf ( \"%05d \\n \" , ( * it ). next ); else cout << -1 << endl ; } } if ( v [ 1 ]. size ()) { v [ 1 ][ v [ 1 ]. size () - 1 ]. next = -1 ; vector < Node >:: iterator it ; for ( it = v [ 1 ]. begin (); it != v [ 1 ]. end (); it ++ ) { printf ( \"%05d %d \" , ( * it ). add , ( * it ). value ); if (( * it ). next != -1 ) printf ( \"%05d \\n \" , ( * it ). next ); else cout << -1 << endl ; } } }","title":"L2-002-\u94fe\u8868\u53bb\u91cd"},{"location":"CCCC/L2-002-%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/#l2-002-\u94fe\u8868\u53bb\u91cd","text":"","title":"L2-002 \u94fe\u8868\u53bb\u91cd"},{"location":"CCCC/L2-002-%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5e26\u6574\u6570\u952e\u503c\u7684\u94fe\u8868 L L \uff0c\u4f60\u9700\u8981\u628a\u5176\u4e2d\u7edd\u5bf9\u503c\u91cd\u590d\u7684\u952e\u503c\u7ed3\u70b9\u5220\u6389\u3002\u5373\u5bf9\u6bcf\u4e2a\u952e\u503c K K \uff0c\u53ea\u6709\u7b2c\u4e00\u4e2a\u7edd\u5bf9\u503c\u7b49\u4e8e K K \u7684\u7ed3\u70b9\u88ab\u4fdd\u7559\u3002\u540c\u65f6\uff0c\u6240\u6709\u88ab\u5220\u9664\u7684\u7ed3\u70b9\u987b\u88ab\u4fdd\u5b58\u5728\u53e6\u4e00\u4e2a\u94fe\u8868\u4e0a\u3002\u4f8b\u5982\u7ed9\u5b9a L L \u4e3a 21\u2192-15\u2192-15\u2192-7\u219215\uff0c\u4f60\u9700\u8981\u8f93\u51fa\u53bb\u91cd\u540e\u7684\u94fe\u8868 21\u2192-15\u2192-7\uff0c\u8fd8\u6709\u88ab\u5220\u9664\u7684\u94fe\u8868 -15\u219215\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa L \u7684\u7b2c\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u548c\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff0c\u4e3a\u7ed3\u70b9\u603b\u6570\uff09\u3002\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u662f\u975e\u8d1f\u7684 5 \u4f4d\u6574\u6570\uff0c\u7a7a\u5730\u5740 NULL \u7528 -1 -1 \u6765\u8868\u793a\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u4e00\u4e2a\u7ed3\u70b9\uff1a \u5730\u5740 \u952e\u503c \u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u5176\u4e2d \u5730\u5740 \u662f\u8be5\u7ed3\u70b9\u7684\u5730\u5740\uff0c \u952e\u503c \u662f\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u6574\u6570\uff0c \u4e0b\u4e00\u4e2a\u7ed3\u70b9 \u662f\u4e0b\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u53bb\u91cd\u540e\u7684\u94fe\u8868\uff0c\u7136\u540e\u8f93\u51fa\u88ab\u5220\u9664\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u6309\u8f93\u5165\u7684\u683c\u5f0f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 00100 5 99999 -7 87654 23854 -15 00000 87654 15 -1 00000 -15 99999 00100 21 23854 \u8f93\u51fa\u6837\u4f8b 00100 21 23854 23854 -15 99999 99999 -7 -1 00000 -15 87654 87654 15 -1","title":"Statement"},{"location":"CCCC/L2-002-%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int add ; int value ; int next ; } temp ; map < int , Node > m ; map < int , int > vis ; vector < Node > v [ 2 ]; int ini , n ; void dfs ( int add ) { if ( vis [ abs ( m [ add ]. value )] == 0 ) { v [ 0 ][ v [ 0 ]. size () - 1 ]. next = m [ add ]. add ; v [ 0 ]. pb ( m [ add ]); vis [ abs ( m [ add ]. value )] = 1 ; } else { if ( v [ 1 ]. size ()) v [ 1 ][ v [ 1 ]. size () - 1 ]. next = m [ add ]. add ; v [ 1 ]. pb ( m [ add ]); } if ( m [ add ]. next != -1 ) dfs ( m [ add ]. next ); } int main () { scanf ( \"%d%d\" , & ini , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . value , & temp . next ); m [ temp . add ] = temp ; } v [ 0 ]. pb ( m [ ini ]); vis [ abs ( m [ ini ]. value )] = 1 ; ini = m [ ini ]. next ; if ( ini != -1 ) dfs ( ini ); if ( v [ 0 ]. size ()) { v [ 0 ][ v [ 0 ]. size () - 1 ]. next = -1 ; vector < Node >:: iterator it ; for ( it = v [ 0 ]. begin (); it != v [ 0 ]. end (); it ++ ) { printf ( \"%05d %d \" , ( * it ). add , ( * it ). value ); if (( * it ). next != -1 ) printf ( \"%05d \\n \" , ( * it ). next ); else cout << -1 << endl ; } } if ( v [ 1 ]. size ()) { v [ 1 ][ v [ 1 ]. size () - 1 ]. next = -1 ; vector < Node >:: iterator it ; for ( it = v [ 1 ]. begin (); it != v [ 1 ]. end (); it ++ ) { printf ( \"%05d %d \" , ( * it ). add , ( * it ). value ); if (( * it ). next != -1 ) printf ( \"%05d \\n \" , ( * it ). next ); else cout << -1 << endl ; } } }","title":"Solution"},{"location":"CCCC/L2-003-%E6%9C%88%E9%A5%BC/","text":"L2-003 \u6708\u997c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e2d\u56fd\u4eba\u5728\u4e2d\u79cb\u4f73\u8282\u65f6\u5403\u7684\u4e00\u79cd\u4f20\u7edf\u98df\u54c1\uff0c\u4e0d\u540c\u5730\u533a\u6709\u8bb8\u591a\u4e0d\u540c\u98ce\u5473\u7684\u6708\u997c\u3002\u73b0\u7ed9\u5b9a\u6240\u6709\u79cd\u7c7b\u6708\u997c\u7684\u5e93\u5b58\u91cf\u3001\u603b\u552e\u4ef7\u3001\u4ee5\u53ca\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\uff0c\u8bf7\u4f60\u8ba1\u7b97\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u662f\u591a\u5c11\u3002 \u6ce8\u610f\uff1a\u9500\u552e\u65f6\u5141\u8bb8\u53d6\u51fa\u4e00\u90e8\u5206\u5e93\u5b58\u3002\u6837\u4f8b\u7ed9\u51fa\u7684\u60c5\u5f62\u662f\u8fd9\u6837\u7684\uff1a\u5047\u5982\u6211\u4eec\u6709 3 \u79cd\u6708\u997c\uff0c\u5176\u5e93\u5b58\u91cf\u5206\u522b\u4e3a 18\u300115\u300110 \u4e07\u5428\uff0c\u603b\u552e\u4ef7\u5206\u522b\u4e3a 75\u300172\u300145 \u4ebf\u5143\u3002\u5982\u679c\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\u53ea\u6709 20 \u4e07\u5428\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u5927\u6536\u76ca\u7b56\u7565\u5e94\u8be5\u662f\u5356\u51fa\u5168\u90e8 15 \u4e07\u5428\u7b2c 2 \u79cd\u6708\u997c\u3001\u4ee5\u53ca 5 \u4e07\u5428\u7b2c 3 \u79cd\u6708\u997c\uff0c\u83b7\u5f97 72 + 45/2 = 94.5\uff08\u4ebf\u5143\uff09\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \u8868\u793a\u6708\u997c\u7684\u79cd\u7c7b\u6570\u3001\u4ee5\u53ca\u4e0d\u8d85\u8fc7 500\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\u7684\u6b63\u6574\u6570 D D \u8868\u793a\u5e02\u573a\u6700\u5927\u9700\u6c42\u91cf\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u5e93\u5b58\u91cf\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u603b\u552e\u4ef7\uff08\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u6536\u76ca\uff0c\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\u5e76\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 3 20 18 15 10 75 72 45 \u8f93\u51fa\u6837\u4f8b 94.50 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; struct Node { double x , y , ave ; } q [ maxn ]; bool comp ( Node x , Node y ) { return x . ave > y . ave ; } int main () { int n , d ; scanf ( \"%d%d\" , & n , & d ); memset ( q , 0 , sizeof ( q )); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & q [ i ]. x ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & q [ i ]. y ); q [ i ]. ave = q [ i ]. y / q [ i ]. x ; } sort ( q , q + n , comp ); long double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( d >= q [ i ]. x ) { sum += q [ i ]. y ; d -= q [ i ]. x ; } else { sum += q [ i ]. ave * d ; break ; } } printf ( \"%.2Lf \\n \" , sum ); }","title":"L2-003-\u6708\u997c"},{"location":"CCCC/L2-003-%E6%9C%88%E9%A5%BC/#l2-003-\u6708\u997c","text":"","title":"L2-003 \u6708\u997c"},{"location":"CCCC/L2-003-%E6%9C%88%E9%A5%BC/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e2d\u56fd\u4eba\u5728\u4e2d\u79cb\u4f73\u8282\u65f6\u5403\u7684\u4e00\u79cd\u4f20\u7edf\u98df\u54c1\uff0c\u4e0d\u540c\u5730\u533a\u6709\u8bb8\u591a\u4e0d\u540c\u98ce\u5473\u7684\u6708\u997c\u3002\u73b0\u7ed9\u5b9a\u6240\u6709\u79cd\u7c7b\u6708\u997c\u7684\u5e93\u5b58\u91cf\u3001\u603b\u552e\u4ef7\u3001\u4ee5\u53ca\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\uff0c\u8bf7\u4f60\u8ba1\u7b97\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u662f\u591a\u5c11\u3002 \u6ce8\u610f\uff1a\u9500\u552e\u65f6\u5141\u8bb8\u53d6\u51fa\u4e00\u90e8\u5206\u5e93\u5b58\u3002\u6837\u4f8b\u7ed9\u51fa\u7684\u60c5\u5f62\u662f\u8fd9\u6837\u7684\uff1a\u5047\u5982\u6211\u4eec\u6709 3 \u79cd\u6708\u997c\uff0c\u5176\u5e93\u5b58\u91cf\u5206\u522b\u4e3a 18\u300115\u300110 \u4e07\u5428\uff0c\u603b\u552e\u4ef7\u5206\u522b\u4e3a 75\u300172\u300145 \u4ebf\u5143\u3002\u5982\u679c\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\u53ea\u6709 20 \u4e07\u5428\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u5927\u6536\u76ca\u7b56\u7565\u5e94\u8be5\u662f\u5356\u51fa\u5168\u90e8 15 \u4e07\u5428\u7b2c 2 \u79cd\u6708\u997c\u3001\u4ee5\u53ca 5 \u4e07\u5428\u7b2c 3 \u79cd\u6708\u997c\uff0c\u83b7\u5f97 72 + 45/2 = 94.5\uff08\u4ebf\u5143\uff09\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \u8868\u793a\u6708\u997c\u7684\u79cd\u7c7b\u6570\u3001\u4ee5\u53ca\u4e0d\u8d85\u8fc7 500\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\u7684\u6b63\u6574\u6570 D D \u8868\u793a\u5e02\u573a\u6700\u5927\u9700\u6c42\u91cf\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u5e93\u5b58\u91cf\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u603b\u552e\u4ef7\uff08\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u6536\u76ca\uff0c\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\u5e76\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 3 20 18 15 10 75 72 45 \u8f93\u51fa\u6837\u4f8b 94.50","title":"Statement"},{"location":"CCCC/L2-003-%E6%9C%88%E9%A5%BC/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; struct Node { double x , y , ave ; } q [ maxn ]; bool comp ( Node x , Node y ) { return x . ave > y . ave ; } int main () { int n , d ; scanf ( \"%d%d\" , & n , & d ); memset ( q , 0 , sizeof ( q )); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & q [ i ]. x ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & q [ i ]. y ); q [ i ]. ave = q [ i ]. y / q [ i ]. x ; } sort ( q , q + n , comp ); long double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( d >= q [ i ]. x ) { sum += q [ i ]. y ; d -= q [ i ]. x ; } else { sum += q [ i ]. ave * d ; break ; } } printf ( \"%.2Lf \\n \" , sum ); }","title":"Solution"},{"location":"CCCC/L2-004-%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F/","text":"L2-004 \u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u5417\uff1f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u53ef\u88ab\u9012\u5f52\u5730\u5b9a\u4e49\u4e3a\u5177\u6709\u4e0b\u5217\u6027\u8d28\u7684\u4e8c\u53c9\u6811\uff1a\u5bf9\u4e8e\u4efb\u4e00\u7ed3\u70b9\uff0c \u5176\u5de6\u5b50\u6811\u4e2d\u6240\u6709\u7ed3\u70b9\u7684\u952e\u503c\u5c0f\u4e8e\u8be5\u7ed3\u70b9\u7684\u952e\u503c\uff1b \u5176\u53f3\u5b50\u6811\u4e2d\u6240\u6709\u7ed3\u70b9\u7684\u952e\u503c\u5927\u4e8e\u7b49\u4e8e\u8be5\u7ed3\u70b9\u7684\u952e\u503c\uff1b \u5176\u5de6\u53f3\u5b50\u6811\u90fd\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u3002 \u6240\u8c13\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u201c\u955c\u50cf\u201d\uff0c\u5373\u5c06\u6240\u6709\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u5bf9\u6362\u4f4d\u7f6e\u540e\u6240\u5f97\u5230\u7684\u6811\u3002 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u952e\u503c\u5e8f\u5217\uff0c\u73b0\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u8fd9\u662f\u5426\u662f\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6216\u5176\u955c\u50cf\u8fdb\u884c\u524d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7684\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6574\u6570\u952e\u503c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u8f93\u5165\u5e8f\u5217\u662f\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6216\u5176\u955c\u50cf\u8fdb\u884c\u524d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u5219\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa YES \uff0c\u7136\u540e\u5728\u4e0b\u4e00\u884c\u8f93\u51fa\u8be5\u6811\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u6570\u5b57\u95f4\u6709 1 \u4e2a\u7a7a\u683c\uff0c\u4e00\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u7b54\u6848\u662f\u5426\uff0c\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 1 7 8 6 5 7 10 8 11 \u8f93\u51fa\u6837\u4f8b 1 YES 5 7 6 8 11 10 8 \u8f93\u5165\u6837\u4f8b 2 7 8 10 11 8 6 7 5 \u8f93\u51fa\u6837\u4f8b 2 YES 11 8 10 7 5 6 8 \u8f93\u5165\u6837\u4f8b 3 7 8 6 8 5 10 9 11 \u8f93\u51fa\u6837\u4f8b 3 NO Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 1000010 #define fi first #define se second #define INF 0x3f3f3f3f #define pii pair<int, int> int n , a [ N ]; struct node { int v , ls , rs ; node () {} node ( int v ) : v ( v ) { ls = rs = -1 ; } } t [ N ]; int cnt ; bool flag ; int root ; int DFS1 ( int l , int r ) { if ( ! flag || l > r ) return -1 ; int id = ++ cnt ; t [ id ] = node ( a [ l ]); if ( l == r ) return id ; int pos = r + 1 ; for ( int i = l + 1 ; i <= r ; ++ i ) if ( a [ i ] >= a [ l ]) { pos = i ; break ; } for ( int i = pos ; i <= r ; ++ i ) if ( a [ i ] < a [ l ]) { flag = 0 ; return -1 ; } t [ id ]. ls = DFS1 ( l + 1 , pos - 1 ); t [ id ]. rs = DFS1 ( pos , r ); return id ; } int DFS2 ( int l , int r ) { if ( ! flag || l > r ) return -1 ; int id = ++ cnt ; t [ id ] = node ( a [ l ]); if ( l == r ) return id ; int pos = r + 1 ; for ( int i = l + 1 ; i <= r ; ++ i ) if ( a [ i ] < a [ l ]) { pos = i ; break ; } for ( int i = pos ; i <= r ; ++ i ) if ( a [ i ] >= a [ l ]) { flag = 0 ; return -1 ; } t [ id ]. ls = DFS2 ( l + 1 , pos - 1 ); t [ id ]. rs = DFS2 ( pos , r ); return id ; } void out ( int u ) { if ( t [ u ]. ls != -1 ) out ( t [ u ]. ls ); if ( t [ u ]. rs != -1 ) out ( t [ u ]. rs ); cout << t [ u ]. v << \" \\n \" [ u == root ]; } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); memset ( t , -1 , sizeof t ); flag = 1 ; cnt = 0 ; root = DFS1 ( 1 , n ); if ( flag ) { cout << \"YES \\n \" ; out ( root ); return 0 ; } memset ( t , -1 , sizeof t ); flag = 1 ; cnt = 0 ; root = DFS2 ( 1 , n ); if ( flag ) { cout << \"YES \\n \" ; out ( root ); return 0 ; } cout << \"NO \\n \" ; return 0 ; }","title":"L2-004-\u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u5417\uff1f"},{"location":"CCCC/L2-004-%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F/#l2-004-\u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u5417","text":"","title":"L2-004 \u8fd9\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u5417\uff1f"},{"location":"CCCC/L2-004-%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u53ef\u88ab\u9012\u5f52\u5730\u5b9a\u4e49\u4e3a\u5177\u6709\u4e0b\u5217\u6027\u8d28\u7684\u4e8c\u53c9\u6811\uff1a\u5bf9\u4e8e\u4efb\u4e00\u7ed3\u70b9\uff0c \u5176\u5de6\u5b50\u6811\u4e2d\u6240\u6709\u7ed3\u70b9\u7684\u952e\u503c\u5c0f\u4e8e\u8be5\u7ed3\u70b9\u7684\u952e\u503c\uff1b \u5176\u53f3\u5b50\u6811\u4e2d\u6240\u6709\u7ed3\u70b9\u7684\u952e\u503c\u5927\u4e8e\u7b49\u4e8e\u8be5\u7ed3\u70b9\u7684\u952e\u503c\uff1b \u5176\u5de6\u53f3\u5b50\u6811\u90fd\u662f\u4e8c\u53c9\u641c\u7d22\u6811\u3002 \u6240\u8c13\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u201c\u955c\u50cf\u201d\uff0c\u5373\u5c06\u6240\u6709\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u5bf9\u6362\u4f4d\u7f6e\u540e\u6240\u5f97\u5230\u7684\u6811\u3002 \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u952e\u503c\u5e8f\u5217\uff0c\u73b0\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u8fd9\u662f\u5426\u662f\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6216\u5176\u955c\u50cf\u8fdb\u884c\u524d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7684\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6574\u6570\u952e\u503c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u8f93\u5165\u5e8f\u5217\u662f\u5bf9\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\u6216\u5176\u955c\u50cf\u8fdb\u884c\u524d\u5e8f\u904d\u5386\u7684\u7ed3\u679c\uff0c\u5219\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa YES \uff0c\u7136\u540e\u5728\u4e0b\u4e00\u884c\u8f93\u51fa\u8be5\u6811\u540e\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002\u6570\u5b57\u95f4\u6709 1 \u4e2a\u7a7a\u683c\uff0c\u4e00\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u7b54\u6848\u662f\u5426\uff0c\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 1 7 8 6 5 7 10 8 11 \u8f93\u51fa\u6837\u4f8b 1 YES 5 7 6 8 11 10 8 \u8f93\u5165\u6837\u4f8b 2 7 8 10 11 8 6 7 5 \u8f93\u51fa\u6837\u4f8b 2 YES 11 8 10 7 5 6 8 \u8f93\u5165\u6837\u4f8b 3 7 8 6 8 5 10 9 11 \u8f93\u51fa\u6837\u4f8b 3 NO","title":"Statement"},{"location":"CCCC/L2-004-%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 1000010 #define fi first #define se second #define INF 0x3f3f3f3f #define pii pair<int, int> int n , a [ N ]; struct node { int v , ls , rs ; node () {} node ( int v ) : v ( v ) { ls = rs = -1 ; } } t [ N ]; int cnt ; bool flag ; int root ; int DFS1 ( int l , int r ) { if ( ! flag || l > r ) return -1 ; int id = ++ cnt ; t [ id ] = node ( a [ l ]); if ( l == r ) return id ; int pos = r + 1 ; for ( int i = l + 1 ; i <= r ; ++ i ) if ( a [ i ] >= a [ l ]) { pos = i ; break ; } for ( int i = pos ; i <= r ; ++ i ) if ( a [ i ] < a [ l ]) { flag = 0 ; return -1 ; } t [ id ]. ls = DFS1 ( l + 1 , pos - 1 ); t [ id ]. rs = DFS1 ( pos , r ); return id ; } int DFS2 ( int l , int r ) { if ( ! flag || l > r ) return -1 ; int id = ++ cnt ; t [ id ] = node ( a [ l ]); if ( l == r ) return id ; int pos = r + 1 ; for ( int i = l + 1 ; i <= r ; ++ i ) if ( a [ i ] < a [ l ]) { pos = i ; break ; } for ( int i = pos ; i <= r ; ++ i ) if ( a [ i ] >= a [ l ]) { flag = 0 ; return -1 ; } t [ id ]. ls = DFS2 ( l + 1 , pos - 1 ); t [ id ]. rs = DFS2 ( pos , r ); return id ; } void out ( int u ) { if ( t [ u ]. ls != -1 ) out ( t [ u ]. ls ); if ( t [ u ]. rs != -1 ) out ( t [ u ]. rs ); cout << t [ u ]. v << \" \\n \" [ u == root ]; } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); memset ( t , -1 , sizeof t ); flag = 1 ; cnt = 0 ; root = DFS1 ( 1 , n ); if ( flag ) { cout << \"YES \\n \" ; out ( root ); return 0 ; } memset ( t , -1 , sizeof t ); flag = 1 ; cnt = 0 ; root = DFS2 ( 1 , n ); if ( flag ) { cout << \"YES \\n \" ; out ( root ); return 0 ; } cout << \"NO \\n \" ; return 0 ; }","title":"Solution"},{"location":"CCCC/L2-005-%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E5%BA%A6/","text":"L2-005 \u96c6\u5408\u76f8\u4f3c\u5ea6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570\u96c6\u5408\uff0c\u5b83\u4eec\u7684\u76f8\u4f3c\u5ea6\u5b9a\u4e49\u4e3a\uff1a N_c / N_t \\times 100\\% N_c / N_t \\times 100\\% \u3002\u5176\u4e2d N_c N_c \u662f\u4e24\u4e2a\u96c6\u5408\u90fd\u6709\u7684\u4e0d\u76f8\u7b49\u6574\u6570\u7684\u4e2a\u6570\uff0c N_t N_t \u662f\u4e24\u4e2a\u96c6\u5408\u4e00\u5171\u6709\u7684\u4e0d\u76f8\u7b49\u6574\u6570\u7684\u4e2a\u6570\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u8ba1\u7b97\u4efb\u610f\u4e00\u5bf9\u7ed9\u5b9a\u96c6\u5408\u7684\u76f8\u4f3c\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 50 \\le 50 \uff09\uff0c\u662f\u96c6\u5408\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u4e2a\u96c6\u5408\u3002\u6bcf\u4e2a\u96c6\u5408\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u96c6\u5408\u4e2d\u5143\u7d20\u7684\u4e2a\u6570\uff1b\u7136\u540e\u8ddf M M \u4e2a [0, 10^9] [0, 10^9] \u533a\u95f4\u5185\u7684\u6574\u6570\u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff08 \\le 2000 \\le 2000 \uff09\uff0c\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u5bf9\u9700\u8981\u8ba1\u7b97\u76f8\u4f3c\u5ea6\u7684\u96c6\u5408\u7684\u7f16\u53f7\uff08\u96c6\u5408\u4ece1\u5230 N N \u7f16\u53f7\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u9700\u8981\u8ba1\u7b97\u7684\u96c6\u5408\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b83\u4eec\u7684\u76f8\u4f3c\u5ea6\uff0c\u4e3a\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u7684\u767e\u5206\u6bd4\u6570\u5b57\u3002 \u8f93\u5165\u6837\u4f8b 3 3 99 87 101 4 87 101 5 87 7 99 101 18 5 135 18 99 2 1 2 1 3 \u8f93\u51fa\u6837\u4f8b 50.00% 33.33% Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { set < int > s [ 51 ]; int n , num , k ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & k ); for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & num ); s [ i ]. insert ( num ); } } scanf ( \"%d\" , & k ); int x , y ; for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); int nt = s [ x ]. size () + s [ y ]. size (); int nc = 0 ; set < int >:: iterator it ; for ( it = s [ x ]. begin (); it != s [ x ]. end (); it ++ ) { if ( s [ y ]. count ( * it )) nc ++ ; } nt -= nc ; printf ( \"%.2lf%% \\n \" , nc * 1.0 / nt * 100 ); } }","title":"L2-005-\u96c6\u5408\u76f8\u4f3c\u5ea6"},{"location":"CCCC/L2-005-%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E5%BA%A6/#l2-005-\u96c6\u5408\u76f8\u4f3c\u5ea6","text":"","title":"L2-005 \u96c6\u5408\u76f8\u4f3c\u5ea6"},{"location":"CCCC/L2-005-%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E5%BA%A6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570\u96c6\u5408\uff0c\u5b83\u4eec\u7684\u76f8\u4f3c\u5ea6\u5b9a\u4e49\u4e3a\uff1a N_c / N_t \\times 100\\% N_c / N_t \\times 100\\% \u3002\u5176\u4e2d N_c N_c \u662f\u4e24\u4e2a\u96c6\u5408\u90fd\u6709\u7684\u4e0d\u76f8\u7b49\u6574\u6570\u7684\u4e2a\u6570\uff0c N_t N_t \u662f\u4e24\u4e2a\u96c6\u5408\u4e00\u5171\u6709\u7684\u4e0d\u76f8\u7b49\u6574\u6570\u7684\u4e2a\u6570\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u8ba1\u7b97\u4efb\u610f\u4e00\u5bf9\u7ed9\u5b9a\u96c6\u5408\u7684\u76f8\u4f3c\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 50 \\le 50 \uff09\uff0c\u662f\u96c6\u5408\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u4e2a\u96c6\u5408\u3002\u6bcf\u4e2a\u96c6\u5408\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u96c6\u5408\u4e2d\u5143\u7d20\u7684\u4e2a\u6570\uff1b\u7136\u540e\u8ddf M M \u4e2a [0, 10^9] [0, 10^9] \u533a\u95f4\u5185\u7684\u6574\u6570\u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff08 \\le 2000 \\le 2000 \uff09\uff0c\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u5bf9\u9700\u8981\u8ba1\u7b97\u76f8\u4f3c\u5ea6\u7684\u96c6\u5408\u7684\u7f16\u53f7\uff08\u96c6\u5408\u4ece1\u5230 N N \u7f16\u53f7\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u9700\u8981\u8ba1\u7b97\u7684\u96c6\u5408\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b83\u4eec\u7684\u76f8\u4f3c\u5ea6\uff0c\u4e3a\u4fdd\u7559\u5c0f\u6570\u70b9\u540e2\u4f4d\u7684\u767e\u5206\u6bd4\u6570\u5b57\u3002 \u8f93\u5165\u6837\u4f8b 3 3 99 87 101 4 87 101 5 87 7 99 101 18 5 135 18 99 2 1 2 1 3 \u8f93\u51fa\u6837\u4f8b 50.00% 33.33%","title":"Statement"},{"location":"CCCC/L2-005-%E9%9B%86%E5%90%88%E7%9B%B8%E4%BC%BC%E5%BA%A6/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { set < int > s [ 51 ]; int n , num , k ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & k ); for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & num ); s [ i ]. insert ( num ); } } scanf ( \"%d\" , & k ); int x , y ; for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); int nt = s [ x ]. size () + s [ y ]. size (); int nc = 0 ; set < int >:: iterator it ; for ( it = s [ x ]. begin (); it != s [ x ]. end (); it ++ ) { if ( s [ y ]. count ( * it )) nc ++ ; } nt -= nc ; printf ( \"%.2lf%% \\n \" , nc * 1.0 / nt * 100 ); } }","title":"Solution"},{"location":"CCCC/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","text":"L2-006 \u6811\u7684\u904d\u5386 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u8f93\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u8fd9\u91cc\u5047\u8bbe\u952e\u503c\u90fd\u662f\u4e92\u4e0d\u76f8\u7b49\u7684\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 30 \\le 30 \uff09\uff0c\u662f\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u5176\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u5176\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 \u8f93\u51fa\u6837\u4f8b 4 1 6 3 5 7 2 Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 110000 struct node { int ls , rs ; node () {} node ( int ls , int rs ) : ls ( ls ), rs ( rs ) {} void init () { ls = rs = -1 ; } } arr [ N ]; int n , a [ N ], b [ N ]; vector < int > res ; int DFS ( int al , int ar , int bl , int br ) { if ( al > ar ) return -1 ; if ( al == ar ) return b [ br ]; int root = b [ br ]; int pos = -1 ; for ( int i = al ; i <= ar ; ++ i ) if ( a [ i ] == root ) { pos = i ; break ; } int sze = pos - al ; arr [ root ]. ls = DFS ( al , pos - 1 , bl , bl + sze - 1 ); arr [ root ]. rs = DFS ( pos + 1 , ar , bl + sze , br - 1 ); return root ; } void BFS ( int rt , vector < int > & res ) { queue < int > q ; q . push ( rt ); while ( ! q . empty ()) { int u = q . front (); q . pop (); res . push_back ( u ); if ( arr [ u ]. ls != -1 ) q . push ( arr [ u ]. ls ); if ( arr [ u ]. rs != -1 ) q . push ( arr [ u ]. rs ); } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i < N ; ++ i ) arr [ i ]. init (); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); for ( int i = 1 ; i <= n ; ++ i ) swap ( a [ i ], b [ i ]); int rt = DFS ( 1 , n , 1 , n ); BFS ( rt , res ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"L2-006-\u6811\u7684\u904d\u5386"},{"location":"CCCC/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/#l2-006-\u6811\u7684\u904d\u5386","text":"","title":"L2-006 \u6811\u7684\u904d\u5386"},{"location":"CCCC/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u8f93\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u8fd9\u91cc\u5047\u8bbe\u952e\u503c\u90fd\u662f\u4e92\u4e0d\u76f8\u7b49\u7684\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 30 \\le 30 \uff09\uff0c\u662f\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u5176\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u5176\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 \u8f93\u51fa\u6837\u4f8b 4 1 6 3 5 7 2","title":"Statement"},{"location":"CCCC/L2-006-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 110000 struct node { int ls , rs ; node () {} node ( int ls , int rs ) : ls ( ls ), rs ( rs ) {} void init () { ls = rs = -1 ; } } arr [ N ]; int n , a [ N ], b [ N ]; vector < int > res ; int DFS ( int al , int ar , int bl , int br ) { if ( al > ar ) return -1 ; if ( al == ar ) return b [ br ]; int root = b [ br ]; int pos = -1 ; for ( int i = al ; i <= ar ; ++ i ) if ( a [ i ] == root ) { pos = i ; break ; } int sze = pos - al ; arr [ root ]. ls = DFS ( al , pos - 1 , bl , bl + sze - 1 ); arr [ root ]. rs = DFS ( pos + 1 , ar , bl + sze , br - 1 ); return root ; } void BFS ( int rt , vector < int > & res ) { queue < int > q ; q . push ( rt ); while ( ! q . empty ()) { int u = q . front (); q . pop (); res . push_back ( u ); if ( arr [ u ]. ls != -1 ) q . push ( arr [ u ]. ls ); if ( arr [ u ]. rs != -1 ) q . push ( arr [ u ]. rs ); } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i < N ; ++ i ) arr [ i ]. init (); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); for ( int i = 1 ; i <= n ; ++ i ) swap ( a [ i ], b [ i ]); int rt = DFS ( 1 , n , 1 , n ); BFS ( rt , res ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-007-%E5%AE%B6%E5%BA%AD%E6%88%BF%E4%BA%A7/","text":"L2-007 \u5bb6\u5ead\u623f\u4ea7 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u6bcf\u4e2a\u4eba\u7684\u5bb6\u5ead\u6210\u5458\u548c\u5176\u81ea\u5df1\u540d\u4e0b\u7684\u623f\u4ea7\uff0c\u8bf7\u4f60\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bb6\u5ead\u7684\u4eba\u53e3\u6570\u3001\u4eba\u5747\u623f\u4ea7\u9762\u79ef\u53ca\u623f\u4ea7\u5957\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u623f\u4ea7\uff1a \u7f16\u53f7 \u7236 \u6bcd k \u5b69\u5b501 ... \u5b69\u5b50k \u623f\u4ea7\u5957\u6570 \u603b\u9762\u79ef \u5176\u4e2d \u7f16\u53f7 \u662f\u6bcf\u4e2a\u4eba\u72ec\u6709\u7684\u4e00\u4e2a4\u4f4d\u6570\u7684\u7f16\u53f7\uff1b \u7236 \u548c \u6bcd \u5206\u522b\u662f\u8be5\u7f16\u53f7\u5bf9\u5e94\u7684\u8fd9\u4e2a\u4eba\u7684\u7236\u6bcd\u7684\u7f16\u53f7\uff08\u5982\u679c\u5df2\u7ecf\u8fc7\u4e16\uff0c\u5219\u663e\u793a -1 \uff09\uff1b k \uff08 0\\le 0\\le k \\le 5 \\le 5 \uff09\u662f\u8be5\u4eba\u7684\u5b50\u5973\u7684\u4e2a\u6570\uff1b \u5b69\u5b50i \u662f\u5176\u5b50\u5973\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u5bb6\u5ead\u4e2a\u6570\uff08\u6240\u6709\u6709\u4eb2\u5c5e\u5173\u7cfb\u7684\u4eba\u90fd\u5c5e\u4e8e\u540c\u4e00\u4e2a\u5bb6\u5ead\uff09\u3002\u968f\u540e\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6bcf\u4e2a\u5bb6\u5ead\u7684\u4fe1\u606f\uff1a \u5bb6\u5ead\u6210\u5458\u7684\u6700\u5c0f\u7f16\u53f7 \u5bb6\u5ead\u4eba\u53e3\u6570 \u4eba\u5747\u623f\u4ea7\u5957\u6570 \u4eba\u5747\u623f\u4ea7\u9762\u79ef \u5176\u4e2d\u4eba\u5747\u503c\u8981\u6c42\u4fdd\u7559\u5c0f\u6570\u70b9\u540e3\u4f4d\u3002\u5bb6\u5ead\u4fe1\u606f\u9996\u5148\u6309\u4eba\u5747\u9762\u79ef\u964d\u5e8f\u8f93\u51fa\uff0c\u82e5\u6709\u5e76\u5217\uff0c\u5219\u6309\u6210\u5458\u7f16\u53f7\u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 6666 5551 5552 1 7777 1 100 1234 5678 9012 1 0002 2 300 8888 -1 -1 0 1 1000 2468 0001 0004 1 2222 1 500 7777 6666 -1 0 2 300 3721 -1 -1 1 2333 2 150 9012 -1 -1 3 1236 1235 1234 1 100 1235 5678 9012 0 1 50 2222 1236 2468 2 6661 6662 1 300 2333 -1 3721 3 6661 6662 6663 1 100 \u8f93\u51fa\u6837\u4f8b 3 8888 1 1.000 1000.000 0001 15 0.600 100.000 5551 4 0.750 100.000 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int pre [ 10000 ]; int find ( int x ) { while ( pre [ x ] != x ) x = pre [ x ]; return x ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } struct Node { int id ; int total ; int tot ; double ave , area ; } temp , q [ maxn ]; bool comp ( Node x , Node y ) { if ( fabs ( x . area - y . area ) < eps ) return x . id < y . id ; return x . area > y . area ; } int main () { for ( int i = 0 ; i < 10000 ; i ++ ) pre [ i ] = i ; int n ; cin >> n ; map < int , Node > m ; map < int , int > vis ; for ( int i = 0 ; i < n ; i ++ ) { int id , a , b , k ; scanf ( \"%d%d%d%d\" , & id , & a , & b , & k ); vis [ id ] = 1 ; if ( a != -1 ) { join ( id , a ); vis [ a ] = 1 ; } if ( b != -1 ) { join ( id , b ); vis [ b ] = 1 ; } for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & a ); if ( a != -1 ) { join ( id , a ); vis [ a ] = 1 ; } } scanf ( \"%d%d\" , & a , & b ); m [ id ]. id = id ; m [ id ]. tot = a ; m [ id ]. area = b ; } map < int , int >:: iterator it , iter ; int count = 0 ; for ( it = vis . begin (); it != vis . end (); it ++ ) { temp . id = 0 ; temp . tot = 0 ; temp . tot = 0 ; temp . ave = 0.0 ; temp . area = 0.0 ; if ( it -> second == 1 ) { it -> second = 0 ; int flag = find ( it -> first ); temp . id = it -> first ; temp . tot += m [ it -> first ]. tot ; temp . area += m [ it -> first ]. area ; temp . total = 1 ; for ( iter = it , iter ++ ; iter != vis . end (); iter ++ ) { if ( iter -> second == 1 && flag == find ( iter -> first )) { iter -> second = 0 ; if ( m [ iter -> first ]. id == iter -> first ) { if ( iter -> first < temp . id ) temp . id = iter -> first ; temp . tot += m [ iter -> first ]. tot ; temp . area += m [ iter -> first ]. area ; } temp . total ++ ; } } temp . ave = temp . tot * 1.0 / temp . total ; temp . area /= temp . total ; q [ count ++ ] = temp ; } } sort ( q , q + count , comp ); printf ( \"%d \\n \" , count ); for ( int i = 0 ; i < count ; i ++ ) { printf ( \"%04d %d %.3lf %.3lf \\n \" , q [ i ]. id , q [ i ]. total , q [ i ]. ave , q [ i ]. area ); } }","title":"L2-007-\u5bb6\u5ead\u623f\u4ea7"},{"location":"CCCC/L2-007-%E5%AE%B6%E5%BA%AD%E6%88%BF%E4%BA%A7/#l2-007-\u5bb6\u5ead\u623f\u4ea7","text":"","title":"L2-007 \u5bb6\u5ead\u623f\u4ea7"},{"location":"CCCC/L2-007-%E5%AE%B6%E5%BA%AD%E6%88%BF%E4%BA%A7/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u6bcf\u4e2a\u4eba\u7684\u5bb6\u5ead\u6210\u5458\u548c\u5176\u81ea\u5df1\u540d\u4e0b\u7684\u623f\u4ea7\uff0c\u8bf7\u4f60\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5bb6\u5ead\u7684\u4eba\u53e3\u6570\u3001\u4eba\u5747\u623f\u4ea7\u9762\u79ef\u53ca\u623f\u4ea7\u5957\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u623f\u4ea7\uff1a \u7f16\u53f7 \u7236 \u6bcd k \u5b69\u5b501 ... \u5b69\u5b50k \u623f\u4ea7\u5957\u6570 \u603b\u9762\u79ef \u5176\u4e2d \u7f16\u53f7 \u662f\u6bcf\u4e2a\u4eba\u72ec\u6709\u7684\u4e00\u4e2a4\u4f4d\u6570\u7684\u7f16\u53f7\uff1b \u7236 \u548c \u6bcd \u5206\u522b\u662f\u8be5\u7f16\u53f7\u5bf9\u5e94\u7684\u8fd9\u4e2a\u4eba\u7684\u7236\u6bcd\u7684\u7f16\u53f7\uff08\u5982\u679c\u5df2\u7ecf\u8fc7\u4e16\uff0c\u5219\u663e\u793a -1 \uff09\uff1b k \uff08 0\\le 0\\le k \\le 5 \\le 5 \uff09\u662f\u8be5\u4eba\u7684\u5b50\u5973\u7684\u4e2a\u6570\uff1b \u5b69\u5b50i \u662f\u5176\u5b50\u5973\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u5bb6\u5ead\u4e2a\u6570\uff08\u6240\u6709\u6709\u4eb2\u5c5e\u5173\u7cfb\u7684\u4eba\u90fd\u5c5e\u4e8e\u540c\u4e00\u4e2a\u5bb6\u5ead\uff09\u3002\u968f\u540e\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6bcf\u4e2a\u5bb6\u5ead\u7684\u4fe1\u606f\uff1a \u5bb6\u5ead\u6210\u5458\u7684\u6700\u5c0f\u7f16\u53f7 \u5bb6\u5ead\u4eba\u53e3\u6570 \u4eba\u5747\u623f\u4ea7\u5957\u6570 \u4eba\u5747\u623f\u4ea7\u9762\u79ef \u5176\u4e2d\u4eba\u5747\u503c\u8981\u6c42\u4fdd\u7559\u5c0f\u6570\u70b9\u540e3\u4f4d\u3002\u5bb6\u5ead\u4fe1\u606f\u9996\u5148\u6309\u4eba\u5747\u9762\u79ef\u964d\u5e8f\u8f93\u51fa\uff0c\u82e5\u6709\u5e76\u5217\uff0c\u5219\u6309\u6210\u5458\u7f16\u53f7\u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 6666 5551 5552 1 7777 1 100 1234 5678 9012 1 0002 2 300 8888 -1 -1 0 1 1000 2468 0001 0004 1 2222 1 500 7777 6666 -1 0 2 300 3721 -1 -1 1 2333 2 150 9012 -1 -1 3 1236 1235 1234 1 100 1235 5678 9012 0 1 50 2222 1236 2468 2 6661 6662 1 300 2333 -1 3721 3 6661 6662 6663 1 100 \u8f93\u51fa\u6837\u4f8b 3 8888 1 1.000 1000.000 0001 15 0.600 100.000 5551 4 0.750 100.000","title":"Statement"},{"location":"CCCC/L2-007-%E5%AE%B6%E5%BA%AD%E6%88%BF%E4%BA%A7/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int pre [ 10000 ]; int find ( int x ) { while ( pre [ x ] != x ) x = pre [ x ]; return x ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } struct Node { int id ; int total ; int tot ; double ave , area ; } temp , q [ maxn ]; bool comp ( Node x , Node y ) { if ( fabs ( x . area - y . area ) < eps ) return x . id < y . id ; return x . area > y . area ; } int main () { for ( int i = 0 ; i < 10000 ; i ++ ) pre [ i ] = i ; int n ; cin >> n ; map < int , Node > m ; map < int , int > vis ; for ( int i = 0 ; i < n ; i ++ ) { int id , a , b , k ; scanf ( \"%d%d%d%d\" , & id , & a , & b , & k ); vis [ id ] = 1 ; if ( a != -1 ) { join ( id , a ); vis [ a ] = 1 ; } if ( b != -1 ) { join ( id , b ); vis [ b ] = 1 ; } for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & a ); if ( a != -1 ) { join ( id , a ); vis [ a ] = 1 ; } } scanf ( \"%d%d\" , & a , & b ); m [ id ]. id = id ; m [ id ]. tot = a ; m [ id ]. area = b ; } map < int , int >:: iterator it , iter ; int count = 0 ; for ( it = vis . begin (); it != vis . end (); it ++ ) { temp . id = 0 ; temp . tot = 0 ; temp . tot = 0 ; temp . ave = 0.0 ; temp . area = 0.0 ; if ( it -> second == 1 ) { it -> second = 0 ; int flag = find ( it -> first ); temp . id = it -> first ; temp . tot += m [ it -> first ]. tot ; temp . area += m [ it -> first ]. area ; temp . total = 1 ; for ( iter = it , iter ++ ; iter != vis . end (); iter ++ ) { if ( iter -> second == 1 && flag == find ( iter -> first )) { iter -> second = 0 ; if ( m [ iter -> first ]. id == iter -> first ) { if ( iter -> first < temp . id ) temp . id = iter -> first ; temp . tot += m [ iter -> first ]. tot ; temp . area += m [ iter -> first ]. area ; } temp . total ++ ; } } temp . ave = temp . tot * 1.0 / temp . total ; temp . area /= temp . total ; q [ count ++ ] = temp ; } } sort ( q , q + count , comp ); printf ( \"%d \\n \" , count ); for ( int i = 0 ; i < count ; i ++ ) { printf ( \"%04d %d %.3lf %.3lf \\n \" , q [ i ]. id , q [ i ]. total , q [ i ]. ave , q [ i ]. area ); } }","title":"Solution"},{"location":"CCCC/L2-008-%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2/","text":"L2-008 \u6700\u957f\u5bf9\u79f0\u5b50\u4e32 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u672c\u9898\u8981\u6c42\u4f60\u8f93\u51fa\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u4f8b\u5982\uff0c\u7ed9\u5b9a Is PAT&TAP symmetric? \uff0c\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u4e3a s PAT&TAP s \uff0c\u4e8e\u662f\u4f60\u5e94\u8be5\u8f93\u51fa11\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u957f\u5ea6\u4e0d\u8d85\u8fc71000\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u7684\u957f\u5ea6\u3002 \u8f93\u5165\u6837\u4f8b Is PAT&TAP symmetric? \u8f93\u51fa\u6837\u4f8b 11 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; getline ( cin , s ); string cnt = \"#\" ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) cnt += s [ i ], cnt += '#' ; len = cnt . size (); int ans = 1 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = 0 ; if ( cnt [ i ] != '#' ) temp ++ ; for ( int j = i - 1 , l = i + 1 ; j >= 0 && l < len ; j -- , l ++ ) { if ( cnt [ j ] == cnt [ l ]) { if ( cnt [ j ] != '#' ) temp += 2 ; } else break ; } ans = max ( ans , temp ); } printf ( \"%d \\n \" , ans ); }","title":"L2-008-\u6700\u957f\u5bf9\u79f0\u5b50\u4e32"},{"location":"CCCC/L2-008-%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2/#l2-008-\u6700\u957f\u5bf9\u79f0\u5b50\u4e32","text":"","title":"L2-008 \u6700\u957f\u5bf9\u79f0\u5b50\u4e32"},{"location":"CCCC/L2-008-%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u672c\u9898\u8981\u6c42\u4f60\u8f93\u51fa\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u4f8b\u5982\uff0c\u7ed9\u5b9a Is PAT&TAP symmetric? \uff0c\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u4e3a s PAT&TAP s \uff0c\u4e8e\u662f\u4f60\u5e94\u8be5\u8f93\u51fa11\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u957f\u5ea6\u4e0d\u8d85\u8fc71000\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u957f\u5bf9\u79f0\u5b50\u4e32\u7684\u957f\u5ea6\u3002 \u8f93\u5165\u6837\u4f8b Is PAT&TAP symmetric? \u8f93\u51fa\u6837\u4f8b 11","title":"Statement"},{"location":"CCCC/L2-008-%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { string s ; getline ( cin , s ); string cnt = \"#\" ; int len = s . size (); for ( int i = 0 ; i < len ; i ++ ) cnt += s [ i ], cnt += '#' ; len = cnt . size (); int ans = 1 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = 0 ; if ( cnt [ i ] != '#' ) temp ++ ; for ( int j = i - 1 , l = i + 1 ; j >= 0 && l < len ; j -- , l ++ ) { if ( cnt [ j ] == cnt [ l ]) { if ( cnt [ j ] != '#' ) temp += 2 ; } else break ; } ans = max ( ans , temp ); } printf ( \"%d \\n \" , ans ); }","title":"Solution"},{"location":"CCCC/L2-009-%E6%8A%A2%E7%BA%A2%E5%8C%85/","text":"L2-009 \u62a2\u7ea2\u5305 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u6ca1\u6709\u4eba\u6ca1\u62a2\u8fc7\u7ea2\u5305\u5427\u2026\u2026 \u8fd9\u91cc\u7ed9\u51fa N N \u4e2a\u4eba\u4e4b\u95f4\u4e92\u76f8\u53d1\u7ea2\u5305\u3001\u62a2\u7ea2\u5305\u7684\u8bb0\u5f55\uff0c\u8bf7\u4f60\u7edf\u8ba1\u4e00\u4e0b\u4ed6\u4eec\u62a2\u7ea2\u5305\u7684\u6536\u83b7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u53c2\u4e0e\u53d1\u7ea2\u5305\u548c\u62a2\u7ea2\u5305\u7684\u603b\u4eba\u6570\uff0c\u5219\u8fd9\u4e9b\u4eba\u4ece1\u5230 N N \u7f16\u53f7\u3002\u968f\u540e N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7f16\u53f7\u4e3a i i \u7684\u4eba\u53d1\u7ea2\u5305\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K\\quad N_1\\quad P_1\\quad \\cdots\\quad N_K\\quad P_K K\\quad N_1\\quad P_1\\quad \\cdots\\quad N_K\\quad P_K \u5176\u4e2d K K \uff08 0 \\le K \\le 20 0 \\le K \\le 20 \uff09\u662f\u53d1\u51fa\u53bb\u7684\u7ea2\u5305\u4e2a\u6570\uff0c N_i N_i \u662f\u62a2\u5230\u7ea2\u5305\u7684\u4eba\u7684\u7f16\u53f7\uff0c P_i P_i \uff08 >0 >0 \uff09\u662f\u5176\u62a2\u5230\u7684\u7ea2\u5305\u91d1\u989d\uff08\u4ee5\u5206\u4e3a\u5355\u4f4d\uff09\u3002\u6ce8\u610f\uff1a\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4eba\u53d1\u51fa\u7684\u7ea2\u5305\uff0c\u6bcf\u4eba\u6700\u591a\u53ea\u80fd\u62a21\u6b21\uff0c\u4e0d\u80fd\u91cd\u590d\u62a2\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u6536\u5165\u91d1\u989d\u4ece\u9ad8\u5230\u4f4e\u7684\u9012\u51cf\u987a\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u4eba\u7684\u7f16\u53f7\u548c\u6536\u5165\u91d1\u989d\uff08\u4ee5\u5143\u4e3a\u5355\u4f4d\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\uff09\u3002\u6bcf\u4e2a\u4eba\u7684\u4fe1\u606f\u5360\u4e00\u884c\uff0c\u4e24\u6570\u5b57\u95f4\u67091\u4e2a\u7a7a\u683c\u3002\u5982\u679c\u6536\u5165\u91d1\u989d\u6709\u5e76\u5217\uff0c\u5219\u6309\u62a2\u5230\u7ea2\u5305\u7684\u4e2a\u6570\u9012\u51cf\u8f93\u51fa\uff1b\u5982\u679c\u8fd8\u6709\u5e76\u5217\uff0c\u5219\u6309\u4e2a\u4eba\u7f16\u53f7\u9012\u589e\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 3 2 22 10 58 8 125 5 1 345 3 211 5 233 7 13 8 101 1 7 8800 2 1 1000 2 1000 2 4 250 10 320 6 5 11 9 22 8 33 7 44 10 55 4 2 1 3 8800 2 1 23 2 123 1 8 250 4 2 121 4 516 7 112 9 10 \u8f93\u51fa\u6837\u4f8b 1 11.63 2 3.63 8 3.63 3 2.11 7 1.69 6 -1.67 9 -2.18 10 -3.26 5 -3.26 4 -12.32 Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int tot , id ; double sum ; } q [ maxn ]; bool comp ( Node x , Node y ) { if ( x . sum == y . sum ) { if ( x . tot == y . tot ) return x . id < y . id ; return x . tot > y . tot ; } return x . sum > y . sum ; } int main () { memset ( q , 0 , sizeof ( q )); int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) q [ i ]. id = i ; for ( int i = 0 ; i < n ; i ++ ) { int k ; scanf ( \"%d\" , & k ); int id , num ; for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d%d\" , & id , & num ); q [ id - 1 ]. sum += num ; q [ id - 1 ]. tot ++ ; q [ i ]. sum -= num ; } } sort ( q , q + n , comp ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%d %.2lf \\n \" , q [ i ]. id + 1 , q [ i ]. sum / 100 ); }","title":"L2-009-\u62a2\u7ea2\u5305"},{"location":"CCCC/L2-009-%E6%8A%A2%E7%BA%A2%E5%8C%85/#l2-009-\u62a2\u7ea2\u5305","text":"","title":"L2-009 \u62a2\u7ea2\u5305"},{"location":"CCCC/L2-009-%E6%8A%A2%E7%BA%A2%E5%8C%85/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u6ca1\u6709\u4eba\u6ca1\u62a2\u8fc7\u7ea2\u5305\u5427\u2026\u2026 \u8fd9\u91cc\u7ed9\u51fa N N \u4e2a\u4eba\u4e4b\u95f4\u4e92\u76f8\u53d1\u7ea2\u5305\u3001\u62a2\u7ea2\u5305\u7684\u8bb0\u5f55\uff0c\u8bf7\u4f60\u7edf\u8ba1\u4e00\u4e0b\u4ed6\u4eec\u62a2\u7ea2\u5305\u7684\u6536\u83b7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u53c2\u4e0e\u53d1\u7ea2\u5305\u548c\u62a2\u7ea2\u5305\u7684\u603b\u4eba\u6570\uff0c\u5219\u8fd9\u4e9b\u4eba\u4ece1\u5230 N N \u7f16\u53f7\u3002\u968f\u540e N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7f16\u53f7\u4e3a i i \u7684\u4eba\u53d1\u7ea2\u5305\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K\\quad N_1\\quad P_1\\quad \\cdots\\quad N_K\\quad P_K K\\quad N_1\\quad P_1\\quad \\cdots\\quad N_K\\quad P_K \u5176\u4e2d K K \uff08 0 \\le K \\le 20 0 \\le K \\le 20 \uff09\u662f\u53d1\u51fa\u53bb\u7684\u7ea2\u5305\u4e2a\u6570\uff0c N_i N_i \u662f\u62a2\u5230\u7ea2\u5305\u7684\u4eba\u7684\u7f16\u53f7\uff0c P_i P_i \uff08 >0 >0 \uff09\u662f\u5176\u62a2\u5230\u7684\u7ea2\u5305\u91d1\u989d\uff08\u4ee5\u5206\u4e3a\u5355\u4f4d\uff09\u3002\u6ce8\u610f\uff1a\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4eba\u53d1\u51fa\u7684\u7ea2\u5305\uff0c\u6bcf\u4eba\u6700\u591a\u53ea\u80fd\u62a21\u6b21\uff0c\u4e0d\u80fd\u91cd\u590d\u62a2\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u6536\u5165\u91d1\u989d\u4ece\u9ad8\u5230\u4f4e\u7684\u9012\u51cf\u987a\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u4eba\u7684\u7f16\u53f7\u548c\u6536\u5165\u91d1\u989d\uff08\u4ee5\u5143\u4e3a\u5355\u4f4d\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e2\u4f4d\uff09\u3002\u6bcf\u4e2a\u4eba\u7684\u4fe1\u606f\u5360\u4e00\u884c\uff0c\u4e24\u6570\u5b57\u95f4\u67091\u4e2a\u7a7a\u683c\u3002\u5982\u679c\u6536\u5165\u91d1\u989d\u6709\u5e76\u5217\uff0c\u5219\u6309\u62a2\u5230\u7ea2\u5305\u7684\u4e2a\u6570\u9012\u51cf\u8f93\u51fa\uff1b\u5982\u679c\u8fd8\u6709\u5e76\u5217\uff0c\u5219\u6309\u4e2a\u4eba\u7f16\u53f7\u9012\u589e\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 3 2 22 10 58 8 125 5 1 345 3 211 5 233 7 13 8 101 1 7 8800 2 1 1000 2 1000 2 4 250 10 320 6 5 11 9 22 8 33 7 44 10 55 4 2 1 3 8800 2 1 23 2 123 1 8 250 4 2 121 4 516 7 112 9 10 \u8f93\u51fa\u6837\u4f8b 1 11.63 2 3.63 8 3.63 3 2.11 7 1.69 6 -1.67 9 -2.18 10 -3.26 5 -3.26 4 -12.32","title":"Statement"},{"location":"CCCC/L2-009-%E6%8A%A2%E7%BA%A2%E5%8C%85/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int tot , id ; double sum ; } q [ maxn ]; bool comp ( Node x , Node y ) { if ( x . sum == y . sum ) { if ( x . tot == y . tot ) return x . id < y . id ; return x . tot > y . tot ; } return x . sum > y . sum ; } int main () { memset ( q , 0 , sizeof ( q )); int n ; scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) q [ i ]. id = i ; for ( int i = 0 ; i < n ; i ++ ) { int k ; scanf ( \"%d\" , & k ); int id , num ; for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d%d\" , & id , & num ); q [ id - 1 ]. sum += num ; q [ id - 1 ]. tot ++ ; q [ i ]. sum -= num ; } } sort ( q , q + n , comp ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%d %.2lf \\n \" , q [ i ]. id + 1 , q [ i ]. sum / 100 ); }","title":"Solution"},{"location":"CCCC/L2-010-%E6%8E%92%E5%BA%A7%E4%BD%8D/","text":"L2-010 \u6392\u5ea7\u4f4d Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5e03\u7f6e\u5bb4\u5e2d\u6700\u5fae\u5999\u7684\u4e8b\u60c5\uff0c\u5c31\u662f\u7ed9\u524d\u6765\u53c2\u5bb4\u7684\u5404\u4f4d\u5bbe\u5ba2\u5b89\u6392\u5ea7\u4f4d\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u603b\u4e0d\u80fd\u628a\u4e24\u4e2a\u6b7b\u5bf9\u5934\u6392\u5230\u540c\u4e00\u5f20\u5bb4\u4f1a\u684c\u65c1\uff01\u8fd9\u4e2a\u8270\u5de8\u4efb\u52a1\u73b0\u5728\u5c31\u4ea4\u7ed9\u4f60\uff0c\u5bf9\u4efb\u4f55\u4e00\u5bf9\u5ba2\u4eba\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u544a\u8bc9\u4e3b\u4eba\u4ed6\u4eec\u662f\u5426\u80fd\u88ab\u5b89\u6392\u540c\u5e2d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570\uff1a N \uff08 \\le \\le 100\uff09\uff0c\u5373\u524d\u6765\u53c2\u5bb4\u7684\u5bbe\u5ba2\u603b\u4eba\u6570\uff0c\u5219\u8fd9\u4e9b\u4eba\u4ece1\u5230 N \u7f16\u53f7\uff1b M \u4e3a\u5df2\u77e5\u4e24\u4e24\u5bbe\u5ba2\u4e4b\u95f4\u7684\u5173\u7cfb\u6570\uff1b K \u4e3a\u67e5\u8be2\u7684\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u5bbe\u5ba2\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u683c\u5f0f\u4e3a\uff1a \u5bbe\u5ba21 \u5bbe\u5ba22 \u5173\u7cfb \uff0c\u5176\u4e2d \u5173\u7cfb \u4e3a1\u8868\u793a\u662f\u670b\u53cb\uff0c-1\u8868\u793a\u662f\u6b7b\u5bf9\u5934\u3002\u6ce8\u610f\u4e24\u4e2a\u4eba\u4e0d\u53ef\u80fd\u65e2\u662f\u670b\u53cb\u53c8\u662f\u654c\u4eba\u3002\u6700\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u9700\u8981\u67e5\u8be2\u7684\u5bbe\u5ba2\u7f16\u53f7\u3002 \u8fd9\u91cc\u5047\u8bbe\u670b\u53cb\u7684\u670b\u53cb\u4e5f\u662f\u670b\u53cb\u3002\u4f46\u654c\u4eba\u7684\u654c\u4eba\u5e76\u4e0d\u4e00\u5b9a\u5c31\u662f\u670b\u53cb\uff0c\u670b\u53cb\u7684\u654c\u4eba\u4e5f\u4e0d\u4e00\u5b9a\u662f\u654c\u4eba\u3002\u53ea\u6709\u5355\u7eaf\u76f4\u63a5\u7684\u654c\u5bf9\u5173\u7cfb\u624d\u662f\u7edd\u5bf9\u4e0d\u80fd\u540c\u5e2d\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u67e5\u8be2\u8f93\u51fa\u4e00\u884c\u7ed3\u679c\uff1a\u5982\u679c\u4e24\u4f4d\u5bbe\u5ba2\u4e4b\u95f4\u662f\u670b\u53cb\uff0c\u4e14\u6ca1\u6709\u654c\u5bf9\u5173\u7cfb\uff0c\u5219\u8f93\u51fa No problem \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u5e76\u4e0d\u662f\u670b\u53cb\uff0c\u4f46\u4e5f\u4e0d\u654c\u5bf9\uff0c\u5219\u8f93\u51fa OK \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u6709\u654c\u5bf9\uff0c\u7136\u800c\u4e5f\u6709\u5171\u540c\u7684\u670b\u53cb\uff0c\u5219\u8f93\u51fa OK but... \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u53ea\u6709\u654c\u5bf9\u5173\u7cfb\uff0c\u5219\u8f93\u51fa No way \u3002 \u8f93\u5165\u6837\u4f8b 7 8 4 5 6 1 2 7 -1 1 3 1 3 4 1 6 7 -1 1 2 1 1 4 1 2 3 -1 3 4 5 7 2 3 7 2 \u8f93\u51fa\u6837\u4f8b No problem OK OK but... No way Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ]; struct Node { vector < int > v ; }; map < int , Node > M ; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; pre [ x ] = r ; return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } bool Hos ( int x , int y ) { vector < int >:: iterator it ; for ( it = M [ x ]. v . begin (); it != M [ x ]. v . end (); it ++ ) { if (( * it ) == y ) return true ; } return false ; } int main () { int n , m , k ; scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) pre [ j ] = j ; } int x , y , flag ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & x , & y , & flag ); if ( flag == 1 ) join ( x , y ); else { M [ x ]. v . push_back ( y ); M [ y ]. v . push_back ( x ); } } for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); if ( find ( x ) == find ( y )) { if ( Hos ( x , y ) == true ) printf ( \"OK but... \\n \" ); else printf ( \"No problem \\n \" ); } else { if ( Hos ( x , y ) == true ) printf ( \"No way \\n \" ); else printf ( \"OK \\n \" ); } } }","title":"L2-010-\u6392\u5ea7\u4f4d"},{"location":"CCCC/L2-010-%E6%8E%92%E5%BA%A7%E4%BD%8D/#l2-010-\u6392\u5ea7\u4f4d","text":"","title":"L2-010 \u6392\u5ea7\u4f4d"},{"location":"CCCC/L2-010-%E6%8E%92%E5%BA%A7%E4%BD%8D/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5e03\u7f6e\u5bb4\u5e2d\u6700\u5fae\u5999\u7684\u4e8b\u60c5\uff0c\u5c31\u662f\u7ed9\u524d\u6765\u53c2\u5bb4\u7684\u5404\u4f4d\u5bbe\u5ba2\u5b89\u6392\u5ea7\u4f4d\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u603b\u4e0d\u80fd\u628a\u4e24\u4e2a\u6b7b\u5bf9\u5934\u6392\u5230\u540c\u4e00\u5f20\u5bb4\u4f1a\u684c\u65c1\uff01\u8fd9\u4e2a\u8270\u5de8\u4efb\u52a1\u73b0\u5728\u5c31\u4ea4\u7ed9\u4f60\uff0c\u5bf9\u4efb\u4f55\u4e00\u5bf9\u5ba2\u4eba\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u544a\u8bc9\u4e3b\u4eba\u4ed6\u4eec\u662f\u5426\u80fd\u88ab\u5b89\u6392\u540c\u5e2d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570\uff1a N \uff08 \\le \\le 100\uff09\uff0c\u5373\u524d\u6765\u53c2\u5bb4\u7684\u5bbe\u5ba2\u603b\u4eba\u6570\uff0c\u5219\u8fd9\u4e9b\u4eba\u4ece1\u5230 N \u7f16\u53f7\uff1b M \u4e3a\u5df2\u77e5\u4e24\u4e24\u5bbe\u5ba2\u4e4b\u95f4\u7684\u5173\u7cfb\u6570\uff1b K \u4e3a\u67e5\u8be2\u7684\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u5bbe\u5ba2\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u683c\u5f0f\u4e3a\uff1a \u5bbe\u5ba21 \u5bbe\u5ba22 \u5173\u7cfb \uff0c\u5176\u4e2d \u5173\u7cfb \u4e3a1\u8868\u793a\u662f\u670b\u53cb\uff0c-1\u8868\u793a\u662f\u6b7b\u5bf9\u5934\u3002\u6ce8\u610f\u4e24\u4e2a\u4eba\u4e0d\u53ef\u80fd\u65e2\u662f\u670b\u53cb\u53c8\u662f\u654c\u4eba\u3002\u6700\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u9700\u8981\u67e5\u8be2\u7684\u5bbe\u5ba2\u7f16\u53f7\u3002 \u8fd9\u91cc\u5047\u8bbe\u670b\u53cb\u7684\u670b\u53cb\u4e5f\u662f\u670b\u53cb\u3002\u4f46\u654c\u4eba\u7684\u654c\u4eba\u5e76\u4e0d\u4e00\u5b9a\u5c31\u662f\u670b\u53cb\uff0c\u670b\u53cb\u7684\u654c\u4eba\u4e5f\u4e0d\u4e00\u5b9a\u662f\u654c\u4eba\u3002\u53ea\u6709\u5355\u7eaf\u76f4\u63a5\u7684\u654c\u5bf9\u5173\u7cfb\u624d\u662f\u7edd\u5bf9\u4e0d\u80fd\u540c\u5e2d\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u67e5\u8be2\u8f93\u51fa\u4e00\u884c\u7ed3\u679c\uff1a\u5982\u679c\u4e24\u4f4d\u5bbe\u5ba2\u4e4b\u95f4\u662f\u670b\u53cb\uff0c\u4e14\u6ca1\u6709\u654c\u5bf9\u5173\u7cfb\uff0c\u5219\u8f93\u51fa No problem \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u5e76\u4e0d\u662f\u670b\u53cb\uff0c\u4f46\u4e5f\u4e0d\u654c\u5bf9\uff0c\u5219\u8f93\u51fa OK \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u6709\u654c\u5bf9\uff0c\u7136\u800c\u4e5f\u6709\u5171\u540c\u7684\u670b\u53cb\uff0c\u5219\u8f93\u51fa OK but... \uff1b\u5982\u679c\u4ed6\u4eec\u4e4b\u95f4\u53ea\u6709\u654c\u5bf9\u5173\u7cfb\uff0c\u5219\u8f93\u51fa No way \u3002 \u8f93\u5165\u6837\u4f8b 7 8 4 5 6 1 2 7 -1 1 3 1 3 4 1 6 7 -1 1 2 1 1 4 1 2 3 -1 3 4 5 7 2 3 7 2 \u8f93\u51fa\u6837\u4f8b No problem OK OK but... No way","title":"Statement"},{"location":"CCCC/L2-010-%E6%8E%92%E5%BA%A7%E4%BD%8D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ]; struct Node { vector < int > v ; }; map < int , Node > M ; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; pre [ x ] = r ; return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } bool Hos ( int x , int y ) { vector < int >:: iterator it ; for ( it = M [ x ]. v . begin (); it != M [ x ]. v . end (); it ++ ) { if (( * it ) == y ) return true ; } return false ; } int main () { int n , m , k ; scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) pre [ j ] = j ; } int x , y , flag ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & x , & y , & flag ); if ( flag == 1 ) join ( x , y ); else { M [ x ]. v . push_back ( y ); M [ y ]. v . push_back ( x ); } } for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); if ( find ( x ) == find ( y )) { if ( Hos ( x , y ) == true ) printf ( \"OK but... \\n \" ); else printf ( \"No problem \\n \" ); } else { if ( Hos ( x , y ) == true ) printf ( \"No way \\n \" ); else printf ( \"OK \\n \" ); } } }","title":"Solution"},{"location":"CCCC/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","text":"L2-011 \u73a9\u8f6c\u4e8c\u53c9\u6811 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u548c\u524d\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u5148\u5c06\u6811\u505a\u4e2a\u955c\u9762\u53cd\u8f6c\uff0c\u518d\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6240\u8c13\u955c\u9762\u53cd\u8f6c\uff0c\u662f\u6307\u5c06\u6240\u6709\u975e\u53f6\u7ed3\u70b9\u7684\u5de6\u53f3\u5b69\u5b50\u5bf9\u6362\u3002\u8fd9\u91cc\u5047\u8bbe\u952e\u503c\u90fd\u662f\u4e92\u4e0d\u76f8\u7b49\u7684\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 30\uff09\uff0c\u662f\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u5176\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u5176\u524d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u53cd\u8f6c\u540e\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 1 2 3 4 5 6 7 4 1 3 2 6 5 7 \u8f93\u51fa\u6837\u4f8b 4 6 1 7 5 3 2 Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define db double #define N 100010 int n , a [ 50 ], b [ 50 ]; struct node { int ls , rs ; node () {} node ( int ls , int rs ) : ls ( ls ), rs ( rs ) {} } arr [ N ]; vector < int > res ; int DFS ( int al , int ar , int bl , int br ) { if ( al > ar ) return -1 ; if ( al == ar ) return b [ bl ]; int root = b [ bl ]; int pos = -1 ; for ( int i = al ; i <= ar ; ++ i ) if ( a [ i ] == root ) { pos = i ; break ; } int sze = pos - al ; arr [ root ]. ls = DFS ( al , pos - 1 , bl + 1 , bl + sze ); arr [ root ]. rs = DFS ( pos + 1 , ar , bl + sze + 1 , br ); return root ; } void rev ( int u ) { if ( u == -1 ) return ; swap ( arr [ u ]. ls , arr [ u ]. rs ); rev ( arr [ u ]. ls ); rev ( arr [ u ]. rs ); } void BFS ( int u ) { if ( u == -1 ) return ; queue < int > q ; q . push ( u ); while ( ! q . empty ()) { int u = q . front (); q . pop (); res . push_back ( u ); int ls = arr [ u ]. ls , rs = arr [ u ]. rs ; if ( ls != -1 ) q . push ( ls ); if ( rs != -1 ) q . push ( rs ); } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( arr , -1 , sizeof arr ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); res . clear (); int root = DFS ( 1 , n , 1 , n ); rev ( root ); BFS ( root ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"L2-011-\u73a9\u8f6c\u4e8c\u53c9\u6811"},{"location":"CCCC/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/#l2-011-\u73a9\u8f6c\u4e8c\u53c9\u6811","text":"","title":"L2-011 \u73a9\u8f6c\u4e8c\u53c9\u6811"},{"location":"CCCC/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u548c\u524d\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u5148\u5c06\u6811\u505a\u4e2a\u955c\u9762\u53cd\u8f6c\uff0c\u518d\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6240\u8c13\u955c\u9762\u53cd\u8f6c\uff0c\u662f\u6307\u5c06\u6240\u6709\u975e\u53f6\u7ed3\u70b9\u7684\u5de6\u53f3\u5b69\u5b50\u5bf9\u6362\u3002\u8fd9\u91cc\u5047\u8bbe\u952e\u503c\u90fd\u662f\u4e92\u4e0d\u76f8\u7b49\u7684\u6b63\u6574\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 30\uff09\uff0c\u662f\u4e8c\u53c9\u6811\u4e2d\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u5176\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u5176\u524d\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u53cd\u8f6c\u540e\u7684\u5c42\u5e8f\u904d\u5386\u7684\u5e8f\u5217\u3002\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 1 2 3 4 5 6 7 4 1 3 2 6 5 7 \u8f93\u51fa\u6837\u4f8b 4 6 1 7 5 3 2","title":"Statement"},{"location":"CCCC/L2-011-%E7%8E%A9%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define db double #define N 100010 int n , a [ 50 ], b [ 50 ]; struct node { int ls , rs ; node () {} node ( int ls , int rs ) : ls ( ls ), rs ( rs ) {} } arr [ N ]; vector < int > res ; int DFS ( int al , int ar , int bl , int br ) { if ( al > ar ) return -1 ; if ( al == ar ) return b [ bl ]; int root = b [ bl ]; int pos = -1 ; for ( int i = al ; i <= ar ; ++ i ) if ( a [ i ] == root ) { pos = i ; break ; } int sze = pos - al ; arr [ root ]. ls = DFS ( al , pos - 1 , bl + 1 , bl + sze ); arr [ root ]. rs = DFS ( pos + 1 , ar , bl + sze + 1 , br ); return root ; } void rev ( int u ) { if ( u == -1 ) return ; swap ( arr [ u ]. ls , arr [ u ]. rs ); rev ( arr [ u ]. ls ); rev ( arr [ u ]. rs ); } void BFS ( int u ) { if ( u == -1 ) return ; queue < int > q ; q . push ( u ); while ( ! q . empty ()) { int u = q . front (); q . pop (); res . push_back ( u ); int ls = arr [ u ]. ls , rs = arr [ u ]. rs ; if ( ls != -1 ) q . push ( ls ); if ( rs != -1 ) q . push ( rs ); } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( arr , -1 , sizeof arr ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); res . clear (); int root = DFS ( 1 , n , 1 , n ); rev ( root ); BFS ( root ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD/","text":"L2-012 \u5173\u4e8e\u5806\u7684\u5224\u65ad Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c06\u4e00\u7cfb\u5217\u7ed9\u5b9a\u6570\u5b57\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u5c0f\u9876\u5806 H[] \u3002\u968f\u540e\u5224\u65ad\u4e00\u7cfb\u5217\u76f8\u5173\u547d\u9898\u662f\u5426\u4e3a\u771f\u3002\u547d\u9898\u5206\u4e0b\u5217\u51e0\u79cd\uff1a x is the root \uff1a x \u662f\u6839\u7ed3\u70b9\uff1b x and y are siblings \uff1a x \u548c y \u662f\u5144\u5f1f\u7ed3\u70b9\uff1b x is the parent of y \uff1a x \u662f y \u7684\u7236\u7ed3\u70b9\uff1b x is a child of y \uff1a x \u662f y \u7684\u4e00\u4e2a\u5b50\u7ed3\u70b9\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u7ec4\u6d4b\u8bd5\u7b2c1\u884c\u5305\u542b2\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 1000\uff09\u548c M \uff08 \\le \\le 20\uff09\uff0c\u5206\u522b\u662f\u63d2\u5165\u5143\u7d20\u7684\u4e2a\u6570\u3001\u4ee5\u53ca\u9700\u8981\u5224\u65ad\u7684\u547d\u9898\u6570\u3002\u4e0b\u4e00\u884c\u7ed9\u51fa\u533a\u95f4 [-10000, 10000] [-10000, 10000] \u5185\u7684 N \u4e2a\u8981\u88ab\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u5c0f\u9876\u5806\u7684\u6574\u6570\u3002\u4e4b\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u547d\u9898\u3002\u9898\u76ee\u4fdd\u8bc1\u547d\u9898\u4e2d\u7684\u7ed3\u70b9\u952e\u503c\u90fd\u662f\u5b58\u5728\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u8f93\u5165\u7684\u6bcf\u4e2a\u547d\u9898\uff0c\u5982\u679c\u5176\u4e3a\u771f\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa T \uff0c\u5426\u5219\u8f93\u51fa F \u3002 \u8f93\u5165\u6837\u4f8b 5 4 46 23 26 24 10 24 is the root 26 and 23 are siblings 46 is the parent of 23 23 is a child of 10 \u8f93\u51fa\u6837\u4f8b F T F T Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < int , int > vis ; int n , m , num ; scanf ( \"%d%d\" , & n , & m ); vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); num = - num ; v . push_back ( num ); push_heap ( v . begin (), v . end ()); } for ( int i = 0 ; i < n ; i ++ ) vis [ - v [ i ]] = i + 1 ; while ( m -- ) { int a , b , c , d ; string s ; cin >> a ; cin >> s ; if ( s == \"and\" ) // 2 { cin >> b ; cin >> s ; cin >> s ; c = vis [ a ]; d = vis [ b ]; if ( v [ c / 2 ] == v [ d / 2 ] && c != d ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } else { cin >> s ; if ( s == \"the\" ) { cin >> s ; if ( s == \"root\" ) // 1 { if ( vis [ a ] == 1 ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } else // 3 { cin >> s ; cin >> b ; c = vis [ a ]; d = vis [ b ]; if ( d / 2 == c ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } } else // 4 { cin >> s ; cin >> s ; cin >> b ; c = vis [ a ]; d = vis [ b ]; if ( c / 2 == d ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } } } }","title":"L2-012-\u5173\u4e8e\u5806\u7684\u5224\u65ad"},{"location":"CCCC/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD/#l2-012-\u5173\u4e8e\u5806\u7684\u5224\u65ad","text":"","title":"L2-012 \u5173\u4e8e\u5806\u7684\u5224\u65ad"},{"location":"CCCC/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c06\u4e00\u7cfb\u5217\u7ed9\u5b9a\u6570\u5b57\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u5c0f\u9876\u5806 H[] \u3002\u968f\u540e\u5224\u65ad\u4e00\u7cfb\u5217\u76f8\u5173\u547d\u9898\u662f\u5426\u4e3a\u771f\u3002\u547d\u9898\u5206\u4e0b\u5217\u51e0\u79cd\uff1a x is the root \uff1a x \u662f\u6839\u7ed3\u70b9\uff1b x and y are siblings \uff1a x \u548c y \u662f\u5144\u5f1f\u7ed3\u70b9\uff1b x is the parent of y \uff1a x \u662f y \u7684\u7236\u7ed3\u70b9\uff1b x is a child of y \uff1a x \u662f y \u7684\u4e00\u4e2a\u5b50\u7ed3\u70b9\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u7ec4\u6d4b\u8bd5\u7b2c1\u884c\u5305\u542b2\u4e2a\u6b63\u6574\u6570 N \uff08 \\le \\le 1000\uff09\u548c M \uff08 \\le \\le 20\uff09\uff0c\u5206\u522b\u662f\u63d2\u5165\u5143\u7d20\u7684\u4e2a\u6570\u3001\u4ee5\u53ca\u9700\u8981\u5224\u65ad\u7684\u547d\u9898\u6570\u3002\u4e0b\u4e00\u884c\u7ed9\u51fa\u533a\u95f4 [-10000, 10000] [-10000, 10000] \u5185\u7684 N \u4e2a\u8981\u88ab\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u5c0f\u9876\u5806\u7684\u6574\u6570\u3002\u4e4b\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u547d\u9898\u3002\u9898\u76ee\u4fdd\u8bc1\u547d\u9898\u4e2d\u7684\u7ed3\u70b9\u952e\u503c\u90fd\u662f\u5b58\u5728\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u8f93\u5165\u7684\u6bcf\u4e2a\u547d\u9898\uff0c\u5982\u679c\u5176\u4e3a\u771f\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa T \uff0c\u5426\u5219\u8f93\u51fa F \u3002 \u8f93\u5165\u6837\u4f8b 5 4 46 23 26 24 10 24 is the root 26 and 23 are siblings 46 is the parent of 23 23 is a child of 10 \u8f93\u51fa\u6837\u4f8b F T F T","title":"Statement"},{"location":"CCCC/L2-012-%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < int , int > vis ; int n , m , num ; scanf ( \"%d%d\" , & n , & m ); vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); num = - num ; v . push_back ( num ); push_heap ( v . begin (), v . end ()); } for ( int i = 0 ; i < n ; i ++ ) vis [ - v [ i ]] = i + 1 ; while ( m -- ) { int a , b , c , d ; string s ; cin >> a ; cin >> s ; if ( s == \"and\" ) // 2 { cin >> b ; cin >> s ; cin >> s ; c = vis [ a ]; d = vis [ b ]; if ( v [ c / 2 ] == v [ d / 2 ] && c != d ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } else { cin >> s ; if ( s == \"the\" ) { cin >> s ; if ( s == \"root\" ) // 1 { if ( vis [ a ] == 1 ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } else // 3 { cin >> s ; cin >> b ; c = vis [ a ]; d = vis [ b ]; if ( d / 2 == c ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } } else // 4 { cin >> s ; cin >> s ; cin >> b ; c = vis [ a ]; d = vis [ b ]; if ( c / 2 == d ) cout << \"T \\n \" ; else cout << \"F \\n \" ; } } } }","title":"Solution"},{"location":"CCCC/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5/","text":"L2-013 \u7ea2\u8272\u8b66\u62a5 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6218\u4e89\u4e2d\u4fdd\u6301\u5404\u4e2a\u57ce\u5e02\u95f4\u7684\u8fde\u901a\u6027\u975e\u5e38\u91cd\u8981\u3002\u672c\u9898\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u62a5\u8b66\u7a0b\u5e8f\uff0c\u5f53\u5931\u53bb\u4e00\u4e2a\u57ce\u5e02\u5bfc\u81f4\u56fd\u5bb6\u88ab\u5206\u88c2\u4e3a\u591a\u4e2a\u65e0\u6cd5\u8fde\u901a\u7684\u533a\u57df\u65f6\uff0c\u5c31\u53d1\u51fa\u7ea2\u8272\u8b66\u62a5\u3002\u6ce8\u610f\uff1a\u82e5\u8be5\u56fd\u672c\u6765\u5c31\u4e0d\u5b8c\u5168\u8fde\u901a\uff0c\u662f\u5206\u88c2\u7684k\u4e2a\u533a\u57df\uff0c\u800c\u5931\u53bb\u4e00\u4e2a\u57ce\u5e02\u5e76\u4e0d\u6539\u53d8\u5176\u4ed6\u57ce\u5e02\u4e4b\u95f4\u7684\u8fde\u901a\u6027\uff0c\u5219\u4e0d\u8981\u53d1\u51fa\u8b66\u62a5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 N \uff080 < < N \\le \\le 500\uff09\u548c M \uff08 \\le \\le 5000\uff09\uff0c\u5206\u522b\u4e3a\u57ce\u5e02\u4e2a\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u57ce\u5e02\u4ece0\u5230 N -1\u7f16\u53f7\uff09\u548c\u8fde\u63a5\u4e24\u57ce\u5e02\u7684\u901a\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u901a\u8def\u6240\u8fde\u63a5\u7684\u4e24\u4e2a\u57ce\u5e02\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5728\u57ce\u5e02\u4fe1\u606f\u4e4b\u540e\u7ed9\u51fa\u88ab\u653b\u5360\u7684\u4fe1\u606f\uff0c\u5373\u4e00\u4e2a\u6b63\u6574\u6570 K \u548c\u968f\u540e\u7684 K \u4e2a\u88ab\u653b\u5360\u7684\u57ce\u5e02\u7684\u7f16\u53f7\u3002 \u6ce8\u610f\uff1a\u8f93\u5165\u4fdd\u8bc1\u7ed9\u51fa\u7684\u88ab\u653b\u5360\u7684\u57ce\u5e02\u7f16\u53f7\u90fd\u662f\u5408\u6cd5\u7684\u4e14\u65e0\u91cd\u590d\uff0c\u4f46\u5e76\u4e0d\u4fdd\u8bc1\u7ed9\u51fa\u7684\u901a\u8def\u6ca1\u6709\u91cd\u590d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u88ab\u653b\u5360\u7684\u57ce\u5e02\uff0c\u5982\u679c\u5b83\u4f1a\u6539\u53d8\u6574\u4e2a\u56fd\u5bb6\u7684\u8fde\u901a\u6027\uff0c\u5219\u8f93\u51fa Red Alert: City k is lost! \uff0c\u5176\u4e2d k \u662f\u8be5\u57ce\u5e02\u7684\u7f16\u53f7\uff1b\u5426\u5219\u53ea\u8f93\u51fa City k is lost. \u5373\u53ef\u3002\u5982\u679c\u8be5\u56fd\u5931\u53bb\u4e86\u6700\u540e\u4e00\u4e2a\u57ce\u5e02\uff0c\u5219\u589e\u52a0\u4e00\u884c\u8f93\u51fa Game Over. \u3002 \u8f93\u5165\u6837\u4f8b 5 4 0 1 1 3 3 0 0 4 5 1 2 0 4 3 \u8f93\u51fa\u6837\u4f8b City 1 is lost. City 2 is lost. Red Alert: City 0 is lost! City 4 is lost. City 3 is lost. Game Over. Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 5e2 + 5 ; const int MOD = 1e9 + 7 ; int G [ maxn ][ maxn ]; int v [ maxn ]; int n , m ; void dfs ( int x ) { v [ x ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 0 && G [ x ][ i ] == 1 ) dfs ( i ); } } void init () { CLR ( G ); CLR ( v ); } int main () { scanf ( \"%d%d\" , & n , & m ); int x , y ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); G [ x ][ y ] = G [ y ][ x ] = 1 ; } int fin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 0 ) { dfs ( i ); fin ++ ; } } int k ; scanf ( \"%d\" , & k ); for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d\" , & x ); for ( int j = 0 ; j < n ; j ++ ) G [ x ][ j ] = G [ j ][ x ] = 0 ; int temp = 0 ; CLR ( v ); for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] == 0 ) { dfs ( j ); temp ++ ; } } if ( temp > fin + 1 ) printf ( \"Red Alert: City %d is lost! \\n \" , x ); else printf ( \"City %d is lost. \\n \" , x ); fin = temp ; if ( i == n - 1 ) printf ( \"Game Over. \\n \" ); } }","title":"L2-013-\u7ea2\u8272\u8b66\u62a5"},{"location":"CCCC/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5/#l2-013-\u7ea2\u8272\u8b66\u62a5","text":"","title":"L2-013 \u7ea2\u8272\u8b66\u62a5"},{"location":"CCCC/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6218\u4e89\u4e2d\u4fdd\u6301\u5404\u4e2a\u57ce\u5e02\u95f4\u7684\u8fde\u901a\u6027\u975e\u5e38\u91cd\u8981\u3002\u672c\u9898\u8981\u6c42\u4f60\u7f16\u5199\u4e00\u4e2a\u62a5\u8b66\u7a0b\u5e8f\uff0c\u5f53\u5931\u53bb\u4e00\u4e2a\u57ce\u5e02\u5bfc\u81f4\u56fd\u5bb6\u88ab\u5206\u88c2\u4e3a\u591a\u4e2a\u65e0\u6cd5\u8fde\u901a\u7684\u533a\u57df\u65f6\uff0c\u5c31\u53d1\u51fa\u7ea2\u8272\u8b66\u62a5\u3002\u6ce8\u610f\uff1a\u82e5\u8be5\u56fd\u672c\u6765\u5c31\u4e0d\u5b8c\u5168\u8fde\u901a\uff0c\u662f\u5206\u88c2\u7684k\u4e2a\u533a\u57df\uff0c\u800c\u5931\u53bb\u4e00\u4e2a\u57ce\u5e02\u5e76\u4e0d\u6539\u53d8\u5176\u4ed6\u57ce\u5e02\u4e4b\u95f4\u7684\u8fde\u901a\u6027\uff0c\u5219\u4e0d\u8981\u53d1\u51fa\u8b66\u62a5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570 N \uff080 < < N \\le \\le 500\uff09\u548c M \uff08 \\le \\le 5000\uff09\uff0c\u5206\u522b\u4e3a\u57ce\u5e02\u4e2a\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u57ce\u5e02\u4ece0\u5230 N -1\u7f16\u53f7\uff09\u548c\u8fde\u63a5\u4e24\u57ce\u5e02\u7684\u901a\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u901a\u8def\u6240\u8fde\u63a5\u7684\u4e24\u4e2a\u57ce\u5e02\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5728\u57ce\u5e02\u4fe1\u606f\u4e4b\u540e\u7ed9\u51fa\u88ab\u653b\u5360\u7684\u4fe1\u606f\uff0c\u5373\u4e00\u4e2a\u6b63\u6574\u6570 K \u548c\u968f\u540e\u7684 K \u4e2a\u88ab\u653b\u5360\u7684\u57ce\u5e02\u7684\u7f16\u53f7\u3002 \u6ce8\u610f\uff1a\u8f93\u5165\u4fdd\u8bc1\u7ed9\u51fa\u7684\u88ab\u653b\u5360\u7684\u57ce\u5e02\u7f16\u53f7\u90fd\u662f\u5408\u6cd5\u7684\u4e14\u65e0\u91cd\u590d\uff0c\u4f46\u5e76\u4e0d\u4fdd\u8bc1\u7ed9\u51fa\u7684\u901a\u8def\u6ca1\u6709\u91cd\u590d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u88ab\u653b\u5360\u7684\u57ce\u5e02\uff0c\u5982\u679c\u5b83\u4f1a\u6539\u53d8\u6574\u4e2a\u56fd\u5bb6\u7684\u8fde\u901a\u6027\uff0c\u5219\u8f93\u51fa Red Alert: City k is lost! \uff0c\u5176\u4e2d k \u662f\u8be5\u57ce\u5e02\u7684\u7f16\u53f7\uff1b\u5426\u5219\u53ea\u8f93\u51fa City k is lost. \u5373\u53ef\u3002\u5982\u679c\u8be5\u56fd\u5931\u53bb\u4e86\u6700\u540e\u4e00\u4e2a\u57ce\u5e02\uff0c\u5219\u589e\u52a0\u4e00\u884c\u8f93\u51fa Game Over. \u3002 \u8f93\u5165\u6837\u4f8b 5 4 0 1 1 3 3 0 0 4 5 1 2 0 4 3 \u8f93\u51fa\u6837\u4f8b City 1 is lost. City 2 is lost. Red Alert: City 0 is lost! City 4 is lost. City 3 is lost. Game Over.","title":"Statement"},{"location":"CCCC/L2-013-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 5e2 + 5 ; const int MOD = 1e9 + 7 ; int G [ maxn ][ maxn ]; int v [ maxn ]; int n , m ; void dfs ( int x ) { v [ x ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 0 && G [ x ][ i ] == 1 ) dfs ( i ); } } void init () { CLR ( G ); CLR ( v ); } int main () { scanf ( \"%d%d\" , & n , & m ); int x , y ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); G [ x ][ y ] = G [ y ][ x ] = 1 ; } int fin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 0 ) { dfs ( i ); fin ++ ; } } int k ; scanf ( \"%d\" , & k ); for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d\" , & x ); for ( int j = 0 ; j < n ; j ++ ) G [ x ][ j ] = G [ j ][ x ] = 0 ; int temp = 0 ; CLR ( v ); for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] == 0 ) { dfs ( j ); temp ++ ; } } if ( temp > fin + 1 ) printf ( \"Red Alert: City %d is lost! \\n \" , x ); else printf ( \"City %d is lost. \\n \" , x ); fin = temp ; if ( i == n - 1 ) printf ( \"Game Over. \\n \" ); } }","title":"Solution"},{"location":"CCCC/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6/","text":"L2-014 \u5217\u8f66\u8c03\u5ea6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u706b\u8f66\u7ad9\u7684\u5217\u8f66\u8c03\u5ea6\u94c1\u8f68\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e24\u7aef\u5206\u522b\u662f\u4e00\u6761\u5165\u53e3\uff08Entrance\uff09\u8f68\u9053\u548c\u4e00\u6761\u51fa\u53e3\uff08Exit\uff09\u8f68\u9053\uff0c\u5b83\u4eec\u4e4b\u95f4\u6709 N \u6761\u5e73\u884c\u7684\u8f68\u9053\u3002\u6bcf\u8d9f\u5217\u8f66\u4ece\u5165\u53e3\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e00\u6761\u8f68\u9053\u8fdb\u5165\uff0c\u6700\u540e\u4ece\u51fa\u53e3\u79bb\u5f00\u3002\u5728\u56fe\u4e2d\u67099\u8d9f\u5217\u8f66\uff0c\u5728\u5165\u53e3\u5904\u6309\u7167{8\uff0c4\uff0c2\uff0c5\uff0c3\uff0c9\uff0c1\uff0c6\uff0c7}\u7684\u987a\u5e8f\u6392\u961f\u7b49\u5f85\u8fdb\u5165\u3002\u5982\u679c\u8981\u6c42\u5b83\u4eec\u5fc5\u987b\u6309\u5e8f\u53f7\u9012\u51cf\u7684\u987a\u5e8f\u4ece\u51fa\u53e3\u79bb\u5f00\uff0c\u5219\u81f3\u5c11\u9700\u8981\u591a\u5c11\u6761\u5e73\u884c\u94c1\u8f68\u7528\u4e8e\u8c03\u5ea6\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 N (2 \\le \\le N \\le 10^5 \\le 10^5 )\uff0c\u4e0b\u4e00\u884c\u7ed9\u51fa\u4ece1\u5230 N \u7684\u6574\u6570\u5e8f\u53f7\u7684\u4e00\u4e2a\u91cd\u6392\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53ef\u4ee5\u5c06\u8f93\u5165\u7684\u5217\u8f66\u6309\u5e8f\u53f7\u9012\u51cf\u7684\u987a\u5e8f\u8c03\u79bb\u6240\u9700\u8981\u7684\u6700\u5c11\u7684\u94c1\u8f68\u6761\u6570\u3002 \u8f93\u5165\u6837\u4f8b 9 8 4 2 5 3 9 1 6 7 \u8f93\u51fa\u6837\u4f8b 4 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { vector < int > v ; int n , num , ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); vector < int >:: iterator it ; it = upper_bound ( v . begin (), v . end (), num ); if ( it != v . end ()) ( * it ) = num ; else v . push_back ( num ); } cout << v . size () << endl ; }","title":"L2-014-\u5217\u8f66\u8c03\u5ea6"},{"location":"CCCC/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6/#l2-014-\u5217\u8f66\u8c03\u5ea6","text":"","title":"L2-014 \u5217\u8f66\u8c03\u5ea6"},{"location":"CCCC/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u706b\u8f66\u7ad9\u7684\u5217\u8f66\u8c03\u5ea6\u94c1\u8f68\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e24\u7aef\u5206\u522b\u662f\u4e00\u6761\u5165\u53e3\uff08Entrance\uff09\u8f68\u9053\u548c\u4e00\u6761\u51fa\u53e3\uff08Exit\uff09\u8f68\u9053\uff0c\u5b83\u4eec\u4e4b\u95f4\u6709 N \u6761\u5e73\u884c\u7684\u8f68\u9053\u3002\u6bcf\u8d9f\u5217\u8f66\u4ece\u5165\u53e3\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e00\u6761\u8f68\u9053\u8fdb\u5165\uff0c\u6700\u540e\u4ece\u51fa\u53e3\u79bb\u5f00\u3002\u5728\u56fe\u4e2d\u67099\u8d9f\u5217\u8f66\uff0c\u5728\u5165\u53e3\u5904\u6309\u7167{8\uff0c4\uff0c2\uff0c5\uff0c3\uff0c9\uff0c1\uff0c6\uff0c7}\u7684\u987a\u5e8f\u6392\u961f\u7b49\u5f85\u8fdb\u5165\u3002\u5982\u679c\u8981\u6c42\u5b83\u4eec\u5fc5\u987b\u6309\u5e8f\u53f7\u9012\u51cf\u7684\u987a\u5e8f\u4ece\u51fa\u53e3\u79bb\u5f00\uff0c\u5219\u81f3\u5c11\u9700\u8981\u591a\u5c11\u6761\u5e73\u884c\u94c1\u8f68\u7528\u4e8e\u8c03\u5ea6\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 N (2 \\le \\le N \\le 10^5 \\le 10^5 )\uff0c\u4e0b\u4e00\u884c\u7ed9\u51fa\u4ece1\u5230 N \u7684\u6574\u6570\u5e8f\u53f7\u7684\u4e00\u4e2a\u91cd\u6392\u5217\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53ef\u4ee5\u5c06\u8f93\u5165\u7684\u5217\u8f66\u6309\u5e8f\u53f7\u9012\u51cf\u7684\u987a\u5e8f\u8c03\u79bb\u6240\u9700\u8981\u7684\u6700\u5c11\u7684\u94c1\u8f68\u6761\u6570\u3002 \u8f93\u5165\u6837\u4f8b 9 8 4 2 5 3 9 1 6 7 \u8f93\u51fa\u6837\u4f8b 4","title":"Statement"},{"location":"CCCC/L2-014-%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { vector < int > v ; int n , num , ans = 0 ; cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); vector < int >:: iterator it ; it = upper_bound ( v . begin (), v . end (), num ); if ( it != v . end ()) ( * it ) = num ; else v . push_back ( num ); } cout << v . size () << endl ; }","title":"Solution"},{"location":"CCCC/L2-015-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9/","text":"L2-015 \u4e92\u8bc4\u6210\u7ee9 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b66\u751f\u4e92\u8bc4\u4f5c\u4e1a\u7684\u7b80\u5355\u89c4\u5219\u662f\u8fd9\u6837\u5b9a\u7684\uff1a\u6bcf\u4e2a\u4eba\u7684\u4f5c\u4e1a\u4f1a\u88ab k \u4e2a\u540c\u5b66\u8bc4\u5ba1\uff0c\u5f97\u5230 k \u4e2a\u6210\u7ee9\u3002\u7cfb\u7edf\u9700\u8981\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u4e00\u4e2a\u6700\u4f4e\u5206\uff0c\u5c06\u5269\u4e0b\u7684\u5206\u6570\u53d6\u5e73\u5747\uff0c\u5c31\u5f97\u5230\u8fd9\u4e2a\u5b66\u751f\u7684\u6700\u540e\u6210\u7ee9\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u8fd9\u4e2a\u4e92\u8bc4\u7cfb\u7edf\u7684\u7b97\u5206\u6a21\u5757\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570 N \uff083 < < N \\le 10^4 \\le 10^4 \uff0c\u5b66\u751f\u603b\u6570\uff09\u3001 k \uff083 \\le \\le k \\le \\le 10\uff0c\u6bcf\u4efd\u4f5c\u4e1a\u7684\u8bc4\u5ba1\u6570\uff09\u3001 M \uff08 \\le \\le 20\uff0c\u9700\u8981\u8f93\u51fa\u7684\u5b66\u751f\u6570\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4efd\u4f5c\u4e1a\u5f97\u5230\u7684 k \u4e2a\u8bc4\u5ba1\u6210\u7ee9\uff08\u5728\u533a\u95f4[0, 100]\u5185\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u975e\u9012\u51cf\u987a\u5e8f\u8f93\u51fa\u6700\u540e\u5f97\u5206\u6700\u9ad8\u7684 M \u4e2a\u6210\u7ee9\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e3\u4f4d\u3002\u5206\u6570\u95f4\u67091\u4e2a\u7a7a\u683c\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 5 3 88 90 85 99 60 67 60 80 76 70 90 93 96 99 99 78 65 77 70 72 88 88 88 88 88 55 55 55 55 55 \u8f93\u51fa\u6837\u4f8b 87.667 88.000 96.000 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; bool comp ( double x , double y ) { return x > y ; } int main () { int n , k , m ; scanf ( \"%d%d%d\" , & n , & k , & m ); vector < double > v , ans ; for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 , Max = INT_MIN , Min = INT_MAX , num ; for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%lf\" , & num ); if ( num > Max ) Max = num ; if ( num < Min ) Min = num ; sum += num ; } sum -= ( Max + Min ); sum /= ( k - 2 ); v . push_back ( sum ); } sort ( v . begin (), v . end (), comp ); for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( i != m - 1 ) printf ( \" \" ); printf ( \"%.3lf\" , v [ i ]); } cout << endl ; }","title":"L2-015-\u4e92\u8bc4\u6210\u7ee9"},{"location":"CCCC/L2-015-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9/#l2-015-\u4e92\u8bc4\u6210\u7ee9","text":"","title":"L2-015 \u4e92\u8bc4\u6210\u7ee9"},{"location":"CCCC/L2-015-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b66\u751f\u4e92\u8bc4\u4f5c\u4e1a\u7684\u7b80\u5355\u89c4\u5219\u662f\u8fd9\u6837\u5b9a\u7684\uff1a\u6bcf\u4e2a\u4eba\u7684\u4f5c\u4e1a\u4f1a\u88ab k \u4e2a\u540c\u5b66\u8bc4\u5ba1\uff0c\u5f97\u5230 k \u4e2a\u6210\u7ee9\u3002\u7cfb\u7edf\u9700\u8981\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u4e00\u4e2a\u6700\u4f4e\u5206\uff0c\u5c06\u5269\u4e0b\u7684\u5206\u6570\u53d6\u5e73\u5747\uff0c\u5c31\u5f97\u5230\u8fd9\u4e2a\u5b66\u751f\u7684\u6700\u540e\u6210\u7ee9\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u8fd9\u4e2a\u4e92\u8bc4\u7cfb\u7edf\u7684\u7b97\u5206\u6a21\u5757\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570 N \uff083 < < N \\le 10^4 \\le 10^4 \uff0c\u5b66\u751f\u603b\u6570\uff09\u3001 k \uff083 \\le \\le k \\le \\le 10\uff0c\u6bcf\u4efd\u4f5c\u4e1a\u7684\u8bc4\u5ba1\u6570\uff09\u3001 M \uff08 \\le \\le 20\uff0c\u9700\u8981\u8f93\u51fa\u7684\u5b66\u751f\u6570\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4efd\u4f5c\u4e1a\u5f97\u5230\u7684 k \u4e2a\u8bc4\u5ba1\u6210\u7ee9\uff08\u5728\u533a\u95f4[0, 100]\u5185\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u975e\u9012\u51cf\u987a\u5e8f\u8f93\u51fa\u6700\u540e\u5f97\u5206\u6700\u9ad8\u7684 M \u4e2a\u6210\u7ee9\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e3\u4f4d\u3002\u5206\u6570\u95f4\u67091\u4e2a\u7a7a\u683c\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 5 3 88 90 85 99 60 67 60 80 76 70 90 93 96 99 99 78 65 77 70 72 88 88 88 88 88 55 55 55 55 55 \u8f93\u51fa\u6837\u4f8b 87.667 88.000 96.000","title":"Statement"},{"location":"CCCC/L2-015-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; bool comp ( double x , double y ) { return x > y ; } int main () { int n , k , m ; scanf ( \"%d%d%d\" , & n , & k , & m ); vector < double > v , ans ; for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 , Max = INT_MIN , Min = INT_MAX , num ; for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%lf\" , & num ); if ( num > Max ) Max = num ; if ( num < Min ) Min = num ; sum += num ; } sum -= ( Max + Min ); sum /= ( k - 2 ); v . push_back ( sum ); } sort ( v . begin (), v . end (), comp ); for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( i != m - 1 ) printf ( \" \" ); printf ( \"%.3lf\" , v [ i ]); } cout << endl ; }","title":"Solution"},{"location":"CCCC/L2-016-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%A4%B1%E6%95%A3%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%85%84%E5%A6%B9/","text":"L2-016 \u613f\u5929\u4e0b\u6709\u60c5\u4eba\u90fd\u662f\u5931\u6563\u591a\u5e74\u7684\u5144\u59b9 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5475\u5475\u3002\u5927\u5bb6\u90fd\u77e5\u9053\u4e94\u670d\u4ee5\u5185\u4e0d\u5f97\u901a\u5a5a\uff0c\u5373\u4e24\u4e2a\u4eba\u6700\u8fd1\u7684\u5171\u540c\u7956\u5148\u5982\u679c\u5728\u4e94\u4ee3\u4ee5\u5185\uff08\u5373\u672c\u4eba\u3001\u7236\u6bcd\u3001\u7956\u7236\u6bcd\u3001\u66fe\u7956\u7236\u6bcd\u3001\u9ad8\u7956\u7236\u6bcd\uff09\u5219\u4e0d\u53ef\u901a\u5a5a\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5e2e\u52a9\u4e00\u5bf9\u6709\u60c5\u4eba\u5224\u65ad\u4e00\u4e0b\uff0c\u4ed6\u4eec\u7a76\u7adf\u662f\u5426\u53ef\u4ee5\u6210\u5a5a\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff082 \\le \\le N \\le 10^4 \\le 10^4 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u4fe1\u606f\uff1a \u672c\u4ebaID \u6027\u522b \u7236\u4eb2ID \u6bcd\u4eb2ID \u5176\u4e2d ID \u662f5\u4f4d\u6570\u5b57\uff0c\u6bcf\u4eba\u4e0d\u540c\uff1b\u6027\u522b M \u4ee3\u8868\u7537\u6027\u3001 F \u4ee3\u8868\u5973\u6027\u3002\u5982\u679c\u67d0\u4eba\u7684\u7236\u4eb2\u6216\u6bcd\u4eb2\u5df2\u7ecf\u4e0d\u53ef\u8003\uff0c\u5219\u76f8\u5e94\u7684 ID \u4f4d\u7f6e\u4e0a\u6807\u8bb0\u4e3a -1 \u3002 \u63a5\u4e0b\u6765\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K \uff0c\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u6709\u60c5\u4eba\u7684 ID \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u4e24\u4e2a\u4eba\u662f\u540c\u8f88\uff0c\u6bcf\u4eba\u53ea\u6709\u4e00\u4e2a\u6027\u522b\uff0c\u5e76\u4e14\u8840\u7f18\u5173\u7cfb\u7f51\u4e2d\u6ca1\u6709\u4e71\u4f26\u6216\u9694\u8f88\u6210\u5a5a\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u6709\u60c5\u4eba\uff0c\u5224\u65ad\u4ed6\u4eec\u7684\u5173\u7cfb\u662f\u5426\u53ef\u4ee5\u901a\u5a5a\uff1a\u5982\u679c\u4e24\u4eba\u662f\u540c\u6027\uff0c\u8f93\u51fa Never Mind \uff1b\u5982\u679c\u662f\u5f02\u6027\u5e76\u4e14\u5173\u7cfb\u51fa\u4e86\u4e94\u670d\uff0c\u8f93\u51fa Yes \uff1b\u5982\u679c\u5f02\u6027\u5173\u7cfb\u672a\u51fa\u4e94\u670d\uff0c\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 24 00001 M 01111 -1 00002 F 02222 03333 00003 M 02222 03333 00004 F 04444 03333 00005 M 04444 05555 00006 F 04444 05555 00007 F 06666 07777 00008 M 06666 07777 00009 M 00001 00002 00010 M 00003 00006 00011 F 00005 00007 00012 F 00008 08888 00013 F 00009 00011 00014 M 00010 09999 00015 M 00010 09999 00016 M 10000 00012 00017 F -1 00012 00018 F 11000 00013 00019 F 11100 00018 00020 F 00015 11110 00021 M 11100 00020 00022 M 00016 -1 00023 M 10012 00017 00024 M 00022 10013 9 00021 00024 00019 00024 00011 00012 00022 00018 00001 00004 00013 00016 00017 00015 00019 00021 00010 00011 \u8f93\u51fa\u6837\u4f8b Never Mind Yes Never Mind No Yes No Yes No No Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; map < int , pii > m ; map < int , int > judge [ 2 ]; queue < int > q [ 2 ]; int ans ; void bfs ( int cur ) { if ( cur == 7 ) return ; for ( int i = 0 ; i < 2 ; i ++ ) { judge [ i ]. clear (); while ( ! q [ i ]. empty ()) { int num = q [ i ]. front (); q [ i ]. pop (); if ( num != -1 ) judge [ i ][ num ] = 1 ; } } map < int , int >:: iterator it ; // for (int i = 0; i < 2; i++) // { // for (it = judge[i].begin(); it != judge[i].end(); it++) // { // if (it != judge[i].begin()) // printf(\" \"); // cout << it->first; // } // cout << endl; // } for ( it = judge [ 0 ]. begin (); it != judge [ 0 ]. end (); it ++ ) { if ( judge [ 1 ][ it -> first ]) { ans = cur ; return ; } else judge [ 1 ]. erase ( it -> first ); } for ( int i = 0 ; i < 2 ; i ++ ) { for ( it = judge [ i ]. begin (); it != judge [ i ]. end (); it ++ ) { if ( m [ it -> first ]. first != -1 ) q [ i ]. push ( m [ it -> first ]. first ); if ( m [ it -> first ]. second != -1 ) q [ i ]. push ( m [ it -> first ]. second ); } } bfs ( cur + 1 ); } int main () { map < int , int > vis , opt ; int n ; scanf ( \"%d\" , & n ); int a , b , c , d ; char code ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d %c %d %d\" , & a , & code , & b , & c ); opt [ a ] = 1 ; if ( code == 'M' ) vis [ a ] = 0 ; else vis [ a ] = 1 ; m [ a ]. first = b ; if ( b != -1 ) { if ( opt [ b ] == 0 ) { m [ b ]. first = -1 ; m [ b ]. second = -1 ; } vis [ b ] = 0 ; } m [ a ]. second = c ; if ( c != -1 ) { if ( opt [ c ] == 0 ) { m [ c ]. first = -1 ; m [ c ]. second = -1 ; } vis [ c ] = 1 ; } } scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( vis [ a ] == vis [ b ]) printf ( \"Never Mind \\n \" ); else { while ( ! q [ 0 ]. empty ()) q [ 0 ]. pop (); while ( ! q [ 1 ]. empty ()) q [ 1 ]. pop (); q [ 0 ]. push ( a ); q [ 1 ]. push ( b ); ans = INT_MAX ; bfs ( 1 ); if ( ans > 5 ) printf ( \"Yes \\n \" ); else printf ( \"No \\n \" ); } } }","title":"L2-016-\u613f\u5929\u4e0b\u6709\u60c5\u4eba\u90fd\u662f\u5931\u6563\u591a\u5e74\u7684\u5144\u59b9"},{"location":"CCCC/L2-016-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%A4%B1%E6%95%A3%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%85%84%E5%A6%B9/#l2-016-\u613f\u5929\u4e0b\u6709\u60c5\u4eba\u90fd\u662f\u5931\u6563\u591a\u5e74\u7684\u5144\u59b9","text":"","title":"L2-016 \u613f\u5929\u4e0b\u6709\u60c5\u4eba\u90fd\u662f\u5931\u6563\u591a\u5e74\u7684\u5144\u59b9"},{"location":"CCCC/L2-016-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%A4%B1%E6%95%A3%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%85%84%E5%A6%B9/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5475\u5475\u3002\u5927\u5bb6\u90fd\u77e5\u9053\u4e94\u670d\u4ee5\u5185\u4e0d\u5f97\u901a\u5a5a\uff0c\u5373\u4e24\u4e2a\u4eba\u6700\u8fd1\u7684\u5171\u540c\u7956\u5148\u5982\u679c\u5728\u4e94\u4ee3\u4ee5\u5185\uff08\u5373\u672c\u4eba\u3001\u7236\u6bcd\u3001\u7956\u7236\u6bcd\u3001\u66fe\u7956\u7236\u6bcd\u3001\u9ad8\u7956\u7236\u6bcd\uff09\u5219\u4e0d\u53ef\u901a\u5a5a\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5e2e\u52a9\u4e00\u5bf9\u6709\u60c5\u4eba\u5224\u65ad\u4e00\u4e0b\uff0c\u4ed6\u4eec\u7a76\u7adf\u662f\u5426\u53ef\u4ee5\u6210\u5a5a\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff082 \\le \\le N \\le 10^4 \\le 10^4 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u4fe1\u606f\uff1a \u672c\u4ebaID \u6027\u522b \u7236\u4eb2ID \u6bcd\u4eb2ID \u5176\u4e2d ID \u662f5\u4f4d\u6570\u5b57\uff0c\u6bcf\u4eba\u4e0d\u540c\uff1b\u6027\u522b M \u4ee3\u8868\u7537\u6027\u3001 F \u4ee3\u8868\u5973\u6027\u3002\u5982\u679c\u67d0\u4eba\u7684\u7236\u4eb2\u6216\u6bcd\u4eb2\u5df2\u7ecf\u4e0d\u53ef\u8003\uff0c\u5219\u76f8\u5e94\u7684 ID \u4f4d\u7f6e\u4e0a\u6807\u8bb0\u4e3a -1 \u3002 \u63a5\u4e0b\u6765\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K \uff0c\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u6709\u60c5\u4eba\u7684 ID \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u4e24\u4e2a\u4eba\u662f\u540c\u8f88\uff0c\u6bcf\u4eba\u53ea\u6709\u4e00\u4e2a\u6027\u522b\uff0c\u5e76\u4e14\u8840\u7f18\u5173\u7cfb\u7f51\u4e2d\u6ca1\u6709\u4e71\u4f26\u6216\u9694\u8f88\u6210\u5a5a\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u6709\u60c5\u4eba\uff0c\u5224\u65ad\u4ed6\u4eec\u7684\u5173\u7cfb\u662f\u5426\u53ef\u4ee5\u901a\u5a5a\uff1a\u5982\u679c\u4e24\u4eba\u662f\u540c\u6027\uff0c\u8f93\u51fa Never Mind \uff1b\u5982\u679c\u662f\u5f02\u6027\u5e76\u4e14\u5173\u7cfb\u51fa\u4e86\u4e94\u670d\uff0c\u8f93\u51fa Yes \uff1b\u5982\u679c\u5f02\u6027\u5173\u7cfb\u672a\u51fa\u4e94\u670d\uff0c\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 24 00001 M 01111 -1 00002 F 02222 03333 00003 M 02222 03333 00004 F 04444 03333 00005 M 04444 05555 00006 F 04444 05555 00007 F 06666 07777 00008 M 06666 07777 00009 M 00001 00002 00010 M 00003 00006 00011 F 00005 00007 00012 F 00008 08888 00013 F 00009 00011 00014 M 00010 09999 00015 M 00010 09999 00016 M 10000 00012 00017 F -1 00012 00018 F 11000 00013 00019 F 11100 00018 00020 F 00015 11110 00021 M 11100 00020 00022 M 00016 -1 00023 M 10012 00017 00024 M 00022 10013 9 00021 00024 00019 00024 00011 00012 00022 00018 00001 00004 00013 00016 00017 00015 00019 00021 00010 00011 \u8f93\u51fa\u6837\u4f8b Never Mind Yes Never Mind No Yes No Yes No No","title":"Statement"},{"location":"CCCC/L2-016-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%A4%B1%E6%95%A3%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%85%84%E5%A6%B9/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; map < int , pii > m ; map < int , int > judge [ 2 ]; queue < int > q [ 2 ]; int ans ; void bfs ( int cur ) { if ( cur == 7 ) return ; for ( int i = 0 ; i < 2 ; i ++ ) { judge [ i ]. clear (); while ( ! q [ i ]. empty ()) { int num = q [ i ]. front (); q [ i ]. pop (); if ( num != -1 ) judge [ i ][ num ] = 1 ; } } map < int , int >:: iterator it ; // for (int i = 0; i < 2; i++) // { // for (it = judge[i].begin(); it != judge[i].end(); it++) // { // if (it != judge[i].begin()) // printf(\" \"); // cout << it->first; // } // cout << endl; // } for ( it = judge [ 0 ]. begin (); it != judge [ 0 ]. end (); it ++ ) { if ( judge [ 1 ][ it -> first ]) { ans = cur ; return ; } else judge [ 1 ]. erase ( it -> first ); } for ( int i = 0 ; i < 2 ; i ++ ) { for ( it = judge [ i ]. begin (); it != judge [ i ]. end (); it ++ ) { if ( m [ it -> first ]. first != -1 ) q [ i ]. push ( m [ it -> first ]. first ); if ( m [ it -> first ]. second != -1 ) q [ i ]. push ( m [ it -> first ]. second ); } } bfs ( cur + 1 ); } int main () { map < int , int > vis , opt ; int n ; scanf ( \"%d\" , & n ); int a , b , c , d ; char code ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d %c %d %d\" , & a , & code , & b , & c ); opt [ a ] = 1 ; if ( code == 'M' ) vis [ a ] = 0 ; else vis [ a ] = 1 ; m [ a ]. first = b ; if ( b != -1 ) { if ( opt [ b ] == 0 ) { m [ b ]. first = -1 ; m [ b ]. second = -1 ; } vis [ b ] = 0 ; } m [ a ]. second = c ; if ( c != -1 ) { if ( opt [ c ] == 0 ) { m [ c ]. first = -1 ; m [ c ]. second = -1 ; } vis [ c ] = 1 ; } } scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); if ( vis [ a ] == vis [ b ]) printf ( \"Never Mind \\n \" ); else { while ( ! q [ 0 ]. empty ()) q [ 0 ]. pop (); while ( ! q [ 1 ]. empty ()) q [ 1 ]. pop (); q [ 0 ]. push ( a ); q [ 1 ]. push ( b ); ans = INT_MAX ; bfs ( 1 ); if ( ans > 5 ) printf ( \"Yes \\n \" ); else printf ( \"No \\n \" ); } } }","title":"Solution"},{"location":"CCCC/L2-017-%E4%BA%BA%E4%BB%A5%E7%BE%A4%E5%88%86/","text":"L2-017 \u4eba\u4ee5\u7fa4\u5206 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u793e\u4ea4\u7f51\u7edc\u4e2d\u6211\u4eec\u7ed9\u6bcf\u4e2a\u4eba\u5b9a\u4e49\u4e86\u4e00\u4e2a\u201c\u6d3b\u8dc3\u5ea6\u201d\uff0c\u73b0\u5e0c\u671b\u6839\u636e\u8fd9\u4e2a\u6307\u6807\u628a\u4eba\u7fa4\u5206\u4e3a\u4e24\u5927\u7c7b\uff0c\u5373\u5916\u5411\u578b\uff08outgoing\uff0c\u5373\u6d3b\u8dc3\u5ea6\u9ad8\u7684\uff09\u548c\u5185\u5411\u578b\uff08introverted\uff0c\u5373\u6d3b\u8dc3\u5ea6\u4f4e\u7684\uff09\u3002\u8981\u6c42\u4e24\u7c7b\u4eba\u7fa4\u7684\u89c4\u6a21\u5c3d\u53ef\u80fd\u63a5\u8fd1\uff0c\u800c\u4ed6\u4eec\u7684\u603b\u6d3b\u8dc3\u5ea6\u5dee\u8ddd\u5c3d\u53ef\u80fd\u62c9\u5f00\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 2 \\le N \\le 10^5 2 \\le N \\le 10^5 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\u6bcf\u4e2a\u4eba\u7684\u6d3b\u8dc3\u5ea6\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e9b\u6570\u5b57\u4ee5\u53ca\u5b83\u4eec\u7684\u548c\u90fd\u4e0d\u4f1a\u8d85\u8fc7 2^{31} 2^{31} \u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\uff1a Outgoing #: N1 Introverted #: N2 Diff = N3 \u5176\u4e2d N1 \u662f\u5916\u5411\u578b\u4eba\u7684\u4e2a\u6570\uff1b N2 \u662f\u5185\u5411\u578b\u4eba\u7684\u4e2a\u6570\uff1b N3 \u662f\u4e24\u7fa4\u4eba\u603b\u6d3b\u8dc3\u5ea6\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u3002 \u8f93\u5165\u6837\u4f8b1 10 23 8 10 99 46 2333 46 1 666 555 \u8f93\u51fa\u6837\u4f8b1 Outgoing #: 5 Introverted #: 5 Diff = 3611 \u8f93\u5165\u6837\u4f8b2 13 110 79 218 69 3721 100 29 135 2 6 13 5188 85 \u8f93\u51fa\u6837\u4f8b2 Outgoing #: 7 Introverted #: 6 Diff = 9359 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; bool comp ( int x , int y ) { return x > y ; } int main () { int n ; scanf ( \"%d\" , & n ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ]); sum += arr [ i ]; } sort ( arr , arr + n , comp ); int ans = n / 2 ; if ( n % 2 ) ans ++ ; int vis = 0 ; for ( int i = 0 ; i < ans ; i ++ ) vis += arr [ i ]; printf ( \"Outgoing #: %d \\n \" , ans ); printf ( \"Introverted #: %d \\n \" , n - ans ); printf ( \"Diff = %d \\n \" , 2 * vis - sum ); }","title":"L2-017-\u4eba\u4ee5\u7fa4\u5206"},{"location":"CCCC/L2-017-%E4%BA%BA%E4%BB%A5%E7%BE%A4%E5%88%86/#l2-017-\u4eba\u4ee5\u7fa4\u5206","text":"","title":"L2-017 \u4eba\u4ee5\u7fa4\u5206"},{"location":"CCCC/L2-017-%E4%BA%BA%E4%BB%A5%E7%BE%A4%E5%88%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u793e\u4ea4\u7f51\u7edc\u4e2d\u6211\u4eec\u7ed9\u6bcf\u4e2a\u4eba\u5b9a\u4e49\u4e86\u4e00\u4e2a\u201c\u6d3b\u8dc3\u5ea6\u201d\uff0c\u73b0\u5e0c\u671b\u6839\u636e\u8fd9\u4e2a\u6307\u6807\u628a\u4eba\u7fa4\u5206\u4e3a\u4e24\u5927\u7c7b\uff0c\u5373\u5916\u5411\u578b\uff08outgoing\uff0c\u5373\u6d3b\u8dc3\u5ea6\u9ad8\u7684\uff09\u548c\u5185\u5411\u578b\uff08introverted\uff0c\u5373\u6d3b\u8dc3\u5ea6\u4f4e\u7684\uff09\u3002\u8981\u6c42\u4e24\u7c7b\u4eba\u7fa4\u7684\u89c4\u6a21\u5c3d\u53ef\u80fd\u63a5\u8fd1\uff0c\u800c\u4ed6\u4eec\u7684\u603b\u6d3b\u8dc3\u5ea6\u5dee\u8ddd\u5c3d\u53ef\u80fd\u62c9\u5f00\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 2 \\le N \\le 10^5 2 \\le N \\le 10^5 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\u6bcf\u4e2a\u4eba\u7684\u6d3b\u8dc3\u5ea6\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u4e9b\u6570\u5b57\u4ee5\u53ca\u5b83\u4eec\u7684\u548c\u90fd\u4e0d\u4f1a\u8d85\u8fc7 2^{31} 2^{31} \u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\uff1a Outgoing #: N1 Introverted #: N2 Diff = N3 \u5176\u4e2d N1 \u662f\u5916\u5411\u578b\u4eba\u7684\u4e2a\u6570\uff1b N2 \u662f\u5185\u5411\u578b\u4eba\u7684\u4e2a\u6570\uff1b N3 \u662f\u4e24\u7fa4\u4eba\u603b\u6d3b\u8dc3\u5ea6\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u3002 \u8f93\u5165\u6837\u4f8b1 10 23 8 10 99 46 2333 46 1 666 555 \u8f93\u51fa\u6837\u4f8b1 Outgoing #: 5 Introverted #: 5 Diff = 3611 \u8f93\u5165\u6837\u4f8b2 13 110 79 218 69 3721 100 29 135 2 6 13 5188 85 \u8f93\u51fa\u6837\u4f8b2 Outgoing #: 7 Introverted #: 6 Diff = 9359","title":"Statement"},{"location":"CCCC/L2-017-%E4%BA%BA%E4%BB%A5%E7%BE%A4%E5%88%86/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; bool comp ( int x , int y ) { return x > y ; } int main () { int n ; scanf ( \"%d\" , & n ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ]); sum += arr [ i ]; } sort ( arr , arr + n , comp ); int ans = n / 2 ; if ( n % 2 ) ans ++ ; int vis = 0 ; for ( int i = 0 ; i < ans ; i ++ ) vis += arr [ i ]; printf ( \"Outgoing #: %d \\n \" , ans ); printf ( \"Introverted #: %d \\n \" , n - ans ); printf ( \"Diff = %d \\n \" , 2 * vis - sum ); }","title":"Solution"},{"location":"CCCC/L2-018-%E5%A4%9A%E9%A1%B9%E5%BC%8FA%E9%99%A4%E4%BB%A5B/","text":"L2-018 \u591a\u9879\u5f0fA\u9664\u4ee5B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u4ecd\u7136\u662f\u4e00\u9053\u5173\u4e8eA/B\u7684\u9898\uff0c\u53ea\u4e0d\u8fc7A\u548cB\u90fd\u6362\u6210\u4e86\u591a\u9879\u5f0f\u3002\u4f60\u9700\u8981\u8ba1\u7b97\u4e24\u4e2a\u591a\u9879\u5f0f\u76f8\u9664\u7684\u5546Q\u548c\u4f59R\uff0c\u5176\u4e2dR\u7684\u9636\u6570\u5fc5\u987b\u5c0f\u4e8eB\u7684\u9636\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5206\u4e24\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u975e\u96f6\u591a\u9879\u5f0f\uff0c\u5148\u7ed9\u51faA\uff0c\u518d\u7ed9\u51faB\u3002\u6bcf\u884c\u7684\u683c\u5f0f\u5982\u4e0b\uff1a N e[1] c[1] ... e[N] c[N] \u5176\u4e2d N \u662f\u8be5\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7684\u4e2a\u6570\uff0c e[i] \u662f\u7b2c i \u4e2a\u975e\u96f6\u9879\u7684\u6307\u6570\uff0c c[i] \u662f\u7b2c i \u4e2a\u975e\u96f6\u9879\u7684\u7cfb\u6570\u3002\u5404\u9879\u6309\u7167\u6307\u6570\u9012\u51cf\u7684\u987a\u5e8f\u7ed9\u51fa\uff0c\u4fdd\u8bc1\u6240\u6709\u6307\u6570\u662f\u5404\u4e0d\u76f8\u540c\u7684\u975e\u8d1f\u6574\u6570\uff0c\u6240\u6709\u7cfb\u6570\u662f\u975e\u96f6\u6574\u6570\uff0c\u6240\u6709\u6574\u6570\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5206\u4e24\u884c\u5148\u540e\u8f93\u51fa\u5546\u548c\u4f59\uff0c\u8f93\u51fa\u683c\u5f0f\u4e0e\u8f93\u5165\u683c\u5f0f\u76f8\u540c\uff0c\u8f93\u51fa\u7684\u7cfb\u6570\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\uff1a\u96f6\u591a\u9879\u5f0f\u662f\u4e00\u4e2a\u7279\u6b8a\u591a\u9879\u5f0f\uff0c\u5bf9\u5e94\u8f93\u51fa\u4e3a 0 0 0.0 \u3002\u4f46\u975e\u96f6\u591a\u9879\u5f0f\u4e0d\u80fd\u8f93\u51fa\u96f6\u7cfb\u6570\uff08\u5305\u62ec\u820d\u5165\u540e\u4e3a0.0\uff09\u7684\u9879\u3002\u5728\u6837\u4f8b\u4e2d\uff0c\u4f59\u591a\u9879\u5f0f\u5176\u5b9e\u6709\u5e38\u6570\u9879 -1/27 \uff0c\u4f46\u56e0\u5176\u820d\u5165\u540e\u4e3a0.0\uff0c\u6545\u4e0d\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 4 4 1 2 -3 1 -1 0 -1 3 2 3 1 -2 0 1 \u8f93\u51fa\u6837\u4f8b 3 2 0.3 1 0.2 0 -1.0 1 1 -3.1 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define pid pair<int, db> #define fi first #define se second const db eps = 0.05 ; int n , m ; db A [ N ], B [ N ]; db Q [ N ]; void out ( db * a ) { vector < pid > vec ; for ( int i = 3000 ; i >= 0 ; -- i ) if ( abs ( a [ i ] - 0 ) > eps ) vec . push_back ( pid ( i , a [ i ])); if ( vec . empty ()) puts ( \"0 0 0.0\" ); else { int len = vec . size (); printf ( \"%d\" , len ); for ( int i = 0 ; i < len ; ++ i ) printf ( \" %d %.1f\" , vec [ i ]. fi , vec [ i ]. se ); puts ( \"\" ); } } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); scanf ( \"%d\" , & n ); int a = 0 , b = 0 ; for ( int i = 1 , e , c ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & e , & c ); A [ e ] = c ; a = max ( a , e ); } scanf ( \"%d\" , & m ); for ( int i = 1 , e , c ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & e , & c ); B [ e ] = c ; b = max ( b , e ); } if ( a < b ) { puts ( \"0 0 0.0\" ); printf ( \"%d\" , n ); for ( int i = 3000 ; i >= 0 ; -- i ) if ( abs ( A [ i ] - 0 ) > eps ) printf ( \" %d %.1f\" , i , A [ i ]); puts ( \"\" ); } else { for ( int i = 3000 ; i >= 0 ; -- i ) { int j , k ; for ( j = 3000 ; j >= 0 ; -- j ) if ( abs ( A [ j ] - 0 ) > eps ) break ; for ( k = 3000 ; k >= 0 ; -- k ) if ( abs ( B [ k ] - 0 ) > eps ) break ; if ( k > j ) break ; Q [ j - k ] = A [ j ] * 1.0 / B [ k ]; for ( int o = 0 ; o <= 3000 ; ++ o ) if ( abs ( B [ o ] - 0 ) > eps ) A [ j - k + o ] -= A [ j ] * 1.0 * B [ o ] / B [ k ]; } out ( Q ); out ( A ); } return 0 ; }","title":"L2-018-\u591a\u9879\u5f0fA\u9664\u4ee5B"},{"location":"CCCC/L2-018-%E5%A4%9A%E9%A1%B9%E5%BC%8FA%E9%99%A4%E4%BB%A5B/#l2-018-\u591a\u9879\u5f0fa\u9664\u4ee5b","text":"","title":"L2-018 \u591a\u9879\u5f0fA\u9664\u4ee5B"},{"location":"CCCC/L2-018-%E5%A4%9A%E9%A1%B9%E5%BC%8FA%E9%99%A4%E4%BB%A5B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fd9\u4ecd\u7136\u662f\u4e00\u9053\u5173\u4e8eA/B\u7684\u9898\uff0c\u53ea\u4e0d\u8fc7A\u548cB\u90fd\u6362\u6210\u4e86\u591a\u9879\u5f0f\u3002\u4f60\u9700\u8981\u8ba1\u7b97\u4e24\u4e2a\u591a\u9879\u5f0f\u76f8\u9664\u7684\u5546Q\u548c\u4f59R\uff0c\u5176\u4e2dR\u7684\u9636\u6570\u5fc5\u987b\u5c0f\u4e8eB\u7684\u9636\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5206\u4e24\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u975e\u96f6\u591a\u9879\u5f0f\uff0c\u5148\u7ed9\u51faA\uff0c\u518d\u7ed9\u51faB\u3002\u6bcf\u884c\u7684\u683c\u5f0f\u5982\u4e0b\uff1a N e[1] c[1] ... e[N] c[N] \u5176\u4e2d N \u662f\u8be5\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7684\u4e2a\u6570\uff0c e[i] \u662f\u7b2c i \u4e2a\u975e\u96f6\u9879\u7684\u6307\u6570\uff0c c[i] \u662f\u7b2c i \u4e2a\u975e\u96f6\u9879\u7684\u7cfb\u6570\u3002\u5404\u9879\u6309\u7167\u6307\u6570\u9012\u51cf\u7684\u987a\u5e8f\u7ed9\u51fa\uff0c\u4fdd\u8bc1\u6240\u6709\u6307\u6570\u662f\u5404\u4e0d\u76f8\u540c\u7684\u975e\u8d1f\u6574\u6570\uff0c\u6240\u6709\u7cfb\u6570\u662f\u975e\u96f6\u6574\u6570\uff0c\u6240\u6709\u6574\u6570\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5206\u4e24\u884c\u5148\u540e\u8f93\u51fa\u5546\u548c\u4f59\uff0c\u8f93\u51fa\u683c\u5f0f\u4e0e\u8f93\u5165\u683c\u5f0f\u76f8\u540c\uff0c\u8f93\u51fa\u7684\u7cfb\u6570\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\uff1a\u96f6\u591a\u9879\u5f0f\u662f\u4e00\u4e2a\u7279\u6b8a\u591a\u9879\u5f0f\uff0c\u5bf9\u5e94\u8f93\u51fa\u4e3a 0 0 0.0 \u3002\u4f46\u975e\u96f6\u591a\u9879\u5f0f\u4e0d\u80fd\u8f93\u51fa\u96f6\u7cfb\u6570\uff08\u5305\u62ec\u820d\u5165\u540e\u4e3a0.0\uff09\u7684\u9879\u3002\u5728\u6837\u4f8b\u4e2d\uff0c\u4f59\u591a\u9879\u5f0f\u5176\u5b9e\u6709\u5e38\u6570\u9879 -1/27 \uff0c\u4f46\u56e0\u5176\u820d\u5165\u540e\u4e3a0.0\uff0c\u6545\u4e0d\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 4 4 1 2 -3 1 -1 0 -1 3 2 3 1 -2 0 1 \u8f93\u51fa\u6837\u4f8b 3 2 0.3 1 0.2 0 -1.0 1 1 -3.1","title":"Statement"},{"location":"CCCC/L2-018-%E5%A4%9A%E9%A1%B9%E5%BC%8FA%E9%99%A4%E4%BB%A5B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define pid pair<int, db> #define fi first #define se second const db eps = 0.05 ; int n , m ; db A [ N ], B [ N ]; db Q [ N ]; void out ( db * a ) { vector < pid > vec ; for ( int i = 3000 ; i >= 0 ; -- i ) if ( abs ( a [ i ] - 0 ) > eps ) vec . push_back ( pid ( i , a [ i ])); if ( vec . empty ()) puts ( \"0 0 0.0\" ); else { int len = vec . size (); printf ( \"%d\" , len ); for ( int i = 0 ; i < len ; ++ i ) printf ( \" %d %.1f\" , vec [ i ]. fi , vec [ i ]. se ); puts ( \"\" ); } } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); scanf ( \"%d\" , & n ); int a = 0 , b = 0 ; for ( int i = 1 , e , c ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & e , & c ); A [ e ] = c ; a = max ( a , e ); } scanf ( \"%d\" , & m ); for ( int i = 1 , e , c ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & e , & c ); B [ e ] = c ; b = max ( b , e ); } if ( a < b ) { puts ( \"0 0 0.0\" ); printf ( \"%d\" , n ); for ( int i = 3000 ; i >= 0 ; -- i ) if ( abs ( A [ i ] - 0 ) > eps ) printf ( \" %d %.1f\" , i , A [ i ]); puts ( \"\" ); } else { for ( int i = 3000 ; i >= 0 ; -- i ) { int j , k ; for ( j = 3000 ; j >= 0 ; -- j ) if ( abs ( A [ j ] - 0 ) > eps ) break ; for ( k = 3000 ; k >= 0 ; -- k ) if ( abs ( B [ k ] - 0 ) > eps ) break ; if ( k > j ) break ; Q [ j - k ] = A [ j ] * 1.0 / B [ k ]; for ( int o = 0 ; o <= 3000 ; ++ o ) if ( abs ( B [ o ] - 0 ) > eps ) A [ j - k + o ] -= A [ j ] * 1.0 * B [ o ] / B [ k ]; } out ( Q ); out ( A ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-019-%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8/","text":"L2-019 \u6084\u6084\u5173\u6ce8 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u65b0\u6d6a\u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u6084\u6084\u5173\u6ce8\u201d\uff0c\u4e00\u4e2a\u7528\u6237\u6084\u6084\u5173\u6ce8\u7684\u4eba\uff0c\u4e0d\u51fa\u73b0\u5728\u8fd9\u4e2a\u7528\u6237\u7684\u5173\u6ce8\u5217\u8868\u4e0a\uff0c\u4f46\u7cfb\u7edf\u4f1a\u63a8\u9001\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u53d1\u8868\u7684\u5fae\u535a\u7ed9\u8be5\u7528\u6237\u3002\u73b0\u5728\u6211\u4eec\u6765\u505a\u4e00\u56de\u7f51\u7edc\u4fa6\u63a2\uff0c\u6839\u636e\u67d0\u4eba\u7684\u5173\u6ce8\u5217\u8868\u548c\u5176\u5bf9\u5176\u4ed6\u7528\u6237\u7684\u70b9\u8d5e\u60c5\u51b5\uff0c\u6252\u51fa\u6709\u53ef\u80fd\u88ab\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u67d0\u7528\u6237\u7684\u5173\u6ce8\u5217\u8868\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a \u4eba\u6570N \u7528\u62371 \u7528\u62372 \u2026\u2026 \u7528\u6237N \u5176\u4e2d N \u662f\u4e0d\u8d85\u8fc75000\u7684\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a \u7528\u6237i \uff08 i =1, \u2026, N \uff09\u662f\u88ab\u5176\u5173\u6ce8\u7684\u7528\u6237\u7684ID\uff0c\u662f\u957f\u5ea6\u4e3a4\u4f4d\u7684\u7531\u6570\u5b57\u548c\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5404\u9879\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u4e4b\u540e\u7ed9\u51fa\u8be5\u7528\u6237\u70b9\u8d5e\u7684\u4fe1\u606f\uff1a\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc710000\u7684\u6b63\u6574\u6570 M \uff0c\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u88ab\u5176\u70b9\u8d5e\u7684\u7528\u6237ID\u548c\u5bf9\u8be5\u7528\u6237\u7684\u70b9\u8d5e\u6b21\u6570\uff08\u4e0d\u8d85\u8fc71000\uff09\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u7528\u6237ID\u662f\u4e00\u4e2a\u7528\u6237\u7684\u552f\u4e00\u8eab\u4efd\u6807\u8bc6\u3002\u9898\u76ee\u4fdd\u8bc1\u5728\u5173\u6ce8\u5217\u8868\u4e2d\u6ca1\u6709\u91cd\u590d\u7528\u6237\uff0c\u5728\u70b9\u8d5e\u4fe1\u606f\u4e2d\u4e5f\u6ca1\u6709\u91cd\u590d\u7528\u6237\u3002 \u8f93\u51fa\u683c\u5f0f \u6211\u4eec\u8ba4\u4e3a\u88ab\u8be5\u7528\u6237\u70b9\u8d5e\u6b21\u6570\u5927\u4e8e\u5176\u70b9\u8d5e\u5e73\u5747\u6570\u3001\u4e14\u4e0d\u5728\u5176\u5173\u6ce8\u5217\u8868\u4e0a\u7684\u4eba\uff0c\u5f88\u53ef\u80fd\u662f\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u3002\u6839\u636e\u8fd9\u4e2a\u5047\u8bbe\uff0c\u8bf7\u4f60\u6309\u7528\u6237ID\u5b57\u6bcd\u5e8f\u7684\u5347\u5e8f\u8f93\u51fa\u53ef\u80fd\u662f\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\uff0c\u6bcf\u884c1\u4e2aID\u3002\u5982\u679c\u5176\u5b9e\u5e76\u6ca1\u6709\u8fd9\u6837\u7684\u4eba\uff0c\u5219\u8f93\u51fa\u201cBing Mei You\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao 8 Magi 50 Pota 30 LLao 3 Ammy 48 Dave 15 GAO3 31 Zoro 1 Cath 60 \u8f93\u51fa\u6837\u4f8b1 Ammy Cath Pota \u8f93\u5165\u6837\u4f8b2 11 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao Pota 7 Magi 50 Pota 30 LLao 48 Ammy 3 Dave 15 GAO3 31 Zoro 29 \u8f93\u51fa\u6837\u4f8b2 Bing Mei You Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < string , int > m ; int n ; cin >> n ; string s ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s ; m [ s ] = 1 ; } scanf ( \"%d\" , & n ); vector < psi > v ; vector < string > ans ; int num ; double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s >> num ; if ( m [ s ] == 0 ) v . push_back ( psi ( s , num )); sum += num ; } sum /= n ; vector < psi >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if (( * it ). second > sum ) ans . push_back (( * it ). first ); } if ( ans . size ()) { sort ( ans . begin (), ans . end ()); vector < string >:: iterator iter ; for ( iter = ans . begin (); iter != ans . end (); iter ++ ) { cout << ( * iter ) << endl ; } } else printf ( \"Bing Mei You \\n \" ); }","title":"L2-019-\u6084\u6084\u5173\u6ce8"},{"location":"CCCC/L2-019-%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8/#l2-019-\u6084\u6084\u5173\u6ce8","text":"","title":"L2-019 \u6084\u6084\u5173\u6ce8"},{"location":"CCCC/L2-019-%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u65b0\u6d6a\u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u6084\u6084\u5173\u6ce8\u201d\uff0c\u4e00\u4e2a\u7528\u6237\u6084\u6084\u5173\u6ce8\u7684\u4eba\uff0c\u4e0d\u51fa\u73b0\u5728\u8fd9\u4e2a\u7528\u6237\u7684\u5173\u6ce8\u5217\u8868\u4e0a\uff0c\u4f46\u7cfb\u7edf\u4f1a\u63a8\u9001\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u53d1\u8868\u7684\u5fae\u535a\u7ed9\u8be5\u7528\u6237\u3002\u73b0\u5728\u6211\u4eec\u6765\u505a\u4e00\u56de\u7f51\u7edc\u4fa6\u63a2\uff0c\u6839\u636e\u67d0\u4eba\u7684\u5173\u6ce8\u5217\u8868\u548c\u5176\u5bf9\u5176\u4ed6\u7528\u6237\u7684\u70b9\u8d5e\u60c5\u51b5\uff0c\u6252\u51fa\u6709\u53ef\u80fd\u88ab\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u67d0\u7528\u6237\u7684\u5173\u6ce8\u5217\u8868\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a \u4eba\u6570N \u7528\u62371 \u7528\u62372 \u2026\u2026 \u7528\u6237N \u5176\u4e2d N \u662f\u4e0d\u8d85\u8fc75000\u7684\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a \u7528\u6237i \uff08 i =1, \u2026, N \uff09\u662f\u88ab\u5176\u5173\u6ce8\u7684\u7528\u6237\u7684ID\uff0c\u662f\u957f\u5ea6\u4e3a4\u4f4d\u7684\u7531\u6570\u5b57\u548c\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5404\u9879\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u4e4b\u540e\u7ed9\u51fa\u8be5\u7528\u6237\u70b9\u8d5e\u7684\u4fe1\u606f\uff1a\u9996\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc710000\u7684\u6b63\u6574\u6570 M \uff0c\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u88ab\u5176\u70b9\u8d5e\u7684\u7528\u6237ID\u548c\u5bf9\u8be5\u7528\u6237\u7684\u70b9\u8d5e\u6b21\u6570\uff08\u4e0d\u8d85\u8fc71000\uff09\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u7528\u6237ID\u662f\u4e00\u4e2a\u7528\u6237\u7684\u552f\u4e00\u8eab\u4efd\u6807\u8bc6\u3002\u9898\u76ee\u4fdd\u8bc1\u5728\u5173\u6ce8\u5217\u8868\u4e2d\u6ca1\u6709\u91cd\u590d\u7528\u6237\uff0c\u5728\u70b9\u8d5e\u4fe1\u606f\u4e2d\u4e5f\u6ca1\u6709\u91cd\u590d\u7528\u6237\u3002 \u8f93\u51fa\u683c\u5f0f \u6211\u4eec\u8ba4\u4e3a\u88ab\u8be5\u7528\u6237\u70b9\u8d5e\u6b21\u6570\u5927\u4e8e\u5176\u70b9\u8d5e\u5e73\u5747\u6570\u3001\u4e14\u4e0d\u5728\u5176\u5173\u6ce8\u5217\u8868\u4e0a\u7684\u4eba\uff0c\u5f88\u53ef\u80fd\u662f\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\u3002\u6839\u636e\u8fd9\u4e2a\u5047\u8bbe\uff0c\u8bf7\u4f60\u6309\u7528\u6237ID\u5b57\u6bcd\u5e8f\u7684\u5347\u5e8f\u8f93\u51fa\u53ef\u80fd\u662f\u5176\u6084\u6084\u5173\u6ce8\u7684\u4eba\uff0c\u6bcf\u884c1\u4e2aID\u3002\u5982\u679c\u5176\u5b9e\u5e76\u6ca1\u6709\u8fd9\u6837\u7684\u4eba\uff0c\u5219\u8f93\u51fa\u201cBing Mei You\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao 8 Magi 50 Pota 30 LLao 3 Ammy 48 Dave 15 GAO3 31 Zoro 1 Cath 60 \u8f93\u51fa\u6837\u4f8b1 Ammy Cath Pota \u8f93\u5165\u6837\u4f8b2 11 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao Pota 7 Magi 50 Pota 30 LLao 48 Ammy 3 Dave 15 GAO3 31 Zoro 29 \u8f93\u51fa\u6837\u4f8b2 Bing Mei You","title":"Statement"},{"location":"CCCC/L2-019-%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { map < string , int > m ; int n ; cin >> n ; string s ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s ; m [ s ] = 1 ; } scanf ( \"%d\" , & n ); vector < psi > v ; vector < string > ans ; int num ; double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { cin >> s >> num ; if ( m [ s ] == 0 ) v . push_back ( psi ( s , num )); sum += num ; } sum /= n ; vector < psi >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if (( * it ). second > sum ) ans . push_back (( * it ). first ); } if ( ans . size ()) { sort ( ans . begin (), ans . end ()); vector < string >:: iterator iter ; for ( iter = ans . begin (); iter != ans . end (); iter ++ ) { cout << ( * iter ) << endl ; } } else printf ( \"Bing Mei You \\n \" ); }","title":"Solution"},{"location":"CCCC/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA/","text":"L2-020 \u529f\u592b\u4f20\u4eba Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u95e8\u6b66\u529f\u80fd\u5426\u4f20\u627f\u4e45\u8fdc\u5e76\u88ab\u53d1\u626c\u5149\u5927\uff0c\u662f\u8981\u770b\u7f18\u5206\u7684\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5e08\u5085\u4f20\u6388\u7ed9\u5f92\u5f1f\u7684\u6b66\u529f\u603b\u8981\u6253\u4e2a\u6298\u6263\uff0c\u4e8e\u662f\u8d8a\u5f80\u540e\u4f20\uff0c\u5f1f\u5b50\u4eec\u7684\u529f\u592b\u5c31\u8d8a\u5f31\u2026\u2026 \u76f4\u5230\u67d0\u4e00\u652f\u7684\u67d0\u4e00\u4ee3\u7a81\u7136\u51fa\u73b0\u4e00\u4e2a\u5929\u5206\u7279\u522b\u9ad8\u7684\u5f1f\u5b50\uff08\u6216\u8005\u662f\u5403\u5230\u4e86\u7075\u4e39\u3001\u6316\u5230\u4e86\u7279\u522b\u7684\u79d8\u7b08\uff09\uff0c\u4f1a\u5c06\u529f\u592b\u7684\u5a01\u529b\u4e00\u4e0b\u5b50\u653e\u5927N\u500d \u2014\u2014 \u6211\u4eec\u79f0\u8fd9\u79cd\u5f1f\u5b50\u4e3a\u201c\u5f97\u9053\u8005\u201d\u3002 \u8fd9\u91cc\u6211\u4eec\u6765\u8003\u5bdf\u67d0\u4e00\u4f4d\u7956\u5e08\u7237\u95e8\u4e0b\u7684\u5f92\u5b50\u5f92\u5b59\u5bb6\u8c31\uff1a\u5047\u8bbe\u5bb6\u8c31\u4e2d\u7684\u6bcf\u4e2a\u4eba\u53ea\u67091\u4f4d\u5e08\u5085\uff08\u9664\u4e86\u7956\u5e08\u7237\u6ca1\u6709\u5e08\u5085\uff09\uff1b\u6bcf\u4f4d\u5e08\u5085\u53ef\u4ee5\u5e26\u5f88\u591a\u5f92\u5f1f\uff1b\u5e76\u4e14\u5047\u8bbe\u8f88\u5206\u4e25\u683c\u6709\u5e8f\uff0c\u5373\u7956\u5e08\u7237\u8fd9\u95e8\u6b66\u529f\u7684\u6bcf\u4e2a\u7b2c i \u4ee3\u4f20\u4eba\u53ea\u80fd\u5728\u7b2c i-1 \u4ee3\u4f20\u4eba\u4e2d\u62dc1\u4e2a\u5e08\u5085\u3002\u6211\u4eec\u5047\u8bbe\u5df2\u77e5\u7956\u5e08\u7237\u7684\u529f\u529b\u503c\u4e3a Z \uff0c\u6bcf\u5411\u4e0b\u4f20\u627f\u4e00\u4ee3\uff0c\u5c31\u4f1a\u51cf\u5f31 r% \uff0c\u9664\u975e\u67d0\u4e00\u4ee3\u5f1f\u5b50\u5f97\u9053\u3002\u73b0\u7ed9\u51fa\u5e08\u95e8\u8c31\u7cfb\u5173\u7cfb\uff0c\u8981\u6c42\u4f60\u7b97\u51fa\u6240\u6709\u5f97\u9053\u8005\u7684\u529f\u529b\u603b\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\uff1a N N \uff08 \\le 10^5 \\le 10^5 \uff09\u2014\u2014\u6574\u4e2a\u5e08\u95e8\u7684\u603b\u4eba\u6570\uff08\u4e8e\u662f\u6bcf\u4e2a\u4eba\u4ece0\u5230 N-1 N-1 \u7f16\u53f7\uff0c\u7956\u5e08\u7237\u7684\u7f16\u53f7\u4e3a0\uff09\uff1b Z Z \u2014\u2014\u7956\u5e08\u7237\u7684\u529f\u529b\u503c\uff08\u4e0d\u4e00\u5b9a\u662f\u6574\u6570\uff0c\u4f46\u8d77\u7801\u662f\u6b63\u6570\uff09\uff1b r r \u2014\u2014\u6bcf\u4f20\u4e00\u4ee3\u529f\u592b\u6240\u6253\u7684\u6298\u6263\u767e\u5206\u6bd4\u503c\uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6570\uff09\u3002\u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u7b2c i i \u884c\uff08 i=0, \\cdots , N-1 i=0, \\cdots , N-1 \uff09\u63cf\u8ff0\u7f16\u53f7\u4e3a i i \u7684\u4eba\u6240\u4f20\u7684\u5f92\u5f1f\uff0c\u683c\u5f0f\u4e3a\uff1a K_i K_i ID[1] ID[2] \\cdots \\cdots ID[ K_i K_i ] \u5176\u4e2d K_i K_i \u662f\u5f92\u5f1f\u7684\u4e2a\u6570\uff0c\u540e\u9762\u8ddf\u7684\u662f\u5404\u4f4d\u5f92\u5f1f\u7684\u7f16\u53f7\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u95f4\u9694\u3002 K_i K_i \u4e3a\u96f6\u8868\u793a\u8fd9\u662f\u4e00\u4f4d\u5f97\u9053\u8005\uff0c\u8fd9\u65f6\u540e\u9762\u8ddf\u7684\u4e00\u4e2a\u6570\u5b57\u8868\u793a\u5176\u6b66\u529f\u88ab\u653e\u5927\u7684\u500d\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6240\u6709\u5f97\u9053\u8005\u7684\u529f\u529b\u603b\u503c\uff0c\u53ea\u4fdd\u7559\u5176\u6574\u6570\u90e8\u5206\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u548c\u6b63\u786e\u7684\u8f93\u51fa\u90fd\u4e0d\u8d85\u8fc7 10^{10} 10^{10} \u3002 \u8f93\u5165\u6837\u4f8b 10 18.0 1.00 3 2 3 5 1 9 1 4 1 7 0 7 2 6 1 1 8 0 9 0 4 0 3 \u8f93\u51fa\u6837\u4f8b 404 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; ll n ; double z , r ; struct Node { int tot ; vector < int > v ; } temp ; ld ans = 0.0 ; vector < Node > d , da ; void dfs ( int x , int cur ) { if ( d [ x ]. tot == 0 ) { ans += z * pow ( r , cur ) * d [ x ]. v [ 0 ]; return ; } vector < int >:: iterator it ; for ( it = d [ x ]. v . begin (); it != d [ x ]. v . end (); it ++ ) { dfs (( * it ), cur + 1 ); } } int main () { int num ; scanf ( \"%lld%lf%lf\" , & n , & z , & r ); r = ( 100 - r ) * 1.0 / 100 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & temp . tot ); temp . v . clear (); if ( temp . tot == 0 ) { scanf ( \"%d\" , & num ); temp . v . pb ( num ); } for ( int j = 0 ; j < temp . tot ; j ++ ) { scanf ( \"%d\" , & num ); temp . v . pb ( num ); } d . pb ( temp ); } dfs ( 0 , 0 ); printf ( \"%.0Lf \\n \" , ans - 0.5 ); }","title":"L2-020-\u529f\u592b\u4f20\u4eba"},{"location":"CCCC/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA/#l2-020-\u529f\u592b\u4f20\u4eba","text":"","title":"L2-020 \u529f\u592b\u4f20\u4eba"},{"location":"CCCC/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u95e8\u6b66\u529f\u80fd\u5426\u4f20\u627f\u4e45\u8fdc\u5e76\u88ab\u53d1\u626c\u5149\u5927\uff0c\u662f\u8981\u770b\u7f18\u5206\u7684\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5e08\u5085\u4f20\u6388\u7ed9\u5f92\u5f1f\u7684\u6b66\u529f\u603b\u8981\u6253\u4e2a\u6298\u6263\uff0c\u4e8e\u662f\u8d8a\u5f80\u540e\u4f20\uff0c\u5f1f\u5b50\u4eec\u7684\u529f\u592b\u5c31\u8d8a\u5f31\u2026\u2026 \u76f4\u5230\u67d0\u4e00\u652f\u7684\u67d0\u4e00\u4ee3\u7a81\u7136\u51fa\u73b0\u4e00\u4e2a\u5929\u5206\u7279\u522b\u9ad8\u7684\u5f1f\u5b50\uff08\u6216\u8005\u662f\u5403\u5230\u4e86\u7075\u4e39\u3001\u6316\u5230\u4e86\u7279\u522b\u7684\u79d8\u7b08\uff09\uff0c\u4f1a\u5c06\u529f\u592b\u7684\u5a01\u529b\u4e00\u4e0b\u5b50\u653e\u5927N\u500d \u2014\u2014 \u6211\u4eec\u79f0\u8fd9\u79cd\u5f1f\u5b50\u4e3a\u201c\u5f97\u9053\u8005\u201d\u3002 \u8fd9\u91cc\u6211\u4eec\u6765\u8003\u5bdf\u67d0\u4e00\u4f4d\u7956\u5e08\u7237\u95e8\u4e0b\u7684\u5f92\u5b50\u5f92\u5b59\u5bb6\u8c31\uff1a\u5047\u8bbe\u5bb6\u8c31\u4e2d\u7684\u6bcf\u4e2a\u4eba\u53ea\u67091\u4f4d\u5e08\u5085\uff08\u9664\u4e86\u7956\u5e08\u7237\u6ca1\u6709\u5e08\u5085\uff09\uff1b\u6bcf\u4f4d\u5e08\u5085\u53ef\u4ee5\u5e26\u5f88\u591a\u5f92\u5f1f\uff1b\u5e76\u4e14\u5047\u8bbe\u8f88\u5206\u4e25\u683c\u6709\u5e8f\uff0c\u5373\u7956\u5e08\u7237\u8fd9\u95e8\u6b66\u529f\u7684\u6bcf\u4e2a\u7b2c i \u4ee3\u4f20\u4eba\u53ea\u80fd\u5728\u7b2c i-1 \u4ee3\u4f20\u4eba\u4e2d\u62dc1\u4e2a\u5e08\u5085\u3002\u6211\u4eec\u5047\u8bbe\u5df2\u77e5\u7956\u5e08\u7237\u7684\u529f\u529b\u503c\u4e3a Z \uff0c\u6bcf\u5411\u4e0b\u4f20\u627f\u4e00\u4ee3\uff0c\u5c31\u4f1a\u51cf\u5f31 r% \uff0c\u9664\u975e\u67d0\u4e00\u4ee3\u5f1f\u5b50\u5f97\u9053\u3002\u73b0\u7ed9\u51fa\u5e08\u95e8\u8c31\u7cfb\u5173\u7cfb\uff0c\u8981\u6c42\u4f60\u7b97\u51fa\u6240\u6709\u5f97\u9053\u8005\u7684\u529f\u529b\u603b\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\uff1a N N \uff08 \\le 10^5 \\le 10^5 \uff09\u2014\u2014\u6574\u4e2a\u5e08\u95e8\u7684\u603b\u4eba\u6570\uff08\u4e8e\u662f\u6bcf\u4e2a\u4eba\u4ece0\u5230 N-1 N-1 \u7f16\u53f7\uff0c\u7956\u5e08\u7237\u7684\u7f16\u53f7\u4e3a0\uff09\uff1b Z Z \u2014\u2014\u7956\u5e08\u7237\u7684\u529f\u529b\u503c\uff08\u4e0d\u4e00\u5b9a\u662f\u6574\u6570\uff0c\u4f46\u8d77\u7801\u662f\u6b63\u6570\uff09\uff1b r r \u2014\u2014\u6bcf\u4f20\u4e00\u4ee3\u529f\u592b\u6240\u6253\u7684\u6298\u6263\u767e\u5206\u6bd4\u503c\uff08\u4e0d\u8d85\u8fc7100\u7684\u6b63\u6570\uff09\u3002\u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u7b2c i i \u884c\uff08 i=0, \\cdots , N-1 i=0, \\cdots , N-1 \uff09\u63cf\u8ff0\u7f16\u53f7\u4e3a i i \u7684\u4eba\u6240\u4f20\u7684\u5f92\u5f1f\uff0c\u683c\u5f0f\u4e3a\uff1a K_i K_i ID[1] ID[2] \\cdots \\cdots ID[ K_i K_i ] \u5176\u4e2d K_i K_i \u662f\u5f92\u5f1f\u7684\u4e2a\u6570\uff0c\u540e\u9762\u8ddf\u7684\u662f\u5404\u4f4d\u5f92\u5f1f\u7684\u7f16\u53f7\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u95f4\u9694\u3002 K_i K_i \u4e3a\u96f6\u8868\u793a\u8fd9\u662f\u4e00\u4f4d\u5f97\u9053\u8005\uff0c\u8fd9\u65f6\u540e\u9762\u8ddf\u7684\u4e00\u4e2a\u6570\u5b57\u8868\u793a\u5176\u6b66\u529f\u88ab\u653e\u5927\u7684\u500d\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6240\u6709\u5f97\u9053\u8005\u7684\u529f\u529b\u603b\u503c\uff0c\u53ea\u4fdd\u7559\u5176\u6574\u6570\u90e8\u5206\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u548c\u6b63\u786e\u7684\u8f93\u51fa\u90fd\u4e0d\u8d85\u8fc7 10^{10} 10^{10} \u3002 \u8f93\u5165\u6837\u4f8b 10 18.0 1.00 3 2 3 5 1 9 1 4 1 7 0 7 2 6 1 1 8 0 9 0 4 0 3 \u8f93\u51fa\u6837\u4f8b 404","title":"Statement"},{"location":"CCCC/L2-020-%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; ll n ; double z , r ; struct Node { int tot ; vector < int > v ; } temp ; ld ans = 0.0 ; vector < Node > d , da ; void dfs ( int x , int cur ) { if ( d [ x ]. tot == 0 ) { ans += z * pow ( r , cur ) * d [ x ]. v [ 0 ]; return ; } vector < int >:: iterator it ; for ( it = d [ x ]. v . begin (); it != d [ x ]. v . end (); it ++ ) { dfs (( * it ), cur + 1 ); } } int main () { int num ; scanf ( \"%lld%lf%lf\" , & n , & z , & r ); r = ( 100 - r ) * 1.0 / 100 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & temp . tot ); temp . v . clear (); if ( temp . tot == 0 ) { scanf ( \"%d\" , & num ); temp . v . pb ( num ); } for ( int j = 0 ; j < temp . tot ; j ++ ) { scanf ( \"%d\" , & num ); temp . v . pb ( num ); } d . pb ( temp ); } dfs ( 0 , 0 ); printf ( \"%.0Lf \\n \" , ans - 0.5 ); }","title":"Solution"},{"location":"CCCC/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/","text":"L2-021 \u70b9\u8d5e\u72c2\u9b54 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u70b9\u8d5e\u201d\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u559c\u6b22\u7684\u535a\u6587\u70b9\u4e2a\u8d5e\u8868\u793a\u652f\u6301\u3002\u6bcf\u7bc7\u535a\u6587\u90fd\u6709\u4e00\u4e9b\u523b\u753b\u5176\u7279\u6027\u7684\u6807\u7b7e\uff0c\u800c\u4f60\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7c7b\u578b\uff0c\u4e5f\u95f4\u63a5\u523b\u753b\u4e86\u4f60\u7684\u7279\u6027\u3002\u7136\u800c\u6709\u8fd9\u4e48\u4e00\u79cd\u4eba\uff0c\u4ed6\u4eec\u4f1a\u901a\u8fc7\u7ed9\u81ea\u5df1\u770b\u5230\u7684\u4e00\u5207\u5185\u5bb9\u70b9\u8d5e\u6765\u72c2\u5237\u5b58\u5728\u611f\uff0c\u8fd9\u79cd\u4eba\u5c31\u88ab\u79f0\u4e3a\u201c\u70b9\u8d5e\u72c2\u9b54\u201d\u3002\u4ed6\u4eec\u70b9\u8d5e\u7684\u6807\u7b7e\u975e\u5e38\u5206\u6563\uff0c\u65e0\u6cd5\u4f53\u73b0\u51fa\u660e\u663e\u7684\u7279\u6027\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u7edf\u8ba1\u6bcf\u4e2a\u4eba\u70b9\u8d5e\u7684\u4e0d\u540c\u6807\u7b7e\u7684\u6570\u91cf\uff0c\u627e\u51fa\u524d3\u540d\u70b9\u8d5e\u72c2\u9b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u662f\u5f85\u7edf\u8ba1\u7684\u7528\u6237\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u5217\u51fa\u4e00\u4f4d\u7528\u6237\u7684\u70b9\u8d5e\u6807\u7b7e\u3002\u683c\u5f0f\u4e3a\u201c Name K K F_1 \\cdots F_K F_1 \\cdots F_K \u201d\uff0c\u5176\u4e2d Name \u662f\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5c0f\u5199\u5b57\u6bcd\u7684\u975e\u7a7a\u7528\u6237\u540d\uff0c 1\\le K\\le 1000 1\\le K\\le 1000 \uff0c F_i F_i \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u7279\u6027\u6807\u7b7e\u7684\u7f16\u53f7\uff0c\u6211\u4eec\u5c06\u6240\u6709\u7279\u6027\u6807\u7b7e\u4ece 1 \u5230 10^7 10^7 \u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u7edf\u8ba1\u6bcf\u4e2a\u4eba\u70b9\u8d5e\u7684\u4e0d\u540c\u6807\u7b7e\u7684\u6570\u91cf\uff0c\u627e\u51fa\u6570\u91cf\u6700\u5927\u7684\u524d3\u540d\uff0c\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u4ed6\u4eec\u7684\u7528\u6237\u540d,\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694,\u4e14\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u6807\u7b7e\u51fa\u73b0\u6b21\u6570\u5e73\u5747\u503c\u6700\u5c0f\u7684\u90a3\u4e2a\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u7528\u6237\u6ca1\u6709\u5e76\u5217\u3002\u82e5\u4e0d\u8db33\u4eba\uff0c\u5219\u7528 - \u8865\u9f50\u7f3a\u5931\uff0c\u4f8b\u5982 mike jenny - \u5c31\u8868\u793a\u53ea\u67092\u4eba\u3002 \u8f93\u5165\u6837\u4f8b 5 bob 11 101 102 103 104 105 106 107 108 108 107 107 peter 8 1 2 3 4 3 2 5 1 chris 12 1 2 3 4 5 6 7 8 9 1 2 3 john 10 8 7 6 5 4 3 2 1 7 5 jack 9 6 7 8 9 10 11 12 13 14 \u8f93\u51fa\u6837\u4f8b jack chris john Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; struct node { string s ; int tot ; int k ; } temp ; int comp ( node x , node y ) { if ( x . tot == y . tot ) return x . k < y . k ; return x . tot > y . tot ; } vector < node > q ; int main () { int n ; int i , j ; map < int , int > vis ; string s ; int k , tot , num ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { vis . clear (); cin >> temp . s >> temp . k ; temp . tot = 0 ; for ( j = 0 ; j < temp . k ; j ++ ) { scanf ( \"%d\" , & num ); if ( vis [ num ] == 0 ) temp . tot ++ ; vis [ num ] ++ ; } q . push_back ( temp ); } sort ( q . begin (), q . end (), comp ); temp . s = \"-\" ; for ( i = 0 ; i < 3 ; i ++ ) q . push_back ( temp ); for ( i = 0 ; i < 3 ; i ++ ) { if ( i ) printf ( \" \" ); cout << q [ i ]. s ; } cout << endl ; }","title":"L2-021-\u70b9\u8d5e\u72c2\u9b54"},{"location":"CCCC/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/#l2-021-\u70b9\u8d5e\u72c2\u9b54","text":"","title":"L2-021 \u70b9\u8d5e\u72c2\u9b54"},{"location":"CCCC/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5fae\u535a\u4e0a\u6709\u4e2a\u201c\u70b9\u8d5e\u201d\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u559c\u6b22\u7684\u535a\u6587\u70b9\u4e2a\u8d5e\u8868\u793a\u652f\u6301\u3002\u6bcf\u7bc7\u535a\u6587\u90fd\u6709\u4e00\u4e9b\u523b\u753b\u5176\u7279\u6027\u7684\u6807\u7b7e\uff0c\u800c\u4f60\u70b9\u8d5e\u7684\u535a\u6587\u7684\u7c7b\u578b\uff0c\u4e5f\u95f4\u63a5\u523b\u753b\u4e86\u4f60\u7684\u7279\u6027\u3002\u7136\u800c\u6709\u8fd9\u4e48\u4e00\u79cd\u4eba\uff0c\u4ed6\u4eec\u4f1a\u901a\u8fc7\u7ed9\u81ea\u5df1\u770b\u5230\u7684\u4e00\u5207\u5185\u5bb9\u70b9\u8d5e\u6765\u72c2\u5237\u5b58\u5728\u611f\uff0c\u8fd9\u79cd\u4eba\u5c31\u88ab\u79f0\u4e3a\u201c\u70b9\u8d5e\u72c2\u9b54\u201d\u3002\u4ed6\u4eec\u70b9\u8d5e\u7684\u6807\u7b7e\u975e\u5e38\u5206\u6563\uff0c\u65e0\u6cd5\u4f53\u73b0\u51fa\u660e\u663e\u7684\u7279\u6027\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u901a\u8fc7\u7edf\u8ba1\u6bcf\u4e2a\u4eba\u70b9\u8d5e\u7684\u4e0d\u540c\u6807\u7b7e\u7684\u6570\u91cf\uff0c\u627e\u51fa\u524d3\u540d\u70b9\u8d5e\u72c2\u9b54\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u662f\u5f85\u7edf\u8ba1\u7684\u7528\u6237\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u5217\u51fa\u4e00\u4f4d\u7528\u6237\u7684\u70b9\u8d5e\u6807\u7b7e\u3002\u683c\u5f0f\u4e3a\u201c Name K K F_1 \\cdots F_K F_1 \\cdots F_K \u201d\uff0c\u5176\u4e2d Name \u662f\u4e0d\u8d85\u8fc78\u4e2a\u82f1\u6587\u5c0f\u5199\u5b57\u6bcd\u7684\u975e\u7a7a\u7528\u6237\u540d\uff0c 1\\le K\\le 1000 1\\le K\\le 1000 \uff0c F_i F_i \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u7279\u6027\u6807\u7b7e\u7684\u7f16\u53f7\uff0c\u6211\u4eec\u5c06\u6240\u6709\u7279\u6027\u6807\u7b7e\u4ece 1 \u5230 10^7 10^7 \u7f16\u53f7\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u7edf\u8ba1\u6bcf\u4e2a\u4eba\u70b9\u8d5e\u7684\u4e0d\u540c\u6807\u7b7e\u7684\u6570\u91cf\uff0c\u627e\u51fa\u6570\u91cf\u6700\u5927\u7684\u524d3\u540d\uff0c\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u4ed6\u4eec\u7684\u7528\u6237\u540d,\u5176\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694,\u4e14\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u6807\u7b7e\u51fa\u73b0\u6b21\u6570\u5e73\u5747\u503c\u6700\u5c0f\u7684\u90a3\u4e2a\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u7528\u6237\u6ca1\u6709\u5e76\u5217\u3002\u82e5\u4e0d\u8db33\u4eba\uff0c\u5219\u7528 - \u8865\u9f50\u7f3a\u5931\uff0c\u4f8b\u5982 mike jenny - \u5c31\u8868\u793a\u53ea\u67092\u4eba\u3002 \u8f93\u5165\u6837\u4f8b 5 bob 11 101 102 103 104 105 106 107 108 108 107 107 peter 8 1 2 3 4 3 2 5 1 chris 12 1 2 3 4 5 6 7 8 9 1 2 3 john 10 8 7 6 5 4 3 2 1 7 5 jack 9 6 7 8 9 10 11 12 13 14 \u8f93\u51fa\u6837\u4f8b jack chris john","title":"Statement"},{"location":"CCCC/L2-021-%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e2 + 5 ; const int MOD = 1e9 + 7 ; struct node { string s ; int tot ; int k ; } temp ; int comp ( node x , node y ) { if ( x . tot == y . tot ) return x . k < y . k ; return x . tot > y . tot ; } vector < node > q ; int main () { int n ; int i , j ; map < int , int > vis ; string s ; int k , tot , num ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { vis . clear (); cin >> temp . s >> temp . k ; temp . tot = 0 ; for ( j = 0 ; j < temp . k ; j ++ ) { scanf ( \"%d\" , & num ); if ( vis [ num ] == 0 ) temp . tot ++ ; vis [ num ] ++ ; } q . push_back ( temp ); } sort ( q . begin (), q . end (), comp ); temp . s = \"-\" ; for ( i = 0 ; i < 3 ; i ++ ) q . push_back ( temp ); for ( i = 0 ; i < 3 ; i ++ ) { if ( i ) printf ( \" \" ); cout << q [ i ]. s ; } cout << endl ; }","title":"Solution"},{"location":"CCCC/L2-022-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","text":"L2-022 \u91cd\u6392\u94fe\u8868 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868 L_1 L_1 \u2192 L_2 L_2 \u2192 \\cdots \\cdots \u2192 L_{n-1} L_{n-1} \u2192 L_n L_n \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06\u94fe\u8868\u91cd\u65b0\u6392\u5217\u4e3a L_n L_n \u2192 L_1 L_1 \u2192 L_{n-1} L_{n-1} \u2192 L_2 L_2 \u2192 \\cdots \\cdots \u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a1\u21922\u21923\u21924\u21925\u21926\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a6\u21921\u21925\u21922\u21924\u21923\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b1\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c1\u884c\u7ed9\u51fa\u7b2c1\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u548c\u7ed3\u70b9\u603b\u4e2a\u6570\uff0c\u5373\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f5\u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL\u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff1b Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6570\u636e\uff0c\u4e3a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff1b Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u94fe\u8868\u4e0a\u81f3\u5c11\u6709\u4e24\u4e2a\u7ed3\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u91cd\u6392\u540e\u7684\u7ed3\u679c\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 6 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 68237 6 00100 00100 1 99999 99999 5 12309 12309 2 00000 00000 4 33218 33218 3 -1 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int pos [ maxn ]; struct Node { int add ; int value ; int next ; } temp ; vector < Node > ans , vis , v ; map < int , Node > m ; void dfs ( int add ) { vis . pb ( m [ add ]); if ( m [ add ]. next != -1 ) dfs ( m [ add ]. next ); } int main () { int ini , n ; scanf ( \"%d%d\" , & ini , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d %d %d\" , & temp . add , & temp . value , & temp . next ); m [ temp . add ] = temp ; } dfs ( ini ); int l = 0 , r = vis . size () - 1 ; while ( 1 ) { if ( r < l ) break ; ans . pb ( vis [ r ]); r -- ; if ( r < l ) break ; ans . pb ( vis [ l ]); l ++ ; } n = ans . size () - 1 ; for ( int i = 0 ; i < n ; i ++ ) printf ( \"%05d %d %05d \\n \" , ans [ i ]. add , ans [ i ]. value , ans [ i + 1 ]. add ); printf ( \"%05d %d -1 \\n \" , ans [ n ]. add , ans [ n ]. value ); // if (n & 1) // { // int mid = (n + 1) / 2; // for (int i = 1, j = n; i < mid; i++, j--) // { // ans.pb(vis[j]); // ans.pb(vis[i]); // } // ans.push_back(vis[mid]); // n = ans.size() - 1; // for (int i = 0; i < n; i++) // printf(\"%05d %d %05d\\n\", ans[i].add, ans[i].value, ans[i + 1].add); // printf(\"%05d %d -1\\n\", ans[n].add, ans[n].value); // } // else // { // int mid = n / 2; // for (int i = 1, j = n; i <= mid; i++, j--) // { // ans.pb(vis[j]); // ans.pb(vis[i]); // } // n = ans.size() - 1; // for (int i = 0; i < n; i++) // printf(\"%05d %d %05d\\n\", ans[i].add, ans[i].value, ans[i + 1].add); // printf(\"%05d %d -1\\n\", ans[n].add, ans[n].value); // } }","title":"L2-022-\u91cd\u6392\u94fe\u8868"},{"location":"CCCC/L2-022-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/#l2-022-\u91cd\u6392\u94fe\u8868","text":"","title":"L2-022 \u91cd\u6392\u94fe\u8868"},{"location":"CCCC/L2-022-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868 L_1 L_1 \u2192 L_2 L_2 \u2192 \\cdots \\cdots \u2192 L_{n-1} L_{n-1} \u2192 L_n L_n \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06\u94fe\u8868\u91cd\u65b0\u6392\u5217\u4e3a L_n L_n \u2192 L_1 L_1 \u2192 L_{n-1} L_{n-1} \u2192 L_2 L_2 \u2192 \\cdots \\cdots \u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a1\u21922\u21923\u21924\u21925\u21926\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a6\u21921\u21925\u21922\u21924\u21923\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b1\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c1\u884c\u7ed9\u51fa\u7b2c1\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u548c\u7ed3\u70b9\u603b\u4e2a\u6570\uff0c\u5373\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f5\u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL\u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff1b Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6570\u636e\uff0c\u4e3a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff1b Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u94fe\u8868\u4e0a\u81f3\u5c11\u6709\u4e24\u4e2a\u7ed3\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u91cd\u6392\u540e\u7684\u7ed3\u679c\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 6 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 68237 6 00100 00100 1 99999 99999 5 12309 12309 2 00000 00000 4 33218 33218 3 -1","title":"Statement"},{"location":"CCCC/L2-022-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int pos [ maxn ]; struct Node { int add ; int value ; int next ; } temp ; vector < Node > ans , vis , v ; map < int , Node > m ; void dfs ( int add ) { vis . pb ( m [ add ]); if ( m [ add ]. next != -1 ) dfs ( m [ add ]. next ); } int main () { int ini , n ; scanf ( \"%d%d\" , & ini , & n ); for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d %d %d\" , & temp . add , & temp . value , & temp . next ); m [ temp . add ] = temp ; } dfs ( ini ); int l = 0 , r = vis . size () - 1 ; while ( 1 ) { if ( r < l ) break ; ans . pb ( vis [ r ]); r -- ; if ( r < l ) break ; ans . pb ( vis [ l ]); l ++ ; } n = ans . size () - 1 ; for ( int i = 0 ; i < n ; i ++ ) printf ( \"%05d %d %05d \\n \" , ans [ i ]. add , ans [ i ]. value , ans [ i + 1 ]. add ); printf ( \"%05d %d -1 \\n \" , ans [ n ]. add , ans [ n ]. value ); // if (n & 1) // { // int mid = (n + 1) / 2; // for (int i = 1, j = n; i < mid; i++, j--) // { // ans.pb(vis[j]); // ans.pb(vis[i]); // } // ans.push_back(vis[mid]); // n = ans.size() - 1; // for (int i = 0; i < n; i++) // printf(\"%05d %d %05d\\n\", ans[i].add, ans[i].value, ans[i + 1].add); // printf(\"%05d %d -1\\n\", ans[n].add, ans[n].value); // } // else // { // int mid = n / 2; // for (int i = 1, j = n; i <= mid; i++, j--) // { // ans.pb(vis[j]); // ans.pb(vis[i]); // } // n = ans.size() - 1; // for (int i = 0; i < n; i++) // printf(\"%05d %d %05d\\n\", ans[i].add, ans[i].value, ans[i + 1].add); // printf(\"%05d %d -1\\n\", ans[n].add, ans[n].value); // } }","title":"Solution"},{"location":"CCCC/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/","text":"L2-023 \u56fe\u7740\u8272\u95ee\u9898 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fe\u7740\u8272\u95ee\u9898\u662f\u4e00\u4e2a\u8457\u540d\u7684NP\u5b8c\u5168\u95ee\u9898\u3002\u7ed9\u5b9a\u65e0\u5411\u56fe G = (V, E) G = (V, E) \uff0c\u95ee\u53ef\u5426\u7528 K K \u79cd\u989c\u8272\u4e3a V V \u4e2d\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\u5206\u914d\u4e00\u79cd\u989c\u8272\uff0c\u4f7f\u5f97\u4e0d\u4f1a\u6709\u4e24\u4e2a\u76f8\u90bb\u9876\u70b9\u5177\u6709\u540c\u4e00\u79cd\u989c\u8272\uff1f \u4f46\u672c\u9898\u5e76\u4e0d\u662f\u8981\u4f60\u89e3\u51b3\u8fd9\u4e2a\u7740\u8272\u95ee\u9898\uff0c\u800c\u662f\u5bf9\u7ed9\u5b9a\u7684\u4e00\u79cd\u989c\u8272\u5206\u914d\uff0c\u8bf7\u4f60\u5224\u65ad\u8fd9\u662f\u5426\u662f\u56fe\u7740\u8272\u95ee\u9898\u7684\u4e00\u4e2a\u89e3\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6574\u6570 V V \uff08 0 < V \\le 500 0 < V \\le 500 \uff09\u3001 E E \uff08 \\ge 0 \\ge 0 \uff09\u548c K K \uff08 0 < K \\le V 0 < K \\le V \uff09\uff0c\u5206\u522b\u662f\u65e0\u5411\u56fe\u7684\u9876\u70b9\u6570\u3001\u8fb9\u6570\u3001\u4ee5\u53ca\u989c\u8272\u6570\u3002\u9876\u70b9\u548c\u989c\u8272\u90fd\u4ece1\u5230 V V \u7f16\u53f7\u3002\u968f\u540e E E \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u53f7\u3002\u5728\u56fe\u7684\u4fe1\u606f\u7ed9\u51fa\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e86\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 20 \\le 20 \uff09\uff0c\u662f\u5f85\u68c0\u67e5\u7684\u989c\u8272\u5206\u914d\u65b9\u6848\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa V V \u4e2a\u9876\u70b9\u7684\u989c\u8272\uff08\u7b2c i i \u4e2a\u6570\u5b57\u8868\u793a\u7b2c i i \u4e2a\u9876\u70b9\u7684\u989c\u8272\uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u5b9a\u7684\u65e0\u5411\u56fe\u662f\u5408\u6cd5\u7684\uff08\u5373\u4e0d\u5b58\u5728\u81ea\u56de\u8def\u548c\u91cd\u8fb9\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u79cd\u989c\u8272\u5206\u914d\u65b9\u6848\uff0c\u5982\u679c\u662f\u56fe\u7740\u8272\u95ee\u9898\u7684\u4e00\u4e2a\u89e3\u5219\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \uff0c\u6bcf\u53e5\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 6 8 3 2 1 1 3 4 6 2 5 2 4 5 4 5 6 3 6 4 1 2 3 3 1 2 4 5 6 6 4 5 1 2 3 4 5 6 2 3 4 2 3 4 \u8f93\u51fa\u6837\u4f8b Yes Yes No No Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 510 int n , m , k ; vector < int > G [ N ]; int v [ N ]; map < int , int > mp ; bool ok () { for ( int i = 1 ; i <= n ; ++ i ) for ( auto j : G [ i ]) if ( v [ i ] == v [ j ]) return 0 ; return 1 ; } int main () { while ( scanf ( \"%d%d%d\" , & n , & m , & k ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } int q ; scanf ( \"%d\" , & q ); while ( q -- ) { int cnt = 0 ; mp . clear (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , v + i ); if ( mp [ v [ i ]] == 0 ) { mp [ v [ i ]] = 1 ; ++ cnt ; } } if ( cnt != k ) puts ( \"No\" ); else puts ( ok () ? \"Yes\" : \"No\" ); } } return 0 ; }","title":"L2-023-\u56fe\u7740\u8272\u95ee\u9898"},{"location":"CCCC/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/#l2-023-\u56fe\u7740\u8272\u95ee\u9898","text":"","title":"L2-023 \u56fe\u7740\u8272\u95ee\u9898"},{"location":"CCCC/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fe\u7740\u8272\u95ee\u9898\u662f\u4e00\u4e2a\u8457\u540d\u7684NP\u5b8c\u5168\u95ee\u9898\u3002\u7ed9\u5b9a\u65e0\u5411\u56fe G = (V, E) G = (V, E) \uff0c\u95ee\u53ef\u5426\u7528 K K \u79cd\u989c\u8272\u4e3a V V \u4e2d\u7684\u6bcf\u4e00\u4e2a\u9876\u70b9\u5206\u914d\u4e00\u79cd\u989c\u8272\uff0c\u4f7f\u5f97\u4e0d\u4f1a\u6709\u4e24\u4e2a\u76f8\u90bb\u9876\u70b9\u5177\u6709\u540c\u4e00\u79cd\u989c\u8272\uff1f \u4f46\u672c\u9898\u5e76\u4e0d\u662f\u8981\u4f60\u89e3\u51b3\u8fd9\u4e2a\u7740\u8272\u95ee\u9898\uff0c\u800c\u662f\u5bf9\u7ed9\u5b9a\u7684\u4e00\u79cd\u989c\u8272\u5206\u914d\uff0c\u8bf7\u4f60\u5224\u65ad\u8fd9\u662f\u5426\u662f\u56fe\u7740\u8272\u95ee\u9898\u7684\u4e00\u4e2a\u89e3\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6574\u6570 V V \uff08 0 < V \\le 500 0 < V \\le 500 \uff09\u3001 E E \uff08 \\ge 0 \\ge 0 \uff09\u548c K K \uff08 0 < K \\le V 0 < K \\le V \uff09\uff0c\u5206\u522b\u662f\u65e0\u5411\u56fe\u7684\u9876\u70b9\u6570\u3001\u8fb9\u6570\u3001\u4ee5\u53ca\u989c\u8272\u6570\u3002\u9876\u70b9\u548c\u989c\u8272\u90fd\u4ece1\u5230 V V \u7f16\u53f7\u3002\u968f\u540e E E \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u53f7\u3002\u5728\u56fe\u7684\u4fe1\u606f\u7ed9\u51fa\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e86\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 20 \\le 20 \uff09\uff0c\u662f\u5f85\u68c0\u67e5\u7684\u989c\u8272\u5206\u914d\u65b9\u6848\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa V V \u4e2a\u9876\u70b9\u7684\u989c\u8272\uff08\u7b2c i i \u4e2a\u6570\u5b57\u8868\u793a\u7b2c i i \u4e2a\u9876\u70b9\u7684\u989c\u8272\uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u5b9a\u7684\u65e0\u5411\u56fe\u662f\u5408\u6cd5\u7684\uff08\u5373\u4e0d\u5b58\u5728\u81ea\u56de\u8def\u548c\u91cd\u8fb9\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u79cd\u989c\u8272\u5206\u914d\u65b9\u6848\uff0c\u5982\u679c\u662f\u56fe\u7740\u8272\u95ee\u9898\u7684\u4e00\u4e2a\u89e3\u5219\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \uff0c\u6bcf\u53e5\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 6 8 3 2 1 1 3 4 6 2 5 2 4 5 4 5 6 3 6 4 1 2 3 3 1 2 4 5 6 6 4 5 1 2 3 4 5 6 2 3 4 2 3 4 \u8f93\u51fa\u6837\u4f8b Yes Yes No No","title":"Statement"},{"location":"CCCC/L2-023-%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 510 int n , m , k ; vector < int > G [ N ]; int v [ N ]; map < int , int > mp ; bool ok () { for ( int i = 1 ; i <= n ; ++ i ) for ( auto j : G [ i ]) if ( v [ i ] == v [ j ]) return 0 ; return 1 ; } int main () { while ( scanf ( \"%d%d%d\" , & n , & m , & k ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } int q ; scanf ( \"%d\" , & q ); while ( q -- ) { int cnt = 0 ; mp . clear (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , v + i ); if ( mp [ v [ i ]] == 0 ) { mp [ v [ i ]] = 1 ; ++ cnt ; } } if ( cnt != k ) puts ( \"No\" ); else puts ( ok () ? \"Yes\" : \"No\" ); } } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-024-%E9%83%A8%E8%90%BD/","text":"L2-024 \u90e8\u843d Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u4e00\u4e2a\u793e\u533a\u91cc\uff0c\u6bcf\u4e2a\u4eba\u90fd\u6709\u81ea\u5df1\u7684\u5c0f\u5708\u5b50\uff0c\u8fd8\u53ef\u80fd\u540c\u65f6\u5c5e\u4e8e\u5f88\u591a\u4e0d\u540c\u7684\u670b\u53cb\u5708\u3002\u6211\u4eec\u8ba4\u4e3a\u670b\u53cb\u7684\u670b\u53cb\u90fd\u7b97\u5728\u4e00\u4e2a\u90e8\u843d\u91cc\uff0c\u4e8e\u662f\u8981\u8bf7\u4f60\u7edf\u8ba1\u4e00\u4e0b\uff0c\u5728\u4e00\u4e2a\u7ed9\u5b9a\u793e\u533a\u4e2d\uff0c\u5230\u5e95\u6709\u591a\u5c11\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u90e8\u843d\uff1f\u5e76\u4e14\u68c0\u67e5\u4efb\u610f\u4e24\u4e2a\u4eba\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u90e8\u843d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u5df2\u77e5\u5c0f\u5708\u5b50\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u5708\u5b50\u91cc\u7684\u4eba\uff1a K K P[1] P[1] P[2] P[2] \\cdots \\cdots P[K] P[K] \u5176\u4e2d K K \u662f\u5c0f\u5708\u5b50\u91cc\u7684\u4eba\u6570\uff0c P[i] P[i] \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u5c0f\u5708\u5b50\u91cc\u6bcf\u4e2a\u4eba\u7684\u7f16\u53f7\u3002\u8fd9\u91cc\u6240\u6709\u4eba\u7684\u7f16\u53f7\u4ece1\u5f00\u59cb\u8fde\u7eed\u7f16\u53f7\uff0c\u6700\u5927\u7f16\u53f7\u4e0d\u4f1a\u8d85\u8fc7 10^4 10^4 \u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 Q Q \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u67e5\u8be2\u6b21\u6570\u3002\u968f\u540e Q Q \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u88ab\u67e5\u8be2\u7684\u4eba\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd9\u4e2a\u793e\u533a\u7684\u603b\u4eba\u6570\u3001\u4ee5\u53ca\u4e92\u4e0d\u76f8\u4ea4\u7684\u90e8\u843d\u7684\u4e2a\u6570\u3002\u968f\u540e\u5bf9\u6bcf\u4e00\u6b21\u67e5\u8be2\uff0c\u5982\u679c\u4ed6\u4eec\u5c5e\u4e8e\u540c\u4e00\u4e2a\u90e8\u843d\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Y \uff0c\u5426\u5219\u8f93\u51fa N \u3002 \u8f93\u5165\u6837\u4f8b 4 3 10 1 2 2 3 4 4 1 5 7 8 3 9 6 4 2 10 5 3 7 \u8f93\u51fa\u6837\u4f8b 10 2 Y N Solution C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ], arr [ maxn ]; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; pre [ x ] = r ; return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } int main () { int n , mi ; int num , vis ; cin >> n ; int i , j , k = 0 ; map < int , int > q ; map < int , int > m ; map < int , int > flag ; flag . clear (); m . clear (); q . clear (); for ( i = 0 ; i < maxn ; i ++ ) pre [ i ] = i ; for ( i = 0 ; i < n ; i ++ ) { cin >> mi ; cin >> num ; flag [ num ] = 1 ; for ( j = 1 ; j < mi ; j ++ ) { scanf ( \"%d\" , & vis ); join ( num , vis ); flag [ vis ] = 1 ; } } map < int , int >:: iterator it ; for ( it = flag . begin (); it != flag . end (); it ++ ) arr [ k ++ ] = it -> first ; int len = k ; for ( i = 0 ; i < k ; i ++ ) q [ find ( arr [ i ])] = 1 ; cout << len << \" \" << q . size () << endl ; scanf ( \"%d\" , & mi ); for ( i = 0 ; i < mi ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); if ( find ( a ) == find ( b )) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); } }","title":"L2-024-\u90e8\u843d"},{"location":"CCCC/L2-024-%E9%83%A8%E8%90%BD/#l2-024-\u90e8\u843d","text":"","title":"L2-024 \u90e8\u843d"},{"location":"CCCC/L2-024-%E9%83%A8%E8%90%BD/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u4e00\u4e2a\u793e\u533a\u91cc\uff0c\u6bcf\u4e2a\u4eba\u90fd\u6709\u81ea\u5df1\u7684\u5c0f\u5708\u5b50\uff0c\u8fd8\u53ef\u80fd\u540c\u65f6\u5c5e\u4e8e\u5f88\u591a\u4e0d\u540c\u7684\u670b\u53cb\u5708\u3002\u6211\u4eec\u8ba4\u4e3a\u670b\u53cb\u7684\u670b\u53cb\u90fd\u7b97\u5728\u4e00\u4e2a\u90e8\u843d\u91cc\uff0c\u4e8e\u662f\u8981\u8bf7\u4f60\u7edf\u8ba1\u4e00\u4e0b\uff0c\u5728\u4e00\u4e2a\u7ed9\u5b9a\u793e\u533a\u4e2d\uff0c\u5230\u5e95\u6709\u591a\u5c11\u4e2a\u4e92\u4e0d\u76f8\u4ea4\u7684\u90e8\u843d\uff1f\u5e76\u4e14\u68c0\u67e5\u4efb\u610f\u4e24\u4e2a\u4eba\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u90e8\u843d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u5df2\u77e5\u5c0f\u5708\u5b50\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u5708\u5b50\u91cc\u7684\u4eba\uff1a K K P[1] P[1] P[2] P[2] \\cdots \\cdots P[K] P[K] \u5176\u4e2d K K \u662f\u5c0f\u5708\u5b50\u91cc\u7684\u4eba\u6570\uff0c P[i] P[i] \uff08 i=1, \\cdots , K i=1, \\cdots , K \uff09\u662f\u5c0f\u5708\u5b50\u91cc\u6bcf\u4e2a\u4eba\u7684\u7f16\u53f7\u3002\u8fd9\u91cc\u6240\u6709\u4eba\u7684\u7f16\u53f7\u4ece1\u5f00\u59cb\u8fde\u7eed\u7f16\u53f7\uff0c\u6700\u5927\u7f16\u53f7\u4e0d\u4f1a\u8d85\u8fc7 10^4 10^4 \u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 Q Q \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u67e5\u8be2\u6b21\u6570\u3002\u968f\u540e Q Q \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u88ab\u67e5\u8be2\u7684\u4eba\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd9\u4e2a\u793e\u533a\u7684\u603b\u4eba\u6570\u3001\u4ee5\u53ca\u4e92\u4e0d\u76f8\u4ea4\u7684\u90e8\u843d\u7684\u4e2a\u6570\u3002\u968f\u540e\u5bf9\u6bcf\u4e00\u6b21\u67e5\u8be2\uff0c\u5982\u679c\u4ed6\u4eec\u5c5e\u4e8e\u540c\u4e00\u4e2a\u90e8\u843d\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Y \uff0c\u5426\u5219\u8f93\u51fa N \u3002 \u8f93\u5165\u6837\u4f8b 4 3 10 1 2 2 3 4 4 1 5 7 8 3 9 6 4 2 10 5 3 7 \u8f93\u51fa\u6837\u4f8b 10 2 Y N","title":"Statement"},{"location":"CCCC/L2-024-%E9%83%A8%E8%90%BD/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long LL ; const double PI = 3.14159265358979323846264338327 ; const double E = 2.718281828459 ; const double eps = 1e-6 ; const int MAXN = 0x3f3f3f3f ; const int MINN = 0xc0c0c0c0 ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ], arr [ maxn ]; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; pre [ x ] = r ; return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } int main () { int n , mi ; int num , vis ; cin >> n ; int i , j , k = 0 ; map < int , int > q ; map < int , int > m ; map < int , int > flag ; flag . clear (); m . clear (); q . clear (); for ( i = 0 ; i < maxn ; i ++ ) pre [ i ] = i ; for ( i = 0 ; i < n ; i ++ ) { cin >> mi ; cin >> num ; flag [ num ] = 1 ; for ( j = 1 ; j < mi ; j ++ ) { scanf ( \"%d\" , & vis ); join ( num , vis ); flag [ vis ] = 1 ; } } map < int , int >:: iterator it ; for ( it = flag . begin (); it != flag . end (); it ++ ) arr [ k ++ ] = it -> first ; int len = k ; for ( i = 0 ; i < k ; i ++ ) q [ find ( arr [ i ])] = 1 ; cout << len << \" \" << q . size () << endl ; scanf ( \"%d\" , & mi ); for ( i = 0 ; i < mi ; i ++ ) { int a , b ; scanf ( \"%d%d\" , & a , & b ); if ( find ( a ) == find ( b )) printf ( \"Y \\n \" ); else printf ( \"N \\n \" ); } }","title":"Solution"},{"location":"CCCC/L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/","text":"L2-025 \u5206\u800c\u6cbb\u4e4b Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB \u5206\u800c\u6cbb\u4e4b\uff0c\u5404\u4e2a\u51fb\u7834\u662f\u5175\u5bb6\u5e38\u7528\u7684\u7b56\u7565\u4e4b\u4e00\u3002\u5728\u6218\u4e89\u4e2d\uff0c\u6211\u4eec\u5e0c\u671b\u9996\u5148\u653b\u4e0b\u654c\u65b9\u7684\u90e8\u5206\u57ce\u5e02\uff0c\u4f7f\u5176\u5269\u4f59\u7684\u57ce\u5e02\u53d8\u6210\u5b64\u7acb\u65e0\u63f4\uff0c\u7136\u540e\u518d\u5206\u5934\u5404\u4e2a\u51fb\u7834\u3002\u4e3a\u6b64\u53c2\u8c0b\u90e8\u63d0\u4f9b\u4e86\u82e5\u5e72\u6253\u51fb\u65b9\u6848\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u6bcf\u4e2a\u65b9\u6848\u7684\u53ef\u884c\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N \u548c M\uff08\u5747\u4e0d\u8d85\u8fc710 000\uff09\uff0c\u5206\u522b\u4e3a\u654c\u65b9\u57ce\u5e02\u4e2a\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u57ce\u5e02\u4ece 1 \u5230 N \u7f16\u53f7\uff09\u548c\u8fde\u63a5\u4e24\u57ce\u5e02\u7684\u901a\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u901a\u8def\u6240\u8fde\u63a5\u7684\u4e24\u4e2a\u57ce\u5e02\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5728\u57ce\u5e02\u4fe1\u606f\u4e4b\u540e\u7ed9\u51fa\u53c2\u8c0b\u90e8\u7684\u7cfb\u5217\u65b9\u6848\uff0c\u5373\u4e00\u4e2a\u6b63\u6574\u6570 K \uff08 \\le \\le 100\uff09\u548c\u968f\u540e\u7684 K \u884c\u65b9\u6848\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\uff1a Np v[1] v[2] ... v[Np] \u5176\u4e2d Np \u662f\u8be5\u65b9\u6848\u4e2d\u8ba1\u5212\u653b\u4e0b\u7684\u57ce\u5e02\u6570\u91cf\uff0c\u540e\u9762\u7684\u7cfb\u5217 v[i] \u662f\u8ba1\u5212\u653b\u4e0b\u7684\u57ce\u5e02\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5957\u65b9\u6848\uff0c\u5982\u679c\u53ef\u884c\u5c31\u8f93\u51fa YES \uff0c\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 10 2 4 5 4 10 3 8 4 6 6 1 7 5 4 9 3 1 8 4 2 2 8 7 9 8 7 6 5 4 2 \u8f93\u51fa\u6837\u4f8b NO YES YES NO NO Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = acos ( -1 ); const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; vector < int > G [ maxn ]; int v [ maxn ]; void init () { CLR ( G ); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); int x , y ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); G [ x ]. pb ( y ); G [ y ]. pb ( x ); } int T ; scanf ( \"%d\" , & T ); while ( T -- ) { int k ; scanf ( \"%d\" , & k ); map < int , int > M ; for ( int j = 0 ; j < k ; j ++ ) { int num ; scanf ( \"%d\" , & num ); M [ num ] = 1 ; } int flag = 1 ; vector < int >:: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ]) continue ; for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( M [ * it ] == 0 ) { flag = 0 ; break ; } } } printf ( \"%s \\n \" , flag ? \"YES\" : \"NO\" ); } }","title":"L2-025-\u5206\u800c\u6cbb\u4e4b"},{"location":"CCCC/L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/#l2-025-\u5206\u800c\u6cbb\u4e4b","text":"","title":"L2-025 \u5206\u800c\u6cbb\u4e4b"},{"location":"CCCC/L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB \u5206\u800c\u6cbb\u4e4b\uff0c\u5404\u4e2a\u51fb\u7834\u662f\u5175\u5bb6\u5e38\u7528\u7684\u7b56\u7565\u4e4b\u4e00\u3002\u5728\u6218\u4e89\u4e2d\uff0c\u6211\u4eec\u5e0c\u671b\u9996\u5148\u653b\u4e0b\u654c\u65b9\u7684\u90e8\u5206\u57ce\u5e02\uff0c\u4f7f\u5176\u5269\u4f59\u7684\u57ce\u5e02\u53d8\u6210\u5b64\u7acb\u65e0\u63f4\uff0c\u7136\u540e\u518d\u5206\u5934\u5404\u4e2a\u51fb\u7834\u3002\u4e3a\u6b64\u53c2\u8c0b\u90e8\u63d0\u4f9b\u4e86\u82e5\u5e72\u6253\u51fb\u65b9\u6848\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u6bcf\u4e2a\u65b9\u6848\u7684\u53ef\u884c\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N \u548c M\uff08\u5747\u4e0d\u8d85\u8fc710 000\uff09\uff0c\u5206\u522b\u4e3a\u654c\u65b9\u57ce\u5e02\u4e2a\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u57ce\u5e02\u4ece 1 \u5230 N \u7f16\u53f7\uff09\u548c\u8fde\u63a5\u4e24\u57ce\u5e02\u7684\u901a\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u901a\u8def\u6240\u8fde\u63a5\u7684\u4e24\u4e2a\u57ce\u5e02\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5728\u57ce\u5e02\u4fe1\u606f\u4e4b\u540e\u7ed9\u51fa\u53c2\u8c0b\u90e8\u7684\u7cfb\u5217\u65b9\u6848\uff0c\u5373\u4e00\u4e2a\u6b63\u6574\u6570 K \uff08 \\le \\le 100\uff09\u548c\u968f\u540e\u7684 K \u884c\u65b9\u6848\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\uff1a Np v[1] v[2] ... v[Np] \u5176\u4e2d Np \u662f\u8be5\u65b9\u6848\u4e2d\u8ba1\u5212\u653b\u4e0b\u7684\u57ce\u5e02\u6570\u91cf\uff0c\u540e\u9762\u7684\u7cfb\u5217 v[i] \u662f\u8ba1\u5212\u653b\u4e0b\u7684\u57ce\u5e02\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5957\u65b9\u6848\uff0c\u5982\u679c\u53ef\u884c\u5c31\u8f93\u51fa YES \uff0c\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 10 2 4 5 4 10 3 8 4 6 6 1 7 5 4 9 3 1 8 4 2 2 8 7 9 8 7 6 5 4 2 \u8f93\u51fa\u6837\u4f8b NO YES YES NO NO","title":"Statement"},{"location":"CCCC/L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = acos ( -1 ); const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; vector < int > G [ maxn ]; int v [ maxn ]; void init () { CLR ( G ); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); int x , y ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & x , & y ); G [ x ]. pb ( y ); G [ y ]. pb ( x ); } int T ; scanf ( \"%d\" , & T ); while ( T -- ) { int k ; scanf ( \"%d\" , & k ); map < int , int > M ; for ( int j = 0 ; j < k ; j ++ ) { int num ; scanf ( \"%d\" , & num ); M [ num ] = 1 ; } int flag = 1 ; vector < int >:: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ]) continue ; for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( M [ * it ] == 0 ) { flag = 0 ; break ; } } } printf ( \"%s \\n \" , flag ? \"YES\" : \"NO\" ); } }","title":"Solution"},{"location":"CCCC/L2-026-%E5%B0%8F%E5%AD%97%E8%BE%88/","text":"L2-026 \u5c0f\u5b57\u8f88 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7ed9\u5b9a\u4e00\u4e2a\u5e9e\u5927\u5bb6\u65cf\u7684\u5bb6\u8c31\uff0c\u8981\u8bf7\u4f60\u7ed9\u51fa\u6700\u5c0f\u4e00\u8f88\u7684\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u5bb6\u65cf\u4eba\u53e3\u603b\u6570 N\uff08\u4e0d\u8d85\u8fc7 100 000 \u7684\u6b63\u6574\u6570\uff09 \u2014\u2014 \u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u628a\u5bb6\u65cf\u6210\u5458\u4ece 1 \u5230 N \u7f16\u53f7\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u7f16\u53f7\uff0c\u5176\u4e2d\u7b2c i \u4e2a\u7f16\u53f7\u5bf9\u5e94\u7b2c i \u4f4d\u6210\u5458\u7684\u7236/\u6bcd\u3002\u5bb6\u8c31\u4e2d\u8f88\u5206\u6700\u9ad8\u7684\u8001\u7956\u5b97\u5bf9\u5e94\u7684\u7236/\u6bcd\u7f16\u53f7\u4e3a -1\u3002\u4e00\u884c\u4e2d\u7684\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u6700\u5c0f\u7684\u8f88\u5206\uff08\u8001\u7956\u5b97\u7684\u8f88\u5206\u4e3a 1\uff0c\u4ee5\u4e0b\u9010\u7ea7\u9012\u589e\uff09\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8f88\u5206\u6700\u5c0f\u7684\u6210\u5458\u7684\u7f16\u53f7\u3002\u7f16\u53f7\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 9 2 6 5 5 -1 5 6 4 7 \u8f93\u51fa\u6837\u4f8b 4 1 9 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; vector < int > arr [ maxn ], ans ; int n , Cur ; queue < int > q ; int Count ; void bfs ( int cur ) { int len = q . size (); for ( int i = 0 ; i < len ; i ++ ) { int num = q . front (); q . pop (); vector < int >:: iterator it ; for ( it = arr [ num ]. begin (); it != arr [ num ]. end (); it ++ ) { q . push ( * it ); Count ++ ; } } if ( Count == n ) { while ( ! q . empty ()) { int num = q . front (); q . pop (); ans . pb ( num ); } sort ( ans . begin (), ans . end ()); Cur = cur + 1 ; return ; } bfs ( cur + 1 ); } int main () { scanf ( \"%d\" , & n ); int vis ; int num ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); if ( num != -1 ) arr [ num ]. pb ( i ); else vis = i ; } if ( n == 1 ) printf ( \"1 \\n 1 \\n \" ); else { Count = 1 ; q . push ( vis ); bfs ( 1 ); printf ( \"%d \\n \" , Cur ); vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( it != ans . begin ()) printf ( \" \" ); printf ( \"%d\" , * it ); } printf ( \" \\n \" ); } }","title":"L2-026-\u5c0f\u5b57\u8f88"},{"location":"CCCC/L2-026-%E5%B0%8F%E5%AD%97%E8%BE%88/#l2-026-\u5c0f\u5b57\u8f88","text":"","title":"L2-026 \u5c0f\u5b57\u8f88"},{"location":"CCCC/L2-026-%E5%B0%8F%E5%AD%97%E8%BE%88/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7ed9\u5b9a\u4e00\u4e2a\u5e9e\u5927\u5bb6\u65cf\u7684\u5bb6\u8c31\uff0c\u8981\u8bf7\u4f60\u7ed9\u51fa\u6700\u5c0f\u4e00\u8f88\u7684\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u5bb6\u65cf\u4eba\u53e3\u603b\u6570 N\uff08\u4e0d\u8d85\u8fc7 100 000 \u7684\u6b63\u6574\u6570\uff09 \u2014\u2014 \u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u628a\u5bb6\u65cf\u6210\u5458\u4ece 1 \u5230 N \u7f16\u53f7\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u7f16\u53f7\uff0c\u5176\u4e2d\u7b2c i \u4e2a\u7f16\u53f7\u5bf9\u5e94\u7b2c i \u4f4d\u6210\u5458\u7684\u7236/\u6bcd\u3002\u5bb6\u8c31\u4e2d\u8f88\u5206\u6700\u9ad8\u7684\u8001\u7956\u5b97\u5bf9\u5e94\u7684\u7236/\u6bcd\u7f16\u53f7\u4e3a -1\u3002\u4e00\u884c\u4e2d\u7684\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u6700\u5c0f\u7684\u8f88\u5206\uff08\u8001\u7956\u5b97\u7684\u8f88\u5206\u4e3a 1\uff0c\u4ee5\u4e0b\u9010\u7ea7\u9012\u589e\uff09\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8f88\u5206\u6700\u5c0f\u7684\u6210\u5458\u7684\u7f16\u53f7\u3002\u7f16\u53f7\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 9 2 6 5 5 -1 5 6 4 7 \u8f93\u51fa\u6837\u4f8b 4 1 9","title":"Statement"},{"location":"CCCC/L2-026-%E5%B0%8F%E5%AD%97%E8%BE%88/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; vector < int > arr [ maxn ], ans ; int n , Cur ; queue < int > q ; int Count ; void bfs ( int cur ) { int len = q . size (); for ( int i = 0 ; i < len ; i ++ ) { int num = q . front (); q . pop (); vector < int >:: iterator it ; for ( it = arr [ num ]. begin (); it != arr [ num ]. end (); it ++ ) { q . push ( * it ); Count ++ ; } } if ( Count == n ) { while ( ! q . empty ()) { int num = q . front (); q . pop (); ans . pb ( num ); } sort ( ans . begin (), ans . end ()); Cur = cur + 1 ; return ; } bfs ( cur + 1 ); } int main () { scanf ( \"%d\" , & n ); int vis ; int num ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); if ( num != -1 ) arr [ num ]. pb ( i ); else vis = i ; } if ( n == 1 ) printf ( \"1 \\n 1 \\n \" ); else { Count = 1 ; q . push ( vis ); bfs ( 1 ); printf ( \"%d \\n \" , Cur ); vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( it != ans . begin ()) printf ( \" \" ); printf ( \"%d\" , * it ); } printf ( \" \\n \" ); } }","title":"Solution"},{"location":"CCCC/L2-027-%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%88%B8/","text":"L2-027 \u540d\u4eba\u5802\u4e0e\u4ee3\u91d1\u5238 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u5728\u4e2d\u56fd\u5927\u5b66MOOC\uff08 http://www.icourse163.org/ \uff09\u5b66\u4e60\u201c\u6570\u636e\u7ed3\u6784\u201d\u8bfe\u7a0b\u7684\u5b66\u751f\uff0c\u60f3\u8981\u83b7\u5f97\u4e00\u5f20\u5408\u683c\u8bc1\u4e66\uff0c\u603b\u8bc4\u6210\u7ee9\u5fc5\u987b\u8fbe\u5230 60 \u5206\u53ca\u4ee5\u4e0a\uff0c\u5e76\u4e14\u6709\u53e6\u52a0\u798f\u5229\uff1a\u603b\u8bc4\u5206\u5728 [G, 100] \u533a\u95f4\u5185\u8005\uff0c\u53ef\u4ee5\u5f97\u5230 50 \u5143 PAT \u4ee3\u91d1\u5238\uff1b\u5728 [60, G) \u533a\u95f4\u5185\u8005\uff0c\u53ef\u4ee5\u5f97\u5230 20 \u5143PAT\u4ee3\u91d1\u5238\u3002\u5168\u56fd\u8003\u70b9\u901a\u7528\uff0c\u4e00\u5e74\u6709\u6548\u3002\u540c\u65f6\u4efb\u8bfe\u8001\u5e08\u8fd8\u4f1a\u628a\u603b\u8bc4\u6210\u7ee9\u524d K \u540d\u7684\u5b66\u751f\u5217\u5165\u8bfe\u7a0b\u201c\u540d\u4eba\u5802\u201d\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5e2e\u52a9\u8001\u5e08\u5217\u51fa\u540d\u4eba\u5802\u7684\u5b66\u751f\uff0c\u5e76\u7edf\u8ba1\u4e00\u5171\u53d1\u51fa\u4e86\u9762\u503c\u591a\u5c11\u5143\u7684 PAT \u4ee3\u91d1\u5238\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f N\uff08\u4e0d\u8d85\u8fc7 10 000 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u5b66\u751f\u603b\u6570\uff09\u3001G\uff08\u5728 (60,100) \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u4e3a\u9898\u9762\u4e2d\u63cf\u8ff0\u7684\u4ee3\u91d1\u5238\u7b49\u7ea7\u5206\u754c\u7ebf\uff09\u3001K\uff08\u4e0d\u8d85\u8fc7 100 \u4e14\u4e0d\u8d85\u8fc7 N \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u8fdb\u5165\u540d\u4eba\u5802\u7684\u6700\u4f4e\u540d\u6b21\uff09\u3002\u63a5\u4e0b\u6765 N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b66\u751f\u7684\u8d26\u53f7\uff08\u957f\u5ea6\u4e0d\u8d85\u8fc715\u4f4d\u3001\u4e0d\u5e26\u7a7a\u683c\u7684\u5b57\u7b26\u4e32\uff09\u548c\u603b\u8bc4\u6210\u7ee9\uff08\u533a\u95f4 [0, 100] \u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u91cd\u590d\u7684\u8d26\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53d1\u51fa\u7684 PAT \u4ee3\u91d1\u5238\u7684\u603b\u9762\u503c\u3002\u7136\u540e\u6309\u603b\u8bc4\u6210\u7ee9\u975e\u5347\u5e8f\u8f93\u51fa\u8fdb\u5165\u540d\u4eba\u5802\u7684\u5b66\u751f\u7684\u540d\u6b21\u3001\u8d26\u53f7\u548c\u6210\u7ee9\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff1a\u6210\u7ee9\u76f8\u540c\u7684\u5b66\u751f\u4eab\u6709\u5e76\u5217\u7684\u6392\u540d\uff0c\u6392\u540d\u5e76\u5217\u65f6\uff0c\u6309\u8d26\u53f7\u7684\u5b57\u6bcd\u5e8f\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 80 5 cy@zju.edu.cn 78 cy@pat-edu.com 87 1001@qq.com 65 uh-oh@163.com 96 test@126.com 39 anyone@qq.com 87 zoe@mit.edu 80 jack@ucla.edu 88 bob@cmu.edu 80 ken@163.com 70 \u8f93\u51fa\u6837\u4f8b 360 1 uh-oh@163.com 96 2 jack@ucla.edu 88 3 anyone@qq.com 87 3 cy@pat-edu.com 87 5 bob@cmu.edu 80 5 zoe@mit.edu 80 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { char account [ 16 ]; int score ; int rank ; } q [ maxn ]; bool comp ( Node x , Node y ) { if ( x . score == y . score ) return strcmp ( x . account , y . account ) < 0 ? 1 : 0 ; return x . score > y . score ; } int main () { int n , g , k ; scanf ( \"%d%d%d\" , & n , & g , & k ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \" %s%d\" , q [ i ]. account , & q [ i ]. score ); if ( q [ i ]. score >= g ) sum += 50 ; else if ( q [ i ]. score >= 60 ) sum += 20 ; } sort ( q , q + n , comp ); printf ( \"%d \\n \" , sum ); q [ 0 ]. rank = 1 ; printf ( \"%d %s %d \\n \" , 1 , q [ 0 ]. account , q [ 0 ]. score ); for ( int i = 1 ; i < n ; i ++ ) { if ( q [ i ]. score == q [ i - 1 ]. score ) q [ i ]. rank = q [ i - 1 ]. rank ; else q [ i ]. rank = i + 1 ; if ( q [ i ]. rank > k ) break ; printf ( \"%d %s %d \\n \" , q [ i ]. rank , q [ i ]. account , q [ i ]. score ); } }","title":"L2-027-\u540d\u4eba\u5802\u4e0e\u4ee3\u91d1\u5238"},{"location":"CCCC/L2-027-%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%88%B8/#l2-027-\u540d\u4eba\u5802\u4e0e\u4ee3\u91d1\u5238","text":"","title":"L2-027 \u540d\u4eba\u5802\u4e0e\u4ee3\u91d1\u5238"},{"location":"CCCC/L2-027-%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%88%B8/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u5728\u4e2d\u56fd\u5927\u5b66MOOC\uff08 http://www.icourse163.org/ \uff09\u5b66\u4e60\u201c\u6570\u636e\u7ed3\u6784\u201d\u8bfe\u7a0b\u7684\u5b66\u751f\uff0c\u60f3\u8981\u83b7\u5f97\u4e00\u5f20\u5408\u683c\u8bc1\u4e66\uff0c\u603b\u8bc4\u6210\u7ee9\u5fc5\u987b\u8fbe\u5230 60 \u5206\u53ca\u4ee5\u4e0a\uff0c\u5e76\u4e14\u6709\u53e6\u52a0\u798f\u5229\uff1a\u603b\u8bc4\u5206\u5728 [G, 100] \u533a\u95f4\u5185\u8005\uff0c\u53ef\u4ee5\u5f97\u5230 50 \u5143 PAT \u4ee3\u91d1\u5238\uff1b\u5728 [60, G) \u533a\u95f4\u5185\u8005\uff0c\u53ef\u4ee5\u5f97\u5230 20 \u5143PAT\u4ee3\u91d1\u5238\u3002\u5168\u56fd\u8003\u70b9\u901a\u7528\uff0c\u4e00\u5e74\u6709\u6548\u3002\u540c\u65f6\u4efb\u8bfe\u8001\u5e08\u8fd8\u4f1a\u628a\u603b\u8bc4\u6210\u7ee9\u524d K \u540d\u7684\u5b66\u751f\u5217\u5165\u8bfe\u7a0b\u201c\u540d\u4eba\u5802\u201d\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5e2e\u52a9\u8001\u5e08\u5217\u51fa\u540d\u4eba\u5802\u7684\u5b66\u751f\uff0c\u5e76\u7edf\u8ba1\u4e00\u5171\u53d1\u51fa\u4e86\u9762\u503c\u591a\u5c11\u5143\u7684 PAT \u4ee3\u91d1\u5238\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f N\uff08\u4e0d\u8d85\u8fc7 10 000 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u5b66\u751f\u603b\u6570\uff09\u3001G\uff08\u5728 (60,100) \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u4e3a\u9898\u9762\u4e2d\u63cf\u8ff0\u7684\u4ee3\u91d1\u5238\u7b49\u7ea7\u5206\u754c\u7ebf\uff09\u3001K\uff08\u4e0d\u8d85\u8fc7 100 \u4e14\u4e0d\u8d85\u8fc7 N \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u8fdb\u5165\u540d\u4eba\u5802\u7684\u6700\u4f4e\u540d\u6b21\uff09\u3002\u63a5\u4e0b\u6765 N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b66\u751f\u7684\u8d26\u53f7\uff08\u957f\u5ea6\u4e0d\u8d85\u8fc715\u4f4d\u3001\u4e0d\u5e26\u7a7a\u683c\u7684\u5b57\u7b26\u4e32\uff09\u548c\u603b\u8bc4\u6210\u7ee9\uff08\u533a\u95f4 [0, 100] \u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u91cd\u590d\u7684\u8d26\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53d1\u51fa\u7684 PAT \u4ee3\u91d1\u5238\u7684\u603b\u9762\u503c\u3002\u7136\u540e\u6309\u603b\u8bc4\u6210\u7ee9\u975e\u5347\u5e8f\u8f93\u51fa\u8fdb\u5165\u540d\u4eba\u5802\u7684\u5b66\u751f\u7684\u540d\u6b21\u3001\u8d26\u53f7\u548c\u6210\u7ee9\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff1a\u6210\u7ee9\u76f8\u540c\u7684\u5b66\u751f\u4eab\u6709\u5e76\u5217\u7684\u6392\u540d\uff0c\u6392\u540d\u5e76\u5217\u65f6\uff0c\u6309\u8d26\u53f7\u7684\u5b57\u6bcd\u5e8f\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 80 5 cy@zju.edu.cn 78 cy@pat-edu.com 87 1001@qq.com 65 uh-oh@163.com 96 test@126.com 39 anyone@qq.com 87 zoe@mit.edu 80 jack@ucla.edu 88 bob@cmu.edu 80 ken@163.com 70 \u8f93\u51fa\u6837\u4f8b 360 1 uh-oh@163.com 96 2 jack@ucla.edu 88 3 anyone@qq.com 87 3 cy@pat-edu.com 87 5 bob@cmu.edu 80 5 zoe@mit.edu 80","title":"Statement"},{"location":"CCCC/L2-027-%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%88%B8/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; struct Node { char account [ 16 ]; int score ; int rank ; } q [ maxn ]; bool comp ( Node x , Node y ) { if ( x . score == y . score ) return strcmp ( x . account , y . account ) < 0 ? 1 : 0 ; return x . score > y . score ; } int main () { int n , g , k ; scanf ( \"%d%d%d\" , & n , & g , & k ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \" %s%d\" , q [ i ]. account , & q [ i ]. score ); if ( q [ i ]. score >= g ) sum += 50 ; else if ( q [ i ]. score >= 60 ) sum += 20 ; } sort ( q , q + n , comp ); printf ( \"%d \\n \" , sum ); q [ 0 ]. rank = 1 ; printf ( \"%d %s %d \\n \" , 1 , q [ 0 ]. account , q [ 0 ]. score ); for ( int i = 1 ; i < n ; i ++ ) { if ( q [ i ]. score == q [ i - 1 ]. score ) q [ i ]. rank = q [ i - 1 ]. rank ; else q [ i ]. rank = i + 1 ; if ( q [ i ]. rank > k ) break ; printf ( \"%d %s %d \\n \" , q [ i ]. rank , q [ i ]. account , q [ i ]. score ); } }","title":"Solution"},{"location":"CCCC/L2-028-%E7%A7%80%E6%81%A9%E7%88%B1%E5%88%86%E5%BE%97%E5%BF%AB/","text":"L2-028 \u79c0\u6069\u7231\u5206\u5f97\u5feb Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u53e4\u4eba\u4e91\uff1a\u79c0\u6069\u7231\uff0c\u5206\u5f97\u5feb\u3002 \u4e92\u8054\u7f51\u4e0a\u6bcf\u5929\u90fd\u6709\u5927\u91cf\u4eba\u53d1\u5e03\u5927\u91cf\u7167\u7247\uff0c\u6211\u4eec\u901a\u8fc7\u5206\u6790\u8fd9\u4e9b\u7167\u7247\uff0c\u53ef\u4ee5\u5206\u6790\u4eba\u4e0e\u4eba\u4e4b\u95f4\u7684\u4eb2\u5bc6\u5ea6\u3002\u5982\u679c\u4e00\u5f20\u7167\u7247\u4e0a\u51fa\u73b0\u4e86 K \u4e2a\u4eba\uff0c\u8fd9\u4e9b\u4eba\u4e24\u4e24\u95f4\u7684\u4eb2\u5bc6\u5ea6\u5c31\u88ab\u5b9a\u4e49\u4e3a 1/K\u3002\u4efb\u610f\u4e24\u4e2a\u4eba\u5982\u679c\u540c\u65f6\u51fa\u73b0\u5728\u82e5\u5e72\u5f20\u7167\u7247\u91cc\uff0c\u4ed6\u4eec\u4e4b\u95f4\u7684\u4eb2\u5bc6\u5ea6\u5c31\u662f\u6240\u6709\u8fd9\u4e9b\u540c\u6846\u7167\u7247\u5bf9\u5e94\u7684\u4eb2\u5bc6\u5ea6\u4e4b\u548c\u3002\u4e0b\u9762\u7ed9\u5b9a\u4e00\u6279\u7167\u7247\uff0c\u8bf7\u4f60\u5206\u6790\u4e00\u5bf9\u7ed9\u5b9a\u7684\u60c5\u4fa3\uff0c\u770b\u770b\u4ed6\u4eec\u5206\u522b\u6709\u6ca1\u6709\u4eb2\u5bc6\u5ea6\u66f4\u9ad8\u7684\u5f02\u6027\u670b\u53cb\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff1aN\uff08\u4e0d\u8d85\u8fc71000\uff0c\u4e3a\u603b\u4eba\u6570\u2014\u2014\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u628a\u6240\u6709\u4eba\u4ece 0 \u5230 N-1 \u7f16\u53f7\u3002\u4e3a\u4e86\u533a\u5206\u6027\u522b\uff0c\u6211\u4eec\u7528\u7f16\u53f7\u524d\u7684\u8d1f\u53f7\u8868\u793a\u5973\u6027\uff09\u548c M\uff08\u4e0d\u8d85\u8fc71000\uff0c\u4e3a\u7167\u7247\u603b\u6570\uff09\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u7167\u7247\u7684\u4fe1\u606f\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K P[1] ... P[K] \u5176\u4e2d K\uff08 \\le \\le 500\uff09\u662f\u8be5\u7167\u7247\u4e2d\u51fa\u73b0\u7684\u4eba\u6570\uff0cP[1] ~ P[K] \u5c31\u662f\u8fd9\u4e9b\u4eba\u7684\u7f16\u53f7\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u5bf9\u5f02\u6027\u60c5\u4fa3\u7684\u7f16\u53f7 A \u548c B\u3002\u540c\u884c\u6570\u5b57\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u53ea\u6709\u4e00\u4e2a\u6027\u522b\uff0c\u5e76\u4e14\u4e0d\u4f1a\u5728\u540c\u4e00\u5f20\u7167\u7247\u91cc\u51fa\u73b0\u591a\u6b21\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa A PA \uff0c\u5176\u4e2d PA \u662f\u4e0e A \u6700\u4eb2\u5bc6\u7684\u5f02\u6027\u3002\u5982\u679c PA \u4e0d\u552f\u4e00\uff0c\u5219\u6309\u4ed6\u4eec\u7f16\u53f7\u7684\u7edd\u5bf9\u503c\u9012\u589e\u8f93\u51fa\uff1b\u7136\u540e\u7c7b\u4f3c\u5730\u8f93\u51fa B PB \u3002\u4f46\u5982\u679c A \u548c B \u6b63\u662f\u5f7c\u6b64\u4eb2\u5bc6\u5ea6\u6700\u9ad8\u7684\u4e00\u5bf9\uff0c\u5219\u53ea\u8f93\u51fa\u4ed6\u4eec\u7684\u7f16\u53f7\uff0c\u65e0\u8bba\u662f\u5426\u8fd8\u6709\u5176\u4ed6\u4eba\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 1 10 4 4 -1 2 -3 4 4 2 -3 -5 -6 3 2 4 -5 3 -6 0 2 -3 2 \u8f93\u51fa\u6837\u4f8b 1 -3 2 2 -5 2 -6 \u8f93\u5165\u6837\u4f8b 2 4 4 4 -1 2 -3 0 2 0 -3 2 2 -3 2 -1 2 -3 2 \u8f93\u51fa\u6837\u4f8b 2 -3 2 Solution C++ //#include <cstdio> //#include <cstring> //#include <ctype.h> //#include <cstdlib> //#include <cmath> //#include <climits> //#include <ctime> //#include <iostream> //#include <algorithm> //#include <deque> //#include <vector> //#include <queue> //#include <string> //#include <map> //#include <stack> //#include <set> //#include <numeric> //#include <sstream> //#include <iomanip> //#include <limits> // //#define CLR(a) memset(a, 0, sizeof(a)) //#define pb push_back // // using namespace std; // typedef long long ll; // typedef long double ld; // typedef unsigned long long ull; // typedef pair <int, int> pii; // typedef pair <ll, ll> pll; // // const double PI = 3.14159265358979323846264338327; // const double E = exp(1); // const double eps = 1e-6; // // const int INF = 0x3f3f3f3f; // const int maxn = 1e3 + 5; // const int MOD = 1e9 + 7; // // double G[maxn][maxn]; // // int main() //{ // CLR(G); // int n, m; // scanf(\"%d%d\", &n, &m); // double k; // int K; // map <int, int> M; // for (int i = 0; i < m; i++) // { // scanf(\"%d\", &K); // double k = 1.0 / K; // vector <int> v; // v.clear(); // int num; // for (int j = 0; j < K; j++) // { // scanf(\"%d\", &num); // v.pb(num); // } // for (int j = 0; j < K; j++) // { // for (int l = 0; l < K; l++) // { // if (j != l && v[j] * v[l] < 0) // { // if (v[j] < 0) // M[abs(v[j])] = 1; // if (v[l] < 0) // M[abs(v[l])] = 1; // int x = abs(v[j]); // int y = abs(v[l]); // G[x][y] += k; // G[y][x] += k; // } // } // } // } // int A, B; // scanf(\"%d%d\", &A, &B); // A = abs(A); // B = abs(B); // double Max1 = -INF; // for (int i = 0; i < n; i++) // { // if (G[A][i] > Max1) // Max1 = G[A][i]; // } // double Max2 = -INF; // for (int i = 0; i < n; i++) // { // if (G[B][i] > Max2) // Max2 = G[B][i]; // } // if (G[A][B] == Max1 && G[B][A] == Max2) // { // int x = A; // int y = B; // if (M[A]) // x *= -1; // if (M[B]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // else // { // for (int i = 0; i < n; i++) // { // if (G[A][i] == Max1) // { // int x = A, y = i; // if (M[A]) // x *= -1; // if (M[i]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // } // for (int i = 0; i < n; i++) // { // if (G[B][i] == Max2) // { // int x = B; // int y = i; // if (M[B]) // x *= -1; // if (M[i]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // } // } //} #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = acos ( -1 ); const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; double ans [ 2 ][ maxn ]; map < int , int > M ; int tran ( char s []) { int len = strlen ( s ); int i ; if ( s [ 0 ] == '-' ) i = 1 ; else i = 0 ; int ans = 0 ; for (; i < len ; i ++ ) { ans = ans * 10 + s [ i ] - '0' ; } if ( s [ 0 ] == '-' ) M [ ans ] = -1 ; else M [ ans ] = 1 ; return ans ; } void print ( int x , int y ) { int a = abs ( x ); int b = abs ( y ); if ( M [ a ] == -1 ) printf ( \"-%d \" , a ); else printf ( \"%d \" , a ); if ( M [ b ] == -1 ) printf ( \"-%d \\n \" , b ); else printf ( \"%d \\n \" , b ); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); vector < int > G [ maxn ]; int num , tot ; char s [ 10 ]; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d\" , & tot ); for ( int j = 0 ; j < tot ; j ++ ) { scanf ( \"%s\" , s ); num = tran ( s ); // cout << num << endl; G [ i ]. pb ( num ); } } // map <int, int>::iterator it; // for (it = M.begin(); it != M.end(); it++) // { // printf(\"%d %d\\n\", it->first, it->second); // } // for (int i = 0; i < m; i++) // { // vector <int>::iterator it; // for (it = G[i].begin(); it != G[i].end(); it++) // { // if (it != G[i].begin()) // printf(\" \"); // printf(\"%d\", *it); // } // cout << endl; // } int A , B ; CLR ( ans ); scanf ( \"%s\" , s ); A = tran ( s ); scanf ( \"%s\" , s ); B = tran ( s ); vector < int >:: iterator it ; double Max [ 2 ] = { 0.0 , 0.0 }; for ( int i = 0 ; i < m ; i ++ ) { int flag [ 2 ] = { 0 , 0 }; for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it == abs ( A )) flag [ 0 ] = 1 ; if ( * it == abs ( B )) flag [ 1 ] = 1 ; if ( flag [ 0 ] && flag [ 1 ]) break ; } if ( flag [ 0 ]) { double k = 1.0 / G [ i ]. size (); for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it != abs ( A ) && M [ * it ] * M [ abs ( A )] == -1 ) { ans [ 0 ][ * it ] += k ; } Max [ 0 ] = max ( Max [ 0 ], ans [ 0 ][ * it ]); } } if ( flag [ 1 ]) { double k = 1.0 / G [ i ]. size (); for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it != abs ( B ) && M [ * it ] * M [ abs ( B )] == -1 ) { ans [ 1 ][ * it ] += k ; } Max [ 1 ] = max ( Max [ 1 ], ans [ 1 ][ * it ]); } } } if ( ans [ 0 ][ abs ( B )] == Max [ 0 ] && ans [ 1 ][ abs ( A )] == Max [ 1 ]) { print ( A , B ); } else { for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ans [ i ][ j ] == Max [ i ] && M [ abs ( i ? B : A )] * M [ j ] == -1 ) { print ( i ? B : A , j ); } } } } }","title":"L2-028-\u79c0\u6069\u7231\u5206\u5f97\u5feb"},{"location":"CCCC/L2-028-%E7%A7%80%E6%81%A9%E7%88%B1%E5%88%86%E5%BE%97%E5%BF%AB/#l2-028-\u79c0\u6069\u7231\u5206\u5f97\u5feb","text":"","title":"L2-028 \u79c0\u6069\u7231\u5206\u5f97\u5feb"},{"location":"CCCC/L2-028-%E7%A7%80%E6%81%A9%E7%88%B1%E5%88%86%E5%BE%97%E5%BF%AB/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u53e4\u4eba\u4e91\uff1a\u79c0\u6069\u7231\uff0c\u5206\u5f97\u5feb\u3002 \u4e92\u8054\u7f51\u4e0a\u6bcf\u5929\u90fd\u6709\u5927\u91cf\u4eba\u53d1\u5e03\u5927\u91cf\u7167\u7247\uff0c\u6211\u4eec\u901a\u8fc7\u5206\u6790\u8fd9\u4e9b\u7167\u7247\uff0c\u53ef\u4ee5\u5206\u6790\u4eba\u4e0e\u4eba\u4e4b\u95f4\u7684\u4eb2\u5bc6\u5ea6\u3002\u5982\u679c\u4e00\u5f20\u7167\u7247\u4e0a\u51fa\u73b0\u4e86 K \u4e2a\u4eba\uff0c\u8fd9\u4e9b\u4eba\u4e24\u4e24\u95f4\u7684\u4eb2\u5bc6\u5ea6\u5c31\u88ab\u5b9a\u4e49\u4e3a 1/K\u3002\u4efb\u610f\u4e24\u4e2a\u4eba\u5982\u679c\u540c\u65f6\u51fa\u73b0\u5728\u82e5\u5e72\u5f20\u7167\u7247\u91cc\uff0c\u4ed6\u4eec\u4e4b\u95f4\u7684\u4eb2\u5bc6\u5ea6\u5c31\u662f\u6240\u6709\u8fd9\u4e9b\u540c\u6846\u7167\u7247\u5bf9\u5e94\u7684\u4eb2\u5bc6\u5ea6\u4e4b\u548c\u3002\u4e0b\u9762\u7ed9\u5b9a\u4e00\u6279\u7167\u7247\uff0c\u8bf7\u4f60\u5206\u6790\u4e00\u5bf9\u7ed9\u5b9a\u7684\u60c5\u4fa3\uff0c\u770b\u770b\u4ed6\u4eec\u5206\u522b\u6709\u6ca1\u6709\u4eb2\u5bc6\u5ea6\u66f4\u9ad8\u7684\u5f02\u6027\u670b\u53cb\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff1aN\uff08\u4e0d\u8d85\u8fc71000\uff0c\u4e3a\u603b\u4eba\u6570\u2014\u2014\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u628a\u6240\u6709\u4eba\u4ece 0 \u5230 N-1 \u7f16\u53f7\u3002\u4e3a\u4e86\u533a\u5206\u6027\u522b\uff0c\u6211\u4eec\u7528\u7f16\u53f7\u524d\u7684\u8d1f\u53f7\u8868\u793a\u5973\u6027\uff09\u548c M\uff08\u4e0d\u8d85\u8fc71000\uff0c\u4e3a\u7167\u7247\u603b\u6570\uff09\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u7167\u7247\u7684\u4fe1\u606f\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K P[1] ... P[K] \u5176\u4e2d K\uff08 \\le \\le 500\uff09\u662f\u8be5\u7167\u7247\u4e2d\u51fa\u73b0\u7684\u4eba\u6570\uff0cP[1] ~ P[K] \u5c31\u662f\u8fd9\u4e9b\u4eba\u7684\u7f16\u53f7\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u5bf9\u5f02\u6027\u60c5\u4fa3\u7684\u7f16\u53f7 A \u548c B\u3002\u540c\u884c\u6570\u5b57\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u53ea\u6709\u4e00\u4e2a\u6027\u522b\uff0c\u5e76\u4e14\u4e0d\u4f1a\u5728\u540c\u4e00\u5f20\u7167\u7247\u91cc\u51fa\u73b0\u591a\u6b21\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa A PA \uff0c\u5176\u4e2d PA \u662f\u4e0e A \u6700\u4eb2\u5bc6\u7684\u5f02\u6027\u3002\u5982\u679c PA \u4e0d\u552f\u4e00\uff0c\u5219\u6309\u4ed6\u4eec\u7f16\u53f7\u7684\u7edd\u5bf9\u503c\u9012\u589e\u8f93\u51fa\uff1b\u7136\u540e\u7c7b\u4f3c\u5730\u8f93\u51fa B PB \u3002\u4f46\u5982\u679c A \u548c B \u6b63\u662f\u5f7c\u6b64\u4eb2\u5bc6\u5ea6\u6700\u9ad8\u7684\u4e00\u5bf9\uff0c\u5219\u53ea\u8f93\u51fa\u4ed6\u4eec\u7684\u7f16\u53f7\uff0c\u65e0\u8bba\u662f\u5426\u8fd8\u6709\u5176\u4ed6\u4eba\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 1 10 4 4 -1 2 -3 4 4 2 -3 -5 -6 3 2 4 -5 3 -6 0 2 -3 2 \u8f93\u51fa\u6837\u4f8b 1 -3 2 2 -5 2 -6 \u8f93\u5165\u6837\u4f8b 2 4 4 4 -1 2 -3 0 2 0 -3 2 2 -3 2 -1 2 -3 2 \u8f93\u51fa\u6837\u4f8b 2 -3 2","title":"Statement"},{"location":"CCCC/L2-028-%E7%A7%80%E6%81%A9%E7%88%B1%E5%88%86%E5%BE%97%E5%BF%AB/#solution","text":"C++ //#include <cstdio> //#include <cstring> //#include <ctype.h> //#include <cstdlib> //#include <cmath> //#include <climits> //#include <ctime> //#include <iostream> //#include <algorithm> //#include <deque> //#include <vector> //#include <queue> //#include <string> //#include <map> //#include <stack> //#include <set> //#include <numeric> //#include <sstream> //#include <iomanip> //#include <limits> // //#define CLR(a) memset(a, 0, sizeof(a)) //#define pb push_back // // using namespace std; // typedef long long ll; // typedef long double ld; // typedef unsigned long long ull; // typedef pair <int, int> pii; // typedef pair <ll, ll> pll; // // const double PI = 3.14159265358979323846264338327; // const double E = exp(1); // const double eps = 1e-6; // // const int INF = 0x3f3f3f3f; // const int maxn = 1e3 + 5; // const int MOD = 1e9 + 7; // // double G[maxn][maxn]; // // int main() //{ // CLR(G); // int n, m; // scanf(\"%d%d\", &n, &m); // double k; // int K; // map <int, int> M; // for (int i = 0; i < m; i++) // { // scanf(\"%d\", &K); // double k = 1.0 / K; // vector <int> v; // v.clear(); // int num; // for (int j = 0; j < K; j++) // { // scanf(\"%d\", &num); // v.pb(num); // } // for (int j = 0; j < K; j++) // { // for (int l = 0; l < K; l++) // { // if (j != l && v[j] * v[l] < 0) // { // if (v[j] < 0) // M[abs(v[j])] = 1; // if (v[l] < 0) // M[abs(v[l])] = 1; // int x = abs(v[j]); // int y = abs(v[l]); // G[x][y] += k; // G[y][x] += k; // } // } // } // } // int A, B; // scanf(\"%d%d\", &A, &B); // A = abs(A); // B = abs(B); // double Max1 = -INF; // for (int i = 0; i < n; i++) // { // if (G[A][i] > Max1) // Max1 = G[A][i]; // } // double Max2 = -INF; // for (int i = 0; i < n; i++) // { // if (G[B][i] > Max2) // Max2 = G[B][i]; // } // if (G[A][B] == Max1 && G[B][A] == Max2) // { // int x = A; // int y = B; // if (M[A]) // x *= -1; // if (M[B]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // else // { // for (int i = 0; i < n; i++) // { // if (G[A][i] == Max1) // { // int x = A, y = i; // if (M[A]) // x *= -1; // if (M[i]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // } // for (int i = 0; i < n; i++) // { // if (G[B][i] == Max2) // { // int x = B; // int y = i; // if (M[B]) // x *= -1; // if (M[i]) // y *= -1; // printf(\"%d %d\\n\", x, y); // } // } // } //} #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = acos ( -1 ); const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; double ans [ 2 ][ maxn ]; map < int , int > M ; int tran ( char s []) { int len = strlen ( s ); int i ; if ( s [ 0 ] == '-' ) i = 1 ; else i = 0 ; int ans = 0 ; for (; i < len ; i ++ ) { ans = ans * 10 + s [ i ] - '0' ; } if ( s [ 0 ] == '-' ) M [ ans ] = -1 ; else M [ ans ] = 1 ; return ans ; } void print ( int x , int y ) { int a = abs ( x ); int b = abs ( y ); if ( M [ a ] == -1 ) printf ( \"-%d \" , a ); else printf ( \"%d \" , a ); if ( M [ b ] == -1 ) printf ( \"-%d \\n \" , b ); else printf ( \"%d \\n \" , b ); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); vector < int > G [ maxn ]; int num , tot ; char s [ 10 ]; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d\" , & tot ); for ( int j = 0 ; j < tot ; j ++ ) { scanf ( \"%s\" , s ); num = tran ( s ); // cout << num << endl; G [ i ]. pb ( num ); } } // map <int, int>::iterator it; // for (it = M.begin(); it != M.end(); it++) // { // printf(\"%d %d\\n\", it->first, it->second); // } // for (int i = 0; i < m; i++) // { // vector <int>::iterator it; // for (it = G[i].begin(); it != G[i].end(); it++) // { // if (it != G[i].begin()) // printf(\" \"); // printf(\"%d\", *it); // } // cout << endl; // } int A , B ; CLR ( ans ); scanf ( \"%s\" , s ); A = tran ( s ); scanf ( \"%s\" , s ); B = tran ( s ); vector < int >:: iterator it ; double Max [ 2 ] = { 0.0 , 0.0 }; for ( int i = 0 ; i < m ; i ++ ) { int flag [ 2 ] = { 0 , 0 }; for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it == abs ( A )) flag [ 0 ] = 1 ; if ( * it == abs ( B )) flag [ 1 ] = 1 ; if ( flag [ 0 ] && flag [ 1 ]) break ; } if ( flag [ 0 ]) { double k = 1.0 / G [ i ]. size (); for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it != abs ( A ) && M [ * it ] * M [ abs ( A )] == -1 ) { ans [ 0 ][ * it ] += k ; } Max [ 0 ] = max ( Max [ 0 ], ans [ 0 ][ * it ]); } } if ( flag [ 1 ]) { double k = 1.0 / G [ i ]. size (); for ( it = G [ i ]. begin (); it != G [ i ]. end (); it ++ ) { if ( * it != abs ( B ) && M [ * it ] * M [ abs ( B )] == -1 ) { ans [ 1 ][ * it ] += k ; } Max [ 1 ] = max ( Max [ 1 ], ans [ 1 ][ * it ]); } } } if ( ans [ 0 ][ abs ( B )] == Max [ 0 ] && ans [ 1 ][ abs ( A )] == Max [ 1 ]) { print ( A , B ); } else { for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ans [ i ][ j ] == Max [ i ] && M [ abs ( i ? B : A )] * M [ j ] == -1 ) { print ( i ? B : A , j ); } } } } }","title":"Solution"},{"location":"CCCC/L2-029-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E5%B9%B8%E7%A6%8F/","text":"L2-029 \u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u7684\u5404\u4f4d\u6570\u5b57\u505a\u4e00\u6b21\u5e73\u65b9\u548c\uff0c\u79f0\u4f5c\u4e00\u6b21\u8fed\u4ee3\u3002\u5982\u679c\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u80fd\u901a\u8fc7\u82e5\u5e72\u6b21\u8fed\u4ee3\u5f97\u5230 1\uff0c\u5c31\u79f0\u8be5\u6570\u4e3a\u5e78\u798f\u6570\u30021 \u662f\u4e00\u4e2a\u5e78\u798f\u6570\u3002\u6b64\u5916\uff0c\u4f8b\u5982 19 \u7ecf\u8fc7 1 \u6b21\u8fed\u4ee3\u5f97\u5230 82\uff0c2 \u6b21\u8fed\u4ee3\u540e\u5f97\u5230 68\uff0c3 \u6b21\u8fed\u4ee3\u540e\u5f97\u5230 100\uff0c\u6700\u540e\u5f97\u5230 1\u3002\u5219 19 \u5c31\u662f\u5e78\u798f\u6570\u3002\u663e\u7136\uff0c\u5728\u4e00\u4e2a\u5e78\u798f\u6570\u8fed\u4ee3\u5230 1 \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6570\u5b57\u90fd\u662f\u5e78\u798f\u6570\uff0c\u5b83\u4eec\u7684\u5e78\u798f\u662f\u4f9d\u9644\u4e8e\u521d\u59cb\u6570\u5b57\u7684\u3002\u4f8b\u5982 82\u300168\u3001100 \u7684\u5e78\u798f\u662f\u4f9d\u9644\u4e8e 19 \u7684\u3002\u800c\u4e00\u4e2a \u7279\u7acb\u72ec\u884c \u7684\u5e78\u798f\u6570\uff0c\u662f\u5728\u4e00\u4e2a\u6709\u9650\u7684\u533a\u95f4\u5185\u4e0d\u4f9d\u9644\u4e8e\u4efb\u4f55\u5176\u5b83\u6570\u5b57\u7684\uff1b\u5176 \u72ec\u7acb\u6027 \u5c31\u662f\u4f9d\u9644\u4e8e\u5b83\u7684\u7684\u5e78\u798f\u6570\u7684\u4e2a\u6570\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u8fd8\u662f\u4e2a\u7d20\u6570\uff0c\u5219\u5176\u72ec\u7acb\u6027\u52a0\u500d\u3002\u4f8b\u5982 19 \u5728\u533a\u95f4[1, 100] \u5185\u5c31\u662f\u4e00\u4e2a\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\uff0c\u5176\u72ec\u7acb\u6027\u4e3a 2\\times 4 = 8 2\\times 4 = 8 \u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u5982\u679c\u4e00\u4e2a\u5927\u4e8e1\u7684\u6570\u5b57\u7ecf\u8fc7\u6570\u6b21\u8fed\u4ee3\u540e\u8fdb\u5165\u4e86\u6b7b\u5faa\u73af\uff0c\u90a3\u8fd9\u4e2a\u6570\u5c31\u4e0d\u5e78\u798f\u3002\u4f8b\u5982 29 \u8fed\u4ee3\u5f97\u5230 85\u300189\u3001145\u300142\u300120\u30014\u300116\u300137\u300158\u300189\u3001\u2026\u2026 \u53ef\u89c1 89 \u5230 58 \u5f62\u6210\u4e86\u6b7b\u5faa\u73af\uff0c\u6240\u4ee5 29 \u5c31\u4e0d\u5e78\u798f\u3002 \u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5217\u51fa\u7ed9\u5b9a\u533a\u95f4\u5185\u7684\u6240\u6709\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u548c\u5b83\u7684\u72ec\u7acb\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u95ed\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\uff1a 1<A<B\\le 10^4 1<A<B\\le 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9012\u589e\u987a\u5e8f\u5217\u51fa\u7ed9\u5b9a\u95ed\u533a\u95f4 [A,B] [A,B] \u5185\u7684\u6240\u6709\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u548c\u5b83\u7684\u72ec\u7acb\u6027\u3002\u6bcf\u5bf9\u6570\u5b57\u5360\u4e00\u884c\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u5982\u679c\u533a\u95f4\u5185\u6ca1\u6709\u5e78\u798f\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa SAD \u3002 \u8f93\u5165\u6837\u4f8b 1 10 40 \u8f93\u51fa\u6837\u4f8b 1 19 8 23 6 28 3 31 4 32 3 \u6ce8\u610f\uff1a \u6837\u4f8b\u4e2d\uff0c10\u300113 \u4e5f\u90fd\u662f\u5e78\u798f\u6570\uff0c\u4f46\u5b83\u4eec\u5206\u522b\u4f9d\u9644\u4e8e\u5176\u4ed6\u6570\u5b57\uff08\u5982 23\u300131 \u7b49\u7b49\uff09\uff0c\u6240\u4ee5\u4e0d\u8f93\u51fa\u3002\u5176\u5b83\u6570\u5b57\u867d\u7136\u5176\u5b9e\u4e5f\u4f9d\u9644\u4e8e\u5176\u5b83\u5e78\u798f\u6570\uff0c\u4f46\u56e0\u4e3a\u90a3\u4e9b\u6570\u5b57\u4e0d\u5728\u7ed9\u5b9a\u533a\u95f4 [10, 40] \u5185\uff0c\u6240\u4ee5\u5b83\u4eec\u5728\u7ed9\u5b9a\u533a\u95f4\u5185\u662f\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2 110 120 \u8f93\u51fa\u6837\u4f8b 2 SAD","title":"L2-029-\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f"},{"location":"CCCC/L2-029-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E5%B9%B8%E7%A6%8F/#l2-029-\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f","text":"","title":"L2-029 \u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f"},{"location":"CCCC/L2-029-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E5%B9%B8%E7%A6%8F/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u7684\u5404\u4f4d\u6570\u5b57\u505a\u4e00\u6b21\u5e73\u65b9\u548c\uff0c\u79f0\u4f5c\u4e00\u6b21\u8fed\u4ee3\u3002\u5982\u679c\u4e00\u4e2a\u5341\u8fdb\u5236\u6570\u80fd\u901a\u8fc7\u82e5\u5e72\u6b21\u8fed\u4ee3\u5f97\u5230 1\uff0c\u5c31\u79f0\u8be5\u6570\u4e3a\u5e78\u798f\u6570\u30021 \u662f\u4e00\u4e2a\u5e78\u798f\u6570\u3002\u6b64\u5916\uff0c\u4f8b\u5982 19 \u7ecf\u8fc7 1 \u6b21\u8fed\u4ee3\u5f97\u5230 82\uff0c2 \u6b21\u8fed\u4ee3\u540e\u5f97\u5230 68\uff0c3 \u6b21\u8fed\u4ee3\u540e\u5f97\u5230 100\uff0c\u6700\u540e\u5f97\u5230 1\u3002\u5219 19 \u5c31\u662f\u5e78\u798f\u6570\u3002\u663e\u7136\uff0c\u5728\u4e00\u4e2a\u5e78\u798f\u6570\u8fed\u4ee3\u5230 1 \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6570\u5b57\u90fd\u662f\u5e78\u798f\u6570\uff0c\u5b83\u4eec\u7684\u5e78\u798f\u662f\u4f9d\u9644\u4e8e\u521d\u59cb\u6570\u5b57\u7684\u3002\u4f8b\u5982 82\u300168\u3001100 \u7684\u5e78\u798f\u662f\u4f9d\u9644\u4e8e 19 \u7684\u3002\u800c\u4e00\u4e2a \u7279\u7acb\u72ec\u884c \u7684\u5e78\u798f\u6570\uff0c\u662f\u5728\u4e00\u4e2a\u6709\u9650\u7684\u533a\u95f4\u5185\u4e0d\u4f9d\u9644\u4e8e\u4efb\u4f55\u5176\u5b83\u6570\u5b57\u7684\uff1b\u5176 \u72ec\u7acb\u6027 \u5c31\u662f\u4f9d\u9644\u4e8e\u5b83\u7684\u7684\u5e78\u798f\u6570\u7684\u4e2a\u6570\u3002\u5982\u679c\u8fd9\u4e2a\u6570\u8fd8\u662f\u4e2a\u7d20\u6570\uff0c\u5219\u5176\u72ec\u7acb\u6027\u52a0\u500d\u3002\u4f8b\u5982 19 \u5728\u533a\u95f4[1, 100] \u5185\u5c31\u662f\u4e00\u4e2a\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\uff0c\u5176\u72ec\u7acb\u6027\u4e3a 2\\times 4 = 8 2\\times 4 = 8 \u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u5982\u679c\u4e00\u4e2a\u5927\u4e8e1\u7684\u6570\u5b57\u7ecf\u8fc7\u6570\u6b21\u8fed\u4ee3\u540e\u8fdb\u5165\u4e86\u6b7b\u5faa\u73af\uff0c\u90a3\u8fd9\u4e2a\u6570\u5c31\u4e0d\u5e78\u798f\u3002\u4f8b\u5982 29 \u8fed\u4ee3\u5f97\u5230 85\u300189\u3001145\u300142\u300120\u30014\u300116\u300137\u300158\u300189\u3001\u2026\u2026 \u53ef\u89c1 89 \u5230 58 \u5f62\u6210\u4e86\u6b7b\u5faa\u73af\uff0c\u6240\u4ee5 29 \u5c31\u4e0d\u5e78\u798f\u3002 \u672c\u9898\u5c31\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5217\u51fa\u7ed9\u5b9a\u533a\u95f4\u5185\u7684\u6240\u6709\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u548c\u5b83\u7684\u72ec\u7acb\u6027\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u95ed\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9\uff1a 1<A<B\\le 10^4 1<A<B\\le 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9012\u589e\u987a\u5e8f\u5217\u51fa\u7ed9\u5b9a\u95ed\u533a\u95f4 [A,B] [A,B] \u5185\u7684\u6240\u6709\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u548c\u5b83\u7684\u72ec\u7acb\u6027\u3002\u6bcf\u5bf9\u6570\u5b57\u5360\u4e00\u884c\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u5982\u679c\u533a\u95f4\u5185\u6ca1\u6709\u5e78\u798f\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa SAD \u3002 \u8f93\u5165\u6837\u4f8b 1 10 40 \u8f93\u51fa\u6837\u4f8b 1 19 8 23 6 28 3 31 4 32 3 \u6ce8\u610f\uff1a \u6837\u4f8b\u4e2d\uff0c10\u300113 \u4e5f\u90fd\u662f\u5e78\u798f\u6570\uff0c\u4f46\u5b83\u4eec\u5206\u522b\u4f9d\u9644\u4e8e\u5176\u4ed6\u6570\u5b57\uff08\u5982 23\u300131 \u7b49\u7b49\uff09\uff0c\u6240\u4ee5\u4e0d\u8f93\u51fa\u3002\u5176\u5b83\u6570\u5b57\u867d\u7136\u5176\u5b9e\u4e5f\u4f9d\u9644\u4e8e\u5176\u5b83\u5e78\u798f\u6570\uff0c\u4f46\u56e0\u4e3a\u90a3\u4e9b\u6570\u5b57\u4e0d\u5728\u7ed9\u5b9a\u533a\u95f4 [10, 40] \u5185\uff0c\u6240\u4ee5\u5b83\u4eec\u5728\u7ed9\u5b9a\u533a\u95f4\u5185\u662f\u7279\u7acb\u72ec\u884c\u7684\u5e78\u798f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2 110 120 \u8f93\u51fa\u6837\u4f8b 2 SAD","title":"Statement"},{"location":"CCCC/L2-030-%E5%86%B0%E5%B2%9B%E4%BA%BA/","text":"L2-030 \u51b0\u5c9b\u4eba Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB 2018\u5e74\u4e16\u754c\u676f\uff0c\u51b0\u5c9b\u961f\u56e01:1\u5e73\u4e86\u5f3a\u5927\u7684\u963f\u6839\u5ef7\u961f\u800c\u4e00\u6218\u6210\u540d\u3002\u597d\u4e8b\u8005\u53d1\u73b0\u51b0\u5c9b\u4eba\u7684\u540d\u5b57\u540e\u9762\u4f3c\u4e4e\u90fd\u6709\u4e2a\u201c\u677e\u201d\uff08son\uff09\uff0c\u4e8e\u662f\u6709\u7f51\u53cb\u79d1\u666e\u5982\u4e0b\uff1a \u51b0\u5c9b\u4eba\u6cbf\u7528\u7684\u662f\u7ef4\u4eac\u4eba\u53e4\u8001\u7684\u7236\u7cfb\u59d3\u5236\uff0c\u5b69\u5b50\u7684\u59d3\u7b49\u4e8e\u7236\u4eb2\u7684\u540d\u52a0\u540e\u7f00\uff0c\u5982\u679c\u662f\u513f\u5b50\u5c31\u52a0 sson\uff0c\u5973\u513f\u5219\u52a0 sdottir\u3002\u56e0\u4e3a\u51b0\u5c9b\u4eba\u53e3\u8f83\u5c11\uff0c\u4e3a\u907f\u514d\u8fd1\u4eb2\u7e41\u884d\uff0c\u672c\u5730\u4eba\u4ea4\u5f80\u524d\u5148\u7528\u4e2a App \u67e5\u4e00\u4e0b\u4e24\u4eba\u7956\u5b97\u82e5\u5e72\u4ee3\u6709\u65e0\u8054\u7cfb\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a App \u7684\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^5 1 < N \\le 10^5 \uff09\uff0c\u4e3a\u5f53\u5730\u4eba\u53e3\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u540d\uff0c\u683c\u5f0f\u4e3a\uff1a \u540d \u59d3\uff08\u5e26\u6027\u522b\u540e\u7f00\uff09 \uff0c\u4e24\u4e2a\u5b57\u7b26\u4e32\u5747\u7531\u4e0d\u8d85\u8fc7 20 \u4e2a\u5c0f\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002\u7ef4\u4eac\u4eba\u540e\u88d4\u662f\u53ef\u4ee5\u901a\u8fc7\u59d3\u7684\u540e\u7f00\u5224\u65ad\u5176\u6027\u522b\u7684\uff0c\u5176\u4ed6\u4eba\u5219\u662f\u5728\u59d3\u7684\u540e\u9762\u52a0 m \u8868\u793a\u7537\u6027\u3001 f \u8868\u793a\u5973\u6027\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u6bcf\u4e2a\u7ef4\u4eac\u5bb6\u65cf\u7684\u8d77\u6e90\u4eba\u90fd\u662f\u7537\u6027\u3002 \u968f\u540e\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 M M \uff0c\u4e3a\u67e5\u8be2\u6570\u91cf\u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u4eba\u540d\uff0c\u683c\u5f0f\u4e3a\uff1a \u540d1 \u59d31 \u540d2 \u59d32 \u3002\u6ce8\u610f\uff1a\u8fd9\u91cc\u7684 \u59d3 \u662f\u4e0d\u5e26\u540e\u7f00\u7684\u3002\u56db\u4e2a\u5b57\u7b26\u4e32\u5747\u7531\u4e0d\u8d85\u8fc7 20 \u4e2a\u5c0f\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002 \u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u4e24\u4e2a\u4eba\u662f\u540c\u540d\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u67e5\u8be2\uff0c\u6839\u636e\u7ed3\u679c\u5728\u4e00\u884c\u5185\u663e\u793a\u4ee5\u4e0b\u4fe1\u606f\uff1a \u82e5\u4e24\u4eba\u4e3a\u5f02\u6027\uff0c\u4e14\u4e94\u4ee3\u4ee5\u5185\u65e0\u516c\u5171\u7956\u5148\uff0c\u5219\u8f93\u51fa Yes \uff1b \u82e5\u4e24\u4eba\u4e3a\u5f02\u6027\uff0c\u4f46\u4e94\u4ee3\u4ee5\u5185\uff08\u4e0d\u5305\u62ec\u7b2c\u4e94\u4ee3\uff09\u6709\u516c\u5171\u7956\u5148\uff0c\u5219\u8f93\u51fa No \uff1b \u82e5\u4e24\u4eba\u4e3a\u540c\u6027\uff0c\u5219\u8f93\u51fa Whatever \uff1b \u82e5\u6709\u4e00\u4eba\u4e0d\u5728\u540d\u5355\u5185\uff0c\u5219\u8f93\u51fa NA \u3002 \u6240\u8c13\u201c\u4e94\u4ee3\u4ee5\u5185\u65e0\u516c\u5171\u7956\u5148\u201d\u662f\u6307\u4e24\u4eba\u7684\u516c\u5171\u7956\u5148\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\u5fc5\u987b\u6bd4\u4efb\u4f55\u4e00\u65b9\u7684\u66fe\u7956\u7236\u8f88\u5206\u9ad8\u3002 \u8f93\u5165\u6837\u4f8b 15 chris smithm adam smithm bob adamsson jack chrissson bill chrissson mike jacksson steve billsson tim mikesson april mikesdottir eric stevesson tracy timsdottir james ericsson patrick jacksson robin patricksson will robinsson 6 tracy tim james eric will robin tracy tim april mike steve bill bob adam eric steve tracy tim tracy tim x man april mikes \u8f93\u51fa\u6837\u4f8b Yes No No Whatever Whatever NA","title":"L2-030-\u51b0\u5c9b\u4eba"},{"location":"CCCC/L2-030-%E5%86%B0%E5%B2%9B%E4%BA%BA/#l2-030-\u51b0\u5c9b\u4eba","text":"","title":"L2-030 \u51b0\u5c9b\u4eba"},{"location":"CCCC/L2-030-%E5%86%B0%E5%B2%9B%E4%BA%BA/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB 2018\u5e74\u4e16\u754c\u676f\uff0c\u51b0\u5c9b\u961f\u56e01:1\u5e73\u4e86\u5f3a\u5927\u7684\u963f\u6839\u5ef7\u961f\u800c\u4e00\u6218\u6210\u540d\u3002\u597d\u4e8b\u8005\u53d1\u73b0\u51b0\u5c9b\u4eba\u7684\u540d\u5b57\u540e\u9762\u4f3c\u4e4e\u90fd\u6709\u4e2a\u201c\u677e\u201d\uff08son\uff09\uff0c\u4e8e\u662f\u6709\u7f51\u53cb\u79d1\u666e\u5982\u4e0b\uff1a \u51b0\u5c9b\u4eba\u6cbf\u7528\u7684\u662f\u7ef4\u4eac\u4eba\u53e4\u8001\u7684\u7236\u7cfb\u59d3\u5236\uff0c\u5b69\u5b50\u7684\u59d3\u7b49\u4e8e\u7236\u4eb2\u7684\u540d\u52a0\u540e\u7f00\uff0c\u5982\u679c\u662f\u513f\u5b50\u5c31\u52a0 sson\uff0c\u5973\u513f\u5219\u52a0 sdottir\u3002\u56e0\u4e3a\u51b0\u5c9b\u4eba\u53e3\u8f83\u5c11\uff0c\u4e3a\u907f\u514d\u8fd1\u4eb2\u7e41\u884d\uff0c\u672c\u5730\u4eba\u4ea4\u5f80\u524d\u5148\u7528\u4e2a App \u67e5\u4e00\u4e0b\u4e24\u4eba\u7956\u5b97\u82e5\u5e72\u4ee3\u6709\u65e0\u8054\u7cfb\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a App \u7684\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^5 1 < N \\le 10^5 \uff09\uff0c\u4e3a\u5f53\u5730\u4eba\u53e3\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u540d\uff0c\u683c\u5f0f\u4e3a\uff1a \u540d \u59d3\uff08\u5e26\u6027\u522b\u540e\u7f00\uff09 \uff0c\u4e24\u4e2a\u5b57\u7b26\u4e32\u5747\u7531\u4e0d\u8d85\u8fc7 20 \u4e2a\u5c0f\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002\u7ef4\u4eac\u4eba\u540e\u88d4\u662f\u53ef\u4ee5\u901a\u8fc7\u59d3\u7684\u540e\u7f00\u5224\u65ad\u5176\u6027\u522b\u7684\uff0c\u5176\u4ed6\u4eba\u5219\u662f\u5728\u59d3\u7684\u540e\u9762\u52a0 m \u8868\u793a\u7537\u6027\u3001 f \u8868\u793a\u5973\u6027\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u6bcf\u4e2a\u7ef4\u4eac\u5bb6\u65cf\u7684\u8d77\u6e90\u4eba\u90fd\u662f\u7537\u6027\u3002 \u968f\u540e\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 M M \uff0c\u4e3a\u67e5\u8be2\u6570\u91cf\u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u4eba\u540d\uff0c\u683c\u5f0f\u4e3a\uff1a \u540d1 \u59d31 \u540d2 \u59d32 \u3002\u6ce8\u610f\uff1a\u8fd9\u91cc\u7684 \u59d3 \u662f\u4e0d\u5e26\u540e\u7f00\u7684\u3002\u56db\u4e2a\u5b57\u7b26\u4e32\u5747\u7531\u4e0d\u8d85\u8fc7 20 \u4e2a\u5c0f\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u3002 \u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u4e24\u4e2a\u4eba\u662f\u540c\u540d\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u4e2a\u67e5\u8be2\uff0c\u6839\u636e\u7ed3\u679c\u5728\u4e00\u884c\u5185\u663e\u793a\u4ee5\u4e0b\u4fe1\u606f\uff1a \u82e5\u4e24\u4eba\u4e3a\u5f02\u6027\uff0c\u4e14\u4e94\u4ee3\u4ee5\u5185\u65e0\u516c\u5171\u7956\u5148\uff0c\u5219\u8f93\u51fa Yes \uff1b \u82e5\u4e24\u4eba\u4e3a\u5f02\u6027\uff0c\u4f46\u4e94\u4ee3\u4ee5\u5185\uff08\u4e0d\u5305\u62ec\u7b2c\u4e94\u4ee3\uff09\u6709\u516c\u5171\u7956\u5148\uff0c\u5219\u8f93\u51fa No \uff1b \u82e5\u4e24\u4eba\u4e3a\u540c\u6027\uff0c\u5219\u8f93\u51fa Whatever \uff1b \u82e5\u6709\u4e00\u4eba\u4e0d\u5728\u540d\u5355\u5185\uff0c\u5219\u8f93\u51fa NA \u3002 \u6240\u8c13\u201c\u4e94\u4ee3\u4ee5\u5185\u65e0\u516c\u5171\u7956\u5148\u201d\u662f\u6307\u4e24\u4eba\u7684\u516c\u5171\u7956\u5148\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\u5fc5\u987b\u6bd4\u4efb\u4f55\u4e00\u65b9\u7684\u66fe\u7956\u7236\u8f88\u5206\u9ad8\u3002 \u8f93\u5165\u6837\u4f8b 15 chris smithm adam smithm bob adamsson jack chrissson bill chrissson mike jacksson steve billsson tim mikesson april mikesdottir eric stevesson tracy timsdottir james ericsson patrick jacksson robin patricksson will robinsson 6 tracy tim james eric will robin tracy tim april mike steve bill bob adam eric steve tracy tim tracy tim x man april mikes \u8f93\u51fa\u6837\u4f8b Yes No No Whatever Whatever NA","title":"Statement"},{"location":"CCCC/L2-031-%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4/","text":"L2-031 \u6df1\u5165\u864e\u7a74 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8457\u540d\u7684\u738b\u724c\u95f4\u8c0d 007 \u9700\u8981\u6267\u884c\u4e00\u6b21\u4efb\u52a1\uff0c\u83b7\u53d6\u654c\u65b9\u7684\u673a\u5bc6\u60c5\u62a5\u3002\u5df2\u77e5\u60c5\u62a5\u85cf\u5728\u4e00\u4e2a\u5730\u4e0b\u8ff7\u5bab\u91cc\uff0c\u8ff7\u5bab\u53ea\u6709\u4e00\u4e2a\u5165\u53e3\uff0c\u91cc\u9762\u6709\u5f88\u591a\u6761\u901a\u8def\uff0c\u6bcf\u6761\u8def\u901a\u5411\u4e00\u6247\u95e8\u3002\u6bcf\u4e00\u6247\u95e8\u80cc\u540e\u6216\u8005\u662f\u4e00\u4e2a\u623f\u95f4\uff0c\u6216\u8005\u53c8\u6709\u5f88\u591a\u6761\u8def\uff0c\u540c\u6837\u662f\u6bcf\u6761\u8def\u901a\u5411\u4e00\u6247\u95e8\u2026\u2026 \u4ed6\u7684\u624b\u91cc\u6709\u4e00\u5f20\u8868\u683c\uff0c\u662f\u5176\u4ed6\u95f4\u8c0d\u5e2e\u4ed6\u6536\u96c6\u5230\u7684\u60c5\u62a5\uff0c\u4ed6\u4eec\u8bb0\u4e0b\u4e86\u6bcf\u6247\u95e8\u7684\u7f16\u53f7\uff0c\u4ee5\u53ca\u8fd9\u6247\u95e8\u80cc\u540e\u7684\u6bcf\u4e00\u6761\u901a\u8def\u6240\u5230\u8fbe\u7684\u95e8\u7684\u7f16\u53f7\u3002007 \u53d1\u73b0\u4e0d\u5b58\u5728\u4e24\u6761\u8def\u901a\u5411\u540c\u4e00\u6247\u95e8\u3002 \u5185\u7ebf\u544a\u8bc9\u4ed6\uff0c\u60c5\u62a5\u5c31\u85cf\u5728\u8ff7\u5bab\u7684\u6700\u6df1\u5904\u3002\u4f46\u662f\u8fd9\u4e2a\u8ff7\u5bab\u592a\u5927\u4e86\uff0c\u4ed6\u9700\u8981\u4f60\u7684\u5e2e\u52a9 \u2014\u2014 \u8bf7\u7f16\u7a0b\u5e2e\u4ed6\u627e\u51fa\u8ddd\u79bb\u5165\u53e3\u6700\u8fdc\u7684\u90a3\u6247\u95e8\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 < 10^5 < 10^5 \uff09\uff0c\u662f\u95e8\u7684\u6570\u91cf\u3002\u6700\u540e N N \u884c\uff0c\u7b2c i i \u884c\uff08 1\\le i \\le N 1\\le i \\le N \uff09\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u7f16\u53f7\u4e3a i i \u7684\u90a3\u6247\u95e8\u80cc\u540e\u80fd\u901a\u5411\u7684\u95e8\uff1a K D[1] D[2] ... D[K] \u5176\u4e2d K \u662f\u901a\u9053\u7684\u6570\u91cf\uff0c\u5176\u540e\u662f\u6bcf\u6247\u95e8\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8ddd\u79bb\u5165\u53e3\u6700\u8fdc\u7684\u90a3\u6247\u95e8\u7684\u7f16\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u7ed3\u679c\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 13 3 2 3 4 2 5 6 1 7 1 8 1 9 0 2 11 10 1 13 0 0 1 12 0 0 \u8f93\u51fa\u6837\u4f8b 12","title":"L2-031-\u6df1\u5165\u864e\u7a74"},{"location":"CCCC/L2-031-%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4/#l2-031-\u6df1\u5165\u864e\u7a74","text":"","title":"L2-031 \u6df1\u5165\u864e\u7a74"},{"location":"CCCC/L2-031-%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8457\u540d\u7684\u738b\u724c\u95f4\u8c0d 007 \u9700\u8981\u6267\u884c\u4e00\u6b21\u4efb\u52a1\uff0c\u83b7\u53d6\u654c\u65b9\u7684\u673a\u5bc6\u60c5\u62a5\u3002\u5df2\u77e5\u60c5\u62a5\u85cf\u5728\u4e00\u4e2a\u5730\u4e0b\u8ff7\u5bab\u91cc\uff0c\u8ff7\u5bab\u53ea\u6709\u4e00\u4e2a\u5165\u53e3\uff0c\u91cc\u9762\u6709\u5f88\u591a\u6761\u901a\u8def\uff0c\u6bcf\u6761\u8def\u901a\u5411\u4e00\u6247\u95e8\u3002\u6bcf\u4e00\u6247\u95e8\u80cc\u540e\u6216\u8005\u662f\u4e00\u4e2a\u623f\u95f4\uff0c\u6216\u8005\u53c8\u6709\u5f88\u591a\u6761\u8def\uff0c\u540c\u6837\u662f\u6bcf\u6761\u8def\u901a\u5411\u4e00\u6247\u95e8\u2026\u2026 \u4ed6\u7684\u624b\u91cc\u6709\u4e00\u5f20\u8868\u683c\uff0c\u662f\u5176\u4ed6\u95f4\u8c0d\u5e2e\u4ed6\u6536\u96c6\u5230\u7684\u60c5\u62a5\uff0c\u4ed6\u4eec\u8bb0\u4e0b\u4e86\u6bcf\u6247\u95e8\u7684\u7f16\u53f7\uff0c\u4ee5\u53ca\u8fd9\u6247\u95e8\u80cc\u540e\u7684\u6bcf\u4e00\u6761\u901a\u8def\u6240\u5230\u8fbe\u7684\u95e8\u7684\u7f16\u53f7\u3002007 \u53d1\u73b0\u4e0d\u5b58\u5728\u4e24\u6761\u8def\u901a\u5411\u540c\u4e00\u6247\u95e8\u3002 \u5185\u7ebf\u544a\u8bc9\u4ed6\uff0c\u60c5\u62a5\u5c31\u85cf\u5728\u8ff7\u5bab\u7684\u6700\u6df1\u5904\u3002\u4f46\u662f\u8fd9\u4e2a\u8ff7\u5bab\u592a\u5927\u4e86\uff0c\u4ed6\u9700\u8981\u4f60\u7684\u5e2e\u52a9 \u2014\u2014 \u8bf7\u7f16\u7a0b\u5e2e\u4ed6\u627e\u51fa\u8ddd\u79bb\u5165\u53e3\u6700\u8fdc\u7684\u90a3\u6247\u95e8\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 < 10^5 < 10^5 \uff09\uff0c\u662f\u95e8\u7684\u6570\u91cf\u3002\u6700\u540e N N \u884c\uff0c\u7b2c i i \u884c\uff08 1\\le i \\le N 1\\le i \\le N \uff09\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u7f16\u53f7\u4e3a i i \u7684\u90a3\u6247\u95e8\u80cc\u540e\u80fd\u901a\u5411\u7684\u95e8\uff1a K D[1] D[2] ... D[K] \u5176\u4e2d K \u662f\u901a\u9053\u7684\u6570\u91cf\uff0c\u5176\u540e\u662f\u6bcf\u6247\u95e8\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8ddd\u79bb\u5165\u53e3\u6700\u8fdc\u7684\u90a3\u6247\u95e8\u7684\u7f16\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u7ed3\u679c\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 13 3 2 3 4 2 5 6 1 7 1 8 1 9 0 2 11 10 1 13 0 0 1 12 0 0 \u8f93\u51fa\u6837\u4f8b 12","title":"Statement"},{"location":"CCCC/L2-032-%E5%BD%A9%E8%99%B9%E7%93%B6/","text":"L2-032 \u5f69\u8679\u74f6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f69\u8679\u74f6\u7684\u5236\u4f5c\u8fc7\u7a0b\uff08\u5e76\u4e0d\uff09\u662f\u8fd9\u6837\u7684\uff1a\u5148\u628a\u4e00\u5927\u6279\u7a7a\u74f6\u94fa\u653e\u5728\u88c5\u586b\u573a\u5730\u4e0a\uff0c\u7136\u540e\u6309\u7167\u4e00\u5b9a\u7684\u987a\u5e8f\u5c06\u6bcf\u79cd\u989c\u8272\u7684\u5c0f\u7403\u5747\u5300\u6492\u5230\u8fd9\u6279\u74f6\u5b50\u91cc\u3002 \u5047\u8bbe\u5f69\u8679\u74f6\u91cc\u8981\u6309\u987a\u5e8f\u88c5 N \u79cd\u989c\u8272\u7684\u5c0f\u7403\uff08\u4e0d\u59a8\u5c06\u987a\u5e8f\u5c31\u7f16\u53f7\u4e3a 1 \u5230 N\uff09\u3002\u73b0\u5728\u5de5\u5382\u91cc\u6709\u6bcf\u79cd\u989c\u8272\u7684\u5c0f\u7403\u5404\u4e00\u7bb1\uff0c\u5de5\u4eba\u9700\u8981\u4e00\u7bb1\u4e00\u7bb1\u5730\u5c06\u5c0f\u7403\u4ece\u5de5\u5382\u91cc\u642c\u5230\u88c5\u586b\u573a\u5730\u3002\u5982\u679c\u642c\u6765\u7684\u8fd9\u7bb1\u5c0f\u7403\u6b63\u597d\u662f\u53ef\u4ee5\u88c5\u586b\u7684\u989c\u8272\uff0c\u5c31\u76f4\u63a5\u62c6\u7bb1\u88c5\u586b\uff1b\u5982\u679c\u4e0d\u662f\uff0c\u5c31\u628a\u7bb1\u5b50\u5148\u7801\u653e\u5728\u4e00\u4e2a\u4e34\u65f6\u8d27\u67b6\u4e0a\uff0c\u7801\u653e\u7684\u65b9\u6cd5\u5c31\u662f\u4e00\u7bb1\u4e00\u7bb1\u5806\u4e0a\u53bb\u3002\u5f53\u4e00\u79cd\u989c\u8272\u88c5\u586b\u5b8c\u4ee5\u540e\uff0c\u5148\u770b\u770b\u8d27\u67b6\u9876\u7aef\u7684\u4e00\u7bb1\u662f\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8981\u88c5\u586b\u7684\u989c\u8272\uff0c\u5982\u679c\u662f\u5c31\u53d6\u4e0b\u6765\u88c5\u586b\uff0c\u5426\u5219\u53bb\u5de5\u5382\u91cc\u518d\u642c\u4e00\u7bb1\u8fc7\u6765\u3002 \u5982\u679c\u5de5\u5382\u91cc\u53d1\u8d27\u7684\u987a\u5e8f\u6bd4\u8f83\u597d\uff0c\u5de5\u4eba\u5c31\u53ef\u4ee5\u987a\u5229\u5730\u5b8c\u6210\u88c5\u586b\u3002\u4f8b\u5982\u8981\u6309\u987a\u5e8f\u88c5\u586b 7 \u79cd\u989c\u8272\uff0c\u5de5\u5382\u6309\u7167 7\u30016\u30011\u30013\u30012\u30015\u30014 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5219\u5de5\u4eba\u5148\u62ff\u5230 7\u30016 \u4e24\u79cd\u4e0d\u80fd\u88c5\u586b\u7684\u989c\u8272\uff0c\u5c06\u5176\u6309\u7167 7 \u5728\u4e0b\u30016 \u5728\u4e0a\u7684\u987a\u5e8f\u5806\u5728\u8d27\u67b6\u4e0a\uff1b\u62ff\u5230 1 \u65f6\u53ef\u4ee5\u76f4\u63a5\u88c5\u586b\uff1b\u62ff\u5230 3 \u65f6\u53c8\u5f97\u4e34\u65f6\u7801\u653e\u5728 6 \u53f7\u989c\u8272\u7bb1\u4e0a\uff1b\u62ff\u5230 2 \u65f6\u53ef\u4ee5\u76f4\u63a5\u88c5\u586b\uff1b\u968f\u540e\u4ece\u8d27\u67b6\u9876\u53d6\u4e0b 3 \u8fdb\u884c\u88c5\u586b\uff1b\u7136\u540e\u62ff\u5230 5\uff0c\u4e34\u65f6\u7801\u653e\u5230 6 \u4e0a\u9762\uff1b\u6700\u540e\u53d6\u4e86 4 \u53f7\u989c\u8272\u76f4\u63a5\u88c5\u586b\uff1b\u5269\u4e0b\u7684\u5de5\u4f5c\u5c31\u662f\u987a\u5e8f\u4ece\u8d27\u67b6\u4e0a\u53d6\u4e0b 5\u30016\u30017 \u4f9d\u6b21\u88c5\u586b\u3002 \u4f46\u5982\u679c\u5de5\u5382\u6309\u7167 3\u30011\u30015\u30014\u30012\u30016\u30017 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5de5\u4eba\u5c31\u5fc5\u987b\u8981\u6124\u6012\u5730\u6298\u817e\u8d27\u67b6\u4e86\uff0c\u56e0\u4e3a\u88c5\u586b\u5b8c 2 \u53f7\u989c\u8272\u4ee5\u540e\uff0c\u4e0d\u628a\u8d27\u67b6\u4e0a\u7684\u591a\u4e2a\u7bb1\u5b50\u642c\u4e0b\u6765\u5c31\u62ff\u4e0d\u5230 3 \u53f7\u7bb1\uff0c\u5c31\u4e0d\u53ef\u80fd\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002 \u53e6\u5916\uff0c\u8d27\u67b6\u7684\u5bb9\u91cf\u6709\u9650\uff0c\u5982\u679c\u8981\u5806\u79ef\u7684\u8d27\u7269\u8d85\u8fc7\u5bb9\u91cf\uff0c\u5de5\u4eba\u4e5f\u6ca1\u529e\u6cd5\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002\u4f8b\u5982\u5de5\u5382\u6309\u7167 7\u30016\u30015\u30014\u30013\u30012\u30011 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5982\u679c\u8d27\u67b6\u591f\u9ad8\uff0c\u80fd\u7801\u653e 6 \u53ea\u7bb1\u5b50\uff0c\u90a3\u8fd8\u662f\u53ef\u4ee5\u987a\u5229\u5b8c\u5de5\u7684\uff1b\u4f46\u5982\u679c\u8d27\u67b6\u53ea\u80fd\u7801\u653e 5 \u53ea\u7bb1\u5b50\uff0c\u5de5\u4eba\u5c31\u53c8\u8981\u6124\u6012\u4e86\u2026\u2026 \u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u4e00\u4e0b\uff0c\u5de5\u5382\u7684\u53d1\u8d27\u987a\u5e8f\u80fd\u5426\u8ba9\u5de5\u4eba\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\u5f69\u8679\u74f6\u7684\u989c\u8272\u6570\u91cf N N \uff08 1 < N \\le 10^3 1 < N \\le 10^3 \uff09\u3001\u4e34\u65f6\u8d27\u67b6\u7684\u5bb9\u91cf M M \uff08 < N < N \uff09\u3001\u4ee5\u53ca\u9700\u8981\u5224\u65ad\u7684\u53d1\u8d27\u987a\u5e8f\u7684\u6570\u91cf K K \u3002 \u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u6570\u5b57\uff0c\u662f 1 \u5230 N N \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u5bf9\u5e94\u5de5\u5382\u7684\u53d1\u8d27\u987a\u5e8f\u3002 \u4e00\u884c\u4e2d\u7684\u6570\u5b57\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u53d1\u8d27\u987a\u5e8f\uff0c\u5982\u679c\u5de5\u4eba\u53ef\u4ee5\u6109\u5feb\u5b8c\u5de5\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa YES \uff1b\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 7 5 3 7 6 1 3 2 5 4 3 1 5 4 2 6 7 7 6 5 4 3 2 1 \u8f93\u51fa\u6837\u4f8b YES NO NO","title":"L2-032-\u5f69\u8679\u74f6"},{"location":"CCCC/L2-032-%E5%BD%A9%E8%99%B9%E7%93%B6/#l2-032-\u5f69\u8679\u74f6","text":"","title":"L2-032 \u5f69\u8679\u74f6"},{"location":"CCCC/L2-032-%E5%BD%A9%E8%99%B9%E7%93%B6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f69\u8679\u74f6\u7684\u5236\u4f5c\u8fc7\u7a0b\uff08\u5e76\u4e0d\uff09\u662f\u8fd9\u6837\u7684\uff1a\u5148\u628a\u4e00\u5927\u6279\u7a7a\u74f6\u94fa\u653e\u5728\u88c5\u586b\u573a\u5730\u4e0a\uff0c\u7136\u540e\u6309\u7167\u4e00\u5b9a\u7684\u987a\u5e8f\u5c06\u6bcf\u79cd\u989c\u8272\u7684\u5c0f\u7403\u5747\u5300\u6492\u5230\u8fd9\u6279\u74f6\u5b50\u91cc\u3002 \u5047\u8bbe\u5f69\u8679\u74f6\u91cc\u8981\u6309\u987a\u5e8f\u88c5 N \u79cd\u989c\u8272\u7684\u5c0f\u7403\uff08\u4e0d\u59a8\u5c06\u987a\u5e8f\u5c31\u7f16\u53f7\u4e3a 1 \u5230 N\uff09\u3002\u73b0\u5728\u5de5\u5382\u91cc\u6709\u6bcf\u79cd\u989c\u8272\u7684\u5c0f\u7403\u5404\u4e00\u7bb1\uff0c\u5de5\u4eba\u9700\u8981\u4e00\u7bb1\u4e00\u7bb1\u5730\u5c06\u5c0f\u7403\u4ece\u5de5\u5382\u91cc\u642c\u5230\u88c5\u586b\u573a\u5730\u3002\u5982\u679c\u642c\u6765\u7684\u8fd9\u7bb1\u5c0f\u7403\u6b63\u597d\u662f\u53ef\u4ee5\u88c5\u586b\u7684\u989c\u8272\uff0c\u5c31\u76f4\u63a5\u62c6\u7bb1\u88c5\u586b\uff1b\u5982\u679c\u4e0d\u662f\uff0c\u5c31\u628a\u7bb1\u5b50\u5148\u7801\u653e\u5728\u4e00\u4e2a\u4e34\u65f6\u8d27\u67b6\u4e0a\uff0c\u7801\u653e\u7684\u65b9\u6cd5\u5c31\u662f\u4e00\u7bb1\u4e00\u7bb1\u5806\u4e0a\u53bb\u3002\u5f53\u4e00\u79cd\u989c\u8272\u88c5\u586b\u5b8c\u4ee5\u540e\uff0c\u5148\u770b\u770b\u8d27\u67b6\u9876\u7aef\u7684\u4e00\u7bb1\u662f\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8981\u88c5\u586b\u7684\u989c\u8272\uff0c\u5982\u679c\u662f\u5c31\u53d6\u4e0b\u6765\u88c5\u586b\uff0c\u5426\u5219\u53bb\u5de5\u5382\u91cc\u518d\u642c\u4e00\u7bb1\u8fc7\u6765\u3002 \u5982\u679c\u5de5\u5382\u91cc\u53d1\u8d27\u7684\u987a\u5e8f\u6bd4\u8f83\u597d\uff0c\u5de5\u4eba\u5c31\u53ef\u4ee5\u987a\u5229\u5730\u5b8c\u6210\u88c5\u586b\u3002\u4f8b\u5982\u8981\u6309\u987a\u5e8f\u88c5\u586b 7 \u79cd\u989c\u8272\uff0c\u5de5\u5382\u6309\u7167 7\u30016\u30011\u30013\u30012\u30015\u30014 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5219\u5de5\u4eba\u5148\u62ff\u5230 7\u30016 \u4e24\u79cd\u4e0d\u80fd\u88c5\u586b\u7684\u989c\u8272\uff0c\u5c06\u5176\u6309\u7167 7 \u5728\u4e0b\u30016 \u5728\u4e0a\u7684\u987a\u5e8f\u5806\u5728\u8d27\u67b6\u4e0a\uff1b\u62ff\u5230 1 \u65f6\u53ef\u4ee5\u76f4\u63a5\u88c5\u586b\uff1b\u62ff\u5230 3 \u65f6\u53c8\u5f97\u4e34\u65f6\u7801\u653e\u5728 6 \u53f7\u989c\u8272\u7bb1\u4e0a\uff1b\u62ff\u5230 2 \u65f6\u53ef\u4ee5\u76f4\u63a5\u88c5\u586b\uff1b\u968f\u540e\u4ece\u8d27\u67b6\u9876\u53d6\u4e0b 3 \u8fdb\u884c\u88c5\u586b\uff1b\u7136\u540e\u62ff\u5230 5\uff0c\u4e34\u65f6\u7801\u653e\u5230 6 \u4e0a\u9762\uff1b\u6700\u540e\u53d6\u4e86 4 \u53f7\u989c\u8272\u76f4\u63a5\u88c5\u586b\uff1b\u5269\u4e0b\u7684\u5de5\u4f5c\u5c31\u662f\u987a\u5e8f\u4ece\u8d27\u67b6\u4e0a\u53d6\u4e0b 5\u30016\u30017 \u4f9d\u6b21\u88c5\u586b\u3002 \u4f46\u5982\u679c\u5de5\u5382\u6309\u7167 3\u30011\u30015\u30014\u30012\u30016\u30017 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5de5\u4eba\u5c31\u5fc5\u987b\u8981\u6124\u6012\u5730\u6298\u817e\u8d27\u67b6\u4e86\uff0c\u56e0\u4e3a\u88c5\u586b\u5b8c 2 \u53f7\u989c\u8272\u4ee5\u540e\uff0c\u4e0d\u628a\u8d27\u67b6\u4e0a\u7684\u591a\u4e2a\u7bb1\u5b50\u642c\u4e0b\u6765\u5c31\u62ff\u4e0d\u5230 3 \u53f7\u7bb1\uff0c\u5c31\u4e0d\u53ef\u80fd\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002 \u53e6\u5916\uff0c\u8d27\u67b6\u7684\u5bb9\u91cf\u6709\u9650\uff0c\u5982\u679c\u8981\u5806\u79ef\u7684\u8d27\u7269\u8d85\u8fc7\u5bb9\u91cf\uff0c\u5de5\u4eba\u4e5f\u6ca1\u529e\u6cd5\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002\u4f8b\u5982\u5de5\u5382\u6309\u7167 7\u30016\u30015\u30014\u30013\u30012\u30011 \u8fd9\u4e2a\u987a\u5e8f\u53d1\u8d27\uff0c\u5982\u679c\u8d27\u67b6\u591f\u9ad8\uff0c\u80fd\u7801\u653e 6 \u53ea\u7bb1\u5b50\uff0c\u90a3\u8fd8\u662f\u53ef\u4ee5\u987a\u5229\u5b8c\u5de5\u7684\uff1b\u4f46\u5982\u679c\u8d27\u67b6\u53ea\u80fd\u7801\u653e 5 \u53ea\u7bb1\u5b50\uff0c\u5de5\u4eba\u5c31\u53c8\u8981\u6124\u6012\u4e86\u2026\u2026 \u672c\u9898\u5c31\u8bf7\u4f60\u5224\u65ad\u4e00\u4e0b\uff0c\u5de5\u5382\u7684\u53d1\u8d27\u987a\u5e8f\u80fd\u5426\u8ba9\u5de5\u4eba\u987a\u5229\u5b8c\u6210\u4efb\u52a1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f\u5f69\u8679\u74f6\u7684\u989c\u8272\u6570\u91cf N N \uff08 1 < N \\le 10^3 1 < N \\le 10^3 \uff09\u3001\u4e34\u65f6\u8d27\u67b6\u7684\u5bb9\u91cf M M \uff08 < N < N \uff09\u3001\u4ee5\u53ca\u9700\u8981\u5224\u65ad\u7684\u53d1\u8d27\u987a\u5e8f\u7684\u6570\u91cf K K \u3002 \u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u6570\u5b57\uff0c\u662f 1 \u5230 N N \u7684\u4e00\u4e2a\u6392\u5217\uff0c\u5bf9\u5e94\u5de5\u5382\u7684\u53d1\u8d27\u987a\u5e8f\u3002 \u4e00\u884c\u4e2d\u7684\u6570\u5b57\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u53d1\u8d27\u987a\u5e8f\uff0c\u5982\u679c\u5de5\u4eba\u53ef\u4ee5\u6109\u5feb\u5b8c\u5de5\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa YES \uff1b\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 7 5 3 7 6 1 3 2 5 4 3 1 5 4 2 6 7 7 6 5 4 3 2 1 \u8f93\u51fa\u6837\u4f8b YES NO NO","title":"Statement"},{"location":"CCCC/L2-033-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/","text":"L2-033 \u7b80\u5355\u8ba1\u7b97\u5668 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u4e3a\u521d\u5b66\u6570\u636e\u7ed3\u6784\u7684\u5c0f\u4f19\u4f34\u8bbe\u8ba1\u4e00\u6b3e\u7b80\u5355\u7684\u5229\u7528\u5806\u6808\u6267\u884c\u7684\u8ba1\u7b97\u5668\u3002\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u8ba1\u7b97\u5668\u7531\u4e24\u4e2a\u5806\u6808\u7ec4\u6210\uff0c\u4e00\u4e2a\u5806\u6808 S_1 S_1 \u5b58\u653e\u6570\u5b57\uff0c\u53e6\u4e00\u4e2a\u5806\u6808 S_2 S_2 \u5b58\u653e\u8fd0\u7b97\u7b26\u3002\u8ba1\u7b97\u5668\u7684\u6700\u4e0b\u65b9\u6709\u4e00\u4e2a\u7b49\u53f7\u952e\uff0c\u6bcf\u6b21\u6309\u4e0b\u8fd9\u4e2a\u952e\uff0c\u8ba1\u7b97\u5668\u5c31\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a \u4ece S_1 S_1 \u4e2d\u5f39\u51fa\u4e24\u4e2a\u6570\u5b57\uff0c\u987a\u5e8f\u4e3a n_1 n_1 \u548c n_2 n_2 \uff1b \u4ece S_2 S_2 \u4e2d\u5f39\u51fa\u4e00\u4e2a\u8fd0\u7b97\u7b26 op\uff1b \u6267\u884c\u8ba1\u7b97 n_2 n_2 op n_1 n_1 \uff1b \u5c06\u5f97\u5230\u7684\u7ed3\u679c\u538b\u56de S_1 S_1 \u3002 \u76f4\u5230\u4e24\u4e2a\u5806\u6808\u90fd\u4e3a\u7a7a\u65f6\uff0c\u8ba1\u7b97\u7ed3\u675f\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c06\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^3 1 < N \\le 10^3 \uff09\uff0c\u4e3a S_1 S_1 \u4e2d\u6570\u5b57\u7684\u4e2a\u6570\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 100 \u7684\u6574\u6570\uff1b\u7b2c\u4e09\u884c\u7ed9\u51fa N-1 N-1 \u4e2a\u8fd0\u7b97\u7b26 \u2014\u2014 \u8fd9\u91cc\u4ec5\u8003\u8651 + \u3001 - \u3001 * \u3001 / \u8fd9\u56db\u79cd\u8fd0\u7b97\u3002\u4e00\u884c\u4e2d\u7684\u6570\u5b57\u548c\u7b26\u53f7\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5c06\u8f93\u5165\u7684\u6570\u5b57\u548c\u8fd0\u7b97\u7b26\u6309\u7ed9\u5b9a\u987a\u5e8f\u5206\u522b\u538b\u5165\u5806\u6808 S_1 S_1 \u548c S_2 S_2 \uff0c\u5c06\u6267\u884c\u8ba1\u7b97\u7684\u6700\u540e\u7ed3\u679c\u8f93\u51fa\u3002\u6ce8\u610f\u6240\u6709\u7684\u8ba1\u7b97\u90fd\u53ea\u53d6\u7ed3\u679c\u7684\u6574\u6570\u90e8\u5206\u3002\u9898\u76ee\u4fdd\u8bc1\u8ba1\u7b97\u7684\u4e2d\u95f4\u548c\u6700\u540e\u7ed3\u679c\u7684\u7edd\u5bf9\u503c\u90fd\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u5982\u679c\u6267\u884c\u9664\u6cd5\u65f6\u51fa\u73b0\u5206\u6bcd\u4e3a\u96f6\u7684\u975e\u6cd5\u64cd\u4f5c\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\uff1a ERROR: X/0 \uff0c\u5176\u4e2d X \u662f\u5f53\u65f6\u7684\u5206\u5b50\u3002\u7136\u540e\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 5 40 5 8 3 2 / * - + \u8f93\u51fa\u6837\u4f8b 1 2 \u8f93\u5165\u6837\u4f8b 2 5 2 5 8 4 4 * / - + \u8f93\u51fa\u6837\u4f8b 2 ERROR: 5/0 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using ll = long long ; const int N = 1e3 + 10 ; int n ; ll a [ N ]; string op [ N ]; int main () { cin >> n ; stack < ll > numS ; stack < string > opS ; for ( int i = 1 ; i <= n ; ++ i ) cin >> a [ i ], numS . push ( a [ i ]); for ( int i = 1 ; i < n ; ++ i ) { cin >> op [ i ]; opS . push ( op [ i ]); } while ( ! opS . empty ()) { string _op = opS . top (); opS . pop (); ll a = numS . top (); numS . pop (); ll b = numS . top (); numS . pop (); if ( _op == \"/\" && ! a ) { cout << \"ERROR: \" << b << \"/0 \\n \" ; return 0 ; } if ( _op == \"/\" ) { b /= a ; } else if ( _op == \"*\" ) { b *= a ; } else if ( _op == \"+\" ) { b += a ; } else { b -= a ; } numS . push ( b ); } cout << numS . top () << endl ; return 0 ; }","title":"L2-033-\u7b80\u5355\u8ba1\u7b97\u5668"},{"location":"CCCC/L2-033-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/#l2-033-\u7b80\u5355\u8ba1\u7b97\u5668","text":"","title":"L2-033 \u7b80\u5355\u8ba1\u7b97\u5668"},{"location":"CCCC/L2-033-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u4e3a\u521d\u5b66\u6570\u636e\u7ed3\u6784\u7684\u5c0f\u4f19\u4f34\u8bbe\u8ba1\u4e00\u6b3e\u7b80\u5355\u7684\u5229\u7528\u5806\u6808\u6267\u884c\u7684\u8ba1\u7b97\u5668\u3002\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u8ba1\u7b97\u5668\u7531\u4e24\u4e2a\u5806\u6808\u7ec4\u6210\uff0c\u4e00\u4e2a\u5806\u6808 S_1 S_1 \u5b58\u653e\u6570\u5b57\uff0c\u53e6\u4e00\u4e2a\u5806\u6808 S_2 S_2 \u5b58\u653e\u8fd0\u7b97\u7b26\u3002\u8ba1\u7b97\u5668\u7684\u6700\u4e0b\u65b9\u6709\u4e00\u4e2a\u7b49\u53f7\u952e\uff0c\u6bcf\u6b21\u6309\u4e0b\u8fd9\u4e2a\u952e\uff0c\u8ba1\u7b97\u5668\u5c31\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a \u4ece S_1 S_1 \u4e2d\u5f39\u51fa\u4e24\u4e2a\u6570\u5b57\uff0c\u987a\u5e8f\u4e3a n_1 n_1 \u548c n_2 n_2 \uff1b \u4ece S_2 S_2 \u4e2d\u5f39\u51fa\u4e00\u4e2a\u8fd0\u7b97\u7b26 op\uff1b \u6267\u884c\u8ba1\u7b97 n_2 n_2 op n_1 n_1 \uff1b \u5c06\u5f97\u5230\u7684\u7ed3\u679c\u538b\u56de S_1 S_1 \u3002 \u76f4\u5230\u4e24\u4e2a\u5806\u6808\u90fd\u4e3a\u7a7a\u65f6\uff0c\u8ba1\u7b97\u7ed3\u675f\uff0c\u6700\u540e\u7684\u7ed3\u679c\u5c06\u663e\u793a\u5728\u5c4f\u5e55\u4e0a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^3 1 < N \\le 10^3 \uff09\uff0c\u4e3a S_1 S_1 \u4e2d\u6570\u5b57\u7684\u4e2a\u6570\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 100 \u7684\u6574\u6570\uff1b\u7b2c\u4e09\u884c\u7ed9\u51fa N-1 N-1 \u4e2a\u8fd0\u7b97\u7b26 \u2014\u2014 \u8fd9\u91cc\u4ec5\u8003\u8651 + \u3001 - \u3001 * \u3001 / \u8fd9\u56db\u79cd\u8fd0\u7b97\u3002\u4e00\u884c\u4e2d\u7684\u6570\u5b57\u548c\u7b26\u53f7\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5c06\u8f93\u5165\u7684\u6570\u5b57\u548c\u8fd0\u7b97\u7b26\u6309\u7ed9\u5b9a\u987a\u5e8f\u5206\u522b\u538b\u5165\u5806\u6808 S_1 S_1 \u548c S_2 S_2 \uff0c\u5c06\u6267\u884c\u8ba1\u7b97\u7684\u6700\u540e\u7ed3\u679c\u8f93\u51fa\u3002\u6ce8\u610f\u6240\u6709\u7684\u8ba1\u7b97\u90fd\u53ea\u53d6\u7ed3\u679c\u7684\u6574\u6570\u90e8\u5206\u3002\u9898\u76ee\u4fdd\u8bc1\u8ba1\u7b97\u7684\u4e2d\u95f4\u548c\u6700\u540e\u7ed3\u679c\u7684\u7edd\u5bf9\u503c\u90fd\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u5982\u679c\u6267\u884c\u9664\u6cd5\u65f6\u51fa\u73b0\u5206\u6bcd\u4e3a\u96f6\u7684\u975e\u6cd5\u64cd\u4f5c\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\uff1a ERROR: X/0 \uff0c\u5176\u4e2d X \u662f\u5f53\u65f6\u7684\u5206\u5b50\u3002\u7136\u540e\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 5 40 5 8 3 2 / * - + \u8f93\u51fa\u6837\u4f8b 1 2 \u8f93\u5165\u6837\u4f8b 2 5 2 5 8 4 4 * / - + \u8f93\u51fa\u6837\u4f8b 2 ERROR: 5/0","title":"Statement"},{"location":"CCCC/L2-033-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using ll = long long ; const int N = 1e3 + 10 ; int n ; ll a [ N ]; string op [ N ]; int main () { cin >> n ; stack < ll > numS ; stack < string > opS ; for ( int i = 1 ; i <= n ; ++ i ) cin >> a [ i ], numS . push ( a [ i ]); for ( int i = 1 ; i < n ; ++ i ) { cin >> op [ i ]; opS . push ( op [ i ]); } while ( ! opS . empty ()) { string _op = opS . top (); opS . pop (); ll a = numS . top (); numS . pop (); ll b = numS . top (); numS . pop (); if ( _op == \"/\" && ! a ) { cout << \"ERROR: \" << b << \"/0 \\n \" ; return 0 ; } if ( _op == \"/\" ) { b /= a ; } else if ( _op == \"*\" ) { b *= a ; } else if ( _op == \"+\" ) { b += a ; } else { b -= a ; } numS . push ( b ); } cout << numS . top () << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L2-034-%E5%8F%A3%E7%BD%A9%E5%8F%91%E6%94%BE/","text":"L2-034 \u53e3\u7f69\u53d1\u653e Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e3a\u4e86\u6297\u51fb\u6765\u52bf\u6c79\u6c79\u7684 COVID19 \u65b0\u578b\u51a0\u72b6\u75c5\u6bd2\uff0c\u5168\u56fd\u5404\u5730\u5747\u542f\u52a8\u4e86\u5404\u9879\u63aa\u65bd\u63a7\u5236\u75ab\u60c5\u53d1\u5c55\uff0c\u5176\u4e2d\u4e00\u4e2a\u91cd\u8981\u7684\u73af\u8282\u662f\u53e3\u7f69\u7684\u53d1\u653e\u3002 \u67d0\u5e02\u51fa\u4e8e\u7ed9\u5e02\u6c11\u53d1\u653e\u53e3\u7f69\u7684\u9700\u8981\uff0c\u63a8\u51fa\u4e86\u4e00\u6b3e\u5c0f\u7a0b\u5e8f\u8ba9\u5e02\u6c11\u586b\u5199\u4fe1\u606f\uff0c\u65b9\u4fbf\u5de5\u4f5c\u7684\u5f00\u5c55\u3002\u5c0f\u7a0b\u5e8f\u6536\u96c6\u4e86\u5404\u79cd\u4fe1\u606f\uff0c\u5305\u62ec\u5e02\u6c11\u7684\u59d3\u540d\u3001\u8eab\u4efd\u8bc1\u3001\u8eab\u4f53\u60c5\u51b5\u3001\u63d0\u4ea4\u65f6\u95f4\u7b49\uff0c\u4f46\u56e0\u4e3a\u6570\u636e\u91cf\u592a\u5927\uff0c\u9700\u8981\u6839\u636e\u4e00\u5b9a\u89c4\u5219\u8fdb\u884c\u7b5b\u9009\u548c\u5904\u7406\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u6309\u7167\u7ed9\u5b9a\u89c4\u5219\u8f93\u51fa\u53e3\u7f69\u7684\u5bc4\u9001\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 D D \u548c P P \uff08 1 \\le D, P \\le 30 1 \\le D, P \\le 30 \uff09\uff0c\u8868\u793a\u6709 D D \u5929\u7684\u6570\u636e\uff0c\u5e02\u6c11\u4e24\u6b21\u83b7\u5f97\u53e3\u7f69\u7684\u65f6\u95f4\u81f3\u5c11\u9700\u8981\u95f4\u9694 P P \u5929\u3002 \u63a5\u4e0b\u6765 D D \u5757\u6570\u636e\uff0c\u6bcf\u5757\u7ed9\u51fa\u4e00\u5929\u7684\u7533\u8bf7\u4fe1\u606f\u3002\u7b2c i i \u5757\u6570\u636e\uff08 i=1, \\cdots , D i=1, \\cdots , D \uff09\u7684\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6574\u6570 T_i T_i \u548c S_i S_i \uff08 1 \\le T_i, S_i \\le 1000 1 \\le T_i, S_i \\le 1000 \uff09\uff0c\u8868\u793a\u5728\u7b2c i i \u5929\u6709 T_i T_i \u6761\u7533\u8bf7\uff0c\u603b\u5171\u6709 S_i S_i \u4e2a\u53e3\u7f69\u53d1\u653e\u540d\u989d\u3002\u968f\u540e T_i T_i \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u7533\u8bf7\u4fe1\u606f\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a \u59d3\u540d \u8eab\u4efd\u8bc1\u53f7 \u8eab\u4f53\u60c5\u51b5 \u63d0\u4ea4\u65f6\u95f4 \u7ed9\u5b9a\u6570\u636e\u7ea6\u675f\u5982\u4e0b\uff1a * \u59d3\u540d \u662f\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10 \u7684\u4e0d\u5305\u542b\u7a7a\u683c\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff1b * \u8eab\u4efd\u8bc1\u53f7 \u662f\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 20 \u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff1b * \u8eab\u4f53\u60c5\u51b5 \u662f 0 \u6216\u8005 1\uff0c0 \u8868\u793a\u81ea\u89c9\u826f\u597d\uff0c1 \u8868\u793a\u6709\u76f8\u5173\u75c7\u72b6\uff1b * \u63d0\u4ea4\u65f6\u95f4 \u662f hh:mm\uff0c\u4e3a24\u5c0f\u65f6\u65f6\u95f4\uff08\u7531 00:00 \u5230 23:59 \u3002\u4f8b\u5982 09:08\u3002\uff09\u3002\u6ce8\u610f\uff0c\u7ed9\u5b9a\u7684\u8bb0\u5f55\u7684\u63d0\u4ea4\u65f6\u95f4\u4e0d\u4e00\u5b9a\u6709\u5e8f\uff1b * \u8eab\u4efd\u8bc1\u53f7 \u5404\u4e0d\u76f8\u540c\uff0c\u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u88ab\u8ba4\u4e3a\u662f\u540c\u4e00\u4e2a\u4eba\uff0c\u6570\u636e\u4fdd\u8bc1\u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u59d3\u540d\u662f\u76f8\u540c\u7684\u3002 \u80fd\u53d1\u653e\u53e3\u7f69\u7684\u8bb0\u5f55\u8981\u6c42\u5982\u4e0b\uff1a * \u8eab\u4efd\u8bc1\u53f7 \u5fc5\u987b\u662f 18 \u4f4d\u7684 \u6570\u5b57 \uff08\u53ef\u4ee5\u5305\u542b\u524d\u5bfc0\uff09\uff1b * \u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u82e5\u5728\u7b2c i i \u5929\u7533\u8bf7\u6210\u529f\uff0c\u5219\u63a5\u4e0b\u6765\u7684 P P \u5929\u4e0d\u80fd\u518d\u6b21\u7533\u8bf7\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u82e5\u7b2c i i \u5929\u7533\u8bf7\u6210\u529f\uff0c\u5219\u7b49\u5230\u7b2c i + P + 1 i + P + 1 \u5929\u624d\u80fd\u518d\u6b21\u7533\u8bf7\uff1b * \u5728\u4e0a\u9762\u4e24\u6761\u90fd\u7b26\u5408\u7684\u60c5\u51b5\u4e0b\uff0c\u6309\u7167\u63d0\u4ea4\u65f6\u95f4\u7684\u5148\u540e\u987a\u5e8f\u53d1\u653e\uff0c\u76f4\u81f3\u5168\u90e8\u8bb0\u5f55\u5904\u7406\u5b8c\u6bd5\u6216 S_i S_i \u4e2a\u540d\u989d\u7528\u5b8c\u3002\u5982\u679c\u63d0\u4ea4\u65f6\u95f4\u76f8\u540c\uff0c\u5219\u6309\u7167\u5728\u5217\u8868\u4e2d\u51fa\u73b0\u7684\u5148\u540e\u987a\u5e8f\u51b3\u5b9a\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u5929\u7684\u7533\u8bf7\u8bb0\u5f55\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u4f4d\u5f97\u5230\u53e3\u7f69\u7684\u4eba\u7684\u59d3\u540d\u53ca\u8eab\u4efd\u8bc1\u53f7\uff0c\u7528\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\u3002\u987a\u5e8f\u6309\u7167\u53d1\u653e\u987a\u5e8f\u786e\u5b9a\u3002 \u5728\u8f93\u51fa\u5b8c\u53d1\u653e\u8bb0\u5f55\u540e\uff0c\u4f60\u8fd8\u9700\u8981\u8f93\u51fa\u6709\u5408\u6cd5\u8bb0\u5f55\u7684\u3001\u8eab\u4f53\u72b6\u51b5\u4e3a 1 \u7684\u7533\u8bf7\u4eba\u7684\u59d3\u540d\u53ca\u8eab\u4efd\u8bc1\u53f7\uff0c\u7528\u7a7a\u683c\u9694\u5f00\u3002\u987a\u5e8f\u6309\u7167\u7533\u8bf7\u8bb0\u5f55\u4e2d\u51fa\u73b0\u7684\u987a\u5e8f\u786e\u5b9a\uff0c\u540c\u4e00\u4e2a\u4eba\u53ea\u9700\u8981\u8f93\u51fa\u4e00\u6b21\u3002 \u8f93\u5165\u6837\u4f8b 4 2 5 3 A 123456789012345670 1 13:58 B 123456789012345671 0 13:58 C 12345678901234567 0 13:22 D 123456789012345672 0 03:24 C 123456789012345673 0 13:59 4 3 A 123456789012345670 1 13:58 E 123456789012345674 0 13:59 C 123456789012345673 0 13:59 F F 0 14:00 1 3 E 123456789012345674 1 13:58 1 1 A 123456789012345670 0 14:11 \u8f93\u51fa\u6837\u4f8b D 123456789012345672 A 123456789012345670 B 123456789012345671 E 123456789012345674 C 123456789012345673 A 123456789012345670 A 123456789012345670 E 123456789012345674 \u6837\u4f8b\u89e3\u91ca \u8f93\u51fa\u4e2d\uff0c\u7b2c\u4e00\u884c\u5230\u7b2c\u4e09\u884c\u662f\u7b2c\u4e00\u5929\u7684\u90e8\u5206\uff1b\u7b2c\u56db\u3001\u4e94\u884c\u662f\u7b2c\u4e8c\u5929\u7684\u90e8\u5206\uff1b\u7b2c\u4e09\u5929\u6ca1\u6709\u7b26\u5408\u8981\u6c42\u7684\u5e02\u6c11\uff1b\u7b2c\u516d\u884c\u662f\u7b2c\u56db\u5929\u7684\u90e8\u5206\u3002\u6700\u540e\u4e24\u884c\u6309\u7167\u51fa\u73b0\u987a\u5e8f\u8f93\u51fa\u4e86\u53ef\u80fd\u5b58\u5728\u8eab\u4f53\u4e0d\u9002\u7684\u4eba\u5458\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 ; bool ok ( string id ) { if ( id . size () != 18 ) return false ; for ( auto & c : id ) { if ( ! isdigit ( c )) return false ; } return true ; } struct node { string name , id , status ; int h , m , ix ; node () {} node ( string name , string id , string status , int h , int m , int ix ) : name ( name ), id ( id ), status ( status ), h ( h ), m ( m ), ix ( ix ) {} bool operator < ( const node & other ) const { if ( h != other . h ) return h < other . h ; if ( m != other . m ) return m < other . m ; return ix < other . ix ; } }; int main () { int D , P ; scanf ( \"%d%d\" , & D , & P ); map < string , string > mp ; map < string , int > last ; vector < string > bin ; for ( int i = 1 ; i <= D ; ++ i ) { int T , S ; cin >> T >> S ; vector < node > vec ; for ( int j = 1 ; j <= T ; ++ j ) { string name , _id , status ; cin >> name >> _id ; cin >> status ; int h , m ; scanf ( \"%02d:%02d\" , & h , & m ); if ( ok ( _id )) { if ( status == \"1\" ) { bin . push_back ( _id ); } mp [ _id ] = name ; vec . push_back ( node ( name , _id , status , h , m , j )); } } sort ( vec . begin (), vec . end ()); for ( auto & it : vec ) { if ( S > 0 && ( last . count ( it . id ) == 0 || last [ it . id ] + P < i )) { -- S ; last [ it . id ] = i ; cout << it . name << ' ' << it . id << \" \\n \" ; } } } map < string , int > uni ; for ( auto & it : bin ) { if ( uni . count ( it ) == 0 ) { cout << mp [ it ] << ' ' << it << \" \\n \" ; uni [ it ] = 1 ; } } return 0 ; }","title":"L2-034-\u53e3\u7f69\u53d1\u653e"},{"location":"CCCC/L2-034-%E5%8F%A3%E7%BD%A9%E5%8F%91%E6%94%BE/#l2-034-\u53e3\u7f69\u53d1\u653e","text":"","title":"L2-034 \u53e3\u7f69\u53d1\u653e"},{"location":"CCCC/L2-034-%E5%8F%A3%E7%BD%A9%E5%8F%91%E6%94%BE/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e3a\u4e86\u6297\u51fb\u6765\u52bf\u6c79\u6c79\u7684 COVID19 \u65b0\u578b\u51a0\u72b6\u75c5\u6bd2\uff0c\u5168\u56fd\u5404\u5730\u5747\u542f\u52a8\u4e86\u5404\u9879\u63aa\u65bd\u63a7\u5236\u75ab\u60c5\u53d1\u5c55\uff0c\u5176\u4e2d\u4e00\u4e2a\u91cd\u8981\u7684\u73af\u8282\u662f\u53e3\u7f69\u7684\u53d1\u653e\u3002 \u67d0\u5e02\u51fa\u4e8e\u7ed9\u5e02\u6c11\u53d1\u653e\u53e3\u7f69\u7684\u9700\u8981\uff0c\u63a8\u51fa\u4e86\u4e00\u6b3e\u5c0f\u7a0b\u5e8f\u8ba9\u5e02\u6c11\u586b\u5199\u4fe1\u606f\uff0c\u65b9\u4fbf\u5de5\u4f5c\u7684\u5f00\u5c55\u3002\u5c0f\u7a0b\u5e8f\u6536\u96c6\u4e86\u5404\u79cd\u4fe1\u606f\uff0c\u5305\u62ec\u5e02\u6c11\u7684\u59d3\u540d\u3001\u8eab\u4efd\u8bc1\u3001\u8eab\u4f53\u60c5\u51b5\u3001\u63d0\u4ea4\u65f6\u95f4\u7b49\uff0c\u4f46\u56e0\u4e3a\u6570\u636e\u91cf\u592a\u5927\uff0c\u9700\u8981\u6839\u636e\u4e00\u5b9a\u89c4\u5219\u8fdb\u884c\u7b5b\u9009\u548c\u5904\u7406\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u6309\u7167\u7ed9\u5b9a\u89c4\u5219\u8f93\u51fa\u53e3\u7f69\u7684\u5bc4\u9001\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 D D \u548c P P \uff08 1 \\le D, P \\le 30 1 \\le D, P \\le 30 \uff09\uff0c\u8868\u793a\u6709 D D \u5929\u7684\u6570\u636e\uff0c\u5e02\u6c11\u4e24\u6b21\u83b7\u5f97\u53e3\u7f69\u7684\u65f6\u95f4\u81f3\u5c11\u9700\u8981\u95f4\u9694 P P \u5929\u3002 \u63a5\u4e0b\u6765 D D \u5757\u6570\u636e\uff0c\u6bcf\u5757\u7ed9\u51fa\u4e00\u5929\u7684\u7533\u8bf7\u4fe1\u606f\u3002\u7b2c i i \u5757\u6570\u636e\uff08 i=1, \\cdots , D i=1, \\cdots , D \uff09\u7684\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6574\u6570 T_i T_i \u548c S_i S_i \uff08 1 \\le T_i, S_i \\le 1000 1 \\le T_i, S_i \\le 1000 \uff09\uff0c\u8868\u793a\u5728\u7b2c i i \u5929\u6709 T_i T_i \u6761\u7533\u8bf7\uff0c\u603b\u5171\u6709 S_i S_i \u4e2a\u53e3\u7f69\u53d1\u653e\u540d\u989d\u3002\u968f\u540e T_i T_i \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u7533\u8bf7\u4fe1\u606f\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a \u59d3\u540d \u8eab\u4efd\u8bc1\u53f7 \u8eab\u4f53\u60c5\u51b5 \u63d0\u4ea4\u65f6\u95f4 \u7ed9\u5b9a\u6570\u636e\u7ea6\u675f\u5982\u4e0b\uff1a * \u59d3\u540d \u662f\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10 \u7684\u4e0d\u5305\u542b\u7a7a\u683c\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff1b * \u8eab\u4efd\u8bc1\u53f7 \u662f\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 20 \u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff1b * \u8eab\u4f53\u60c5\u51b5 \u662f 0 \u6216\u8005 1\uff0c0 \u8868\u793a\u81ea\u89c9\u826f\u597d\uff0c1 \u8868\u793a\u6709\u76f8\u5173\u75c7\u72b6\uff1b * \u63d0\u4ea4\u65f6\u95f4 \u662f hh:mm\uff0c\u4e3a24\u5c0f\u65f6\u65f6\u95f4\uff08\u7531 00:00 \u5230 23:59 \u3002\u4f8b\u5982 09:08\u3002\uff09\u3002\u6ce8\u610f\uff0c\u7ed9\u5b9a\u7684\u8bb0\u5f55\u7684\u63d0\u4ea4\u65f6\u95f4\u4e0d\u4e00\u5b9a\u6709\u5e8f\uff1b * \u8eab\u4efd\u8bc1\u53f7 \u5404\u4e0d\u76f8\u540c\uff0c\u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u88ab\u8ba4\u4e3a\u662f\u540c\u4e00\u4e2a\u4eba\uff0c\u6570\u636e\u4fdd\u8bc1\u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u59d3\u540d\u662f\u76f8\u540c\u7684\u3002 \u80fd\u53d1\u653e\u53e3\u7f69\u7684\u8bb0\u5f55\u8981\u6c42\u5982\u4e0b\uff1a * \u8eab\u4efd\u8bc1\u53f7 \u5fc5\u987b\u662f 18 \u4f4d\u7684 \u6570\u5b57 \uff08\u53ef\u4ee5\u5305\u542b\u524d\u5bfc0\uff09\uff1b * \u540c\u4e00\u4e2a\u8eab\u4efd\u8bc1\u53f7\u82e5\u5728\u7b2c i i \u5929\u7533\u8bf7\u6210\u529f\uff0c\u5219\u63a5\u4e0b\u6765\u7684 P P \u5929\u4e0d\u80fd\u518d\u6b21\u7533\u8bf7\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u82e5\u7b2c i i \u5929\u7533\u8bf7\u6210\u529f\uff0c\u5219\u7b49\u5230\u7b2c i + P + 1 i + P + 1 \u5929\u624d\u80fd\u518d\u6b21\u7533\u8bf7\uff1b * \u5728\u4e0a\u9762\u4e24\u6761\u90fd\u7b26\u5408\u7684\u60c5\u51b5\u4e0b\uff0c\u6309\u7167\u63d0\u4ea4\u65f6\u95f4\u7684\u5148\u540e\u987a\u5e8f\u53d1\u653e\uff0c\u76f4\u81f3\u5168\u90e8\u8bb0\u5f55\u5904\u7406\u5b8c\u6bd5\u6216 S_i S_i \u4e2a\u540d\u989d\u7528\u5b8c\u3002\u5982\u679c\u63d0\u4ea4\u65f6\u95f4\u76f8\u540c\uff0c\u5219\u6309\u7167\u5728\u5217\u8868\u4e2d\u51fa\u73b0\u7684\u5148\u540e\u987a\u5e8f\u51b3\u5b9a\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e00\u5929\u7684\u7533\u8bf7\u8bb0\u5f55\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u4f4d\u5f97\u5230\u53e3\u7f69\u7684\u4eba\u7684\u59d3\u540d\u53ca\u8eab\u4efd\u8bc1\u53f7\uff0c\u7528\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\u3002\u987a\u5e8f\u6309\u7167\u53d1\u653e\u987a\u5e8f\u786e\u5b9a\u3002 \u5728\u8f93\u51fa\u5b8c\u53d1\u653e\u8bb0\u5f55\u540e\uff0c\u4f60\u8fd8\u9700\u8981\u8f93\u51fa\u6709\u5408\u6cd5\u8bb0\u5f55\u7684\u3001\u8eab\u4f53\u72b6\u51b5\u4e3a 1 \u7684\u7533\u8bf7\u4eba\u7684\u59d3\u540d\u53ca\u8eab\u4efd\u8bc1\u53f7\uff0c\u7528\u7a7a\u683c\u9694\u5f00\u3002\u987a\u5e8f\u6309\u7167\u7533\u8bf7\u8bb0\u5f55\u4e2d\u51fa\u73b0\u7684\u987a\u5e8f\u786e\u5b9a\uff0c\u540c\u4e00\u4e2a\u4eba\u53ea\u9700\u8981\u8f93\u51fa\u4e00\u6b21\u3002 \u8f93\u5165\u6837\u4f8b 4 2 5 3 A 123456789012345670 1 13:58 B 123456789012345671 0 13:58 C 12345678901234567 0 13:22 D 123456789012345672 0 03:24 C 123456789012345673 0 13:59 4 3 A 123456789012345670 1 13:58 E 123456789012345674 0 13:59 C 123456789012345673 0 13:59 F F 0 14:00 1 3 E 123456789012345674 1 13:58 1 1 A 123456789012345670 0 14:11 \u8f93\u51fa\u6837\u4f8b D 123456789012345672 A 123456789012345670 B 123456789012345671 E 123456789012345674 C 123456789012345673 A 123456789012345670 A 123456789012345670 E 123456789012345674 \u6837\u4f8b\u89e3\u91ca \u8f93\u51fa\u4e2d\uff0c\u7b2c\u4e00\u884c\u5230\u7b2c\u4e09\u884c\u662f\u7b2c\u4e00\u5929\u7684\u90e8\u5206\uff1b\u7b2c\u56db\u3001\u4e94\u884c\u662f\u7b2c\u4e8c\u5929\u7684\u90e8\u5206\uff1b\u7b2c\u4e09\u5929\u6ca1\u6709\u7b26\u5408\u8981\u6c42\u7684\u5e02\u6c11\uff1b\u7b2c\u516d\u884c\u662f\u7b2c\u56db\u5929\u7684\u90e8\u5206\u3002\u6700\u540e\u4e24\u884c\u6309\u7167\u51fa\u73b0\u987a\u5e8f\u8f93\u51fa\u4e86\u53ef\u80fd\u5b58\u5728\u8eab\u4f53\u4e0d\u9002\u7684\u4eba\u5458\u3002","title":"Statement"},{"location":"CCCC/L2-034-%E5%8F%A3%E7%BD%A9%E5%8F%91%E6%94%BE/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 ; bool ok ( string id ) { if ( id . size () != 18 ) return false ; for ( auto & c : id ) { if ( ! isdigit ( c )) return false ; } return true ; } struct node { string name , id , status ; int h , m , ix ; node () {} node ( string name , string id , string status , int h , int m , int ix ) : name ( name ), id ( id ), status ( status ), h ( h ), m ( m ), ix ( ix ) {} bool operator < ( const node & other ) const { if ( h != other . h ) return h < other . h ; if ( m != other . m ) return m < other . m ; return ix < other . ix ; } }; int main () { int D , P ; scanf ( \"%d%d\" , & D , & P ); map < string , string > mp ; map < string , int > last ; vector < string > bin ; for ( int i = 1 ; i <= D ; ++ i ) { int T , S ; cin >> T >> S ; vector < node > vec ; for ( int j = 1 ; j <= T ; ++ j ) { string name , _id , status ; cin >> name >> _id ; cin >> status ; int h , m ; scanf ( \"%02d:%02d\" , & h , & m ); if ( ok ( _id )) { if ( status == \"1\" ) { bin . push_back ( _id ); } mp [ _id ] = name ; vec . push_back ( node ( name , _id , status , h , m , j )); } } sort ( vec . begin (), vec . end ()); for ( auto & it : vec ) { if ( S > 0 && ( last . count ( it . id ) == 0 || last [ it . id ] + P < i )) { -- S ; last [ it . id ] = i ; cout << it . name << ' ' << it . id << \" \\n \" ; } } } map < string , int > uni ; for ( auto & it : bin ) { if ( uni . count ( it ) == 0 ) { cout << mp [ it ] << ' ' << it << \" \\n \" ; uni [ it ] = 1 ; } } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-035-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","text":"L2-035 \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u5982\u679c\u6bcf\u4e00\u4e2a\u5c42\u7684\u7ed3\u70b9\u6570\u90fd\u8fbe\u5230\u6700\u5927\u503c\uff0c\u5219\u8fd9\u4e2a\u4e8c\u53c9\u6811\u5c31\u662f \u5b8c\u7f8e\u4e8c\u53c9\u6811 \u3002\u5bf9\u4e8e\u6df1\u5ea6\u4e3a D D \u7684\uff0c\u6709 N N \u4e2a\u7ed3\u70b9\u7684\u4e8c\u53c9\u6811\uff0c\u82e5\u5176\u7ed3\u70b9\u5bf9\u5e94\u4e8e\u76f8\u540c\u6df1\u5ea6\u5b8c\u7f8e\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7684\u524d N N \u4e2a\u7ed3\u70b9\uff0c\u8fd9\u6837\u7684\u6811\u5c31\u662f \u5b8c\u5168\u4e8c\u53c9\u6811 \u3002 \u7ed9\u5b9a\u4e00\u68f5\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u7ed9\u51fa\u8fd9\u68f5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 30 \\le 30 \uff09\uff0c\u5373\u6811\u4e2d\u7ed3\u70b9\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u540e\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u4e3a N N \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\u3002\u540c\u4e00\u884c\u4e2d\u6240\u6709\u6570\u5b57\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6240\u6709\u6570\u5b57\u90fd\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 91 71 2 34 10 15 55 18 \u8f93\u51fa\u6837\u4f8b 18 34 55 71 2 10 15 91 Solution C++ #include <bits/stdc++.h> using namespace std ; constexpr int N = 1e2 + 10 ; int n , a [ N ], b [ N ]; void dfs ( int u ) { if ( u > n ) return ; dfs ( u << 1 ); dfs ( u * 2 + 1 ); b [ u ] = ++* b ; } int main () { cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> a [ i ]; } * b = 0 ; dfs ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cout << a [ b [ i ]] << \" \\n \" [ i == n ]; } return 0 ; }","title":"L2-035-\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"CCCC/L2-035-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#l2-035-\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386","text":"","title":"L2-035 \u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386"},{"location":"CCCC/L2-035-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u5982\u679c\u6bcf\u4e00\u4e2a\u5c42\u7684\u7ed3\u70b9\u6570\u90fd\u8fbe\u5230\u6700\u5927\u503c\uff0c\u5219\u8fd9\u4e2a\u4e8c\u53c9\u6811\u5c31\u662f \u5b8c\u7f8e\u4e8c\u53c9\u6811 \u3002\u5bf9\u4e8e\u6df1\u5ea6\u4e3a D D \u7684\uff0c\u6709 N N \u4e2a\u7ed3\u70b9\u7684\u4e8c\u53c9\u6811\uff0c\u82e5\u5176\u7ed3\u70b9\u5bf9\u5e94\u4e8e\u76f8\u540c\u6df1\u5ea6\u5b8c\u7f8e\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7684\u524d N N \u4e2a\u7ed3\u70b9\uff0c\u8fd9\u6837\u7684\u6811\u5c31\u662f \u5b8c\u5168\u4e8c\u53c9\u6811 \u3002 \u7ed9\u5b9a\u4e00\u68f5\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u540e\u5e8f\u904d\u5386\uff0c\u8bf7\u4f60\u7ed9\u51fa\u8fd9\u68f5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 30 \\le 30 \uff09\uff0c\u5373\u6811\u4e2d\u7ed3\u70b9\u4e2a\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u540e\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u4e3a N N \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\u3002\u540c\u4e00\u884c\u4e2d\u6240\u6709\u6570\u5b57\u90fd\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u6811\u7684\u5c42\u5e8f\u904d\u5386\u5e8f\u5217\u3002\u6240\u6709\u6570\u5b57\u90fd\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 91 71 2 34 10 15 55 18 \u8f93\u51fa\u6837\u4f8b 18 34 55 71 2 10 15 91","title":"Statement"},{"location":"CCCC/L2-035-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; constexpr int N = 1e2 + 10 ; int n , a [ N ], b [ N ]; void dfs ( int u ) { if ( u > n ) return ; dfs ( u << 1 ); dfs ( u * 2 + 1 ); b [ u ] = ++* b ; } int main () { cin >> n ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> a [ i ]; } * b = 0 ; dfs ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cout << a [ b [ i ]] << \" \\n \" [ i == n ]; } return 0 ; }","title":"Solution"},{"location":"CCCC/L2-036-%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5/","text":"L2-036 \u7f51\u7ea2\u70b9\u6253\u5361\u653b\u7565 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u65c5\u6e38\u666f\u70b9\uff0c\u5982\u679c\u88ab\u5e26\u706b\u4e86\u7684\u8bdd\uff0c\u5c31\u88ab\u79f0\u4e3a\u201c\u7f51\u7ea2\u70b9\u201d\u3002\u5927\u5bb6\u6765\u7f51\u7ea2\u70b9\u6e38\u73a9\uff0c\u4fd7\u79f0\u201c\u6253\u5361\u201d\u3002\u5728\u5404\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u7684\u5feb\uff08\u7701\uff09\u4e50\uff08\u94b1\uff09\u65b9\u6cd5\u79f0\u4e3a\u201c\u653b\u7565\u201d\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u4e00\u5927\u5806\u653b\u7565\u4e2d\uff0c\u627e\u51fa\u90a3\u4e2a\u80fd\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\u3001\u5e76\u4e14\u8def\u4e0a\u82b1\u8d39\u6700\u5c11\u7684\u653b\u7565\u3002 \u8f93\u5165\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a\u7f51\u7ea2\u70b9\u7684\u4e2a\u6570 N N \uff08 1 < N\\le 200 1 < N\\le 200 \uff09\u548c\u7f51\u7ea2\u70b9\u4e4b\u95f4\u901a\u8def\u7684\u6761\u6570 M M \u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u6709\u901a\u8def\u7684\u4e24\u4e2a\u7f51\u7ea2\u70b9\u3001\u4ee5\u53ca\u8fd9\u6761\u8def\u4e0a\u7684\u65c5\u884c\u82b1\u8d39\uff08\u4e3a\u6b63\u6574\u6570\uff09\uff0c\u683c\u5f0f\u4e3a\u201c\u7f51\u7ea2\u70b91 \u7f51\u7ea2\u70b92 \u8d39\u7528\u201d\uff0c\u5176\u4e2d\u7f51\u7ea2\u70b9\u4ece 1 \u5230 N N \u7f16\u53f7\uff1b\u540c\u65f6\u4e5f\u7ed9\u51fa\u4f60\u5bb6\u5230\u67d0\u4e9b\u7f51\u7ea2\u70b9\u7684\u82b1\u8d39\uff0c\u683c\u5f0f\u76f8\u540c\uff0c\u5176\u4e2d\u4f60\u5bb6\u7684\u7f16\u53f7\u56fa\u5b9a\u4e3a 0 \u3002 \u518d\u4e0b\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff0c\u662f\u5f85\u68c0\u9a8c\u7684\u653b\u7565\u7684\u6570\u91cf\u3002\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u5f85\u68c0\u653b\u7565\uff0c\u683c\u5f0f\u4e3a\uff1a n n V_1 V_1 V_2 V_2 \\cdots \\cdots V_n V_n \u5176\u4e2d n (\\le 200) n (\\le 200) \u662f\u653b\u7565\u4e2d\u7684\u7f51\u7ea2\u70b9\u6570\uff0c V_i V_i \u662f\u8def\u5f84\u4e0a\u7684\u7f51\u7ea2\u70b9\u7f16\u53f7\u3002\u8fd9\u91cc\u5047\u8bbe\u4f60\u4ece\u5bb6\u91cc\u51fa\u53d1\uff0c\u4ece V_1 V_1 \u5f00\u59cb\u6253\u5361\uff0c\u6700\u540e\u4ece V_n V_n \u56de\u5bb6\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u6ee1\u8db3\u8981\u6c42\u7684\u653b\u7565\u7684\u4e2a\u6570\u3002 \u5728\u7b2c\u4e8c\u884c\u4e2d\uff0c\u9996\u5148\u8f93\u51fa\u90a3\u4e2a\u80fd\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\u3001\u5e76\u4e14\u8def\u4e0a\u82b1\u8d39\u6700\u5c11\u7684\u653b\u7565\u7684\u5e8f\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u4e2a\u653b\u7565\u7684\u603b\u8def\u8d39\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u8fd9\u6837\u7684\u653b\u7565\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u5e8f\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u3002 \u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u6709\u6548\u653b\u7565\uff0c\u5e76\u4e14\u603b\u8def\u8d39\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u5165\u6837\u4f8b 6 13 0 5 2 6 2 2 6 0 1 3 4 2 1 5 2 2 5 1 3 1 1 4 1 2 1 6 1 6 3 2 1 2 1 4 5 3 2 0 2 7 6 5 1 4 3 6 2 6 5 2 1 6 3 4 8 6 2 1 6 3 4 5 2 3 2 1 5 6 6 1 3 4 5 2 7 6 2 1 3 4 5 2 6 5 2 1 4 3 6 \u8f93\u51fa\u6837\u4f8b 3 5 11 \u6837\u4f8b\u8bf4\u660e \u7b2c 2\u30013\u30014\u30016 \u6761\u90fd\u4e0d\u6ee1\u8db3\u653b\u7565\u7684\u57fa\u672c\u8981\u6c42\uff0c\u5373\u4e0d\u80fd\u505a\u5230\u4ece\u5bb6\u91cc\u51fa\u53d1\uff0c\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\uff0c\u4e14\u80fd\u56de\u5230\u5bb6\u91cc\u3002\u6240\u4ee5\u6ee1\u8db3\u6761\u4ef6\u7684\u653b\u7565\u6709 3 \u6761\u3002 \u7b2c 1 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u662f\uff1a(0->5) 2 + (5->1) 2 + (1->4) 2 + (4->3) 2 + (3->6) 2 + (6->2) 2 + (2->0) 2 = 14\uff1b \u7b2c 5 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u540c\u7406\u53ef\u7b97\u5f97\uff1a1 + 1 + 1 + 2 + 3 + 1 + 2 = 11\uff0c\u662f\u4e00\u6761\u66f4\u7701\u94b1\u7684\u653b\u7565\uff1b \u7b2c 7 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u540c\u7406\u53ef\u7b97\u5f97\uff1a2 + 1 + 1 + 2 + 2 + 2 + 1 = 11\uff0c\u4e0e\u7b2c 5 \u6761\u82b1\u8d39\u76f8\u540c\uff0c\u4f46\u5e8f\u53f7\u8f83\u5927\uff0c\u6240\u4ee5\u4e0d\u8f93\u51fa\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second const int N = 2e2 + 10 ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n , m , q , g [ N ][ N ]; ll get ( vector < int > vec ) { vec . push_back ( 0 ); int st = 0 ; ll res = 0 ; vector < int > vis ( n + 1 , 0 ); for ( auto & it : vec ) { if ( g [ st ][ it ] == INF ) return INFLL ; res += g [ st ][ it ]; st = it ; vis [ it ] ++ ; } for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ] != 1 ) return INFLL ; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; memset ( g , 0x3f , sizeof g ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { cin >> u >> v >> w ; g [ u ][ v ] = w ; g [ v ][ u ] = w ; } int num = 0 , ix = -1 ; ll Min = INFLL ; cin >> q ; for ( int i = 1 ; i <= q ; ++ i ) { int _n ; cin >> _n ; vector < int > vec ( _n ); for ( auto & it : vec ) cin >> it ; ll cost = get ( vec ); if ( cost < Min ) { Min = cost ; ix = i ; } if ( cost < INFLL ) { ++ num ; } } cout << num << endl ; cout << ix << ' ' << Min << endl ; return 0 ; }","title":"L2-036-\u7f51\u7ea2\u70b9\u6253\u5361\u653b\u7565"},{"location":"CCCC/L2-036-%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5/#l2-036-\u7f51\u7ea2\u70b9\u6253\u5361\u653b\u7565","text":"","title":"L2-036 \u7f51\u7ea2\u70b9\u6253\u5361\u653b\u7565"},{"location":"CCCC/L2-036-%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u65c5\u6e38\u666f\u70b9\uff0c\u5982\u679c\u88ab\u5e26\u706b\u4e86\u7684\u8bdd\uff0c\u5c31\u88ab\u79f0\u4e3a\u201c\u7f51\u7ea2\u70b9\u201d\u3002\u5927\u5bb6\u6765\u7f51\u7ea2\u70b9\u6e38\u73a9\uff0c\u4fd7\u79f0\u201c\u6253\u5361\u201d\u3002\u5728\u5404\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u7684\u5feb\uff08\u7701\uff09\u4e50\uff08\u94b1\uff09\u65b9\u6cd5\u79f0\u4e3a\u201c\u653b\u7565\u201d\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u4ece\u4e00\u5927\u5806\u653b\u7565\u4e2d\uff0c\u627e\u51fa\u90a3\u4e2a\u80fd\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\u3001\u5e76\u4e14\u8def\u4e0a\u82b1\u8d39\u6700\u5c11\u7684\u653b\u7565\u3002 \u8f93\u5165\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a\u7f51\u7ea2\u70b9\u7684\u4e2a\u6570 N N \uff08 1 < N\\le 200 1 < N\\le 200 \uff09\u548c\u7f51\u7ea2\u70b9\u4e4b\u95f4\u901a\u8def\u7684\u6761\u6570 M M \u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u6709\u901a\u8def\u7684\u4e24\u4e2a\u7f51\u7ea2\u70b9\u3001\u4ee5\u53ca\u8fd9\u6761\u8def\u4e0a\u7684\u65c5\u884c\u82b1\u8d39\uff08\u4e3a\u6b63\u6574\u6570\uff09\uff0c\u683c\u5f0f\u4e3a\u201c\u7f51\u7ea2\u70b91 \u7f51\u7ea2\u70b92 \u8d39\u7528\u201d\uff0c\u5176\u4e2d\u7f51\u7ea2\u70b9\u4ece 1 \u5230 N N \u7f16\u53f7\uff1b\u540c\u65f6\u4e5f\u7ed9\u51fa\u4f60\u5bb6\u5230\u67d0\u4e9b\u7f51\u7ea2\u70b9\u7684\u82b1\u8d39\uff0c\u683c\u5f0f\u76f8\u540c\uff0c\u5176\u4e2d\u4f60\u5bb6\u7684\u7f16\u53f7\u56fa\u5b9a\u4e3a 0 \u3002 \u518d\u4e0b\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff0c\u662f\u5f85\u68c0\u9a8c\u7684\u653b\u7565\u7684\u6570\u91cf\u3002\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6761\u5f85\u68c0\u653b\u7565\uff0c\u683c\u5f0f\u4e3a\uff1a n n V_1 V_1 V_2 V_2 \\cdots \\cdots V_n V_n \u5176\u4e2d n (\\le 200) n (\\le 200) \u662f\u653b\u7565\u4e2d\u7684\u7f51\u7ea2\u70b9\u6570\uff0c V_i V_i \u662f\u8def\u5f84\u4e0a\u7684\u7f51\u7ea2\u70b9\u7f16\u53f7\u3002\u8fd9\u91cc\u5047\u8bbe\u4f60\u4ece\u5bb6\u91cc\u51fa\u53d1\uff0c\u4ece V_1 V_1 \u5f00\u59cb\u6253\u5361\uff0c\u6700\u540e\u4ece V_n V_n \u56de\u5bb6\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u6ee1\u8db3\u8981\u6c42\u7684\u653b\u7565\u7684\u4e2a\u6570\u3002 \u5728\u7b2c\u4e8c\u884c\u4e2d\uff0c\u9996\u5148\u8f93\u51fa\u90a3\u4e2a\u80fd\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\u3001\u5e76\u4e14\u8def\u4e0a\u82b1\u8d39\u6700\u5c11\u7684\u653b\u7565\u7684\u5e8f\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u4e2a\u653b\u7565\u7684\u603b\u8def\u8d39\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u8fd9\u6837\u7684\u653b\u7565\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u5e8f\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u3002 \u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u5b58\u5728\u4e00\u4e2a\u6709\u6548\u653b\u7565\uff0c\u5e76\u4e14\u603b\u8def\u8d39\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u5165\u6837\u4f8b 6 13 0 5 2 6 2 2 6 0 1 3 4 2 1 5 2 2 5 1 3 1 1 4 1 2 1 6 1 6 3 2 1 2 1 4 5 3 2 0 2 7 6 5 1 4 3 6 2 6 5 2 1 6 3 4 8 6 2 1 6 3 4 5 2 3 2 1 5 6 6 1 3 4 5 2 7 6 2 1 3 4 5 2 6 5 2 1 4 3 6 \u8f93\u51fa\u6837\u4f8b 3 5 11 \u6837\u4f8b\u8bf4\u660e \u7b2c 2\u30013\u30014\u30016 \u6761\u90fd\u4e0d\u6ee1\u8db3\u653b\u7565\u7684\u57fa\u672c\u8981\u6c42\uff0c\u5373\u4e0d\u80fd\u505a\u5230\u4ece\u5bb6\u91cc\u51fa\u53d1\uff0c\u5728\u6bcf\u4e2a\u7f51\u7ea2\u70b9\u6253\u5361\u4ec5\u4e00\u6b21\uff0c\u4e14\u80fd\u56de\u5230\u5bb6\u91cc\u3002\u6240\u4ee5\u6ee1\u8db3\u6761\u4ef6\u7684\u653b\u7565\u6709 3 \u6761\u3002 \u7b2c 1 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u662f\uff1a(0->5) 2 + (5->1) 2 + (1->4) 2 + (4->3) 2 + (3->6) 2 + (6->2) 2 + (2->0) 2 = 14\uff1b \u7b2c 5 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u540c\u7406\u53ef\u7b97\u5f97\uff1a1 + 1 + 1 + 2 + 3 + 1 + 2 = 11\uff0c\u662f\u4e00\u6761\u66f4\u7701\u94b1\u7684\u653b\u7565\uff1b \u7b2c 7 \u6761\u653b\u7565\u7684\u603b\u8def\u8d39\u540c\u7406\u53ef\u7b97\u5f97\uff1a2 + 1 + 1 + 2 + 2 + 2 + 1 = 11\uff0c\u4e0e\u7b2c 5 \u6761\u82b1\u8d39\u76f8\u540c\uff0c\u4f46\u5e8f\u53f7\u8f83\u5927\uff0c\u6240\u4ee5\u4e0d\u8f93\u51fa\u3002","title":"Statement"},{"location":"CCCC/L2-036-%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = long double ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second const int N = 2e2 + 10 ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; int n , m , q , g [ N ][ N ]; ll get ( vector < int > vec ) { vec . push_back ( 0 ); int st = 0 ; ll res = 0 ; vector < int > vis ( n + 1 , 0 ); for ( auto & it : vec ) { if ( g [ st ][ it ] == INF ) return INFLL ; res += g [ st ][ it ]; st = it ; vis [ it ] ++ ; } for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ] != 1 ) return INFLL ; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; memset ( g , 0x3f , sizeof g ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { cin >> u >> v >> w ; g [ u ][ v ] = w ; g [ v ][ u ] = w ; } int num = 0 , ix = -1 ; ll Min = INFLL ; cin >> q ; for ( int i = 1 ; i <= q ; ++ i ) { int _n ; cin >> _n ; vector < int > vec ( _n ); for ( auto & it : vec ) cin >> it ; ll cost = get ( vec ); if ( cost < Min ) { Min = cost ; ix = i ; } if ( cost < INFLL ) { ++ num ; } } cout << num << endl ; cout << ix << ' ' << Min << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L2-037-%E5%8C%85%E8%A3%85%E6%9C%BA/","text":"L2-037 \u5305\u88c5\u673a Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u79cd\u81ea\u52a8\u5305\u88c5\u673a\u7684\u7ed3\u6784\u5982\u56fe 1 \u6240\u793a\u3002\u9996\u5148\u673a\u5668\u4e2d\u6709 N N \u6761\u8f68\u9053\uff0c\u653e\u7f6e\u4e86\u4e00\u4e9b\u7269\u54c1\u3002\u8f68\u9053\u4e0b\u9762\u6709\u4e00\u4e2a\u7b50\u3002\u5f53\u67d0\u6761\u8f68\u9053\u7684\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u6d3b\u585e\u5411\u5de6\u63a8\u52a8\uff0c\u5c06\u8f68\u9053\u5c3d\u5934\u7684\u4e00\u4ef6\u7269\u54c1\u63a8\u843d\u7b50\u4e2d\u3002\u5f53 0 \u53f7\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u673a\u68b0\u624b\u5c06\u6293\u53d6\u7b50\u9876\u90e8\u7684\u4e00\u4ef6\u7269\u54c1\uff0c\u653e\u5230\u6d41\u6c34\u7ebf\u4e0a\u3002\u56fe 2 \u663e\u793a\u4e86\u987a\u5e8f\u6309\u4e0b\u6309\u94ae 3\u30012\u30013\u30010\u30011\u30012\u30010 \u540e\u5305\u88c5\u673a\u7684\u72b6\u6001\u3002 \u56fe1 \u81ea\u52a8\u5305\u88c5\u673a\u7684\u7ed3\u6784 \u56fe 2 \u987a\u5e8f\u6309\u4e0b\u6309\u94ae 3\u30012\u30013\u30010\u30011\u30012\u30010 \u540e\u5305\u88c5\u673a\u7684\u72b6\u6001 \u4e00\u79cd\u7279\u6b8a\u60c5\u51b5\u662f\uff0c\u56e0\u4e3a\u7b50\u7684\u5bb9\u91cf\u662f\u6709\u9650\u7684\uff0c\u5f53\u7b50\u5df2\u7ecf\u6ee1\u4e86\uff0c\u4f46\u4ecd\u7136\u6709\u67d0\u6761\u8f68\u9053\u7684\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u7cfb\u7edf\u5e94\u5f3a\u5236\u542f\u52a8 0 \u53f7\u952e\uff0c\u5148\u4ece\u7b50\u91cc\u6293\u51fa\u4e00\u4ef6\u7269\u54c1\uff0c\u518d\u5c06\u5bf9\u5e94\u8f68\u9053\u7684\u7269\u54c1\u63a8\u843d\u3002\u6b64\u5916\uff0c\u5982\u679c\u8f68\u9053\u5df2\u7ecf\u7a7a\u4e86\uff0c\u518d\u6309\u5bf9\u5e94\u7684\u6309\u94ae\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u4e8b\uff1b\u540c\u6837\u7684\uff0c\u5982\u679c\u7b50\u662f\u7a7a\u7684\uff0c\u6309 0 \u53f7\u6309\u94ae\u4e5f\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u4e8b\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7cfb\u5217\u6309\u94ae\u64cd\u4f5c\uff0c\u8bf7\u4f60\u4f9d\u6b21\u5217\u51fa\u6d41\u6c34\u7ebf\u4e0a\u7684\u7269\u54c1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u3001 M M \uff08 \\le 1000 \\le 1000 \uff09\u548c S_{max} S_{max} \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u8f68\u9053\u7684\u6761\u6570\uff08\u4e8e\u662f\u8f68\u9053\u4ece 1 \u5230 N N \u7f16\u53f7\uff09\u3001\u6bcf\u6761\u8f68\u9053\u521d\u59cb\u653e\u7f6e\u7684\u7269\u54c1\u6570\u91cf\u3001\u4ee5\u53ca\u7b50\u7684\u6700\u5927\u5bb9\u91cf\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa M M \u4e2a\u82f1\u6587\u5927\u5199\u5b57\u6bcd\uff0c\u8868\u793a\u6bcf\u6761\u8f68\u9053\u7684\u521d\u59cb\u7269\u54c1\u6446\u653e\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u7cfb\u5217\u6570\u5b57\uff0c\u987a\u5e8f\u5bf9\u5e94\u88ab\u6309\u4e0b\u7684\u6309\u94ae\u7f16\u53f7\uff0c\u76f4\u5230 -1 -1 \u6807\u5fd7\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e2a\u6570\u5b57\u4e0d\u8981\u5904\u7406\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u4f1a\u53d6\u51fa\u4e00\u4ef6\u7269\u54c1\u653e\u5728\u6d41\u6c34\u7ebf\u4e0a\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u6d41\u6c34\u7ebf\u4e0a\u7684\u7269\u54c1\uff0c\u4e0d\u5f97\u6709\u4efb\u4f55\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 4 4 GPLT PATA OMSA 3 2 3 0 1 2 0 2 2 0 -1 \u8f93\u51fa\u6837\u4f8b MATA","title":"L2-037-\u5305\u88c5\u673a"},{"location":"CCCC/L2-037-%E5%8C%85%E8%A3%85%E6%9C%BA/#l2-037-\u5305\u88c5\u673a","text":"","title":"L2-037 \u5305\u88c5\u673a"},{"location":"CCCC/L2-037-%E5%8C%85%E8%A3%85%E6%9C%BA/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u79cd\u81ea\u52a8\u5305\u88c5\u673a\u7684\u7ed3\u6784\u5982\u56fe 1 \u6240\u793a\u3002\u9996\u5148\u673a\u5668\u4e2d\u6709 N N \u6761\u8f68\u9053\uff0c\u653e\u7f6e\u4e86\u4e00\u4e9b\u7269\u54c1\u3002\u8f68\u9053\u4e0b\u9762\u6709\u4e00\u4e2a\u7b50\u3002\u5f53\u67d0\u6761\u8f68\u9053\u7684\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u6d3b\u585e\u5411\u5de6\u63a8\u52a8\uff0c\u5c06\u8f68\u9053\u5c3d\u5934\u7684\u4e00\u4ef6\u7269\u54c1\u63a8\u843d\u7b50\u4e2d\u3002\u5f53 0 \u53f7\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u673a\u68b0\u624b\u5c06\u6293\u53d6\u7b50\u9876\u90e8\u7684\u4e00\u4ef6\u7269\u54c1\uff0c\u653e\u5230\u6d41\u6c34\u7ebf\u4e0a\u3002\u56fe 2 \u663e\u793a\u4e86\u987a\u5e8f\u6309\u4e0b\u6309\u94ae 3\u30012\u30013\u30010\u30011\u30012\u30010 \u540e\u5305\u88c5\u673a\u7684\u72b6\u6001\u3002 \u56fe1 \u81ea\u52a8\u5305\u88c5\u673a\u7684\u7ed3\u6784 \u56fe 2 \u987a\u5e8f\u6309\u4e0b\u6309\u94ae 3\u30012\u30013\u30010\u30011\u30012\u30010 \u540e\u5305\u88c5\u673a\u7684\u72b6\u6001 \u4e00\u79cd\u7279\u6b8a\u60c5\u51b5\u662f\uff0c\u56e0\u4e3a\u7b50\u7684\u5bb9\u91cf\u662f\u6709\u9650\u7684\uff0c\u5f53\u7b50\u5df2\u7ecf\u6ee1\u4e86\uff0c\u4f46\u4ecd\u7136\u6709\u67d0\u6761\u8f68\u9053\u7684\u6309\u94ae\u88ab\u6309\u4e0b\u65f6\uff0c\u7cfb\u7edf\u5e94\u5f3a\u5236\u542f\u52a8 0 \u53f7\u952e\uff0c\u5148\u4ece\u7b50\u91cc\u6293\u51fa\u4e00\u4ef6\u7269\u54c1\uff0c\u518d\u5c06\u5bf9\u5e94\u8f68\u9053\u7684\u7269\u54c1\u63a8\u843d\u3002\u6b64\u5916\uff0c\u5982\u679c\u8f68\u9053\u5df2\u7ecf\u7a7a\u4e86\uff0c\u518d\u6309\u5bf9\u5e94\u7684\u6309\u94ae\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u4e8b\uff1b\u540c\u6837\u7684\uff0c\u5982\u679c\u7b50\u662f\u7a7a\u7684\uff0c\u6309 0 \u53f7\u6309\u94ae\u4e5f\u4e0d\u4f1a\u53d1\u751f\u4efb\u4f55\u4e8b\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7cfb\u5217\u6309\u94ae\u64cd\u4f5c\uff0c\u8bf7\u4f60\u4f9d\u6b21\u5217\u51fa\u6d41\u6c34\u7ebf\u4e0a\u7684\u7269\u54c1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u3001 M M \uff08 \\le 1000 \\le 1000 \uff09\u548c S_{max} S_{max} \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u8f68\u9053\u7684\u6761\u6570\uff08\u4e8e\u662f\u8f68\u9053\u4ece 1 \u5230 N N \u7f16\u53f7\uff09\u3001\u6bcf\u6761\u8f68\u9053\u521d\u59cb\u653e\u7f6e\u7684\u7269\u54c1\u6570\u91cf\u3001\u4ee5\u53ca\u7b50\u7684\u6700\u5927\u5bb9\u91cf\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa M M \u4e2a\u82f1\u6587\u5927\u5199\u5b57\u6bcd\uff0c\u8868\u793a\u6bcf\u6761\u8f68\u9053\u7684\u521d\u59cb\u7269\u54c1\u6446\u653e\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u7cfb\u5217\u6570\u5b57\uff0c\u987a\u5e8f\u5bf9\u5e94\u88ab\u6309\u4e0b\u7684\u6309\u94ae\u7f16\u53f7\uff0c\u76f4\u5230 -1 -1 \u6807\u5fd7\u8f93\u5165\u7ed3\u675f\uff0c\u8fd9\u4e2a\u6570\u5b57\u4e0d\u8981\u5904\u7406\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u4f1a\u53d6\u51fa\u4e00\u4ef6\u7269\u54c1\u653e\u5728\u6d41\u6c34\u7ebf\u4e0a\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u6d41\u6c34\u7ebf\u4e0a\u7684\u7269\u54c1\uff0c\u4e0d\u5f97\u6709\u4efb\u4f55\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 4 4 GPLT PATA OMSA 3 2 3 0 1 2 0 2 2 0 -1 \u8f93\u51fa\u6837\u4f8b MATA","title":"Statement"},{"location":"CCCC/L2-038-%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/","text":"L2-038 \u75c5\u6bd2\u6eaf\u6e90 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u75c5\u6bd2\u5bb9\u6613\u53d1\u751f\u53d8\u5f02\u3002\u67d0\u79cd\u75c5\u6bd2\u53ef\u4ee5\u901a\u8fc7\u7a81\u53d8\u4ea7\u751f\u82e5\u5e72\u53d8\u5f02\u7684\u6bd2\u682a\uff0c\u800c\u8fd9\u4e9b\u53d8\u5f02\u7684\u75c5\u6bd2\u53c8\u53ef\u80fd\u88ab\u8bf1\u53d1\u7a81\u53d8\u4ea7\u751f\u7b2c\u4e8c\u4ee3\u53d8\u5f02\uff0c\u5982\u6b64\u7ee7\u7eed\u4e0d\u65ad\u53d8\u5316\u3002 \u73b0\u7ed9\u5b9a\u4e00\u4e9b\u75c5\u6bd2\u4e4b\u95f4\u7684\u53d8\u5f02\u5173\u7cfb\uff0c\u8981\u6c42\u4f60\u627e\u51fa\u5176\u4e2d\u6700\u957f\u7684\u4e00\u6761\u53d8\u5f02\u94fe\u3002 \u5728\u6b64\u5047\u8bbe\u7ed9\u51fa\u7684\u53d8\u5f02\u90fd\u662f\u7531\u7a81\u53d8\u5f15\u8d77\u7684\uff0c\u4e0d\u8003\u8651\u590d\u6742\u7684\u57fa\u56e0\u91cd\u7ec4\u53d8\u5f02\u95ee\u9898 \u2014\u2014 \u5373\u6bcf\u4e00\u79cd\u75c5\u6bd2\u90fd\u662f\u7531\u552f\u4e00\u7684\u4e00\u79cd\u75c5\u6bd2\u7a81\u53d8\u800c\u6765\uff0c\u5e76\u4e14\u4e0d\u5b58\u5728\u5faa\u73af\u53d8\u5f02\u7684\u60c5\u51b5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u75c5\u6bd2\u79cd\u7c7b\u7684\u603b\u6570\u3002\u4e8e\u662f\u6211\u4eec\u5c06\u6240\u6709\u75c5\u6bd2\u4ece 0 \u5230 N-1 N-1 \u8fdb\u884c\u7f16\u53f7\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u4e00\u79cd\u75c5\u6bd2\u7684\u53d8\u5f02\u60c5\u51b5\uff1a k \u53d8\u5f02\u682a1 \u2026\u2026 \u53d8\u5f02\u682ak \u5176\u4e2d k \u662f\u8be5\u75c5\u6bd2\u4ea7\u751f\u7684\u53d8\u5f02\u6bd2\u682a\u7684\u79cd\u7c7b\u6570\uff0c\u540e\u9762\u8ddf\u7740\u6bcf\u79cd\u53d8\u5f02\u682a\u7684\u7f16\u53f7\u3002\u7b2c i i \u884c\u5bf9\u5e94\u7f16\u53f7\u4e3a i i \u7684\u75c5\u6bd2\uff08 0\\le i <N 0\\le i <N \uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u75c5\u6bd2\u6e90\u5934\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u4ece\u6e90\u5934\u5f00\u59cb\u6700\u957f\u53d8\u5f02\u94fe\u7684\u957f\u5ea6\u3002 \u5728\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u4ece\u6e90\u5934\u5f00\u59cb\u6700\u957f\u7684\u4e00\u6761\u53d8\u5f02\u94fe\uff0c\u7f16\u53f7\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6700\u957f\u94fe\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u3002 \u6ce8\uff1a\u6211\u4eec\u79f0\u5e8f\u5217 { a_1, \\cdots , a_n a_1, \\cdots , a_n } \u6bd4\u5e8f\u5217 { b_1, \\cdots , b_n b_1, \\cdots , b_n } \u201c\u5c0f\u201d\uff0c\u5982\u679c\u5b58\u5728 1\\le k \\le n 1\\le k \\le n \u6ee1\u8db3 a_i = b_i a_i = b_i \u5bf9\u6240\u6709 i<k i<k \u6210\u7acb\uff0c\u4e14 a_k < b_k a_k < b_k \u3002 \u8f93\u5165\u6837\u4f8b 10 3 6 4 8 0 0 0 2 5 9 0 1 7 1 2 0 2 3 1 \u8f93\u51fa\u6837\u4f8b 4 0 4 9 1","title":"L2-038-\u75c5\u6bd2\u6eaf\u6e90"},{"location":"CCCC/L2-038-%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/#l2-038-\u75c5\u6bd2\u6eaf\u6e90","text":"","title":"L2-038 \u75c5\u6bd2\u6eaf\u6e90"},{"location":"CCCC/L2-038-%E7%97%85%E6%AF%92%E6%BA%AF%E6%BA%90/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u75c5\u6bd2\u5bb9\u6613\u53d1\u751f\u53d8\u5f02\u3002\u67d0\u79cd\u75c5\u6bd2\u53ef\u4ee5\u901a\u8fc7\u7a81\u53d8\u4ea7\u751f\u82e5\u5e72\u53d8\u5f02\u7684\u6bd2\u682a\uff0c\u800c\u8fd9\u4e9b\u53d8\u5f02\u7684\u75c5\u6bd2\u53c8\u53ef\u80fd\u88ab\u8bf1\u53d1\u7a81\u53d8\u4ea7\u751f\u7b2c\u4e8c\u4ee3\u53d8\u5f02\uff0c\u5982\u6b64\u7ee7\u7eed\u4e0d\u65ad\u53d8\u5316\u3002 \u73b0\u7ed9\u5b9a\u4e00\u4e9b\u75c5\u6bd2\u4e4b\u95f4\u7684\u53d8\u5f02\u5173\u7cfb\uff0c\u8981\u6c42\u4f60\u627e\u51fa\u5176\u4e2d\u6700\u957f\u7684\u4e00\u6761\u53d8\u5f02\u94fe\u3002 \u5728\u6b64\u5047\u8bbe\u7ed9\u51fa\u7684\u53d8\u5f02\u90fd\u662f\u7531\u7a81\u53d8\u5f15\u8d77\u7684\uff0c\u4e0d\u8003\u8651\u590d\u6742\u7684\u57fa\u56e0\u91cd\u7ec4\u53d8\u5f02\u95ee\u9898 \u2014\u2014 \u5373\u6bcf\u4e00\u79cd\u75c5\u6bd2\u90fd\u662f\u7531\u552f\u4e00\u7684\u4e00\u79cd\u75c5\u6bd2\u7a81\u53d8\u800c\u6765\uff0c\u5e76\u4e14\u4e0d\u5b58\u5728\u5faa\u73af\u53d8\u5f02\u7684\u60c5\u51b5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u75c5\u6bd2\u79cd\u7c7b\u7684\u603b\u6570\u3002\u4e8e\u662f\u6211\u4eec\u5c06\u6240\u6709\u75c5\u6bd2\u4ece 0 \u5230 N-1 N-1 \u8fdb\u884c\u7f16\u53f7\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u63cf\u8ff0\u4e00\u79cd\u75c5\u6bd2\u7684\u53d8\u5f02\u60c5\u51b5\uff1a k \u53d8\u5f02\u682a1 \u2026\u2026 \u53d8\u5f02\u682ak \u5176\u4e2d k \u662f\u8be5\u75c5\u6bd2\u4ea7\u751f\u7684\u53d8\u5f02\u6bd2\u682a\u7684\u79cd\u7c7b\u6570\uff0c\u540e\u9762\u8ddf\u7740\u6bcf\u79cd\u53d8\u5f02\u682a\u7684\u7f16\u53f7\u3002\u7b2c i i \u884c\u5bf9\u5e94\u7f16\u53f7\u4e3a i i \u7684\u75c5\u6bd2\uff08 0\\le i <N 0\\le i <N \uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u75c5\u6bd2\u6e90\u5934\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u8f93\u51fa\u4ece\u6e90\u5934\u5f00\u59cb\u6700\u957f\u53d8\u5f02\u94fe\u7684\u957f\u5ea6\u3002 \u5728\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u4ece\u6e90\u5934\u5f00\u59cb\u6700\u957f\u7684\u4e00\u6761\u53d8\u5f02\u94fe\uff0c\u7f16\u53f7\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6700\u957f\u94fe\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u3002 \u6ce8\uff1a\u6211\u4eec\u79f0\u5e8f\u5217 { a_1, \\cdots , a_n a_1, \\cdots , a_n } \u6bd4\u5e8f\u5217 { b_1, \\cdots , b_n b_1, \\cdots , b_n } \u201c\u5c0f\u201d\uff0c\u5982\u679c\u5b58\u5728 1\\le k \\le n 1\\le k \\le n \u6ee1\u8db3 a_i = b_i a_i = b_i \u5bf9\u6240\u6709 i<k i<k \u6210\u7acb\uff0c\u4e14 a_k < b_k a_k < b_k \u3002 \u8f93\u5165\u6837\u4f8b 10 3 6 4 8 0 0 0 2 5 9 0 1 7 1 2 0 2 3 1 \u8f93\u51fa\u6837\u4f8b 4 0 4 9 1","title":"Statement"},{"location":"CCCC/L2-039-%E6%B8%85%E7%82%B9%E4%BB%A3%E7%A0%81%E5%BA%93/","text":"L2-039 \u6e05\u70b9\u4ee3\u7801\u5e93 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0a\u56fe\u8f6c\u81ea\u65b0\u6d6a\u5fae\u535a\uff1a\u201c\u963f\u91cc\u4ee3\u7801\u5e93\u6709\u51e0\u4ebf\u884c\u4ee3\u7801\uff0c\u4f46\u5176\u4e2d\u6709\u5f88\u591a\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\uff0c\u6bd4\u5982\u5355\u5355\u5feb\u6392\u5c31\u88ab\u91cd\u5199\u4e86\u51e0\u767e\u904d\u3002\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u80fd\u591f\u5c06\u4ee3\u7801\u5e93\u4e2d\u6240\u6709\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\u627e\u51fa\u3002\u5404\u4f4d\u5927\u4f6c\u6709\u5565\u60f3\u6cd5\uff0c\u6211\u5f53\u65f6\u5c31\u61f5\u4e86\uff0c\u7136\u540e\u5c31\u6302\u4e86\u3002\u3002\u3002\u201d \u8fd9\u91cc\u6211\u4eec\u628a\u95ee\u9898\u7b80\u5316\u4e00\u4e0b\uff1a\u9996\u5148\u5047\u8bbe\u4e24\u4e2a\u529f\u80fd\u6a21\u5757\u5982\u679c\u63a5\u53d7\u540c\u6837\u7684\u8f93\u5165\uff0c\u603b\u662f\u7ed9\u51fa\u540c\u6837\u7684\u8f93\u51fa\uff0c\u5219\u5b83\u4eec\u5c31\u662f\u529f\u80fd\u91cd\u590d\u7684\uff1b\u5176\u6b21\u6211\u4eec\u628a\u6bcf\u4e2a\u6a21\u5757\u7684\u8f93\u51fa\u90fd\u7b80\u5316\u4e3a\u4e00\u4e2a\u6574\u6570\uff08\u5728 int \u8303\u56f4\u5185\uff09\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u7cfb\u5217\u8f93\u5165\uff0c\u68c0\u67e5\u6240\u6709\u529f\u80fd\u6a21\u5757\u7684\u5bf9\u5e94\u8f93\u51fa\uff0c\u4ece\u800c\u67e5\u51fa\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u8fd9\u4e2a\u7b80\u5316\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a N N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c M M \uff08 \\le 10^2 \\le 10^2 \uff09\uff0c\u5bf9\u5e94\u529f\u80fd\u6a21\u5757\u7684\u4e2a\u6570\u548c\u7cfb\u5217\u6d4b\u8bd5\u8f93\u5165\u7684\u4e2a\u6570\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u529f\u80fd\u6a21\u5757\u7684 M M \u4e2a\u5bf9\u5e94\u8f93\u51fa\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u4e0d\u540c\u529f\u80fd\u7684\u4e2a\u6570 K K \u3002\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u5177\u6709\u8fd9\u4e2a\u529f\u80fd\u7684\u6a21\u5757\u7684\u4e2a\u6570\uff0c\u4ee5\u53ca\u8fd9\u4e2a\u529f\u80fd\u7684\u5bf9\u5e94\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u8f93\u51fa\u9996\u5148\u6309\u6a21\u5757\u4e2a\u6570\u975e\u9012\u589e\u987a\u5e8f\uff0c\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6309\u8f93\u51fa\u5e8f\u5217\u7684\u9012\u589e\u5e8f\u7ed9\u51fa\u3002 \u6ce8\uff1a\u6240\u8c13\u6570\u5217 { A_1 A_1 , \u2026, A_M A_M } \u6bd4 { B_1 B_1 , \u2026, B_M B_M } \u5927\uff0c\u662f\u6307\u5b58\u5728 1\\le i <M 1\\le i <M \uff0c\u4f7f\u5f97 A_1=B_1 A_1=B_1 \uff0c\u2026\uff0c A_i=B_i A_i=B_i \u6210\u7acb\uff0c\u4e14 A_{i+1} > B_{i+1} A_{i+1} > B_{i+1} \u3002 \u8f93\u5165\u6837\u4f8b 7 3 35 28 74 -1 -1 22 28 74 35 -1 -1 22 11 66 0 35 28 74 35 28 74 \u8f93\u51fa\u6837\u4f8b 4 3 35 28 74 2 -1 -1 22 1 11 66 0 1 28 74 35","title":"L2-039-\u6e05\u70b9\u4ee3\u7801\u5e93"},{"location":"CCCC/L2-039-%E6%B8%85%E7%82%B9%E4%BB%A3%E7%A0%81%E5%BA%93/#l2-039-\u6e05\u70b9\u4ee3\u7801\u5e93","text":"","title":"L2-039 \u6e05\u70b9\u4ee3\u7801\u5e93"},{"location":"CCCC/L2-039-%E6%B8%85%E7%82%B9%E4%BB%A3%E7%A0%81%E5%BA%93/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0a\u56fe\u8f6c\u81ea\u65b0\u6d6a\u5fae\u535a\uff1a\u201c\u963f\u91cc\u4ee3\u7801\u5e93\u6709\u51e0\u4ebf\u884c\u4ee3\u7801\uff0c\u4f46\u5176\u4e2d\u6709\u5f88\u591a\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\uff0c\u6bd4\u5982\u5355\u5355\u5feb\u6392\u5c31\u88ab\u91cd\u5199\u4e86\u51e0\u767e\u904d\u3002\u8bf7\u8bbe\u8ba1\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u80fd\u591f\u5c06\u4ee3\u7801\u5e93\u4e2d\u6240\u6709\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\u627e\u51fa\u3002\u5404\u4f4d\u5927\u4f6c\u6709\u5565\u60f3\u6cd5\uff0c\u6211\u5f53\u65f6\u5c31\u61f5\u4e86\uff0c\u7136\u540e\u5c31\u6302\u4e86\u3002\u3002\u3002\u201d \u8fd9\u91cc\u6211\u4eec\u628a\u95ee\u9898\u7b80\u5316\u4e00\u4e0b\uff1a\u9996\u5148\u5047\u8bbe\u4e24\u4e2a\u529f\u80fd\u6a21\u5757\u5982\u679c\u63a5\u53d7\u540c\u6837\u7684\u8f93\u5165\uff0c\u603b\u662f\u7ed9\u51fa\u540c\u6837\u7684\u8f93\u51fa\uff0c\u5219\u5b83\u4eec\u5c31\u662f\u529f\u80fd\u91cd\u590d\u7684\uff1b\u5176\u6b21\u6211\u4eec\u628a\u6bcf\u4e2a\u6a21\u5757\u7684\u8f93\u51fa\u90fd\u7b80\u5316\u4e3a\u4e00\u4e2a\u6574\u6570\uff08\u5728 int \u8303\u56f4\u5185\uff09\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8bbe\u8ba1\u4e00\u7cfb\u5217\u8f93\u5165\uff0c\u68c0\u67e5\u6240\u6709\u529f\u80fd\u6a21\u5757\u7684\u5bf9\u5e94\u8f93\u51fa\uff0c\u4ece\u800c\u67e5\u51fa\u529f\u80fd\u91cd\u590d\u7684\u4ee3\u7801\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u8fd9\u4e2a\u7b80\u5316\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a N N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c M M \uff08 \\le 10^2 \\le 10^2 \uff09\uff0c\u5bf9\u5e94\u529f\u80fd\u6a21\u5757\u7684\u4e2a\u6570\u548c\u7cfb\u5217\u6d4b\u8bd5\u8f93\u5165\u7684\u4e2a\u6570\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u529f\u80fd\u6a21\u5757\u7684 M M \u4e2a\u5bf9\u5e94\u8f93\u51fa\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u4e0d\u540c\u529f\u80fd\u7684\u4e2a\u6570 K K \u3002\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u5177\u6709\u8fd9\u4e2a\u529f\u80fd\u7684\u6a21\u5757\u7684\u4e2a\u6570\uff0c\u4ee5\u53ca\u8fd9\u4e2a\u529f\u80fd\u7684\u5bf9\u5e94\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u8f93\u51fa\u9996\u5148\u6309\u6a21\u5757\u4e2a\u6570\u975e\u9012\u589e\u987a\u5e8f\uff0c\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6309\u8f93\u51fa\u5e8f\u5217\u7684\u9012\u589e\u5e8f\u7ed9\u51fa\u3002 \u6ce8\uff1a\u6240\u8c13\u6570\u5217 { A_1 A_1 , \u2026, A_M A_M } \u6bd4 { B_1 B_1 , \u2026, B_M B_M } \u5927\uff0c\u662f\u6307\u5b58\u5728 1\\le i <M 1\\le i <M \uff0c\u4f7f\u5f97 A_1=B_1 A_1=B_1 \uff0c\u2026\uff0c A_i=B_i A_i=B_i \u6210\u7acb\uff0c\u4e14 A_{i+1} > B_{i+1} A_{i+1} > B_{i+1} \u3002 \u8f93\u5165\u6837\u4f8b 7 3 35 28 74 -1 -1 22 28 74 35 -1 -1 22 11 66 0 35 28 74 35 28 74 \u8f93\u51fa\u6837\u4f8b 4 3 35 28 74 2 -1 -1 22 1 11 66 0 1 28 74 35","title":"Statement"},{"location":"CCCC/L2-040-%E5%93%B2%E5%93%B2%E6%89%93%E6%B8%B8%E6%88%8F/","text":"L2-040 \u54f2\u54f2\u6253\u6e38\u620f Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u54f2\u54f2\u662f\u4e00\u4f4d\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u3002\u6700\u8fd1\u4e00\u6b3e\u540d\u53eb\u300a\u8fbe\u8bfa\u8fbe\u8bfa\u300b\u7684\u65b0\u6e38\u620f\u521a\u521a\u4e0a\u5e02\uff0c\u54f2\u54f2\u81ea\u7136\u8981\u5feb\u901f\u653b\u7565\u6e38\u620f\uff0c\u5b88\u62a4\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u7684\u4e00\u5207\uff01 \u4e3a\u7b80\u5316\u6a21\u578b\uff0c\u6211\u4eec\u4e0d\u59a8\u5047\u8bbe\u6e38\u620f\u6709 N N \u4e2a\u5267\u60c5\u70b9\uff0c\u901a\u8fc7\u6e38\u620f\u91cc\u4e0d\u540c\u7684\u64cd\u4f5c\u6216\u9009\u62e9\u53ef\u4ee5\u4ece\u67d0\u4e2a\u5267\u60c5\u70b9\u53bb\u5f80\u53e6\u5916\u4e00\u4e2a\u5267\u60c5\u70b9\u3002\u6b64\u5916\uff0c\u6e38\u620f\u8fd8\u8bbe\u7f6e\u4e86\u4e00\u4e9b \u5b58\u6863 \uff0c\u5728\u67d0\u4e2a\u5267\u60c5\u70b9\u53ef\u4ee5\u5c06\u73a9\u5bb6\u7684\u6e38\u620f\u8fdb\u5ea6\u4fdd\u5b58\u5728\u4e00\u4e2a\u6863\u4f4d\u4e0a\uff0c\u8bfb\u53d6\u5b58\u6863\u540e\u53ef\u4ee5\u56de\u5230\u5267\u60c5\u70b9\uff0c\u91cd\u65b0\u8fdb\u884c\u64cd\u4f5c\u6216\u8005\u9009\u62e9\uff0c\u5230\u8fbe\u4e0d\u540c\u7684\u5267\u60c5\u70b9\u3002 \u4e3a\u4e86\u8ffd\u8e2a\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u54f2\u54f2\u7684\u653b\u7565\u8fdb\u5ea6\uff0c\u4f60\u6253\u7b97\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u5b8c\u6210\u8fd9\u4e2a\u5de5\u4f5c\u3002\u5047\u8bbe\u4f60\u5df2\u7ecf\u77e5\u9053\u4e86\u6e38\u620f\u7684\u5168\u90e8\u5267\u60c5\u70b9\u548c\u6d41\u7a0b\uff0c\u4ee5\u53ca\u54f2\u54f2\u7684\u6e38\u620f\u64cd\u4f5c\uff0c\u8bf7\u4f60\u8f93\u51fa\u54f2\u54f2\u7684\u6e38\u620f\u8fdb\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M ( 1\\le N , M \\le 10^5 1\\le N , M \\le 10^5 )\uff0c\u8868\u793a\u603b\u5171\u6709 N N \u4e2a\u5267\u60c5\u70b9\uff0c\u54f2\u54f2\u6709 M M \u4e2a\u6e38\u620f\u64cd\u4f5c\u3002 \u63a5\u4e0b\u6765\u7684 N N \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u4e2a\u5267\u60c5\u70b9\u7684\u53d1\u5c55\u8bbe\u5b9a\u3002\u7b2c i i \u884c\u7684\u7b2c\u4e00\u4e2a\u6570\u5b57\u662f K_i K_i \uff0c\u8868\u793a\u5267\u60c5\u70b9 i i \u901a\u8fc7\u4e00\u4e9b\u64cd\u4f5c\u6216\u9009\u62e9\u80fd\u53bb\u5f80\u4e0b\u9762 K_i K_i \u4e2a\u5267\u60c5\u70b9\uff1b\u63a5\u4e0b\u6765\u6709 K_i K_i \u4e2a\u6570\u5b57\uff0c\u7b2c k k \u4e2a\u6570\u5b57\u8868\u793a\u505a\u7b2c k k \u4e2a\u64cd\u4f5c\u6216\u9009\u62e9\u53ef\u4ee5\u53bb\u5f80\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u6700\u540e\u6709 M M \u884c\uff0c\u6bcf\u884c\u7b2c\u4e00\u4e2a\u6570\u5b57\u662f 0\u30011 \u6216 2\uff0c\u5206\u522b\u8868\u793a\uff1a 0 \u8868\u793a\u54f2\u54f2\u505a\u51fa\u4e86\u67d0\u4e2a\u64cd\u4f5c\u6216\u9009\u62e9\uff0c\u540e\u9762\u7d27\u63a5\u7740\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u54f2\u54f2\u5728\u5f53\u524d\u5267\u60c5\u70b9\u505a\u51fa\u4e86\u7b2c j j \u4e2a\u9009\u62e9\u3002\u6211\u4eec\u4fdd\u8bc1\u54f2\u54f2\u7684\u9009\u62e9\u6c38\u8fdc\u662f\u5408\u6cd5\u7684\u3002 1 \u8868\u793a\u54f2\u54f2\u8fdb\u884c\u4e86\u4e00\u6b21\u5b58\u6863\uff0c\u540e\u9762\u7d27\u63a5\u7740\u662f\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u5b58\u6863\u653e\u5728\u4e86\u7b2c j j \u4e2a\u6863\u4f4d\u4e0a\u3002 2 \u8868\u793a\u54f2\u54f2\u8fdb\u884c\u4e86\u4e00\u6b21\u8bfb\u53d6\u5b58\u6863\u7684\u64cd\u4f5c\uff0c\u540e\u9762\u7d27\u63a5\u7740\u662f\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u8bfb\u53d6\u4e86\u653e\u5728\u7b2c j j \u4e2a\u4f4d\u7f6e\u7684\u5b58\u6863\u3002 \u7ea6\u5b9a\uff1a\u6240\u6709\u64cd\u4f5c\u6216\u9009\u62e9\u4ee5\u53ca\u5267\u60c5\u70b9\u7f16\u53f7\u90fd\u4ece 1 \u53f7\u5f00\u59cb\u3002\u5b58\u6863\u7684\u6863\u4f4d\u4e0d\u8d85\u8fc7 100 \u4e2a\uff0c\u7f16\u53f7\u4e5f\u4ece 1 \u5f00\u59cb\u3002\u6e38\u620f\u9ed8\u8ba4\u4ece 1 \u53f7\u5267\u60c5\u70b9\u5f00\u59cb\u3002\u603b\u7684\u9009\u9879\u6570\uff08\u5373 \\sum K_i \\sum K_i \uff09\u4e0d\u8d85\u8fc7 10^6 10^6 \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e2a 1\uff08\u5373\u5b58\u6863\uff09\u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b58\u6863\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u6700\u540e\u4e00\u884c\u8f93\u51fa\u54f2\u54f2\u6700\u540e\u5230\u8fbe\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u8f93\u5165\u6837\u4f8b 10 11 3 2 3 4 1 6 3 4 7 5 1 3 1 9 2 3 5 3 1 8 5 1 9 2 8 10 0 1 1 0 3 0 1 1 2 0 2 0 2 2 2 0 3 0 1 1 1 0 2 \u8f93\u51fa\u6837\u4f8b 1 3 9 10 \u6837\u4f8b\u89e3\u91ca \u7b80\u5355\u7ed9\u51fa\u6837\u4f8b\u4e2d\u7ecf\u8fc7\u7684\u5267\u60c5\u70b9\u987a\u5e8f\uff1a 1 -> 4 -> 3 -> 7 -> 8 -> 3 -> 5 -> 9 -> 10\u3002 \u6863\u4f4d 1 \u5f00\u59cb\u5b58\u7684\u662f 1 \u53f7\u5267\u60c5\u70b9\uff1b\u6863\u4f4d 2 \u5b58\u7684\u662f 3 \u53f7\u5267\u60c5\u70b9\uff1b\u6863\u4f4d 1 \u540e\u6765\u53c8\u5b58\u4e86 9 \u53f7\u5267\u60c5\u70b9\u3002","title":"L2-040-\u54f2\u54f2\u6253\u6e38\u620f"},{"location":"CCCC/L2-040-%E5%93%B2%E5%93%B2%E6%89%93%E6%B8%B8%E6%88%8F/#l2-040-\u54f2\u54f2\u6253\u6e38\u620f","text":"","title":"L2-040 \u54f2\u54f2\u6253\u6e38\u620f"},{"location":"CCCC/L2-040-%E5%93%B2%E5%93%B2%E6%89%93%E6%B8%B8%E6%88%8F/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u54f2\u54f2\u662f\u4e00\u4f4d\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u3002\u6700\u8fd1\u4e00\u6b3e\u540d\u53eb\u300a\u8fbe\u8bfa\u8fbe\u8bfa\u300b\u7684\u65b0\u6e38\u620f\u521a\u521a\u4e0a\u5e02\uff0c\u54f2\u54f2\u81ea\u7136\u8981\u5feb\u901f\u653b\u7565\u6e38\u620f\uff0c\u5b88\u62a4\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u7684\u4e00\u5207\uff01 \u4e3a\u7b80\u5316\u6a21\u578b\uff0c\u6211\u4eec\u4e0d\u59a8\u5047\u8bbe\u6e38\u620f\u6709 N N \u4e2a\u5267\u60c5\u70b9\uff0c\u901a\u8fc7\u6e38\u620f\u91cc\u4e0d\u540c\u7684\u64cd\u4f5c\u6216\u9009\u62e9\u53ef\u4ee5\u4ece\u67d0\u4e2a\u5267\u60c5\u70b9\u53bb\u5f80\u53e6\u5916\u4e00\u4e2a\u5267\u60c5\u70b9\u3002\u6b64\u5916\uff0c\u6e38\u620f\u8fd8\u8bbe\u7f6e\u4e86\u4e00\u4e9b \u5b58\u6863 \uff0c\u5728\u67d0\u4e2a\u5267\u60c5\u70b9\u53ef\u4ee5\u5c06\u73a9\u5bb6\u7684\u6e38\u620f\u8fdb\u5ea6\u4fdd\u5b58\u5728\u4e00\u4e2a\u6863\u4f4d\u4e0a\uff0c\u8bfb\u53d6\u5b58\u6863\u540e\u53ef\u4ee5\u56de\u5230\u5267\u60c5\u70b9\uff0c\u91cd\u65b0\u8fdb\u884c\u64cd\u4f5c\u6216\u8005\u9009\u62e9\uff0c\u5230\u8fbe\u4e0d\u540c\u7684\u5267\u60c5\u70b9\u3002 \u4e3a\u4e86\u8ffd\u8e2a\u786c\u6838\u6e38\u620f\u73a9\u5bb6\u54f2\u54f2\u7684\u653b\u7565\u8fdb\u5ea6\uff0c\u4f60\u6253\u7b97\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u5b8c\u6210\u8fd9\u4e2a\u5de5\u4f5c\u3002\u5047\u8bbe\u4f60\u5df2\u7ecf\u77e5\u9053\u4e86\u6e38\u620f\u7684\u5168\u90e8\u5267\u60c5\u70b9\u548c\u6d41\u7a0b\uff0c\u4ee5\u53ca\u54f2\u54f2\u7684\u6e38\u620f\u64cd\u4f5c\uff0c\u8bf7\u4f60\u8f93\u51fa\u54f2\u54f2\u7684\u6e38\u620f\u8fdb\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M ( 1\\le N , M \\le 10^5 1\\le N , M \\le 10^5 )\uff0c\u8868\u793a\u603b\u5171\u6709 N N \u4e2a\u5267\u60c5\u70b9\uff0c\u54f2\u54f2\u6709 M M \u4e2a\u6e38\u620f\u64cd\u4f5c\u3002 \u63a5\u4e0b\u6765\u7684 N N \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u4e2a\u5267\u60c5\u70b9\u7684\u53d1\u5c55\u8bbe\u5b9a\u3002\u7b2c i i \u884c\u7684\u7b2c\u4e00\u4e2a\u6570\u5b57\u662f K_i K_i \uff0c\u8868\u793a\u5267\u60c5\u70b9 i i \u901a\u8fc7\u4e00\u4e9b\u64cd\u4f5c\u6216\u9009\u62e9\u80fd\u53bb\u5f80\u4e0b\u9762 K_i K_i \u4e2a\u5267\u60c5\u70b9\uff1b\u63a5\u4e0b\u6765\u6709 K_i K_i \u4e2a\u6570\u5b57\uff0c\u7b2c k k \u4e2a\u6570\u5b57\u8868\u793a\u505a\u7b2c k k \u4e2a\u64cd\u4f5c\u6216\u9009\u62e9\u53ef\u4ee5\u53bb\u5f80\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u6700\u540e\u6709 M M \u884c\uff0c\u6bcf\u884c\u7b2c\u4e00\u4e2a\u6570\u5b57\u662f 0\u30011 \u6216 2\uff0c\u5206\u522b\u8868\u793a\uff1a 0 \u8868\u793a\u54f2\u54f2\u505a\u51fa\u4e86\u67d0\u4e2a\u64cd\u4f5c\u6216\u9009\u62e9\uff0c\u540e\u9762\u7d27\u63a5\u7740\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u54f2\u54f2\u5728\u5f53\u524d\u5267\u60c5\u70b9\u505a\u51fa\u4e86\u7b2c j j \u4e2a\u9009\u62e9\u3002\u6211\u4eec\u4fdd\u8bc1\u54f2\u54f2\u7684\u9009\u62e9\u6c38\u8fdc\u662f\u5408\u6cd5\u7684\u3002 1 \u8868\u793a\u54f2\u54f2\u8fdb\u884c\u4e86\u4e00\u6b21\u5b58\u6863\uff0c\u540e\u9762\u7d27\u63a5\u7740\u662f\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u5b58\u6863\u653e\u5728\u4e86\u7b2c j j \u4e2a\u6863\u4f4d\u4e0a\u3002 2 \u8868\u793a\u54f2\u54f2\u8fdb\u884c\u4e86\u4e00\u6b21\u8bfb\u53d6\u5b58\u6863\u7684\u64cd\u4f5c\uff0c\u540e\u9762\u7d27\u63a5\u7740\u662f\u4e00\u4e2a\u6570\u5b57 j j \uff0c\u8868\u793a\u8bfb\u53d6\u4e86\u653e\u5728\u7b2c j j \u4e2a\u4f4d\u7f6e\u7684\u5b58\u6863\u3002 \u7ea6\u5b9a\uff1a\u6240\u6709\u64cd\u4f5c\u6216\u9009\u62e9\u4ee5\u53ca\u5267\u60c5\u70b9\u7f16\u53f7\u90fd\u4ece 1 \u53f7\u5f00\u59cb\u3002\u5b58\u6863\u7684\u6863\u4f4d\u4e0d\u8d85\u8fc7 100 \u4e2a\uff0c\u7f16\u53f7\u4e5f\u4ece 1 \u5f00\u59cb\u3002\u6e38\u620f\u9ed8\u8ba4\u4ece 1 \u53f7\u5267\u60c5\u70b9\u5f00\u59cb\u3002\u603b\u7684\u9009\u9879\u6570\uff08\u5373 \\sum K_i \\sum K_i \uff09\u4e0d\u8d85\u8fc7 10^6 10^6 \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u4e2a 1\uff08\u5373\u5b58\u6863\uff09\u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5b58\u6863\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u6700\u540e\u4e00\u884c\u8f93\u51fa\u54f2\u54f2\u6700\u540e\u5230\u8fbe\u7684\u5267\u60c5\u70b9\u7f16\u53f7\u3002 \u8f93\u5165\u6837\u4f8b 10 11 3 2 3 4 1 6 3 4 7 5 1 3 1 9 2 3 5 3 1 8 5 1 9 2 8 10 0 1 1 0 3 0 1 1 2 0 2 0 2 2 2 0 3 0 1 1 1 0 2 \u8f93\u51fa\u6837\u4f8b 1 3 9 10 \u6837\u4f8b\u89e3\u91ca \u7b80\u5355\u7ed9\u51fa\u6837\u4f8b\u4e2d\u7ecf\u8fc7\u7684\u5267\u60c5\u70b9\u987a\u5e8f\uff1a 1 -> 4 -> 3 -> 7 -> 8 -> 3 -> 5 -> 9 -> 10\u3002 \u6863\u4f4d 1 \u5f00\u59cb\u5b58\u7684\u662f 1 \u53f7\u5267\u60c5\u70b9\uff1b\u6863\u4f4d 2 \u5b58\u7684\u662f 3 \u53f7\u5267\u60c5\u70b9\uff1b\u6863\u4f4d 1 \u540e\u6765\u53c8\u5b58\u4e86 9 \u53f7\u5267\u60c5\u70b9\u3002","title":"Statement"},{"location":"CCCC/L3-001-%E5%87%91%E9%9B%B6%E9%92%B1/","text":"L3-001 \u51d1\u96f6\u94b1 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u97e9\u6885\u6885\u559c\u6b22\u6ee1\u5b87\u5b99\u5230\u5904\u901b\u8857\u3002\u73b0\u5728\u5979\u901b\u5230\u4e86\u4e00\u5bb6\u706b\u661f\u5e97\u91cc\uff0c\u53d1\u73b0\u8fd9\u5bb6\u5e97\u6709\u4e2a\u7279\u522b\u7684\u89c4\u77e9\uff1a\u4f60\u53ef\u4ee5\u7528\u4efb\u4f55\u661f\u7403\u7684\u786c\u5e01\u4ed8\u94b1\uff0c\u4f46\u662f\u7edd\u4e0d\u627e\u96f6\uff0c\u5f53\u7136\u4e5f\u4e0d\u80fd\u6b20\u503a\u3002\u97e9\u6885\u6885\u624b\u8fb9\u6709 10^4 10^4 \u679a\u6765\u81ea\u5404\u4e2a\u661f\u7403\u7684\u786c\u5e01\uff0c\u9700\u8981\u8bf7\u4f60\u5e2e\u5979\u76d8\u7b97\u4e00\u4e0b\uff0c\u662f\u5426\u53ef\u80fd\u7cbe\u786e\u51d1\u51fa\u8981\u4ed8\u7684\u6b3e\u989d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 10^4 \\le 10^4 \uff09\u662f\u786c\u5e01\u7684\u603b\u4e2a\u6570\uff0c M M \uff08 \\le 10^2 \\le 10^2 \uff09\u662f\u97e9\u6885\u6885\u8981\u4ed8\u7684\u6b3e\u989d\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u679a\u786c\u5e01\u7684\u6b63\u6574\u6570\u9762\u503c\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u786c\u5e01\u7684\u9762\u503c V_1 \\le V_2 \\le \\cdots \\le V_k V_1 \\le V_2 \\le \\cdots \\le V_k \uff0c\u6ee1\u8db3\u6761\u4ef6 V_1 + V_2 + ... + V_k = M V_1 + V_2 + ... + V_k = M \u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u3002\u82e5\u65e0\u89e3\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u6ce8\uff1a\u6211\u4eec\u8bf4\u5e8f\u5217{ A[1], A[2], \\cdots A[1], A[2], \\cdots }\u6bd4{ B[1], B[2], \\cdots B[1], B[2], \\cdots }\u201c\u5c0f\u201d\uff0c\u662f\u6307\u5b58\u5728 k \\ge 1 k \\ge 1 \u4f7f\u5f97 A[i]=B[i] A[i]=B[i] \u5bf9\u6240\u6709 i < k i < k \u6210\u7acb\uff0c\u5e76\u4e14 A[k] < B[k] A[k] < B[k] \u3002 \u8f93\u5165\u6837\u4f8b 1 8 9 5 9 8 7 2 3 4 1 \u8f93\u51fa\u6837\u4f8b 1 1 3 5 \u8f93\u5165\u6837\u4f8b 2 4 8 7 2 4 3 \u8f93\u51fa\u6837\u4f8b 2 No Solution Tutorial \u601d\u8def\uff1a dp[i][j] dp[i][j] \u8868\u793a\u524d i i \u4e2a\u786c\u5e01\u80fd\u5426\u51d1\u51fa j j \u5143\u94b1\uff0c\u8f6c\u79fb\u6709\uff1a \\begin{eqnarray*} dp[i][j] &= dp[i - 1][j - arr[i]] \\end{eqnarray*} \\begin{eqnarray*} dp[i][j] &= dp[i - 1][j - arr[i]] \\end{eqnarray*} \u6700\u540e\u8f93\u51fa\u7b54\u6848\u5e8f\u5217\u7684\u65f6\u5019\uff0c\u5148\u6392\u4e2a\u5e8f\uff0c\u7136\u540e\u6839\u636e\u5df2\u7ecf\u8f6c\u79fb\u597d\u7684 dp dp \u6570\u7ec4\u66b4\u641c\u5373\u53ef\u3002 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ], dp [ maxn ][ 105 ]; int n , m ; vector < int > v ; bool comp ( int x , int y ) { return x > y ; } bool in_range ( int x , int y ) { if ( x >= 0 && x < n && y > 0 && y <= m ) return true ; return false ; } void dfs ( int x , int y ) { if ( in_range ( x , y )) { if ( x == 0 && y == arr [ x ]) { v . push_back ( arr [ x ]); return ; } if ( dp [ x - 1 ][ y - arr [ x ]]) { v . push_back ( arr [ x ]); dfs ( x - 1 , y - arr [ x ]); } else dfs ( x - 1 , y ); } else return ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & arr [ i ]); sort ( arr , arr + n , comp ); memset ( dp , 0 , sizeof ( dp )); if ( arr [ 0 ] <= m ) dp [ 0 ][ arr [ 0 ]] = 1 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( arr [ i ] > j ) dp [ i ][ j ] = dp [ i - 1 ][ j ]; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i - 1 ][ j - arr [ i ]]); } } // for (int i = 0; i < n; i++) // { // for (int j = 0; j <= m; j++) // { // if (j) // printf(\" \"); // printf(\"%d\", dp[i][j]); // } // cout << endl; // } if ( dp [ n - 1 ][ m ]) { v . clear (); dfs ( n - 1 , m ); sort ( v . begin (), v . end ()); vector < int >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if ( it != v . begin ()) printf ( \" \" ); cout << ( * it ); } cout << endl ; } else printf ( \"No Solution \\n \" ); }","title":"L3-001-\u51d1\u96f6\u94b1"},{"location":"CCCC/L3-001-%E5%87%91%E9%9B%B6%E9%92%B1/#l3-001-\u51d1\u96f6\u94b1","text":"","title":"L3-001 \u51d1\u96f6\u94b1"},{"location":"CCCC/L3-001-%E5%87%91%E9%9B%B6%E9%92%B1/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u97e9\u6885\u6885\u559c\u6b22\u6ee1\u5b87\u5b99\u5230\u5904\u901b\u8857\u3002\u73b0\u5728\u5979\u901b\u5230\u4e86\u4e00\u5bb6\u706b\u661f\u5e97\u91cc\uff0c\u53d1\u73b0\u8fd9\u5bb6\u5e97\u6709\u4e2a\u7279\u522b\u7684\u89c4\u77e9\uff1a\u4f60\u53ef\u4ee5\u7528\u4efb\u4f55\u661f\u7403\u7684\u786c\u5e01\u4ed8\u94b1\uff0c\u4f46\u662f\u7edd\u4e0d\u627e\u96f6\uff0c\u5f53\u7136\u4e5f\u4e0d\u80fd\u6b20\u503a\u3002\u97e9\u6885\u6885\u624b\u8fb9\u6709 10^4 10^4 \u679a\u6765\u81ea\u5404\u4e2a\u661f\u7403\u7684\u786c\u5e01\uff0c\u9700\u8981\u8bf7\u4f60\u5e2e\u5979\u76d8\u7b97\u4e00\u4e0b\uff0c\u662f\u5426\u53ef\u80fd\u7cbe\u786e\u51d1\u51fa\u8981\u4ed8\u7684\u6b3e\u989d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 10^4 \\le 10^4 \uff09\u662f\u786c\u5e01\u7684\u603b\u4e2a\u6570\uff0c M M \uff08 \\le 10^2 \\le 10^2 \uff09\u662f\u97e9\u6885\u6885\u8981\u4ed8\u7684\u6b3e\u989d\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u679a\u786c\u5e01\u7684\u6b63\u6574\u6570\u9762\u503c\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u786c\u5e01\u7684\u9762\u503c V_1 \\le V_2 \\le \\cdots \\le V_k V_1 \\le V_2 \\le \\cdots \\le V_k \uff0c\u6ee1\u8db3\u6761\u4ef6 V_1 + V_2 + ... + V_k = M V_1 + V_2 + ... + V_k = M \u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u3002\u82e5\u65e0\u89e3\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u6ce8\uff1a\u6211\u4eec\u8bf4\u5e8f\u5217{ A[1], A[2], \\cdots A[1], A[2], \\cdots }\u6bd4{ B[1], B[2], \\cdots B[1], B[2], \\cdots }\u201c\u5c0f\u201d\uff0c\u662f\u6307\u5b58\u5728 k \\ge 1 k \\ge 1 \u4f7f\u5f97 A[i]=B[i] A[i]=B[i] \u5bf9\u6240\u6709 i < k i < k \u6210\u7acb\uff0c\u5e76\u4e14 A[k] < B[k] A[k] < B[k] \u3002 \u8f93\u5165\u6837\u4f8b 1 8 9 5 9 8 7 2 3 4 1 \u8f93\u51fa\u6837\u4f8b 1 1 3 5 \u8f93\u5165\u6837\u4f8b 2 4 8 7 2 4 3 \u8f93\u51fa\u6837\u4f8b 2 No Solution","title":"Statement"},{"location":"CCCC/L3-001-%E5%87%91%E9%9B%B6%E9%92%B1/#tutorial","text":"\u601d\u8def\uff1a dp[i][j] dp[i][j] \u8868\u793a\u524d i i \u4e2a\u786c\u5e01\u80fd\u5426\u51d1\u51fa j j \u5143\u94b1\uff0c\u8f6c\u79fb\u6709\uff1a \\begin{eqnarray*} dp[i][j] &= dp[i - 1][j - arr[i]] \\end{eqnarray*} \\begin{eqnarray*} dp[i][j] &= dp[i - 1][j - arr[i]] \\end{eqnarray*} \u6700\u540e\u8f93\u51fa\u7b54\u6848\u5e8f\u5217\u7684\u65f6\u5019\uff0c\u5148\u6392\u4e2a\u5e8f\uff0c\u7136\u540e\u6839\u636e\u5df2\u7ecf\u8f6c\u79fb\u597d\u7684 dp dp \u6570\u7ec4\u66b4\u641c\u5373\u53ef\u3002","title":"Tutorial"},{"location":"CCCC/L3-001-%E5%87%91%E9%9B%B6%E9%92%B1/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ], dp [ maxn ][ 105 ]; int n , m ; vector < int > v ; bool comp ( int x , int y ) { return x > y ; } bool in_range ( int x , int y ) { if ( x >= 0 && x < n && y > 0 && y <= m ) return true ; return false ; } void dfs ( int x , int y ) { if ( in_range ( x , y )) { if ( x == 0 && y == arr [ x ]) { v . push_back ( arr [ x ]); return ; } if ( dp [ x - 1 ][ y - arr [ x ]]) { v . push_back ( arr [ x ]); dfs ( x - 1 , y - arr [ x ]); } else dfs ( x - 1 , y ); } else return ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & arr [ i ]); sort ( arr , arr + n , comp ); memset ( dp , 0 , sizeof ( dp )); if ( arr [ 0 ] <= m ) dp [ 0 ][ arr [ 0 ]] = 1 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( arr [ i ] > j ) dp [ i ][ j ] = dp [ i - 1 ][ j ]; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i - 1 ][ j - arr [ i ]]); } } // for (int i = 0; i < n; i++) // { // for (int j = 0; j <= m; j++) // { // if (j) // printf(\" \"); // printf(\"%d\", dp[i][j]); // } // cout << endl; // } if ( dp [ n - 1 ][ m ]) { v . clear (); dfs ( n - 1 , m ); sort ( v . begin (), v . end ()); vector < int >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if ( it != v . begin ()) printf ( \" \" ); cout << ( * it ); } cout << endl ; } else printf ( \"No Solution \\n \" ); }","title":"Solution"},{"location":"CCCC/L3-002-%E7%89%B9%E6%AE%8A%E5%A0%86%E6%A0%88/","text":"L3-002 \u7279\u6b8a\u5806\u6808 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5806\u6808\u662f\u4e00\u79cd\u7ecf\u5178\u7684\u540e\u8fdb\u5148\u51fa\u7684\u7ebf\u6027\u7ed3\u6784\uff0c\u76f8\u5173\u7684\u64cd\u4f5c\u4e3b\u8981\u6709\u201c\u5165\u6808\u201d\uff08\u5728\u5806\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\uff09\u548c\u201c\u51fa\u6808\u201d\uff08\u5c06\u6808\u9876\u5143\u7d20\u8fd4\u56de\u5e76\u4ece\u5806\u6808\u4e2d\u5220\u9664\uff09\u3002\u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u9644\u52a0\u7684\u64cd\u4f5c\uff1a\u201c\u53d6\u4e2d\u503c\u201d\u2014\u2014\u5373\u8fd4\u56de\u6240\u6709\u5806\u6808\u4e2d\u5143\u7d20\u952e\u503c\u7684\u4e2d\u503c\u3002\u7ed9\u5b9a N \u4e2a\u5143\u7d20\uff0c\u5982\u679c N \u662f\u5076\u6570\uff0c\u5219\u4e2d\u503c\u5b9a\u4e49\u4e3a\u7b2c N/2 \u5c0f\u5143\uff1b\u82e5\u662f\u5947\u6570\uff0c\u5219\u4e3a\u7b2c (N+1)/2 \u5c0f\u5143\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7684\u7b2c\u4e00\u884c\u662f\u6b63\u6574\u6570 N\uff08 \\le 10^5 \\le 10^5 \uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u6307\u4ee4\uff0c\u4e3a\u4ee5\u4e0b 3 \u79cd\u4e4b\u4e00\uff1a Push key Pop PeekMedian \u5176\u4e2d key \u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff1b Push \u8868\u793a\u201c\u5165\u6808\u201d\uff1b Pop \u8868\u793a\u201c\u51fa\u6808\u201d\uff1b PeekMedian \u8868\u793a\u201c\u53d6\u4e2d\u503c\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a Push \u64cd\u4f5c\uff0c\u5c06 key \u63d2\u5165\u5806\u6808\uff0c\u65e0\u9700\u8f93\u51fa\uff1b\u5bf9\u6bcf\u4e2a Pop \u6216 PeekMedian \u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u7684\u8fd4\u56de\u503c\u3002\u82e5\u64cd\u4f5c\u975e\u6cd5\uff0c\u5219\u5bf9\u5e94\u8f93\u51fa Invalid \u3002 \u8f93\u5165\u6837\u4f8b 17 Pop PeekMedian Push 3 PeekMedian Push 2 PeekMedian Push 1 PeekMedian Pop Pop Push 5 Push 4 PeekMedian Pop Pop Pop Pop \u8f93\u51fa\u6837\u4f8b Invalid Invalid 3 2 2 1 2 4 4 5 3 Invalid Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define db double #define N 100010 int n ; int sta [ N ], top ; namespace SEG { int a [ N << 2 ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { a [ id ] += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } int query ( int id , int l , int r , int k ) { if ( l == r ) return l ; int mid = ( l + r ) >> 1 ; if ( a [ id << 1 ] >= k ) return query ( id << 1 , l , mid , k ); else return query ( id << 1 | 1 , mid + 1 , r , k - a [ id << 1 ]); } } // namespace SEG void out () { puts ( \"Invalid\" ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { char op [ 10 ]; top = 0 ; SEG :: init (); int x = 100000 ; int d ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , op ); if ( op [ 1 ] == 'o' ) { if ( top == 0 ) out (); else { printf ( \"%d \\n \" , sta [ top ]); SEG :: update ( 1 , 1 , x , sta [ top ], -1 ); top -- ; } } else if ( op [ 1 ] == 'u' ) { scanf ( \"%d\" , & d ); sta [ ++ top ] = d ; SEG :: update ( 1 , 1 , x , d , 1 ); } else { if ( top == 0 ) out (); else printf ( \"%d \\n \" , SEG :: query ( 1 , 1 , x , ( top + 1 ) / 2 )); } } } return 0 ; }","title":"L3-002-\u7279\u6b8a\u5806\u6808"},{"location":"CCCC/L3-002-%E7%89%B9%E6%AE%8A%E5%A0%86%E6%A0%88/#l3-002-\u7279\u6b8a\u5806\u6808","text":"","title":"L3-002 \u7279\u6b8a\u5806\u6808"},{"location":"CCCC/L3-002-%E7%89%B9%E6%AE%8A%E5%A0%86%E6%A0%88/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5806\u6808\u662f\u4e00\u79cd\u7ecf\u5178\u7684\u540e\u8fdb\u5148\u51fa\u7684\u7ebf\u6027\u7ed3\u6784\uff0c\u76f8\u5173\u7684\u64cd\u4f5c\u4e3b\u8981\u6709\u201c\u5165\u6808\u201d\uff08\u5728\u5806\u6808\u9876\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\uff09\u548c\u201c\u51fa\u6808\u201d\uff08\u5c06\u6808\u9876\u5143\u7d20\u8fd4\u56de\u5e76\u4ece\u5806\u6808\u4e2d\u5220\u9664\uff09\u3002\u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u53e6\u4e00\u4e2a\u9644\u52a0\u7684\u64cd\u4f5c\uff1a\u201c\u53d6\u4e2d\u503c\u201d\u2014\u2014\u5373\u8fd4\u56de\u6240\u6709\u5806\u6808\u4e2d\u5143\u7d20\u952e\u503c\u7684\u4e2d\u503c\u3002\u7ed9\u5b9a N \u4e2a\u5143\u7d20\uff0c\u5982\u679c N \u662f\u5076\u6570\uff0c\u5219\u4e2d\u503c\u5b9a\u4e49\u4e3a\u7b2c N/2 \u5c0f\u5143\uff1b\u82e5\u662f\u5947\u6570\uff0c\u5219\u4e3a\u7b2c (N+1)/2 \u5c0f\u5143\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7684\u7b2c\u4e00\u884c\u662f\u6b63\u6574\u6570 N\uff08 \\le 10^5 \\le 10^5 \uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u6307\u4ee4\uff0c\u4e3a\u4ee5\u4e0b 3 \u79cd\u4e4b\u4e00\uff1a Push key Pop PeekMedian \u5176\u4e2d key \u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff1b Push \u8868\u793a\u201c\u5165\u6808\u201d\uff1b Pop \u8868\u793a\u201c\u51fa\u6808\u201d\uff1b PeekMedian \u8868\u793a\u201c\u53d6\u4e2d\u503c\u201d\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a Push \u64cd\u4f5c\uff0c\u5c06 key \u63d2\u5165\u5806\u6808\uff0c\u65e0\u9700\u8f93\u51fa\uff1b\u5bf9\u6bcf\u4e2a Pop \u6216 PeekMedian \u64cd\u4f5c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u76f8\u5e94\u7684\u8fd4\u56de\u503c\u3002\u82e5\u64cd\u4f5c\u975e\u6cd5\uff0c\u5219\u5bf9\u5e94\u8f93\u51fa Invalid \u3002 \u8f93\u5165\u6837\u4f8b 17 Pop PeekMedian Push 3 PeekMedian Push 2 PeekMedian Push 1 PeekMedian Pop Pop Push 5 Push 4 PeekMedian Pop Pop Pop Pop \u8f93\u51fa\u6837\u4f8b Invalid Invalid 3 2 2 1 2 4 4 5 3 Invalid","title":"Statement"},{"location":"CCCC/L3-002-%E7%89%B9%E6%AE%8A%E5%A0%86%E6%A0%88/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define db double #define N 100010 int n ; int sta [ N ], top ; namespace SEG { int a [ N << 2 ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { a [ id ] += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } int query ( int id , int l , int r , int k ) { if ( l == r ) return l ; int mid = ( l + r ) >> 1 ; if ( a [ id << 1 ] >= k ) return query ( id << 1 , l , mid , k ); else return query ( id << 1 | 1 , mid + 1 , r , k - a [ id << 1 ]); } } // namespace SEG void out () { puts ( \"Invalid\" ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { char op [ 10 ]; top = 0 ; SEG :: init (); int x = 100000 ; int d ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , op ); if ( op [ 1 ] == 'o' ) { if ( top == 0 ) out (); else { printf ( \"%d \\n \" , sta [ top ]); SEG :: update ( 1 , 1 , x , sta [ top ], -1 ); top -- ; } } else if ( op [ 1 ] == 'u' ) { scanf ( \"%d\" , & d ); sta [ ++ top ] = d ; SEG :: update ( 1 , 1 , x , d , 1 ); } else { if ( top == 0 ) out (); else printf ( \"%d \\n \" , SEG :: query ( 1 , 1 , x , ( top + 1 ) / 2 )); } } } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-003-%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4/","text":"L3-003 \u793e\u4ea4\u96c6\u7fa4 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u5728\u793e\u4ea4\u7f51\u7edc\u5e73\u53f0\u6ce8\u518c\u65f6\uff0c\u4e00\u822c\u603b\u662f\u88ab\u8981\u6c42\u586b\u5199\u4f60\u7684\u4e2a\u4eba\u5174\u8da3\u7231\u597d\uff0c\u4ee5\u4fbf\u627e\u5230\u5177\u6709\u76f8\u540c\u5174\u8da3\u7231\u597d\u7684\u6f5c\u5728\u7684\u670b\u53cb\u3002\u4e00\u4e2a\u201c\u793e\u4ea4\u96c6\u7fa4\u201d\u662f\u6307\u90e8\u5206\u5174\u8da3\u7231\u597d\u76f8\u540c\u7684\u4eba\u7684\u96c6\u5408\u3002\u4f60\u9700\u8981\u627e\u51fa\u6240\u6709\u7684\u793e\u4ea4\u96c6\u7fa4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u793e\u4ea4\u7f51\u7edc\u5e73\u53f0\u6ce8\u518c\u7684\u6240\u6709\u7528\u6237\u7684\u4eba\u6570\u3002\u4e8e\u662f\u8fd9\u4e9b\u4eba\u4ece 1 \u5230 N \u7f16\u53f7\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u5174\u8da3\u7231\u597d\u5217\u8868\uff1a K_i K_i : h_i[1] h_i[1] h_i[2] h_i[2] \u2026 h_i[K_i] h_i[K_i] \u5176\u4e2d K_i (>0) K_i (>0) \u662f\u5174\u8da3\u7231\u597d\u7684\u4e2a\u6570\uff0c h_i[j] h_i[j] \u662f\u7b2c j j \u4e2a\u5174\u8da3\u7231\u597d\u7684\u7f16\u53f7\uff0c\u4e3a\u533a\u95f4 [1, 1000] \u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e0d\u540c\u7684\u793e\u4ea4\u96c6\u7fa4\u7684\u4e2a\u6570\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u6309\u975e\u589e\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u96c6\u7fa4\u4e2d\u7684\u4eba\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 3: 2 7 10 1: 4 2: 5 3 1: 4 1: 3 1: 4 4: 6 8 1 5 1: 4 \u8f93\u51fa\u6837\u4f8b 3 4 3 1 Tutorial \u601d\u8def\uff1a \u5e76\u67e5\u96c6 \u7528\u4e00\u4e2a cou[i] cou[i] \u6765\u8868\u793a\u7b2c i i \u95e8\u8bfe\u7a0b\u7684\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba\u3002 \u5408\u5e76\u7684\u65f6\u5019\uff1a \u5224\u65ad cou[i] cou[i] \u5982\u679c cou[i] cou[i] \u5b58\u5728\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba, \u90a3\u4e48\u5c06\u8fd9\u4e24\u4eba join \u8d77\u6765 \u5982\u679c\u4e0d\u5b58\u5728, \u90a3\u4e48\u8fd9\u95e8\u8bfe\u7a0b\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba\u5c31\u662f\u8fd9\u4e2a\u4eba \u6700\u540e\u627e\u6709\u51e0\u4e2a\u8fde\u901a\u5757 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ], cou [ maxn ]; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; int j = x , i ; while ( j != r ) { i = pre [ j ]; pre [ j ] = r ; j = i ; } return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } bool comp ( int x , int y ) { return x > y ; } int main () { CLR ( cou ); int n , k , num ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) pre [ i ] = i ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d:\" , & k ); for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & num ); if ( cou [ num ]) join ( i , cou [ num ]); else cou [ num ] = i ; } } map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) m [ find ( i )] ++ ; vector < int > v ; map < int , int >:: iterator it ; for ( it = m . begin (); it != m . end (); it ++ ) v . push_back ( it -> second ); sort ( v . begin (), v . end (), comp ); int len = v . size (); cout << len << endl ; for ( int i = 0 ; i < len ; i ++ ) { if ( i ) printf ( \" \" ); printf ( \"%d\" , v [ i ]); } cout << endl ; }","title":"L3-003-\u793e\u4ea4\u96c6\u7fa4"},{"location":"CCCC/L3-003-%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4/#l3-003-\u793e\u4ea4\u96c6\u7fa4","text":"","title":"L3-003 \u793e\u4ea4\u96c6\u7fa4"},{"location":"CCCC/L3-003-%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u5728\u793e\u4ea4\u7f51\u7edc\u5e73\u53f0\u6ce8\u518c\u65f6\uff0c\u4e00\u822c\u603b\u662f\u88ab\u8981\u6c42\u586b\u5199\u4f60\u7684\u4e2a\u4eba\u5174\u8da3\u7231\u597d\uff0c\u4ee5\u4fbf\u627e\u5230\u5177\u6709\u76f8\u540c\u5174\u8da3\u7231\u597d\u7684\u6f5c\u5728\u7684\u670b\u53cb\u3002\u4e00\u4e2a\u201c\u793e\u4ea4\u96c6\u7fa4\u201d\u662f\u6307\u90e8\u5206\u5174\u8da3\u7231\u597d\u76f8\u540c\u7684\u4eba\u7684\u96c6\u5408\u3002\u4f60\u9700\u8981\u627e\u51fa\u6240\u6709\u7684\u793e\u4ea4\u96c6\u7fa4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u793e\u4ea4\u7f51\u7edc\u5e73\u53f0\u6ce8\u518c\u7684\u6240\u6709\u7528\u6237\u7684\u4eba\u6570\u3002\u4e8e\u662f\u8fd9\u4e9b\u4eba\u4ece 1 \u5230 N \u7f16\u53f7\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u5174\u8da3\u7231\u597d\u5217\u8868\uff1a K_i K_i : h_i[1] h_i[1] h_i[2] h_i[2] \u2026 h_i[K_i] h_i[K_i] \u5176\u4e2d K_i (>0) K_i (>0) \u662f\u5174\u8da3\u7231\u597d\u7684\u4e2a\u6570\uff0c h_i[j] h_i[j] \u662f\u7b2c j j \u4e2a\u5174\u8da3\u7231\u597d\u7684\u7f16\u53f7\uff0c\u4e3a\u533a\u95f4 [1, 1000] \u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e0d\u540c\u7684\u793e\u4ea4\u96c6\u7fa4\u7684\u4e2a\u6570\u3002\u968f\u540e\u7b2c\u4e8c\u884c\u6309\u975e\u589e\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u96c6\u7fa4\u4e2d\u7684\u4eba\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 3: 2 7 10 1: 4 2: 5 3 1: 4 1: 3 1: 4 4: 6 8 1 5 1: 4 \u8f93\u51fa\u6837\u4f8b 3 4 3 1","title":"Statement"},{"location":"CCCC/L3-003-%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4/#tutorial","text":"\u601d\u8def\uff1a \u5e76\u67e5\u96c6 \u7528\u4e00\u4e2a cou[i] cou[i] \u6765\u8868\u793a\u7b2c i i \u95e8\u8bfe\u7a0b\u7684\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba\u3002 \u5408\u5e76\u7684\u65f6\u5019\uff1a \u5224\u65ad cou[i] cou[i] \u5982\u679c cou[i] cou[i] \u5b58\u5728\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba, \u90a3\u4e48\u5c06\u8fd9\u4e24\u4eba join \u8d77\u6765 \u5982\u679c\u4e0d\u5b58\u5728, \u90a3\u4e48\u8fd9\u95e8\u8bfe\u7a0b\u7b2c\u4e00\u4e2a\u611f\u5174\u8da3\u7684\u4eba\u5c31\u662f\u8fd9\u4e2a\u4eba \u6700\u540e\u627e\u6709\u51e0\u4e2a\u8fde\u901a\u5757","title":"Tutorial"},{"location":"CCCC/L3-003-%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int pre [ maxn ], cou [ maxn ]; int find ( int x ) { int r = x ; while ( pre [ r ] != r ) r = pre [ r ]; int j = x , i ; while ( j != r ) { i = pre [ j ]; pre [ j ] = r ; j = i ; } return r ; } void join ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( x != fy ) pre [ fx ] = fy ; } bool comp ( int x , int y ) { return x > y ; } int main () { CLR ( cou ); int n , k , num ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) pre [ i ] = i ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d:\" , & k ); for ( int j = 0 ; j < k ; j ++ ) { scanf ( \"%d\" , & num ); if ( cou [ num ]) join ( i , cou [ num ]); else cou [ num ] = i ; } } map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) m [ find ( i )] ++ ; vector < int > v ; map < int , int >:: iterator it ; for ( it = m . begin (); it != m . end (); it ++ ) v . push_back ( it -> second ); sort ( v . begin (), v . end (), comp ); int len = v . size (); cout << len << endl ; for ( int i = 0 ; i < len ; i ++ ) { if ( i ) printf ( \" \" ); printf ( \"%d\" , v [ i ]); } cout << endl ; }","title":"Solution"},{"location":"CCCC/L3-004-%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD/","text":"L3-004 \u80bf\u7624\u8bca\u65ad Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u8bca\u65ad\u80bf\u7624\u75be\u75c5\u65f6\uff0c\u8ba1\u7b97\u80bf\u7624\u4f53\u79ef\u662f\u5f88\u91cd\u8981\u7684\u4e00\u73af\u3002\u7ed9\u5b9a\u75c5\u7076\u626b\u63cf\u5207\u7247\u4e2d\u6807\u6ce8\u51fa\u7684\u7591\u4f3c\u80bf\u7624\u533a\u57df\uff0c\u8bf7\u4f60\u8ba1\u7b97\u80bf\u7624\u7684\u4f53\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570\uff1a M M \u3001 N N \u3001 L L \u3001 T T \uff0c\u5176\u4e2d M M \u548c N N \u662f\u6bcf\u5f20\u5207\u7247\u7684\u5c3a\u5bf8\uff08\u5373\u6bcf\u5f20\u5207\u7247\u662f\u4e00\u4e2a M\\times N M\\times N \u7684\u50cf\u7d20\u77e9\u9635\u3002\u6700\u5927\u5206\u8fa8\u7387\u662f 1286\\times 128 1286\\times 128 \uff09\uff1b L L \uff08 \\le 60 \\le 60 \uff09\u662f\u5207\u7247\u7684\u5f20\u6570\uff1b T T \u662f\u4e00\u4e2a\u6574\u6570\u9608\u503c\uff08\u82e5\u7591\u4f3c\u80bf\u7624\u7684\u8fde\u901a\u4f53\u4f53\u79ef\u5c0f\u4e8e T T \uff0c\u5219\u8be5\u5c0f\u5757\u5ffd\u7565\u4e0d\u8ba1\uff09\u3002 \u6700\u540e\u7ed9\u51fa L L \u5f20\u5207\u7247\u3002\u6bcf\u5f20\u7528\u4e00\u4e2a\u75310\u548c1\u7ec4\u6210\u7684 M\\times N M\\times N \u7684\u77e9\u9635\u8868\u793a\uff0c\u5176\u4e2d1\u8868\u793a\u7591\u4f3c\u80bf\u7624\u7684\u50cf\u7d20\uff0c0\u8868\u793a\u6b63\u5e38\u50cf\u7d20\u3002\u7531\u4e8e\u5207\u7247\u539a\u5ea6\u53ef\u4ee5\u8ba4\u4e3a\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4e8e\u662f\u6211\u4eec\u53ea\u8981\u6570\u8fde\u901a\u4f53\u4e2d1\u7684\u4e2a\u6570\u5c31\u53ef\u4ee5\u5f97\u5230\u4f53\u79ef\u4e86\u3002\u9ebb\u70e6\u7684\u662f\uff0c\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u80bf\u7624\uff0c\u8fd9\u65f6\u6211\u4eec\u53ea\u7edf\u8ba1\u90a3\u4e9b\u4f53\u79ef\u4e0d\u5c0f\u4e8e T T \u7684\u3002\u4e24\u4e2a\u50cf\u7d20\u88ab\u8ba4\u4e3a\u662f\u201c\u8fde\u901a\u7684\u201d\uff0c\u5982\u679c\u5b83\u4eec\u6709\u4e00\u4e2a\u5171\u540c\u7684\u5207\u9762\uff0c\u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6240\u67096\u4e2a\u7ea2\u8272\u7684\u50cf\u7d20\u90fd\u4e0e\u84dd\u8272\u7684\u50cf\u7d20\u8fde\u901a\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80bf\u7624\u7684\u603b\u4f53\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 3 4 5 2 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 \u8f93\u51fa\u6837\u4f8b 26 Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define fi first #define se second #define pid pair<int, db> #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define N 10010 int m , n , l , t ; int Move [][ 3 ] = { 0 , 0 , 1 , 0 , 0 , -1 , 0 , 1 , 0 , 0 , -1 , 0 , 1 , 0 , 0 , -1 , 0 , 0 , }; int G [ 61 ][ 1300 ][ 130 ]; int vis [ 61 ][ 1300 ][ 130 ]; bool ok ( int x , int y , int z ) { if ( vis [ x ][ y ][ z ] || x <= 0 || x > l || y <= 0 || y > n || z <= 0 || z > m || ! G [ x ][ y ][ z ]) return 0 ; return 1 ; } struct node { int x , y , z ; node () {} node ( int x , int y , int z ) : x ( x ), y ( y ), z ( z ) {} }; int BFS ( int x , int y , int z ) { queue < node > q ; q . push ( node ( x , y , z )); vis [ x ][ y ][ z ] = 1 ; int res = 0 ; while ( ! q . empty ()) { x = q . front (). x , y = q . front (). y , z = q . front (). z ; ++ res ; q . pop (); for ( int i = 0 ; i < 6 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; int nz = z + Move [ i ][ 2 ]; if ( ok ( nx , ny , nz )) { vis [ nx ][ ny ][ nz ] = 1 ; q . push ( node ( nx , ny , nz )); } } } return res ; } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset ( vis , 0 , sizeof vis ); scanf ( \"%d%d%d%d\" , & n , & m , & l , & t ); for ( int i = 1 ; i <= l ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int k = 1 ; k <= m ; ++ k ) scanf ( \"%d\" , & G [ i ][ j ][ k ]); int res = 0 ; for ( int i = 1 ; i <= l ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int k = 1 ; k <= m ; ++ k ) { if ( vis [ i ][ j ][ k ] || ! G [ i ][ j ][ k ]) continue ; int tmp = BFS ( i , j , k ); if ( tmp >= t ) res += tmp ; } cout << res << \" \\n \" ; return 0 ; }","title":"L3-004-\u80bf\u7624\u8bca\u65ad"},{"location":"CCCC/L3-004-%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD/#l3-004-\u80bf\u7624\u8bca\u65ad","text":"","title":"L3-004 \u80bf\u7624\u8bca\u65ad"},{"location":"CCCC/L3-004-%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u8bca\u65ad\u80bf\u7624\u75be\u75c5\u65f6\uff0c\u8ba1\u7b97\u80bf\u7624\u4f53\u79ef\u662f\u5f88\u91cd\u8981\u7684\u4e00\u73af\u3002\u7ed9\u5b9a\u75c5\u7076\u626b\u63cf\u5207\u7247\u4e2d\u6807\u6ce8\u51fa\u7684\u7591\u4f3c\u80bf\u7624\u533a\u57df\uff0c\u8bf7\u4f60\u8ba1\u7b97\u80bf\u7624\u7684\u4f53\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570\uff1a M M \u3001 N N \u3001 L L \u3001 T T \uff0c\u5176\u4e2d M M \u548c N N \u662f\u6bcf\u5f20\u5207\u7247\u7684\u5c3a\u5bf8\uff08\u5373\u6bcf\u5f20\u5207\u7247\u662f\u4e00\u4e2a M\\times N M\\times N \u7684\u50cf\u7d20\u77e9\u9635\u3002\u6700\u5927\u5206\u8fa8\u7387\u662f 1286\\times 128 1286\\times 128 \uff09\uff1b L L \uff08 \\le 60 \\le 60 \uff09\u662f\u5207\u7247\u7684\u5f20\u6570\uff1b T T \u662f\u4e00\u4e2a\u6574\u6570\u9608\u503c\uff08\u82e5\u7591\u4f3c\u80bf\u7624\u7684\u8fde\u901a\u4f53\u4f53\u79ef\u5c0f\u4e8e T T \uff0c\u5219\u8be5\u5c0f\u5757\u5ffd\u7565\u4e0d\u8ba1\uff09\u3002 \u6700\u540e\u7ed9\u51fa L L \u5f20\u5207\u7247\u3002\u6bcf\u5f20\u7528\u4e00\u4e2a\u75310\u548c1\u7ec4\u6210\u7684 M\\times N M\\times N \u7684\u77e9\u9635\u8868\u793a\uff0c\u5176\u4e2d1\u8868\u793a\u7591\u4f3c\u80bf\u7624\u7684\u50cf\u7d20\uff0c0\u8868\u793a\u6b63\u5e38\u50cf\u7d20\u3002\u7531\u4e8e\u5207\u7247\u539a\u5ea6\u53ef\u4ee5\u8ba4\u4e3a\u662f\u4e00\u4e2a\u5e38\u6570\uff0c\u4e8e\u662f\u6211\u4eec\u53ea\u8981\u6570\u8fde\u901a\u4f53\u4e2d1\u7684\u4e2a\u6570\u5c31\u53ef\u4ee5\u5f97\u5230\u4f53\u79ef\u4e86\u3002\u9ebb\u70e6\u7684\u662f\uff0c\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u80bf\u7624\uff0c\u8fd9\u65f6\u6211\u4eec\u53ea\u7edf\u8ba1\u90a3\u4e9b\u4f53\u79ef\u4e0d\u5c0f\u4e8e T T \u7684\u3002\u4e24\u4e2a\u50cf\u7d20\u88ab\u8ba4\u4e3a\u662f\u201c\u8fde\u901a\u7684\u201d\uff0c\u5982\u679c\u5b83\u4eec\u6709\u4e00\u4e2a\u5171\u540c\u7684\u5207\u9762\uff0c\u5982\u4e0b\u56fe\u6240\u793a\uff0c\u6240\u67096\u4e2a\u7ea2\u8272\u7684\u50cf\u7d20\u90fd\u4e0e\u84dd\u8272\u7684\u50cf\u7d20\u8fde\u901a\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80bf\u7624\u7684\u603b\u4f53\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 3 4 5 2 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 \u8f93\u51fa\u6837\u4f8b 26","title":"Statement"},{"location":"CCCC/L3-004-%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define fi first #define se second #define pid pair<int, db> #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define N 10010 int m , n , l , t ; int Move [][ 3 ] = { 0 , 0 , 1 , 0 , 0 , -1 , 0 , 1 , 0 , 0 , -1 , 0 , 1 , 0 , 0 , -1 , 0 , 0 , }; int G [ 61 ][ 1300 ][ 130 ]; int vis [ 61 ][ 1300 ][ 130 ]; bool ok ( int x , int y , int z ) { if ( vis [ x ][ y ][ z ] || x <= 0 || x > l || y <= 0 || y > n || z <= 0 || z > m || ! G [ x ][ y ][ z ]) return 0 ; return 1 ; } struct node { int x , y , z ; node () {} node ( int x , int y , int z ) : x ( x ), y ( y ), z ( z ) {} }; int BFS ( int x , int y , int z ) { queue < node > q ; q . push ( node ( x , y , z )); vis [ x ][ y ][ z ] = 1 ; int res = 0 ; while ( ! q . empty ()) { x = q . front (). x , y = q . front (). y , z = q . front (). z ; ++ res ; q . pop (); for ( int i = 0 ; i < 6 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; int nz = z + Move [ i ][ 2 ]; if ( ok ( nx , ny , nz )) { vis [ nx ][ ny ][ nz ] = 1 ; q . push ( node ( nx , ny , nz )); } } } return res ; } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset ( vis , 0 , sizeof vis ); scanf ( \"%d%d%d%d\" , & n , & m , & l , & t ); for ( int i = 1 ; i <= l ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int k = 1 ; k <= m ; ++ k ) scanf ( \"%d\" , & G [ i ][ j ][ k ]); int res = 0 ; for ( int i = 1 ; i <= l ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int k = 1 ; k <= m ; ++ k ) { if ( vis [ i ][ j ][ k ] || ! G [ i ][ j ][ k ]) continue ; int tmp = BFS ( i , j , k ); if ( tmp >= t ) res += tmp ; } cout << res << \" \\n \" ; return 0 ; }","title":"Solution"},{"location":"CCCC/L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/","text":"L3-005 \u5783\u573e\u7bb1\u5206\u5e03 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5012\u5783\u573e\u7684\u65f6\u5019\uff0c\u90fd\u5e0c\u671b\u5783\u573e\u7bb1\u8ddd\u79bb\u81ea\u5df1\u6bd4\u8f83\u8fd1\uff0c\u4f46\u662f\u8c01\u90fd\u4e0d\u613f\u610f\u5b88\u7740\u5783\u573e\u7bb1\u4f4f\u3002\u6240\u4ee5\u5783\u573e\u7bb1\u7684\u4f4d\u7f6e\u5fc5\u987b\u9009\u5728\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u6700\u957f\u7684\u5730\u65b9\uff0c\u540c\u65f6\u8fd8\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u5c45\u6c11\u70b9\u90fd\u5728\u8ddd\u79bb\u5b83\u4e00\u4e2a\u4e0d\u592a\u8fdc\u7684\u8303\u56f4\u5185\u3002 \u73b0\u7ed9\u5b9a\u4e00\u4e2a\u5c45\u6c11\u533a\u7684\u5730\u56fe\uff0c\u4ee5\u53ca\u82e5\u5e72\u5783\u573e\u7bb1\u7684\u5019\u9009\u5730\u70b9\uff0c\u8bf7\u4f60\u63a8\u8350\u6700\u5408\u9002\u7684\u5730\u70b9\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u5e73\u5747\u8ddd\u79bb\u6700\u77ed\u7684\u90a3\u4e2a\u89e3\u3002\u5982\u679c\u8fd9\u6837\u7684\u89e3\u8fd8\u662f\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5c0f\u7684\u5730\u70b9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 10^3 \\le 10^3 \uff09\u662f\u5c45\u6c11\u70b9\u7684\u4e2a\u6570\uff1b M M \uff08 \\le 10 \\le 10 \uff09\u662f\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u7684\u4e2a\u6570\uff1b K K \uff08 \\le 10^4 \\le 10^4 \uff09\u662f\u5c45\u6c11\u70b9\u548c\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u4e4b\u95f4\u7684\u9053\u8def\u7684\u6761\u6570\uff1b D_S D_S \u662f\u5c45\u6c11\u70b9\u4e0e\u5783\u573e\u7bb1\u4e4b\u95f4\u4e0d\u80fd\u8d85\u8fc7\u7684\u6700\u5927\u8ddd\u79bb\u3002\u6240\u6709\u7684\u5c45\u6c11\u70b9\u4ece1\u5230 N N \u7f16\u53f7\uff0c\u6240\u6709\u7684\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u4ece G1 G1 \u5230 GM GM \u7f16\u53f7\u3002 \u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u63cf\u8ff0\u4e00\u6761\u9053\u8def\uff1a P1 P2 Dist \u5176\u4e2d P1 \u548c P2 \u662f\u9053\u8def\u4e24\u7aef\u70b9\u7684\u7f16\u53f7\uff0c\u7aef\u70b9\u53ef\u4ee5\u662f\u5c45\u6c11\u70b9\uff0c\u4e5f\u53ef\u4ee5\u662f\u5783\u573e\u7bb1\u5019\u9009\u70b9\u3002 Dist \u662f\u9053\u8def\u7684\u957f\u5ea6\uff0c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u6700\u4f73\u5019\u9009\u5730\u70b9\u7684\u7f16\u53f7\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u8be5\u5730\u70b9\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\u548c\u5e73\u5747\u8ddd\u79bb\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002\u5982\u679c\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b1 4 3 11 5 1 2 2 1 4 2 1 G1 4 1 G2 3 2 3 2 2 G2 1 3 4 2 3 G3 2 4 G1 3 G2 G1 1 G3 G2 2 \u8f93\u51fa\u6837\u4f8b1 G1 2.0 3.3 \u8f93\u5165\u6837\u4f8b2 2 1 2 10 1 G1 9 2 G1 20 \u8f93\u51fa\u6837\u4f8b2 No Solution Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define fi first #define se second #define pid pair<int, db> #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define N 10010 int n , m , k , Ds ; struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N << 1 ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) struct node { int to , w ; node () {} node ( int to , int w ) : to ( to ), w ( w ) {} bool operator < ( const node & other ) const { return w > other . w ; } }; ll dist [ N ]; bool used [ N ]; void Dij ( int st ) { for ( int i = 1 ; i <= n + m ; ++ i ) { dist [ i ] = INF ; used [ i ] = 0 ; } dist [ st ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; erp ( u ) if ( dist [ v ] > dist [ u ] + w ) { dist [ v ] = dist [ u ] + w ; pq . push ( node ( v , dist [ v ])); } } } int read () { char s [ 10 ]; scanf ( \"%s\" , s ); int tot = 0 ; int i ; if ( s [ 0 ] == 'G' ) i = 1 ; else i = 0 ; for ( int len = strlen ( s ); i < len ; ++ i ) tot = tot * 10 + ( s [ i ] - '0' ); if ( s [ 0 ] == 'G' ) tot += n ; return tot ; } int id ; ll total , Mindis ; void f ( int now ) { ll Max = 0 , Min = INF , tot = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { // printf(\"%d %d %d\\n\", now, i, dist[i]); tot += dist [ i ]; Max = max ( Max , dist [ i ]); Min = min ( Min , dist [ i ]); } if ( Max > Ds ) return ; if ( Min > Mindis ) { id = now ; total = tot ; Mindis = Min ; } else if ( Min == Mindis && tot < total ) { id = now ; total = tot ; } } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); G . init (); scanf ( \"%d%d%d%d\" , & n , & m , & k , & Ds ); for ( int i = 1 , u , v , w ; i <= k ; ++ i ) { u = read (); v = read (); scanf ( \"%d\" , & w ); G . add ( u , v , w ); } Mindis = 0 ; total = INFLL ; for ( int i = 1 ; i <= m ; ++ i ) { Dij ( i + n ); f ( i ); } if ( total == INFLL ) puts ( \"No Solution\" ); else { printf ( \"G%d \\n \" , id ); printf ( \"%.1f %.1f \\n \" , Mindis * 1.0 , total * 1.0 / n ); } return 0 ; }","title":"L3-005-\u5783\u573e\u7bb1\u5206\u5e03"},{"location":"CCCC/L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/#l3-005-\u5783\u573e\u7bb1\u5206\u5e03","text":"","title":"L3-005 \u5783\u573e\u7bb1\u5206\u5e03"},{"location":"CCCC/L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5012\u5783\u573e\u7684\u65f6\u5019\uff0c\u90fd\u5e0c\u671b\u5783\u573e\u7bb1\u8ddd\u79bb\u81ea\u5df1\u6bd4\u8f83\u8fd1\uff0c\u4f46\u662f\u8c01\u90fd\u4e0d\u613f\u610f\u5b88\u7740\u5783\u573e\u7bb1\u4f4f\u3002\u6240\u4ee5\u5783\u573e\u7bb1\u7684\u4f4d\u7f6e\u5fc5\u987b\u9009\u5728\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u6700\u957f\u7684\u5730\u65b9\uff0c\u540c\u65f6\u8fd8\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u5c45\u6c11\u70b9\u90fd\u5728\u8ddd\u79bb\u5b83\u4e00\u4e2a\u4e0d\u592a\u8fdc\u7684\u8303\u56f4\u5185\u3002 \u73b0\u7ed9\u5b9a\u4e00\u4e2a\u5c45\u6c11\u533a\u7684\u5730\u56fe\uff0c\u4ee5\u53ca\u82e5\u5e72\u5783\u573e\u7bb1\u7684\u5019\u9009\u5730\u70b9\uff0c\u8bf7\u4f60\u63a8\u8350\u6700\u5408\u9002\u7684\u5730\u70b9\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u5e73\u5747\u8ddd\u79bb\u6700\u77ed\u7684\u90a3\u4e2a\u89e3\u3002\u5982\u679c\u8fd9\u6837\u7684\u89e3\u8fd8\u662f\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5c0f\u7684\u5730\u70b9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa4\u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 10^3 \\le 10^3 \uff09\u662f\u5c45\u6c11\u70b9\u7684\u4e2a\u6570\uff1b M M \uff08 \\le 10 \\le 10 \uff09\u662f\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u7684\u4e2a\u6570\uff1b K K \uff08 \\le 10^4 \\le 10^4 \uff09\u662f\u5c45\u6c11\u70b9\u548c\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u4e4b\u95f4\u7684\u9053\u8def\u7684\u6761\u6570\uff1b D_S D_S \u662f\u5c45\u6c11\u70b9\u4e0e\u5783\u573e\u7bb1\u4e4b\u95f4\u4e0d\u80fd\u8d85\u8fc7\u7684\u6700\u5927\u8ddd\u79bb\u3002\u6240\u6709\u7684\u5c45\u6c11\u70b9\u4ece1\u5230 N N \u7f16\u53f7\uff0c\u6240\u6709\u7684\u5783\u573e\u7bb1\u5019\u9009\u5730\u70b9\u4ece G1 G1 \u5230 GM GM \u7f16\u53f7\u3002 \u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u63cf\u8ff0\u4e00\u6761\u9053\u8def\uff1a P1 P2 Dist \u5176\u4e2d P1 \u548c P2 \u662f\u9053\u8def\u4e24\u7aef\u70b9\u7684\u7f16\u53f7\uff0c\u7aef\u70b9\u53ef\u4ee5\u662f\u5c45\u6c11\u70b9\uff0c\u4e5f\u53ef\u4ee5\u662f\u5783\u573e\u7bb1\u5019\u9009\u70b9\u3002 Dist \u662f\u9053\u8def\u7684\u957f\u5ea6\uff0c\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u6700\u4f73\u5019\u9009\u5730\u70b9\u7684\u7f16\u53f7\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u8be5\u5730\u70b9\u5230\u6240\u6709\u5c45\u6c11\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\u548c\u5e73\u5747\u8ddd\u79bb\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e1\u4f4d\u3002\u5982\u679c\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b1 4 3 11 5 1 2 2 1 4 2 1 G1 4 1 G2 3 2 3 2 2 G2 1 3 4 2 3 G3 2 4 G1 3 G2 G1 1 G3 G2 2 \u8f93\u51fa\u6837\u4f8b1 G1 2.0 3.3 \u8f93\u5165\u6837\u4f8b2 2 1 2 10 1 G1 9 2 G1 20 \u8f93\u51fa\u6837\u4f8b2 No Solution","title":"Statement"},{"location":"CCCC/L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define fi first #define se second #define pid pair<int, db> #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define N 10010 int n , m , k , Ds ; struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N << 1 ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) struct node { int to , w ; node () {} node ( int to , int w ) : to ( to ), w ( w ) {} bool operator < ( const node & other ) const { return w > other . w ; } }; ll dist [ N ]; bool used [ N ]; void Dij ( int st ) { for ( int i = 1 ; i <= n + m ; ++ i ) { dist [ i ] = INF ; used [ i ] = 0 ; } dist [ st ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; erp ( u ) if ( dist [ v ] > dist [ u ] + w ) { dist [ v ] = dist [ u ] + w ; pq . push ( node ( v , dist [ v ])); } } } int read () { char s [ 10 ]; scanf ( \"%s\" , s ); int tot = 0 ; int i ; if ( s [ 0 ] == 'G' ) i = 1 ; else i = 0 ; for ( int len = strlen ( s ); i < len ; ++ i ) tot = tot * 10 + ( s [ i ] - '0' ); if ( s [ 0 ] == 'G' ) tot += n ; return tot ; } int id ; ll total , Mindis ; void f ( int now ) { ll Max = 0 , Min = INF , tot = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { // printf(\"%d %d %d\\n\", now, i, dist[i]); tot += dist [ i ]; Max = max ( Max , dist [ i ]); Min = min ( Min , dist [ i ]); } if ( Max > Ds ) return ; if ( Min > Mindis ) { id = now ; total = tot ; Mindis = Min ; } else if ( Min == Mindis && tot < total ) { id = now ; total = tot ; } } int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); G . init (); scanf ( \"%d%d%d%d\" , & n , & m , & k , & Ds ); for ( int i = 1 , u , v , w ; i <= k ; ++ i ) { u = read (); v = read (); scanf ( \"%d\" , & w ); G . add ( u , v , w ); } Mindis = 0 ; total = INFLL ; for ( int i = 1 ; i <= m ; ++ i ) { Dij ( i + n ); f ( i ); } if ( total == INFLL ) puts ( \"No Solution\" ); else { printf ( \"G%d \\n \" , id ); printf ( \"%.1f %.1f \\n \" , Mindis * 1.0 , total * 1.0 / n ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-006-%E8%BF%8E%E9%A3%8E%E4%B8%80%E5%88%80%E6%96%A9/","text":"L3-006 \u8fce\u98ce\u4e00\u5200\u65a9 Statement Metadata \u4f5c\u8005: \u5218\u6c5d\u4f73 \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fce\u7740\u4e00\u9762\u77e9\u5f62\u7684\u5927\u65d7\u4e00\u5200\u65a9\u4e0b\uff0c\u5982\u679c\u4f60\u7684\u5200\u591f\u5feb\u7684\u8bdd\uff0c\u8fd9\u7b14\u76f4\u4e00\u5200\u53ef\u4ee5\u5207\u51fa\u4e24\u5757\u591a\u8fb9\u5f62\u7684\u6b8b\u7247\u3002\u53cd\u8fc7\u6765\u8bf4\uff0c\u5982\u679c\u6709\u4eba\u62ff\u7740\u4e24\u5757\u6b8b\u7247\u6765\u5439\u725b\uff0c\u8bf4\u8fd9\u662f\u81ea\u5df1\u8fce\u98ce\u4e00\u5200\u65a9\u843d\u7684\uff0c\u4f60\u80fd\u68c0\u67e5\u4e00\u4e0b\u8fd9\u662f\u4e0d\u662f\u771f\u7684\u5417\uff1f \u6ce8\u610f\u6446\u5728\u4f60\u9762\u524d\u7684\u4e24\u4e2a\u591a\u8fb9\u5f62\u53ef\u4e0d\u4e00\u5b9a\u662f\u7aef\u7aef\u6b63\u6b63\u6446\u597d\u7684\uff0c\u5b83\u4eec\u53ef\u80fd\u88ab\u5e73\u79fb\u3001\u88ab\u65cb\u8f6c\uff08\u9006\u65f6\u948890\u5ea6\u3001180\u5ea6\u3001\u6216270\u5ea6\uff09\uff0c\u6216\u8005\u88ab\uff08\u955c\u50cf\uff09\u7ffb\u9762\u3002 \u8fd9\u91cc\u5047\u8bbe\u539f\u59cb\u5927\u65d7\u7684\u56db\u8fb9\u90fd\u4e0e\u5750\u6807\u8f74\u662f\u5e73\u884c\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 20 \\le 20 \uff09\uff0c\u968f\u540e\u7ed9\u51fa N N \u5bf9\u591a\u8fb9\u5f62\u3002\u6bcf\u4e2a\u591a\u8fb9\u5f62\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\uff1a k\\quad x_1\\quad y_1\\cdots x_k\\quad y_k k\\quad x_1\\quad y_1\\cdots x_k\\quad y_k \u5176\u4e2d k k \uff08 2 < k \\le 10 2 < k \\le 10 \uff09\u662f\u591a\u8fb9\u5f62\u9876\u70b9\u4e2a\u6570\uff1b (x_i, y_i) (x_i, y_i) \uff08 0 \\le x_i, y_i \\le 10^8 0 \\le x_i, y_i \\le 10^8 \uff09\u662f\u9876\u70b9\u5750\u6807\uff0c\u6309\u7167\u987a\u65f6\u9488\u6216\u9006\u65f6\u9488\u7684\u987a\u5e8f\u7ed9\u51fa\u3002 \u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u591a\u4f59\u9876\u70b9\u3002\u5373\u6bcf\u4e2a\u591a\u8fb9\u5f62\u7684\u9876\u70b9\u90fd\u662f\u4e0d\u91cd\u590d\u7684\uff0c\u4efb\u610f3\u4e2a\u76f8\u90bb\u9876\u70b9\u4e0d\u5171\u7ebf\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u591a\u8fb9\u5f62\uff0c\u8f93\u51fa YES \u6216\u8005 NO \u3002 \u8f93\u5165\u6837\u4f8b 8 3 0 0 1 0 1 1 3 0 0 1 1 0 1 3 0 0 1 0 1 1 3 0 0 1 1 0 2 4 0 4 1 4 1 0 0 0 4 4 0 4 1 0 1 0 0 3 0 0 1 1 0 1 4 2 3 1 4 1 7 2 7 5 10 10 10 12 12 12 14 11 14 10 3 28 35 29 35 29 37 3 7 9 8 11 8 9 5 87 26 92 26 92 23 90 22 87 22 5 0 0 2 0 1 1 1 2 0 2 4 0 0 1 1 2 1 2 0 4 0 0 0 1 1 1 2 0 4 0 0 0 1 1 1 2 0 \u8f93\u51fa\u6837\u4f8b YES NO YES YES YES YES NO YES","title":"L3-006-\u8fce\u98ce\u4e00\u5200\u65a9"},{"location":"CCCC/L3-006-%E8%BF%8E%E9%A3%8E%E4%B8%80%E5%88%80%E6%96%A9/#l3-006-\u8fce\u98ce\u4e00\u5200\u65a9","text":"","title":"L3-006 \u8fce\u98ce\u4e00\u5200\u65a9"},{"location":"CCCC/L3-006-%E8%BF%8E%E9%A3%8E%E4%B8%80%E5%88%80%E6%96%A9/#statement","text":"Metadata \u4f5c\u8005: \u5218\u6c5d\u4f73 \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u8fce\u7740\u4e00\u9762\u77e9\u5f62\u7684\u5927\u65d7\u4e00\u5200\u65a9\u4e0b\uff0c\u5982\u679c\u4f60\u7684\u5200\u591f\u5feb\u7684\u8bdd\uff0c\u8fd9\u7b14\u76f4\u4e00\u5200\u53ef\u4ee5\u5207\u51fa\u4e24\u5757\u591a\u8fb9\u5f62\u7684\u6b8b\u7247\u3002\u53cd\u8fc7\u6765\u8bf4\uff0c\u5982\u679c\u6709\u4eba\u62ff\u7740\u4e24\u5757\u6b8b\u7247\u6765\u5439\u725b\uff0c\u8bf4\u8fd9\u662f\u81ea\u5df1\u8fce\u98ce\u4e00\u5200\u65a9\u843d\u7684\uff0c\u4f60\u80fd\u68c0\u67e5\u4e00\u4e0b\u8fd9\u662f\u4e0d\u662f\u771f\u7684\u5417\uff1f \u6ce8\u610f\u6446\u5728\u4f60\u9762\u524d\u7684\u4e24\u4e2a\u591a\u8fb9\u5f62\u53ef\u4e0d\u4e00\u5b9a\u662f\u7aef\u7aef\u6b63\u6b63\u6446\u597d\u7684\uff0c\u5b83\u4eec\u53ef\u80fd\u88ab\u5e73\u79fb\u3001\u88ab\u65cb\u8f6c\uff08\u9006\u65f6\u948890\u5ea6\u3001180\u5ea6\u3001\u6216270\u5ea6\uff09\uff0c\u6216\u8005\u88ab\uff08\u955c\u50cf\uff09\u7ffb\u9762\u3002 \u8fd9\u91cc\u5047\u8bbe\u539f\u59cb\u5927\u65d7\u7684\u56db\u8fb9\u90fd\u4e0e\u5750\u6807\u8f74\u662f\u5e73\u884c\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 20 \\le 20 \uff09\uff0c\u968f\u540e\u7ed9\u51fa N N \u5bf9\u591a\u8fb9\u5f62\u3002\u6bcf\u4e2a\u591a\u8fb9\u5f62\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\uff1a k\\quad x_1\\quad y_1\\cdots x_k\\quad y_k k\\quad x_1\\quad y_1\\cdots x_k\\quad y_k \u5176\u4e2d k k \uff08 2 < k \\le 10 2 < k \\le 10 \uff09\u662f\u591a\u8fb9\u5f62\u9876\u70b9\u4e2a\u6570\uff1b (x_i, y_i) (x_i, y_i) \uff08 0 \\le x_i, y_i \\le 10^8 0 \\le x_i, y_i \\le 10^8 \uff09\u662f\u9876\u70b9\u5750\u6807\uff0c\u6309\u7167\u987a\u65f6\u9488\u6216\u9006\u65f6\u9488\u7684\u987a\u5e8f\u7ed9\u51fa\u3002 \u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u591a\u4f59\u9876\u70b9\u3002\u5373\u6bcf\u4e2a\u591a\u8fb9\u5f62\u7684\u9876\u70b9\u90fd\u662f\u4e0d\u91cd\u590d\u7684\uff0c\u4efb\u610f3\u4e2a\u76f8\u90bb\u9876\u70b9\u4e0d\u5171\u7ebf\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u591a\u8fb9\u5f62\uff0c\u8f93\u51fa YES \u6216\u8005 NO \u3002 \u8f93\u5165\u6837\u4f8b 8 3 0 0 1 0 1 1 3 0 0 1 1 0 1 3 0 0 1 0 1 1 3 0 0 1 1 0 2 4 0 4 1 4 1 0 0 0 4 4 0 4 1 0 1 0 0 3 0 0 1 1 0 1 4 2 3 1 4 1 7 2 7 5 10 10 10 12 12 12 14 11 14 10 3 28 35 29 35 29 37 3 7 9 8 11 8 9 5 87 26 92 26 92 23 90 22 87 22 5 0 0 2 0 1 1 1 2 0 2 4 0 0 1 1 2 1 2 0 4 0 0 0 1 1 1 2 0 4 0 0 0 1 1 1 2 0 \u8f93\u51fa\u6837\u4f8b YES NO YES YES YES YES NO YES","title":"Statement"},{"location":"CCCC/L3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/","text":"L3-007 \u5929\u68af\u5730\u56fe Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u5929\u68af\u8d5b\u4e13\u5c5e\u5728\u7ebf\u5730\u56fe\uff0c\u961f\u5458\u8f93\u5165\u81ea\u5df1\u5b66\u6821\u6240\u5728\u5730\u548c\u8d5b\u573a\u5730\u70b9\u540e\uff0c\u8be5\u5730\u56fe\u5e94\u8be5\u63a8\u8350\u4e24\u6761\u8def\u7ebf\uff1a\u4e00\u6761\u662f\u6700\u5feb\u5230\u8fbe\u8def\u7ebf\uff1b\u4e00\u6761\u662f\u6700\u77ed\u8ddd\u79bb\u7684\u8def\u7ebf\u3002\u9898\u76ee\u4fdd\u8bc1\u5bf9\u4efb\u610f\u7684\u67e5\u8be2\u8bf7\u6c42\uff0c\u5730\u56fe\u4e0a\u90fd\u81f3\u5c11\u5b58\u5728\u4e00\u6761\u53ef\u8fbe\u8def\u7ebf\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N \uff082 \\le \\le N \\le \\le 500\uff09\u548c M \uff0c\u5206\u522b\u4e3a\u5730\u56fe\u4e2d\u6240\u6709\u6807\u8bb0\u5730\u70b9\u7684\u4e2a\u6570\u548c\u8fde\u63a5\u5730\u70b9\u7684\u9053\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u6309\u5982\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u6761\u9053\u8def\u7684\u4fe1\u606f\uff1a V1 V2 one-way length time \u5176\u4e2d V1 \u548c V2 \u662f\u9053\u8def\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u53f7\uff08\u4ece0\u5230 N -1\uff09\uff1b\u5982\u679c\u8be5\u9053\u8def\u662f\u4ece V1 \u5230 V2 \u7684\u5355\u884c\u7ebf\uff0c\u5219 one-way \u4e3a1\uff0c\u5426\u5219\u4e3a0\uff1b length \u662f\u9053\u8def\u7684\u957f\u5ea6\uff1b time \u662f\u901a\u8fc7\u8be5\u8def\u6240\u9700\u8981\u7684\u65f6\u95f4\u3002\u6700\u540e\u7ed9\u51fa\u4e00\u5bf9\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6700\u5feb\u5230\u8fbe\u7684\u65f6\u95f4 T \u548c\u7528\u8282\u70b9\u7f16\u53f7\u8868\u793a\u7684\u8def\u7ebf\uff1a Time = T: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u7136\u540e\u5728\u4e0b\u4e00\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6700\u77ed\u8ddd\u79bb D \u548c\u7528\u8282\u70b9\u7f16\u53f7\u8868\u793a\u7684\u8def\u7ebf\uff1a Distance = D: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u5982\u679c\u6700\u5feb\u5230\u8fbe\u8def\u7ebf\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u51e0\u6761\u6700\u5feb\u8def\u7ebf\u4e2d\u6700\u77ed\u7684\u90a3\u6761\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6761\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002\u800c\u5982\u679c\u6700\u77ed\u8ddd\u79bb\u7684\u8def\u7ebf\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u9014\u5f84\u8282\u70b9\u6570\u6700\u5c11\u7684\u90a3\u6761\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6761\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002 \u5982\u679c\u8fd9\u4e24\u6761\u8def\u7ebf\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u5219\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\uff1a Time = T; Distance = D: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u8f93\u5165\u6837\u4f8b1 10 15 0 1 0 1 1 8 0 0 1 1 4 8 1 1 1 5 4 0 2 3 5 9 1 1 4 0 6 0 1 1 7 3 1 1 2 8 3 1 1 2 2 5 0 2 2 2 1 1 1 1 1 5 0 1 3 1 4 0 1 1 9 7 1 1 3 3 1 0 2 5 6 3 1 2 1 5 3 \u8f93\u51fa\u6837\u4f8b1 Time = 6: 5 => 4 => 8 => 3 Distance = 3: 5 => 1 => 3 \u8f93\u5165\u6837\u4f8b2 7 9 0 4 1 1 1 1 6 1 3 1 2 6 1 1 1 2 5 1 2 2 3 0 0 1 1 3 1 1 3 1 3 2 1 2 1 4 5 0 2 2 6 5 1 2 1 3 5 \u8f93\u51fa\u6837\u4f8b2 Time = 3; Distance = 4: 3 => 2 => 5 Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 1010 #define M 1000010 #define INF 0x3f3f3f3f int n , m , st , ed ; struct Graph { struct node { int to , nx , l , t ; node () {} node ( int to , int nx , int l , int t ) : to ( to ), nx ( nx ), l ( l ), t ( t ) {} } a [ M << 1 ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int l , int t ) { a [ ++ pos ] = node ( v , head [ u ], l , t ); head [ u ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, l = G.a[it].l, t = G.a[it].t; it; \\ it = G.a[it].nx, v = G.a[it].to, l = G.a[it].l, t = G.a[it].t) int Time , Dis ; namespace Dij { struct node { int to , a , b , fa ; node () {} node ( int to , int a , int b , int fa ) : to ( to ), a ( a ), b ( b ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; return b > other . b ; } }; int dist [ N ][ 2 ], fa [ N ]; bool used [ N ]; void work1 ( vector < int > & res ) { for ( int i = 1 ; i <= n ; ++ i ) { dist [ i ][ 0 ] = dist [ i ][ 1 ] = INF ; fa [ i ] = -1 ; used [ i ] = 0 ; } dist [ st ][ 0 ] = dist [ st ][ 1 ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 , 0 , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { Time = dist [ u ][ 0 ]; int it = u ; while ( it ) { res . push_back ( it ); it = fa [ it ]; } reverse ( res . begin (), res . end ()); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + t ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + t ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + l ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + t && dist [ v ][ 1 ] > dist [ u ][ 1 ] + l ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + t ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + l ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } void work2 ( vector < int > & res ) { for ( int i = 1 ; i <= n ; ++ i ) { dist [ i ][ 0 ] = dist [ i ][ 1 ] = INF ; fa [ i ] = -1 ; used [ i ] = 0 ; } dist [ st ][ 0 ] = dist [ st ][ 1 ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 , 0 , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { Dis = dist [ u ][ 0 ]; int it = u ; while ( it ) { res . push_back ( it ); it = fa [ it ]; } reverse ( res . begin (), res . end ()); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + l ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + l ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + 1 ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + l && dist [ v ][ 1 ] > dist [ u ][ 1 ] + 1 ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + l ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + 1 ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } } // namespace Dij bool same ( vector < int > l , vector < int > r ) { if (( int ) l . size () != ( int ) r . size ()) return 0 ; int len = ( int ) l . size (); for ( int i = 0 ; i < len ; ++ i ) if ( l [ i ] != r [ i ]) return 0 ; return 1 ; } void out ( vector < int > vec ) { int len = ( int ) vec . size (); for ( int i = 0 ; i < len ; ++ i ) { printf ( \"%d\" , vec [ i ] - 1 ); if ( i != len - 1 ) printf ( \" => \" ); else printf ( \" \\n \" ); } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { G . init (); for ( int i = 1 , u , v , tp , l , t ; i <= m ; ++ i ) { scanf ( \"%d%d%d%d%d\" , & u , & v , & tp , & l , & t ); ++ u , ++ v ; G . add ( u , v , l , t ); if ( tp == 0 ) G . add ( v , u , l , t ); } scanf ( \"%d%d\" , & st , & ed ); ++ st , ++ ed ; vector < int > res [ 2 ]; Dij :: work1 ( res [ 0 ]); Dij :: work2 ( res [ 1 ]); if ( same ( res [ 0 ], res [ 1 ])) { printf ( \"Time = %d; Distance = %d: \" , Time , Dis ); out ( res [ 0 ]); } else { printf ( \"Time = %d: \" , Time ); out ( res [ 0 ]); printf ( \"Distance = %d: \" , Dis ); out ( res [ 1 ]); } } return 0 ; }","title":"L3-007-\u5929\u68af\u5730\u56fe"},{"location":"CCCC/L3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/#l3-007-\u5929\u68af\u5730\u56fe","text":"","title":"L3-007 \u5929\u68af\u5730\u56fe"},{"location":"CCCC/L3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5b9e\u73b0\u4e00\u4e2a\u5929\u68af\u8d5b\u4e13\u5c5e\u5728\u7ebf\u5730\u56fe\uff0c\u961f\u5458\u8f93\u5165\u81ea\u5df1\u5b66\u6821\u6240\u5728\u5730\u548c\u8d5b\u573a\u5730\u70b9\u540e\uff0c\u8be5\u5730\u56fe\u5e94\u8be5\u63a8\u8350\u4e24\u6761\u8def\u7ebf\uff1a\u4e00\u6761\u662f\u6700\u5feb\u5230\u8fbe\u8def\u7ebf\uff1b\u4e00\u6761\u662f\u6700\u77ed\u8ddd\u79bb\u7684\u8def\u7ebf\u3002\u9898\u76ee\u4fdd\u8bc1\u5bf9\u4efb\u610f\u7684\u67e5\u8be2\u8bf7\u6c42\uff0c\u5730\u56fe\u4e0a\u90fd\u81f3\u5c11\u5b58\u5728\u4e00\u6761\u53ef\u8fbe\u8def\u7ebf\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N \uff082 \\le \\le N \\le \\le 500\uff09\u548c M \uff0c\u5206\u522b\u4e3a\u5730\u56fe\u4e2d\u6240\u6709\u6807\u8bb0\u5730\u70b9\u7684\u4e2a\u6570\u548c\u8fde\u63a5\u5730\u70b9\u7684\u9053\u8def\u6761\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u6309\u5982\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u6761\u9053\u8def\u7684\u4fe1\u606f\uff1a V1 V2 one-way length time \u5176\u4e2d V1 \u548c V2 \u662f\u9053\u8def\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u53f7\uff08\u4ece0\u5230 N -1\uff09\uff1b\u5982\u679c\u8be5\u9053\u8def\u662f\u4ece V1 \u5230 V2 \u7684\u5355\u884c\u7ebf\uff0c\u5219 one-way \u4e3a1\uff0c\u5426\u5219\u4e3a0\uff1b length \u662f\u9053\u8def\u7684\u957f\u5ea6\uff1b time \u662f\u901a\u8fc7\u8be5\u8def\u6240\u9700\u8981\u7684\u65f6\u95f4\u3002\u6700\u540e\u7ed9\u51fa\u4e00\u5bf9\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6700\u5feb\u5230\u8fbe\u7684\u65f6\u95f4 T \u548c\u7528\u8282\u70b9\u7f16\u53f7\u8868\u793a\u7684\u8def\u7ebf\uff1a Time = T: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u7136\u540e\u5728\u4e0b\u4e00\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u6700\u77ed\u8ddd\u79bb D \u548c\u7528\u8282\u70b9\u7f16\u53f7\u8868\u793a\u7684\u8def\u7ebf\uff1a Distance = D: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u5982\u679c\u6700\u5feb\u5230\u8fbe\u8def\u7ebf\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u51e0\u6761\u6700\u5feb\u8def\u7ebf\u4e2d\u6700\u77ed\u7684\u90a3\u6761\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6761\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002\u800c\u5982\u679c\u6700\u77ed\u8ddd\u79bb\u7684\u8def\u7ebf\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u9014\u5f84\u8282\u70b9\u6570\u6700\u5c11\u7684\u90a3\u6761\uff0c\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6761\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002 \u5982\u679c\u8fd9\u4e24\u6761\u8def\u7ebf\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u5219\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\uff1a Time = T; Distance = D: \u8d77\u70b9 => \u8282\u70b91 => ... => \u7ec8\u70b9 \u8f93\u5165\u6837\u4f8b1 10 15 0 1 0 1 1 8 0 0 1 1 4 8 1 1 1 5 4 0 2 3 5 9 1 1 4 0 6 0 1 1 7 3 1 1 2 8 3 1 1 2 2 5 0 2 2 2 1 1 1 1 1 5 0 1 3 1 4 0 1 1 9 7 1 1 3 3 1 0 2 5 6 3 1 2 1 5 3 \u8f93\u51fa\u6837\u4f8b1 Time = 6: 5 => 4 => 8 => 3 Distance = 3: 5 => 1 => 3 \u8f93\u5165\u6837\u4f8b2 7 9 0 4 1 1 1 1 6 1 3 1 2 6 1 1 1 2 5 1 2 2 3 0 0 1 1 3 1 1 3 1 3 2 1 2 1 4 5 0 2 2 6 5 1 2 1 3 5 \u8f93\u51fa\u6837\u4f8b2 Time = 3; Distance = 4: 3 => 2 => 5","title":"Statement"},{"location":"CCCC/L3-007-%E5%A4%A9%E6%A2%AF%E5%9C%B0%E5%9B%BE/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 1010 #define M 1000010 #define INF 0x3f3f3f3f int n , m , st , ed ; struct Graph { struct node { int to , nx , l , t ; node () {} node ( int to , int nx , int l , int t ) : to ( to ), nx ( nx ), l ( l ), t ( t ) {} } a [ M << 1 ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int l , int t ) { a [ ++ pos ] = node ( v , head [ u ], l , t ); head [ u ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, l = G.a[it].l, t = G.a[it].t; it; \\ it = G.a[it].nx, v = G.a[it].to, l = G.a[it].l, t = G.a[it].t) int Time , Dis ; namespace Dij { struct node { int to , a , b , fa ; node () {} node ( int to , int a , int b , int fa ) : to ( to ), a ( a ), b ( b ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; return b > other . b ; } }; int dist [ N ][ 2 ], fa [ N ]; bool used [ N ]; void work1 ( vector < int > & res ) { for ( int i = 1 ; i <= n ; ++ i ) { dist [ i ][ 0 ] = dist [ i ][ 1 ] = INF ; fa [ i ] = -1 ; used [ i ] = 0 ; } dist [ st ][ 0 ] = dist [ st ][ 1 ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 , 0 , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { Time = dist [ u ][ 0 ]; int it = u ; while ( it ) { res . push_back ( it ); it = fa [ it ]; } reverse ( res . begin (), res . end ()); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + t ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + t ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + l ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + t && dist [ v ][ 1 ] > dist [ u ][ 1 ] + l ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + t ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + l ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } void work2 ( vector < int > & res ) { for ( int i = 1 ; i <= n ; ++ i ) { dist [ i ][ 0 ] = dist [ i ][ 1 ] = INF ; fa [ i ] = -1 ; used [ i ] = 0 ; } dist [ st ][ 0 ] = dist [ st ][ 1 ] = 0 ; priority_queue < node > pq ; pq . push ( node ( st , 0 , 0 , 0 )); while ( ! pq . empty ()) { int u = pq . top (). to , pre = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; fa [ u ] = pre ; if ( u == ed ) { Dis = dist [ u ][ 0 ]; int it = u ; while ( it ) { res . push_back ( it ); it = fa [ it ]; } reverse ( res . begin (), res . end ()); return ; } erp ( u ) { if ( dist [ v ][ 0 ] > dist [ u ][ 0 ] + l ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + l ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + 1 ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } else if ( dist [ v ][ 0 ] == dist [ u ][ 0 ] + l && dist [ v ][ 1 ] > dist [ u ][ 1 ] + 1 ) { dist [ v ][ 0 ] = dist [ u ][ 0 ] + l ; dist [ v ][ 1 ] = dist [ u ][ 1 ] + 1 ; pq . push ( node ( v , dist [ v ][ 0 ], dist [ v ][ 1 ], u )); } } } } } // namespace Dij bool same ( vector < int > l , vector < int > r ) { if (( int ) l . size () != ( int ) r . size ()) return 0 ; int len = ( int ) l . size (); for ( int i = 0 ; i < len ; ++ i ) if ( l [ i ] != r [ i ]) return 0 ; return 1 ; } void out ( vector < int > vec ) { int len = ( int ) vec . size (); for ( int i = 0 ; i < len ; ++ i ) { printf ( \"%d\" , vec [ i ] - 1 ); if ( i != len - 1 ) printf ( \" => \" ); else printf ( \" \\n \" ); } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { G . init (); for ( int i = 1 , u , v , tp , l , t ; i <= m ; ++ i ) { scanf ( \"%d%d%d%d%d\" , & u , & v , & tp , & l , & t ); ++ u , ++ v ; G . add ( u , v , l , t ); if ( tp == 0 ) G . add ( v , u , l , t ); } scanf ( \"%d%d\" , & st , & ed ); ++ st , ++ ed ; vector < int > res [ 2 ]; Dij :: work1 ( res [ 0 ]); Dij :: work2 ( res [ 1 ]); if ( same ( res [ 0 ], res [ 1 ])) { printf ( \"Time = %d; Distance = %d: \" , Time , Dis ); out ( res [ 0 ]); } else { printf ( \"Time = %d: \" , Time ); out ( res [ 0 ]); printf ( \"Distance = %d: \" , Dis ); out ( res [ 1 ]); } } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-008-%E5%96%8A%E5%B1%B1/","text":"L3-008 \u558a\u5c71 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u558a\u5c71\uff0c\u662f\u4eba\u53cc\u624b\u56f4\u5728\u5634\u8fb9\u6210\u5587\u53ed\u72b6\uff0c\u5bf9\u7740\u8fdc\u65b9\u9ad8\u5c71\u53d1\u51fa\u201c\u5582\u2014\u5582\u5582\u2014\u5582\u5582\u5582\u2026\u2026\u201d\u7684\u547c\u5524\u3002\u547c\u5524\u58f0\u901a\u8fc7\u7a7a\u6c14\u7684\u4f20\u9012\uff0c\u56de\u8361\u4e8e\u6df1\u8c37\u4e4b\u95f4\uff0c\u4f20\u9001\u5230\u4eba\u4eec\u8033\u4e2d\uff0c\u53d1\u51fa\u7ea6\u5b9a\u4fd7\u6210\u7684\u201c\u8baf\u53f7\u201d\uff0c\u8fbe\u5230\u58f0\u8baf\u4f20\u9012\u4ea4\u6d41\u7684\u76ee\u7684\u3002\u539f\u6765\u5b83\u662f\u5f5d\u65cf\u5148\u6c11\u7528\u6765\u6c42\u63f4\u547c\u6551\u7684\u201c\u8baf\u53f7\u201d\uff0c\u6162\u6162\u5730\u4eba\u4eec\u5728\u751f\u6d3b\u5b9e\u8df5\u4e2d\u53d1\u73b0\u4e86\u5b83\u7684\u5b9e\u7528\u4ef7\u503c\uff0c\u4fbf\u628a\u5b83\u4f5c\u4e3a\u4e00\u79cd\u4ea4\u6d41\u5de5\u5177\u4e16\u4ee3\u4f20\u88ad\u4f7f\u7528\u3002\uff08\u56fe\u6587\u6458\u81ea\uff1a http://news.xrxxw.com/newsshow-8018.html \uff09 \u4e00\u4e2a\u5c71\u5934\u547c\u558a\u7684\u58f0\u97f3\u53ef\u4ee5\u88ab\u4e34\u8fd1\u7684\u5c71\u5934\u540c\u65f6\u542c\u5230\u3002\u9898\u76ee\u5047\u8bbe\u6bcf\u4e2a\u5c71\u5934\u6700\u591a\u6709\u4e24\u4e2a\u80fd\u542c\u5230\u5b83\u7684\u4e34\u8fd1\u5c71\u5934\u3002\u7ed9\u5b9a\u4efb\u610f\u4e00\u4e2a\u53d1\u51fa\u539f\u59cb\u4fe1\u53f7\u7684\u5c71\u5934\uff0c\u672c\u9898\u8bf7\u4f60\u627e\u51fa\u8fd9\u4e2a\u4fe1\u53f7\u6700\u8fdc\u80fd\u4f20\u8fbe\u5230\u7684\u5730\u65b9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570 n \u3001 m \u548c k \uff0c\u5176\u4e2d n \uff08 \\le \\le 10000\uff09\u662f\u603b\u7684\u5c71\u5934\u6570\uff08\u4e8e\u662f\u5047\u8bbe\u6bcf\u4e2a\u5c71\u5934\u4ece1\u5230 n \u7f16\u53f7\uff09\u3002\u63a5\u4e0b\u6765\u7684 m \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa2\u4e2a\u4e0d\u8d85\u8fc7 n \u7684\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u5206\u522b\u4ee3\u8868\u53ef\u4ee5\u542c\u5230\u5f7c\u6b64\u7684\u4e24\u4e2a\u5c71\u5934\u7684\u7f16\u53f7\u3002\u8fd9\u91cc\u4fdd\u8bc1\u6bcf\u4e00\u5bf9\u5c71\u5934\u53ea\u88ab\u8f93\u5165\u4e00\u6b21\uff0c\u4e0d\u4f1a\u6709\u91cd\u590d\u7684\u5173\u7cfb\u8f93\u5165\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa k \uff08 \\le \\le 10\uff09\u4e2a\u4e0d\u8d85\u8fc7 n \u7684\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u4ee3\u8868\u9700\u8981\u67e5\u8be2\u7684\u5c71\u5934\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u4f9d\u6b21\u5bf9\u4e8e\u8f93\u5165\u4e2d\u7684\u6bcf\u4e2a\u88ab\u67e5\u8be2\u7684\u5c71\u5934\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5176\u53d1\u51fa\u7684\u547c\u558a\u80fd\u591f\u8fde\u9501\u4f20\u8fbe\u5230\u7684\u6700\u8fdc\u7684\u90a3\u4e2a\u5c71\u5934\u3002\u6ce8\u610f\uff1a\u88ab\u8f93\u51fa\u7684\u9996\u5148\u5fc5\u987b\u662f\u88ab\u67e5\u8be2\u7684\u4e2a\u5c71\u5934\u80fd\u8fde\u9501\u4f20\u5230\u7684\u3002\u82e5\u8fd9\u6837\u7684\u5c71\u5934\u4e0d\u53ea\u4e00\u4e2a\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u82e5\u6b64\u5c71\u5934\u7684\u547c\u558a\u65e0\u6cd5\u4f20\u5230\u4efb\u4f55\u5176\u4ed6\u5c71\u5934\uff0c\u5219\u8f93\u51fa0\u3002 \u8f93\u5165\u6837\u4f8b 7 5 4 1 2 2 3 3 1 4 5 5 6 1 4 5 7 \u8f93\u51fa\u6837\u4f8b 2 6 4 0 Tutorial \u601d\u8def\uff1a \u56e0\u4e3a\u6bcf\u4e2a\u5c71\u5934\u6700\u591a\u6709\u4e24\u4e2a\u80fd\u542c\u5230\u5b83\u7684\u4e34\u8fd1\u5c71\u5934 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7ed9\u6bcf\u4e2a\u5c71\u5934\u90fd\u5206\u914d\u6700\u591a\u4e24\u4e2a\u5b50\u513f\u5b50 \u7136\u540e\u518d\u4ece\u513f\u5b50\u5f80\u4e0b\u627e \u4e00\u5c42\u4e00\u5c42\u5f80\u4e0b\u627e\u5982\u679c\u627e\u7684\u5143\u7d20\u4e4b\u524d\u5df2\u7ecf\u51fa\u73b0\u8fc7, \u8fd9\u4e2a\u5c31\u4e0d\u538b\u5165\u961f\u5217 \u76f4\u5230\u6700\u540e\u961f\u5217\u4e3a\u7a7a, \u8f93\u51fa\u5f53\u5c42\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-3 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int ans ; queue < int > opt ; map < int , int > q , vis ; struct Node { int l , r ; } w [ maxn ]; void bfs ( int cur ) { int len = opt . size (); int Min = INF ; while ( len -- ) { int num = opt . front (); opt . pop (); if ( num < Min ) Min = num ; if ( vis [ w [ num ]. l ] == 0 ) { opt . push ( w [ num ]. l ); vis [ w [ num ]. l ] = 1 ; } if ( vis [ w [ num ]. r ] == 0 ) { opt . push ( w [ num ]. r ); vis [ w [ num ]. r ] = 1 ; } } if ( opt . empty ()) { ans = Min ; return ; } else bfs ( cur + 1 ); } int main () { int n , m , k ; scanf ( \"%d%d%d\" , & n , & m , & k ); int a , b ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); q [ a ] = 1 ; q [ b ] = 1 ; if ( w [ a ]. l ) w [ a ]. r = b ; else w [ a ]. l = b ; if ( w [ b ]. l ) w [ b ]. r = a ; else w [ b ]. l = a ; } for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d\" , & a ); if ( q [ a ] == 0 ) printf ( \"0 \\n \" ); else { vis . clear (); vis [ 0 ] = 1 ; while ( ! opt . empty ()) opt . pop (); if ( w [ a ]. l != 0 ) opt . push ( w [ a ]. l ); if ( w [ a ]. r != 0 ) opt . push ( w [ a ]. r ); vis [ w [ a ]. l ] = 1 ; vis [ w [ a ]. r ] = 1 ; vis [ a ] = 1 ; bfs ( 1 ); printf ( \"%d \\n \" , ans ); } } }","title":"L3-008-\u558a\u5c71"},{"location":"CCCC/L3-008-%E5%96%8A%E5%B1%B1/#l3-008-\u558a\u5c71","text":"","title":"L3-008 \u558a\u5c71"},{"location":"CCCC/L3-008-%E5%96%8A%E5%B1%B1/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u558a\u5c71\uff0c\u662f\u4eba\u53cc\u624b\u56f4\u5728\u5634\u8fb9\u6210\u5587\u53ed\u72b6\uff0c\u5bf9\u7740\u8fdc\u65b9\u9ad8\u5c71\u53d1\u51fa\u201c\u5582\u2014\u5582\u5582\u2014\u5582\u5582\u5582\u2026\u2026\u201d\u7684\u547c\u5524\u3002\u547c\u5524\u58f0\u901a\u8fc7\u7a7a\u6c14\u7684\u4f20\u9012\uff0c\u56de\u8361\u4e8e\u6df1\u8c37\u4e4b\u95f4\uff0c\u4f20\u9001\u5230\u4eba\u4eec\u8033\u4e2d\uff0c\u53d1\u51fa\u7ea6\u5b9a\u4fd7\u6210\u7684\u201c\u8baf\u53f7\u201d\uff0c\u8fbe\u5230\u58f0\u8baf\u4f20\u9012\u4ea4\u6d41\u7684\u76ee\u7684\u3002\u539f\u6765\u5b83\u662f\u5f5d\u65cf\u5148\u6c11\u7528\u6765\u6c42\u63f4\u547c\u6551\u7684\u201c\u8baf\u53f7\u201d\uff0c\u6162\u6162\u5730\u4eba\u4eec\u5728\u751f\u6d3b\u5b9e\u8df5\u4e2d\u53d1\u73b0\u4e86\u5b83\u7684\u5b9e\u7528\u4ef7\u503c\uff0c\u4fbf\u628a\u5b83\u4f5c\u4e3a\u4e00\u79cd\u4ea4\u6d41\u5de5\u5177\u4e16\u4ee3\u4f20\u88ad\u4f7f\u7528\u3002\uff08\u56fe\u6587\u6458\u81ea\uff1a http://news.xrxxw.com/newsshow-8018.html \uff09 \u4e00\u4e2a\u5c71\u5934\u547c\u558a\u7684\u58f0\u97f3\u53ef\u4ee5\u88ab\u4e34\u8fd1\u7684\u5c71\u5934\u540c\u65f6\u542c\u5230\u3002\u9898\u76ee\u5047\u8bbe\u6bcf\u4e2a\u5c71\u5934\u6700\u591a\u6709\u4e24\u4e2a\u80fd\u542c\u5230\u5b83\u7684\u4e34\u8fd1\u5c71\u5934\u3002\u7ed9\u5b9a\u4efb\u610f\u4e00\u4e2a\u53d1\u51fa\u539f\u59cb\u4fe1\u53f7\u7684\u5c71\u5934\uff0c\u672c\u9898\u8bf7\u4f60\u627e\u51fa\u8fd9\u4e2a\u4fe1\u53f7\u6700\u8fdc\u80fd\u4f20\u8fbe\u5230\u7684\u5730\u65b9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6b63\u6574\u6570 n \u3001 m \u548c k \uff0c\u5176\u4e2d n \uff08 \\le \\le 10000\uff09\u662f\u603b\u7684\u5c71\u5934\u6570\uff08\u4e8e\u662f\u5047\u8bbe\u6bcf\u4e2a\u5c71\u5934\u4ece1\u5230 n \u7f16\u53f7\uff09\u3002\u63a5\u4e0b\u6765\u7684 m \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa2\u4e2a\u4e0d\u8d85\u8fc7 n \u7684\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u5206\u522b\u4ee3\u8868\u53ef\u4ee5\u542c\u5230\u5f7c\u6b64\u7684\u4e24\u4e2a\u5c71\u5934\u7684\u7f16\u53f7\u3002\u8fd9\u91cc\u4fdd\u8bc1\u6bcf\u4e00\u5bf9\u5c71\u5934\u53ea\u88ab\u8f93\u5165\u4e00\u6b21\uff0c\u4e0d\u4f1a\u6709\u91cd\u590d\u7684\u5173\u7cfb\u8f93\u5165\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa k \uff08 \\le \\le 10\uff09\u4e2a\u4e0d\u8d85\u8fc7 n \u7684\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u5f00\uff0c\u4ee3\u8868\u9700\u8981\u67e5\u8be2\u7684\u5c71\u5934\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u4f9d\u6b21\u5bf9\u4e8e\u8f93\u5165\u4e2d\u7684\u6bcf\u4e2a\u88ab\u67e5\u8be2\u7684\u5c71\u5934\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5176\u53d1\u51fa\u7684\u547c\u558a\u80fd\u591f\u8fde\u9501\u4f20\u8fbe\u5230\u7684\u6700\u8fdc\u7684\u90a3\u4e2a\u5c71\u5934\u3002\u6ce8\u610f\uff1a\u88ab\u8f93\u51fa\u7684\u9996\u5148\u5fc5\u987b\u662f\u88ab\u67e5\u8be2\u7684\u4e2a\u5c71\u5934\u80fd\u8fde\u9501\u4f20\u5230\u7684\u3002\u82e5\u8fd9\u6837\u7684\u5c71\u5934\u4e0d\u53ea\u4e00\u4e2a\uff0c\u5219\u8f93\u51fa\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u82e5\u6b64\u5c71\u5934\u7684\u547c\u558a\u65e0\u6cd5\u4f20\u5230\u4efb\u4f55\u5176\u4ed6\u5c71\u5934\uff0c\u5219\u8f93\u51fa0\u3002 \u8f93\u5165\u6837\u4f8b 7 5 4 1 2 2 3 3 1 4 5 5 6 1 4 5 7 \u8f93\u51fa\u6837\u4f8b 2 6 4 0","title":"Statement"},{"location":"CCCC/L3-008-%E5%96%8A%E5%B1%B1/#tutorial","text":"\u601d\u8def\uff1a \u56e0\u4e3a\u6bcf\u4e2a\u5c71\u5934\u6700\u591a\u6709\u4e24\u4e2a\u80fd\u542c\u5230\u5b83\u7684\u4e34\u8fd1\u5c71\u5934 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7ed9\u6bcf\u4e2a\u5c71\u5934\u90fd\u5206\u914d\u6700\u591a\u4e24\u4e2a\u5b50\u513f\u5b50 \u7136\u540e\u518d\u4ece\u513f\u5b50\u5f80\u4e0b\u627e \u4e00\u5c42\u4e00\u5c42\u5f80\u4e0b\u627e\u5982\u679c\u627e\u7684\u5143\u7d20\u4e4b\u524d\u5df2\u7ecf\u51fa\u73b0\u8fc7, \u8fd9\u4e2a\u5c31\u4e0d\u538b\u5165\u961f\u5217 \u76f4\u5230\u6700\u540e\u961f\u5217\u4e3a\u7a7a, \u8f93\u51fa\u5f53\u5c42\u7f16\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a","title":"Tutorial"},{"location":"CCCC/L3-008-%E5%96%8A%E5%B1%B1/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-3 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int ans ; queue < int > opt ; map < int , int > q , vis ; struct Node { int l , r ; } w [ maxn ]; void bfs ( int cur ) { int len = opt . size (); int Min = INF ; while ( len -- ) { int num = opt . front (); opt . pop (); if ( num < Min ) Min = num ; if ( vis [ w [ num ]. l ] == 0 ) { opt . push ( w [ num ]. l ); vis [ w [ num ]. l ] = 1 ; } if ( vis [ w [ num ]. r ] == 0 ) { opt . push ( w [ num ]. r ); vis [ w [ num ]. r ] = 1 ; } } if ( opt . empty ()) { ans = Min ; return ; } else bfs ( cur + 1 ); } int main () { int n , m , k ; scanf ( \"%d%d%d\" , & n , & m , & k ); int a , b ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d\" , & a , & b ); q [ a ] = 1 ; q [ b ] = 1 ; if ( w [ a ]. l ) w [ a ]. r = b ; else w [ a ]. l = b ; if ( w [ b ]. l ) w [ b ]. r = a ; else w [ b ]. l = a ; } for ( int i = 0 ; i < k ; i ++ ) { scanf ( \"%d\" , & a ); if ( q [ a ] == 0 ) printf ( \"0 \\n \" ); else { vis . clear (); vis [ 0 ] = 1 ; while ( ! opt . empty ()) opt . pop (); if ( w [ a ]. l != 0 ) opt . push ( w [ a ]. l ); if ( w [ a ]. r != 0 ) opt . push ( w [ a ]. r ); vis [ w [ a ]. l ] = 1 ; vis [ w [ a ]. r ] = 1 ; vis [ a ] = 1 ; bfs ( 1 ); printf ( \"%d \\n \" , ans ); } } }","title":"Solution"},{"location":"CCCC/L3-009-%E9%95%BF%E5%9F%8E/","text":"L3-009 \u957f\u57ce Statement Metadata \u4f5c\u8005: \u9093\u4fca\u8f89 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u6b63\u5982\u6211\u4eec\u6240\u77e5\uff0c\u4e2d\u56fd\u53e4\u4ee3\u957f\u57ce\u7684\u5efa\u9020\u662f\u4e3a\u4e86\u62b5\u5fa1\u5916\u654c\u5165\u4fb5\u3002\u5728\u957f\u57ce\u4e0a\uff0c\u5efa\u9020\u4e86\u8bb8\u591a\u70fd\u706b\u53f0\u3002\u6bcf\u4e2a\u70fd\u706b\u53f0\u90fd\u76d1\u89c6\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u5730\u533a\u8303\u56f4\u3002\u4e00\u65e6\u67d0\u4e2a\u5730\u533a\u6709\u5916\u654c\u5165\u4fb5\uff0c\u503c\u5b88\u5728\u5bf9\u5e94\u70fd\u706b\u53f0\u4e0a\u7684\u58eb\u5175\u5c31\u4f1a\u5c06\u654c\u60c5\u901a\u62a5\u7ed9\u5468\u56f4\u7684\u70fd\u706b\u53f0\uff0c\u5e76\u8fc5\u901f\u63a5\u529b\u5730\u4f20\u9012\u5230\u603b\u90e8\u3002 \u73b0\u5728\u5982\u56fe1\u6240\u793a\uff0c\u82e5\u6c34\u5e73\u4e3a\u5357\u5317\u65b9\u5411\u3001\u5782\u76f4\u4e3a\u6d77\u62d4\u9ad8\u5ea6\u65b9\u5411\uff0c\u5047\u8bbe\u957f\u57ce\u5c31\u662f\u4f9d\u6b21\u76f8\u8054\u7684\u4e00\u7cfb\u5217\u7ebf\u6bb5\uff0c\u800c\u4e14\u5728\u6b64\u8303\u56f4\u5185\u7684\u4efb\u4e00\u5782\u76f4\u7ebf\u4e0e\u8fd9\u4e9b\u7ebf\u6bb5\u6709\u4e14\u4ec5\u6709\u552f\u4e00\u7684\u4ea4\u70b9\u3002 \u56fe 1 \u8fdb\u4e00\u6b65\u5730\uff0c\u5047\u8bbe\u70fd\u706b\u53f0\u53ea\u80fd\u5efa\u9020\u5728\u7ebf\u6bb5\u7684\u7aef\u70b9\u5904\u3002\u6211\u4eec\u8ba4\u4e3a\u70fd\u706b\u53f0\u672c\u8eab\u662f\u6ca1\u6709\u9ad8\u5ea6\u7684\uff0c\u6bcf\u4e2a\u70fd\u706b\u53f0\u53ea\u8d1f\u8d23\u5411\u5317\u65b9\uff08\u56fe1\u4e2d\u5411\u5de6\uff09\u77ad\u671b\uff0c\u800c\u4e14\u4e00\u65e6\u6709\u5916\u654c\u5165\u4fb5\uff0c\u53ea\u8981\u654c\u4eba\u4e0e\u70fd\u706b\u53f0\u4e4b\u95f4\u672a\u88ab\u5c71\u4f53\u906e\u6321\uff0c\u54e8\u5175\u5c31\u4f1a\u7acb\u5373\u5bdf\u89c9\u3002\u5f53\u7136\uff0c\u6309\u7167\u8fd9\u4e00\u519b\u89c4\uff0c\u5bf9\u4e8e\u5357\u4fa7\u7684\u654c\u60c5\u5404\u70fd\u706b\u53f0\u5e76\u4e0d\u8d1f\u8d23\u4efb\u3002\u4e00\u65e6\u54e8\u5175\u53d1\u73b0\u654c\u60c5\uff0c\u4ed6\u5c31\u4f1a\u7acb\u5373\u4ee5\u72fc\u70df\u6216\u70fd\u706b\u7684\u5f62\u5f0f\uff0c\u5411\u5176\u5357\u65b9\u7684\u70fd\u706b\u53f0\u4f20\u9012\u8b66\u62a5\uff0c\u76f4\u5230\u4f4d\u4e8e\u6700\u5357\u4fa7\u7684\u603b\u90e8\u3002 \u4ee5\u56fe2\u4e2d\u7684\u957f\u57ce\u4e3a\u4f8b\uff0c\u8d1f\u8d23\u5b88\u536b\u7684\u56db\u4e2a\u70fd\u706b\u53f0\u7528\u84dd\u767d\u5706\u70b9\u793a\u610f\uff0c\u6700\u5357\u4fa7\u7684\u603b\u90e8\u7528\u7ea2\u8272\u5706\u70b9\u793a\u610f\u3002\u5982\u679c\u7ea2\u8272\u661f\u5f62\u6807\u793a\u7684\u5730\u65b9\u51fa\u73b0\u654c\u60c5\uff0c\u5c06\u88ab\u54e8\u5175\u4eec\u53d1\u73b0\u5e76\u6cbf\u7ea2\u8272\u6298\u7ebf\u5c06\u8b66\u62a5\u4f20\u9012\u5230\u603b\u90e8\u3002\u5f53\u7136\uff0c\u5c31\u8fd9\u4e2a\u4f8b\u5b50\u800c\u8a00\u53ea\u9700\u4e24\u4e2a\u70fd\u706b\u53f0\u7684\u534f\u4f5c\uff0c\u4f46\u5176\u4ed6\u4f4d\u7f6e\u7684\u654c\u60c5\u53ef\u80fd\u9700\u8981\u66f4\u591a\u3002 \u7136\u800c\u53cd\u8fc7\u6765\uff0c\u5373\u4fbf\u8fd9\u91cc\u76844\u4e2a\u70fd\u706b\u53f0\u5168\u90e8\u53c2\u4e0e\uff0c\u4f9d\u7136\u6709\u4e0d\u80fd\u8986\u76d6\u7684\uff08\u9ec4\u8272\uff09\u533a\u57df\u3002 \u56fe 2 \u53e6\u5916\uff0c\u4e3a\u907f\u514d\u6b67\u4e49\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u7ea6\u5b9a\uff0c\u4e0e\u67d0\u4e2a\u70fd\u706b\u53f0\u7684\u89c6\u7ebf\u521a\u597d\u76f8\u5207\u7684\u533a\u57df\u90fd\u8ba4\u4e3a\u53ef\u4ee5\u88ab\u8be5\u70fd\u706b\u53f0\u6240\u76d1\u89c6\u3002\u4ee5\u56fe3\u4e2d\u7684\u957f\u57ce\u4e3a\u4f8b\uff0c\u82e5A\u3001B\u3001C\u3001D\u70b9\u5747\u5171\u7ebf\uff0c\u4e14\u5728D\u70b9\u8bbe\u7f6e\u4e00\u5904\u70fd\u706b\u53f0\uff0c\u5219A\u3001B\u3001C\u4ee5\u53ca\u7ebf\u6bb5BC\u4e0a\u7684\u4efb\u4f55\u4e00\u70b9\u90fd\u5728\u8be5\u70fd\u706b\u53f0\u7684\u76d1\u89c6\u8303\u56f4\u4e4b\u5185\u3002 \u56fe 3 \u597d\u4e86\uff0c\u5018\u82e5\u4f60\u662f\u79e6\u59cb\u7687\u7684\u592a\u5c09\uff0c\u4e3a\u4e0d\u81f4\u51fa\u73b0\u66f4\u591a\u5b5f\u59dc\u5973\u5f0f\u7684\u60b2\u5267\uff0c\u5982\u4f55\u5728\u4fdd\u8bc1\u957f\u57ce\u5b89\u5168\u7684\u524d\u63d0\u4e0b\uff0c\u4f7f\u6d88\u8017\u7684\u6c11\u529b\uff08\u5efa\u9020\u7684\u70fd\u706b\u53f0\uff09\u6700\u5c11\u5462\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff083 \\le \\le N \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u523b\u753b\u957f\u57ce\u8fb9\u7f18\u7684\u6298\u7ebf\u9876\u70b9\uff08\u542b\u8d77\u70b9\u548c\u7ec8\u70b9\uff09\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u9876\u70b9\u7684 x \u548c y \u5750\u6807\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\u9876\u70b9\u4ece\u5357\u5230\u5317\u4f9d\u6b21\u7ed9\u51fa\uff0c\u7b2c\u4e00\u4e2a\u9876\u70b9\u4e3a\u603b\u90e8\u6240\u5728\u4f4d\u7f6e\u3002\u5750\u6807\u4e3a\u533a\u95f4 [-10^9, 10^9) [-10^9, 10^9) \u5185\u7684\u6574\u6570\uff0c\u4e14\u6ca1\u6709\u91cd\u5408\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6240\u9700\u5efa\u9020\u70fd\u706b\u53f0\uff08\u4e0d\u542b\u603b\u90e8\uff09\u7684\u6700\u5c11\u6570\u76ee\u3002 \u8f93\u5165\u6837\u4f8b 10 67 32 48 -49 32 53 22 -44 19 22 11 40 10 -65 -1 -23 -3 31 -7 59 \u8f93\u51fa\u6837\u4f8b 2 Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int n ; int x [ N ], y [ N ]; int sta [ N ], top ; int vis [ N ]; ll Cross ( int a , int b , int c ) { ll X [ 2 ] = { x [ b ] - x [ a ], x [ c ] - x [ a ]}; ll Y [ 2 ] = { y [ b ] - y [ a ], y [ c ] - y [ a ]}; return X [ 0 ] * Y [ 1 ] - X [ 1 ] * Y [ 0 ]; } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = n ; i >= 1 ; -- i ) scanf ( \"%d%d\" , x + i , y + i ); top = 0 ; memset ( vis , 0 , sizeof vis ); for ( int i = n ; i >= 1 ; -- i ) { if ( top >= 1 ) { while ( top >= 2 && Cross ( sta [ top - 1 ], sta [ top ], i ) <= 0 ) -- top ; vis [ sta [ top ]] = 1 ; } sta [ ++ top ] = i ; } printf ( \"%d \\n \" , accumulate ( vis + 1 , vis + 1 + n , 0 ) - 1 ); } return 0 ; }","title":"L3-009-\u957f\u57ce"},{"location":"CCCC/L3-009-%E9%95%BF%E5%9F%8E/#l3-009-\u957f\u57ce","text":"","title":"L3-009 \u957f\u57ce"},{"location":"CCCC/L3-009-%E9%95%BF%E5%9F%8E/#statement","text":"Metadata \u4f5c\u8005: \u9093\u4fca\u8f89 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB \u6b63\u5982\u6211\u4eec\u6240\u77e5\uff0c\u4e2d\u56fd\u53e4\u4ee3\u957f\u57ce\u7684\u5efa\u9020\u662f\u4e3a\u4e86\u62b5\u5fa1\u5916\u654c\u5165\u4fb5\u3002\u5728\u957f\u57ce\u4e0a\uff0c\u5efa\u9020\u4e86\u8bb8\u591a\u70fd\u706b\u53f0\u3002\u6bcf\u4e2a\u70fd\u706b\u53f0\u90fd\u76d1\u89c6\u7740\u4e00\u4e2a\u7279\u5b9a\u7684\u5730\u533a\u8303\u56f4\u3002\u4e00\u65e6\u67d0\u4e2a\u5730\u533a\u6709\u5916\u654c\u5165\u4fb5\uff0c\u503c\u5b88\u5728\u5bf9\u5e94\u70fd\u706b\u53f0\u4e0a\u7684\u58eb\u5175\u5c31\u4f1a\u5c06\u654c\u60c5\u901a\u62a5\u7ed9\u5468\u56f4\u7684\u70fd\u706b\u53f0\uff0c\u5e76\u8fc5\u901f\u63a5\u529b\u5730\u4f20\u9012\u5230\u603b\u90e8\u3002 \u73b0\u5728\u5982\u56fe1\u6240\u793a\uff0c\u82e5\u6c34\u5e73\u4e3a\u5357\u5317\u65b9\u5411\u3001\u5782\u76f4\u4e3a\u6d77\u62d4\u9ad8\u5ea6\u65b9\u5411\uff0c\u5047\u8bbe\u957f\u57ce\u5c31\u662f\u4f9d\u6b21\u76f8\u8054\u7684\u4e00\u7cfb\u5217\u7ebf\u6bb5\uff0c\u800c\u4e14\u5728\u6b64\u8303\u56f4\u5185\u7684\u4efb\u4e00\u5782\u76f4\u7ebf\u4e0e\u8fd9\u4e9b\u7ebf\u6bb5\u6709\u4e14\u4ec5\u6709\u552f\u4e00\u7684\u4ea4\u70b9\u3002 \u56fe 1 \u8fdb\u4e00\u6b65\u5730\uff0c\u5047\u8bbe\u70fd\u706b\u53f0\u53ea\u80fd\u5efa\u9020\u5728\u7ebf\u6bb5\u7684\u7aef\u70b9\u5904\u3002\u6211\u4eec\u8ba4\u4e3a\u70fd\u706b\u53f0\u672c\u8eab\u662f\u6ca1\u6709\u9ad8\u5ea6\u7684\uff0c\u6bcf\u4e2a\u70fd\u706b\u53f0\u53ea\u8d1f\u8d23\u5411\u5317\u65b9\uff08\u56fe1\u4e2d\u5411\u5de6\uff09\u77ad\u671b\uff0c\u800c\u4e14\u4e00\u65e6\u6709\u5916\u654c\u5165\u4fb5\uff0c\u53ea\u8981\u654c\u4eba\u4e0e\u70fd\u706b\u53f0\u4e4b\u95f4\u672a\u88ab\u5c71\u4f53\u906e\u6321\uff0c\u54e8\u5175\u5c31\u4f1a\u7acb\u5373\u5bdf\u89c9\u3002\u5f53\u7136\uff0c\u6309\u7167\u8fd9\u4e00\u519b\u89c4\uff0c\u5bf9\u4e8e\u5357\u4fa7\u7684\u654c\u60c5\u5404\u70fd\u706b\u53f0\u5e76\u4e0d\u8d1f\u8d23\u4efb\u3002\u4e00\u65e6\u54e8\u5175\u53d1\u73b0\u654c\u60c5\uff0c\u4ed6\u5c31\u4f1a\u7acb\u5373\u4ee5\u72fc\u70df\u6216\u70fd\u706b\u7684\u5f62\u5f0f\uff0c\u5411\u5176\u5357\u65b9\u7684\u70fd\u706b\u53f0\u4f20\u9012\u8b66\u62a5\uff0c\u76f4\u5230\u4f4d\u4e8e\u6700\u5357\u4fa7\u7684\u603b\u90e8\u3002 \u4ee5\u56fe2\u4e2d\u7684\u957f\u57ce\u4e3a\u4f8b\uff0c\u8d1f\u8d23\u5b88\u536b\u7684\u56db\u4e2a\u70fd\u706b\u53f0\u7528\u84dd\u767d\u5706\u70b9\u793a\u610f\uff0c\u6700\u5357\u4fa7\u7684\u603b\u90e8\u7528\u7ea2\u8272\u5706\u70b9\u793a\u610f\u3002\u5982\u679c\u7ea2\u8272\u661f\u5f62\u6807\u793a\u7684\u5730\u65b9\u51fa\u73b0\u654c\u60c5\uff0c\u5c06\u88ab\u54e8\u5175\u4eec\u53d1\u73b0\u5e76\u6cbf\u7ea2\u8272\u6298\u7ebf\u5c06\u8b66\u62a5\u4f20\u9012\u5230\u603b\u90e8\u3002\u5f53\u7136\uff0c\u5c31\u8fd9\u4e2a\u4f8b\u5b50\u800c\u8a00\u53ea\u9700\u4e24\u4e2a\u70fd\u706b\u53f0\u7684\u534f\u4f5c\uff0c\u4f46\u5176\u4ed6\u4f4d\u7f6e\u7684\u654c\u60c5\u53ef\u80fd\u9700\u8981\u66f4\u591a\u3002 \u7136\u800c\u53cd\u8fc7\u6765\uff0c\u5373\u4fbf\u8fd9\u91cc\u76844\u4e2a\u70fd\u706b\u53f0\u5168\u90e8\u53c2\u4e0e\uff0c\u4f9d\u7136\u6709\u4e0d\u80fd\u8986\u76d6\u7684\uff08\u9ec4\u8272\uff09\u533a\u57df\u3002 \u56fe 2 \u53e6\u5916\uff0c\u4e3a\u907f\u514d\u6b67\u4e49\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u7ea6\u5b9a\uff0c\u4e0e\u67d0\u4e2a\u70fd\u706b\u53f0\u7684\u89c6\u7ebf\u521a\u597d\u76f8\u5207\u7684\u533a\u57df\u90fd\u8ba4\u4e3a\u53ef\u4ee5\u88ab\u8be5\u70fd\u706b\u53f0\u6240\u76d1\u89c6\u3002\u4ee5\u56fe3\u4e2d\u7684\u957f\u57ce\u4e3a\u4f8b\uff0c\u82e5A\u3001B\u3001C\u3001D\u70b9\u5747\u5171\u7ebf\uff0c\u4e14\u5728D\u70b9\u8bbe\u7f6e\u4e00\u5904\u70fd\u706b\u53f0\uff0c\u5219A\u3001B\u3001C\u4ee5\u53ca\u7ebf\u6bb5BC\u4e0a\u7684\u4efb\u4f55\u4e00\u70b9\u90fd\u5728\u8be5\u70fd\u706b\u53f0\u7684\u76d1\u89c6\u8303\u56f4\u4e4b\u5185\u3002 \u56fe 3 \u597d\u4e86\uff0c\u5018\u82e5\u4f60\u662f\u79e6\u59cb\u7687\u7684\u592a\u5c09\uff0c\u4e3a\u4e0d\u81f4\u51fa\u73b0\u66f4\u591a\u5b5f\u59dc\u5973\u5f0f\u7684\u60b2\u5267\uff0c\u5982\u4f55\u5728\u4fdd\u8bc1\u957f\u57ce\u5b89\u5168\u7684\u524d\u63d0\u4e0b\uff0c\u4f7f\u6d88\u8017\u7684\u6c11\u529b\uff08\u5efa\u9020\u7684\u70fd\u706b\u53f0\uff09\u6700\u5c11\u5462\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff083 \\le \\le N \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u523b\u753b\u957f\u57ce\u8fb9\u7f18\u7684\u6298\u7ebf\u9876\u70b9\uff08\u542b\u8d77\u70b9\u548c\u7ec8\u70b9\uff09\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u9876\u70b9\u7684 x \u548c y \u5750\u6807\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\u9876\u70b9\u4ece\u5357\u5230\u5317\u4f9d\u6b21\u7ed9\u51fa\uff0c\u7b2c\u4e00\u4e2a\u9876\u70b9\u4e3a\u603b\u90e8\u6240\u5728\u4f4d\u7f6e\u3002\u5750\u6807\u4e3a\u533a\u95f4 [-10^9, 10^9) [-10^9, 10^9) \u5185\u7684\u6574\u6570\uff0c\u4e14\u6ca1\u6709\u91cd\u5408\u70b9\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6240\u9700\u5efa\u9020\u70fd\u706b\u53f0\uff08\u4e0d\u542b\u603b\u90e8\uff09\u7684\u6700\u5c11\u6570\u76ee\u3002 \u8f93\u5165\u6837\u4f8b 10 67 32 48 -49 32 53 22 -44 19 22 11 40 10 -65 -1 -23 -3 31 -7 59 \u8f93\u51fa\u6837\u4f8b 2","title":"Statement"},{"location":"CCCC/L3-009-%E9%95%BF%E5%9F%8E/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int n ; int x [ N ], y [ N ]; int sta [ N ], top ; int vis [ N ]; ll Cross ( int a , int b , int c ) { ll X [ 2 ] = { x [ b ] - x [ a ], x [ c ] - x [ a ]}; ll Y [ 2 ] = { y [ b ] - y [ a ], y [ c ] - y [ a ]}; return X [ 0 ] * Y [ 1 ] - X [ 1 ] * Y [ 0 ]; } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = n ; i >= 1 ; -- i ) scanf ( \"%d%d\" , x + i , y + i ); top = 0 ; memset ( vis , 0 , sizeof vis ); for ( int i = n ; i >= 1 ; -- i ) { if ( top >= 1 ) { while ( top >= 2 && Cross ( sta [ top - 1 ], sta [ top ], i ) <= 0 ) -- top ; vis [ sta [ top ]] = 1 ; } sta [ ++ top ] = i ; } printf ( \"%d \\n \" , accumulate ( vis + 1 , vis + 1 + n , 0 ) - 1 ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","text":"L3-010 \u662f\u5426\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c06\u4e00\u7cfb\u5217\u7ed9\u5b9a\u6570\u5b57\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff08\u5b9a\u4e49\u4e3a\u5de6\u5b50\u6811\u952e\u503c\u5927\uff0c\u53f3\u5b50\u6811\u952e\u503c\u5c0f\uff09\uff0c\u4f60\u9700\u8981\u5224\u65ad\u6700\u540e\u7684\u6811\u662f\u5426\u4e00\u68f5\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u5e76\u4e14\u7ed9\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc720\u7684\u6b63\u6574\u6570 N \uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6b63\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5c06\u8f93\u5165\u7684 N \u4e2a\u6b63\u6574\u6570\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff0c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa YES \uff0c\u5982\u679c\u8be5\u6811\u662f\u5b8c\u5168\u4e8c\u53c9\u6811\uff1b\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b1 9 38 45 42 24 58 30 67 12 51 \u8f93\u51fa\u6837\u4f8b1 38 45 24 58 42 30 12 67 51 YES \u8f93\u5165\u6837\u4f8b2 8 38 24 12 45 58 67 42 51 \u8f93\u51fa\u6837\u4f8b2 38 45 24 58 42 12 67 51 NO Tutorial \u601d\u8def\uff1a \u56e0\u4e3a\u662f\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811 \u53ef\u4ee5\u7528\u6570\u5b57\u5efa\u6811\u7684\u65b9\u5f0f, \u7136\u540e\u904d\u5386\u4e00\u904d\u8fd9\u4e2a\u6570\u5b57, \u5c31\u662f\u5c42\u5e8f\u904d\u5386 \u904d\u5386\u7684\u8fc7\u7a0b\u4e2d, \u9700\u8981\u5224\u65ad\u4e00\u4e2a\u4e2d\u95f4\u7684\u4f4d\u7f6e, \u662f\u5426\u6709\u4e00\u4e2a\u4f4d\u7f6e\u662f\u6ca1\u6709\u7ed3\u70b9\u7684 \u5982\u679c\u6709\u5c31\u4e0d\u662f\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811 \u8981\u6ce8\u610f\u8fd9\u4e2a\u6811\u7684\u5b9a\u4e49\u662f\u5de6\u5b50\u6811\u952e\u503c\u6bd4\u53f3\u5b50\u6811\u952e\u503c\u5927 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; int n , l ; int flag ; vector < int > ans ; void Build () { string temp = \"\" ; CLR ( arr ); int num ; scanf ( \"%d\" , & arr [ 1 ]); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); for ( int j = 1 ;;) { if ( arr [ j ] != 0 ) { if ( num < arr [ j ]) j = j * 2 + 1 ; else j *= 2 ; } else { arr [ j ] = num ; if ( j > len ) len = j ; break ; } } } for ( int i = 1 ; i <= len ; i ++ ) { if ( arr [ i ]) ans . pb ( arr [ i ]); else flag = 0 ; } } int main () { scanf ( \"%d\" , & n ); flag = 1 ; Build (); vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( it != ans . begin ()) printf ( \" \" ); printf ( \"%d\" , ( * it )); } printf ( \" \\n \" ); if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); }","title":"L3-010-\u662f\u5426\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811"},{"location":"CCCC/L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#l3-010-\u662f\u5426\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811","text":"","title":"L3-010 \u662f\u5426\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811"},{"location":"CCCC/L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c06\u4e00\u7cfb\u5217\u7ed9\u5b9a\u6570\u5b57\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff08\u5b9a\u4e49\u4e3a\u5de6\u5b50\u6811\u952e\u503c\u5927\uff0c\u53f3\u5b50\u6811\u952e\u503c\u5c0f\uff09\uff0c\u4f60\u9700\u8981\u5224\u65ad\u6700\u540e\u7684\u6811\u662f\u5426\u4e00\u68f5\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u5e76\u4e14\u7ed9\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc720\u7684\u6b63\u6574\u6570 N \uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6b63\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5c06\u8f93\u5165\u7684 N \u4e2a\u6b63\u6574\u6570\u987a\u5e8f\u63d2\u5165\u4e00\u4e2a\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u6811\u7684\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff0c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u7b2c\u4e8c\u884c\u8f93\u51fa YES \uff0c\u5982\u679c\u8be5\u6811\u662f\u5b8c\u5168\u4e8c\u53c9\u6811\uff1b\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b1 9 38 45 42 24 58 30 67 12 51 \u8f93\u51fa\u6837\u4f8b1 38 45 24 58 42 30 12 67 51 YES \u8f93\u5165\u6837\u4f8b2 8 38 24 12 45 58 67 42 51 \u8f93\u51fa\u6837\u4f8b2 38 45 24 58 42 12 67 51 NO","title":"Statement"},{"location":"CCCC/L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#tutorial","text":"\u601d\u8def\uff1a \u56e0\u4e3a\u662f\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811 \u53ef\u4ee5\u7528\u6570\u5b57\u5efa\u6811\u7684\u65b9\u5f0f, \u7136\u540e\u904d\u5386\u4e00\u904d\u8fd9\u4e2a\u6570\u5b57, \u5c31\u662f\u5c42\u5e8f\u904d\u5386 \u904d\u5386\u7684\u8fc7\u7a0b\u4e2d, \u9700\u8981\u5224\u65ad\u4e00\u4e2a\u4e2d\u95f4\u7684\u4f4d\u7f6e, \u662f\u5426\u6709\u4e00\u4e2a\u4f4d\u7f6e\u662f\u6ca1\u6709\u7ed3\u70b9\u7684 \u5982\u679c\u6709\u5c31\u4e0d\u662f\u5b8c\u5168\u4e8c\u53c9\u641c\u7d22\u6811 \u8981\u6ce8\u610f\u8fd9\u4e2a\u6811\u7684\u5b9a\u4e49\u662f\u5de6\u5b50\u6811\u952e\u503c\u6bd4\u53f3\u5b50\u6811\u952e\u503c\u5927","title":"Tutorial"},{"location":"CCCC/L3-010-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e3 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; int n , l ; int flag ; vector < int > ans ; void Build () { string temp = \"\" ; CLR ( arr ); int num ; scanf ( \"%d\" , & arr [ 1 ]); int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); for ( int j = 1 ;;) { if ( arr [ j ] != 0 ) { if ( num < arr [ j ]) j = j * 2 + 1 ; else j *= 2 ; } else { arr [ j ] = num ; if ( j > len ) len = j ; break ; } } } for ( int i = 1 ; i <= len ; i ++ ) { if ( arr [ i ]) ans . pb ( arr [ i ]); else flag = 0 ; } } int main () { scanf ( \"%d\" , & n ); flag = 1 ; Build (); vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( it != ans . begin ()) printf ( \" \" ); printf ( \"%d\" , ( * it )); } printf ( \" \\n \" ); if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); }","title":"Solution"},{"location":"CCCC/L3-011-%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99/","text":"L3-011 \u76f4\u6363\u9ec4\u9f99 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u662f\u4e00\u90e8\u6218\u4e89\u5927\u7247 \u2014\u2014 \u4f60\u9700\u8981\u4ece\u5df1\u65b9\u5927\u672c\u8425\u51fa\u53d1\uff0c\u4e00\u8def\u653b\u57ce\u7565\u5730\u6740\u5230\u654c\u65b9\u5927\u672c\u8425\u3002\u9996\u5148\u65f6\u95f4\u5c31\u662f\u751f\u547d\uff0c\u6240\u4ee5\u4f60\u5fc5\u987b\u9009\u62e9\u5408\u9002\u7684\u8def\u5f84\uff0c\u4ee5\u6700\u5feb\u7684\u901f\u5ea6\u5360\u9886\u654c\u65b9\u5927\u672c\u8425\u3002\u5f53\u8fd9\u6837\u7684\u8def\u5f84\u4e0d\u552f\u4e00\u65f6\uff0c\u8981\u6c42\u9009\u62e9\u53ef\u4ee5\u6cbf\u9014\u89e3\u653e\u6700\u591a\u57ce\u9547\u7684\u8def\u5f84\u3002\u82e5\u8fd9\u6837\u7684\u8def\u5f84\u4e5f\u4e0d\u552f\u4e00\uff0c\u5219\u9009\u62e9\u53ef\u4ee5\u6709\u6548\u6740\u4f24\u6700\u591a\u654c\u519b\u7684\u8def\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570 N\uff082 \\le \\le N \\le \\le 200\uff0c\u57ce\u9547\u603b\u6570\uff09\u548c K\uff08\u57ce\u9547\u95f4\u9053\u8def\u6761\u6570\uff09\uff0c\u4ee5\u53ca\u5df1\u65b9\u5927\u672c\u8425\u548c\u654c\u65b9\u5927\u672c\u8425\u7684\u4ee3\u53f7\u3002\u968f\u540e N-1 \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u9664\u4e86\u5df1\u65b9\u5927\u672c\u8425\u5916\u7684\u4e00\u4e2a\u57ce\u9547\u7684\u4ee3\u53f7\u548c\u9a7b\u5b88\u7684\u654c\u519b\u6570\u91cf\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u518d\u540e\u9762\u6709 K \u884c\uff0c\u6bcf\u884c\u6309\u683c\u5f0f \u57ce\u95471 \u57ce\u95472 \u8ddd\u79bb \u7ed9\u51fa\u4e24\u4e2a\u57ce\u9547\u4e4b\u95f4\u9053\u8def\u7684\u957f\u5ea6\u3002\u8fd9\u91cc\u8bbe\u6bcf\u4e2a\u57ce\u9547\uff08\u5305\u62ec\u53cc\u65b9\u5927\u672c\u8425\uff09\u7684\u4ee3\u53f7\u662f\u7531 3 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u9898\u76ee\u8981\u6c42\u627e\u5230\u6700\u5408\u9002\u7684\u8fdb\u653b\u8def\u5f84\uff08\u9898\u76ee\u4fdd\u8bc1\u901f\u5ea6\u6700\u5feb\u3001\u89e3\u653e\u6700\u591a\u3001\u6740\u4f24\u6700\u5f3a\u7684\u8def\u5f84\u662f\u552f\u4e00\u7684\uff09\uff0c\u5e76\u5728\u7b2c\u4e00\u884c\u6309\u7167\u683c\u5f0f \u5df1\u65b9\u5927\u672c\u8425->\u57ce\u95471->...->\u654c\u65b9\u5927\u672c\u8425 \u8f93\u51fa\u3002\u7b2c\u4e8c\u884c\u987a\u5e8f\u8f93\u51fa\u6700\u5feb\u8fdb\u653b\u8def\u5f84\u7684\u6761\u6570\u3001\u6700\u77ed\u8fdb\u653b\u8ddd\u79bb\u3001\u6b7c\u654c\u603b\u6570\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 12 PAT DBY DBY 100 PTA 20 PDS 90 PMS 40 TAP 50 ATP 200 LNN 80 LAO 30 LON 70 PAT PTA 10 PAT PMS 10 PAT ATP 20 PAT LNN 10 LNN LAO 10 LAO LON 10 LON DBY 10 PMS TAP 10 TAP DBY 10 DBY PDS 10 PDS PTA 10 DBY ATP 10 \u8f93\u51fa\u6837\u4f8b PAT->PTA->PDS->DBY 3 30 210 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 220 struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N * N ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) string name [ N ]; map < string , int > id ; int n , m ; string str [ 2 ]; int st , ed ; int val [ N ]; struct node { int u , a , b , c , fa ; node () {} node ( int u , int a , int b , int c , int fa ) : u ( u ), a ( a ), b ( b ), c ( c ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; if ( b != other . b ) return b < other . b ; return c < other . c ; } }; int dist [ 4 ][ N ]; bool used [ N ]; int pre [ N ]; void Dijkstra () { for ( int i = 1 ; i <= n ; ++ i ) { dist [ 0 ][ i ] = INF ; dist [ 1 ][ i ] = dist [ 2 ][ i ] = - INF ; used [ i ] = 0 ; } dist [ 0 ][ 1 ] = dist [ 1 ][ 1 ] = 0 ; dist [ 2 ][ 1 ] = val [ 1 ]; dist [ 3 ][ 1 ] = 1 ; priority_queue < node > pq ; pq . push ( node ( 1 , 0 , 0 , val [ 1 ], 0 )); vector < int > res ; while ( ! pq . empty ()) { int u = pq . top (). u , fa = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; pre [ u ] = fa ; if ( u == ed ) { int it = u ; while ( it ) { res . push_back ( it ); it = pre [ it ]; } reverse ( res . begin (), res . end ()); break ; } erp ( u ) { if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w ) dist [ 3 ][ v ] += dist [ 3 ][ u ]; if ( dist [ 0 ][ v ] > dist [ 0 ][ u ] + w ) { dist [ 0 ][ v ] = dist [ 0 ][ u ] + w ; dist [ 1 ][ v ] = dist [ 1 ][ u ] + 1 ; dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; dist [ 3 ][ v ] = dist [ 3 ][ u ]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } else if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w && dist [ 1 ][ v ] < dist [ 1 ][ u ] + 1 ) { dist [ 1 ][ v ] = dist [ 1 ][ u ] + 1 ; dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; // dist[3][v] += dist[3][u]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } else if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w && dist [ 1 ][ v ] == dist [ 1 ][ u ] + 1 && dist [ 2 ][ v ] < dist [ 2 ][ u ] + val [ v ]) { dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; // dist[3][v] += dist[3][u]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } } } for ( int i = 0 , len = res . size (); i < len ; ++ i ) { cout << name [ res [ i ]]; if ( i == len - 1 ) cout << \" \\n \" ; else cout << \"->\" ; } cout << dist [ 3 ][ ed ] << \" \" << dist [ 0 ][ ed ] << \" \" << dist [ 2 ][ ed ] << \" \\n \" ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); while ( cin >> n >> m ) { id . clear (); G . init (); cin >> str [ 0 ] >> str [ 1 ]; id [ str [ 0 ]] = 1 ; name [ 1 ] = str [ 0 ]; st = 1 ; ed = -1 ; for ( int i = 2 ; i <= n ; ++ i ) { cin >> name [ i ] >> val [ i ]; id [ name [ i ]] = i ; if ( ed == -1 && str [ 1 ] == name [ i ]) ed = i ; } for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { string a , b ; cin >> a >> b >> w ; u = id [ a ], v = id [ b ]; G . add ( u , v , w ); } Dijkstra (); } return 0 ; }","title":"L3-011-\u76f4\u6363\u9ec4\u9f99"},{"location":"CCCC/L3-011-%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99/#l3-011-\u76f4\u6363\u9ec4\u9f99","text":"","title":"L3-011 \u76f4\u6363\u9ec4\u9f99"},{"location":"CCCC/L3-011-%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u662f\u4e00\u90e8\u6218\u4e89\u5927\u7247 \u2014\u2014 \u4f60\u9700\u8981\u4ece\u5df1\u65b9\u5927\u672c\u8425\u51fa\u53d1\uff0c\u4e00\u8def\u653b\u57ce\u7565\u5730\u6740\u5230\u654c\u65b9\u5927\u672c\u8425\u3002\u9996\u5148\u65f6\u95f4\u5c31\u662f\u751f\u547d\uff0c\u6240\u4ee5\u4f60\u5fc5\u987b\u9009\u62e9\u5408\u9002\u7684\u8def\u5f84\uff0c\u4ee5\u6700\u5feb\u7684\u901f\u5ea6\u5360\u9886\u654c\u65b9\u5927\u672c\u8425\u3002\u5f53\u8fd9\u6837\u7684\u8def\u5f84\u4e0d\u552f\u4e00\u65f6\uff0c\u8981\u6c42\u9009\u62e9\u53ef\u4ee5\u6cbf\u9014\u89e3\u653e\u6700\u591a\u57ce\u9547\u7684\u8def\u5f84\u3002\u82e5\u8fd9\u6837\u7684\u8def\u5f84\u4e5f\u4e0d\u552f\u4e00\uff0c\u5219\u9009\u62e9\u53ef\u4ee5\u6709\u6548\u6740\u4f24\u6700\u591a\u654c\u519b\u7684\u8def\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570 N\uff082 \\le \\le N \\le \\le 200\uff0c\u57ce\u9547\u603b\u6570\uff09\u548c K\uff08\u57ce\u9547\u95f4\u9053\u8def\u6761\u6570\uff09\uff0c\u4ee5\u53ca\u5df1\u65b9\u5927\u672c\u8425\u548c\u654c\u65b9\u5927\u672c\u8425\u7684\u4ee3\u53f7\u3002\u968f\u540e N-1 \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u9664\u4e86\u5df1\u65b9\u5927\u672c\u8425\u5916\u7684\u4e00\u4e2a\u57ce\u9547\u7684\u4ee3\u53f7\u548c\u9a7b\u5b88\u7684\u654c\u519b\u6570\u91cf\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u518d\u540e\u9762\u6709 K \u884c\uff0c\u6bcf\u884c\u6309\u683c\u5f0f \u57ce\u95471 \u57ce\u95472 \u8ddd\u79bb \u7ed9\u51fa\u4e24\u4e2a\u57ce\u9547\u4e4b\u95f4\u9053\u8def\u7684\u957f\u5ea6\u3002\u8fd9\u91cc\u8bbe\u6bcf\u4e2a\u57ce\u9547\uff08\u5305\u62ec\u53cc\u65b9\u5927\u672c\u8425\uff09\u7684\u4ee3\u53f7\u662f\u7531 3 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u9898\u76ee\u8981\u6c42\u627e\u5230\u6700\u5408\u9002\u7684\u8fdb\u653b\u8def\u5f84\uff08\u9898\u76ee\u4fdd\u8bc1\u901f\u5ea6\u6700\u5feb\u3001\u89e3\u653e\u6700\u591a\u3001\u6740\u4f24\u6700\u5f3a\u7684\u8def\u5f84\u662f\u552f\u4e00\u7684\uff09\uff0c\u5e76\u5728\u7b2c\u4e00\u884c\u6309\u7167\u683c\u5f0f \u5df1\u65b9\u5927\u672c\u8425->\u57ce\u95471->...->\u654c\u65b9\u5927\u672c\u8425 \u8f93\u51fa\u3002\u7b2c\u4e8c\u884c\u987a\u5e8f\u8f93\u51fa\u6700\u5feb\u8fdb\u653b\u8def\u5f84\u7684\u6761\u6570\u3001\u6700\u77ed\u8fdb\u653b\u8ddd\u79bb\u3001\u6b7c\u654c\u603b\u6570\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 12 PAT DBY DBY 100 PTA 20 PDS 90 PMS 40 TAP 50 ATP 200 LNN 80 LAO 30 LON 70 PAT PTA 10 PAT PMS 10 PAT ATP 20 PAT LNN 10 LNN LAO 10 LAO LON 10 LON DBY 10 PMS TAP 10 TAP DBY 10 DBY PDS 10 PDS PTA 10 DBY ATP 10 \u8f93\u51fa\u6837\u4f8b PAT->PTA->PDS->DBY 3 30 210","title":"Statement"},{"location":"CCCC/L3-011-%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 220 struct Graph { struct node { int to , nx , w ; node () {} node ( int to , int nx , int w ) : to ( to ), nx ( nx ), w ( w ) {} } a [ N * N ]; int head [ N ], pos ; void init () { memset ( head , 0 , sizeof head ); pos = 0 ; } void add ( int u , int v , int w ) { a [ ++ pos ] = node ( v , head [ u ], w ); head [ u ] = pos ; a [ ++ pos ] = node ( u , head [ v ], w ); head [ v ] = pos ; } } G ; #define erp(u) \\ for (int it = G.head[u], v = G.a[it].to, w = G.a[it].w; it; it = G.a[it].nx, v = G.a[it].to, w = G.a[it].w) string name [ N ]; map < string , int > id ; int n , m ; string str [ 2 ]; int st , ed ; int val [ N ]; struct node { int u , a , b , c , fa ; node () {} node ( int u , int a , int b , int c , int fa ) : u ( u ), a ( a ), b ( b ), c ( c ), fa ( fa ) {} bool operator < ( const node & other ) const { if ( a != other . a ) return a > other . a ; if ( b != other . b ) return b < other . b ; return c < other . c ; } }; int dist [ 4 ][ N ]; bool used [ N ]; int pre [ N ]; void Dijkstra () { for ( int i = 1 ; i <= n ; ++ i ) { dist [ 0 ][ i ] = INF ; dist [ 1 ][ i ] = dist [ 2 ][ i ] = - INF ; used [ i ] = 0 ; } dist [ 0 ][ 1 ] = dist [ 1 ][ 1 ] = 0 ; dist [ 2 ][ 1 ] = val [ 1 ]; dist [ 3 ][ 1 ] = 1 ; priority_queue < node > pq ; pq . push ( node ( 1 , 0 , 0 , val [ 1 ], 0 )); vector < int > res ; while ( ! pq . empty ()) { int u = pq . top (). u , fa = pq . top (). fa ; pq . pop (); if ( used [ u ]) continue ; used [ u ] = 1 ; pre [ u ] = fa ; if ( u == ed ) { int it = u ; while ( it ) { res . push_back ( it ); it = pre [ it ]; } reverse ( res . begin (), res . end ()); break ; } erp ( u ) { if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w ) dist [ 3 ][ v ] += dist [ 3 ][ u ]; if ( dist [ 0 ][ v ] > dist [ 0 ][ u ] + w ) { dist [ 0 ][ v ] = dist [ 0 ][ u ] + w ; dist [ 1 ][ v ] = dist [ 1 ][ u ] + 1 ; dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; dist [ 3 ][ v ] = dist [ 3 ][ u ]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } else if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w && dist [ 1 ][ v ] < dist [ 1 ][ u ] + 1 ) { dist [ 1 ][ v ] = dist [ 1 ][ u ] + 1 ; dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; // dist[3][v] += dist[3][u]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } else if ( dist [ 0 ][ v ] == dist [ 0 ][ u ] + w && dist [ 1 ][ v ] == dist [ 1 ][ u ] + 1 && dist [ 2 ][ v ] < dist [ 2 ][ u ] + val [ v ]) { dist [ 2 ][ v ] = dist [ 2 ][ u ] + val [ v ]; // dist[3][v] += dist[3][u]; pq . push ( node ( v , dist [ 0 ][ v ], dist [ 1 ][ v ], dist [ 2 ][ v ], u )); } } } for ( int i = 0 , len = res . size (); i < len ; ++ i ) { cout << name [ res [ i ]]; if ( i == len - 1 ) cout << \" \\n \" ; else cout << \"->\" ; } cout << dist [ 3 ][ ed ] << \" \" << dist [ 0 ][ ed ] << \" \" << dist [ 2 ][ ed ] << \" \\n \" ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); while ( cin >> n >> m ) { id . clear (); G . init (); cin >> str [ 0 ] >> str [ 1 ]; id [ str [ 0 ]] = 1 ; name [ 1 ] = str [ 0 ]; st = 1 ; ed = -1 ; for ( int i = 2 ; i <= n ; ++ i ) { cin >> name [ i ] >> val [ i ]; id [ name [ i ]] = i ; if ( ed == -1 && str [ 1 ] == name [ i ]) ed = i ; } for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { string a , b ; cin >> a >> b >> w ; u = id [ a ], v = id [ b ]; G . add ( u , v , w ); } Dijkstra (); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-012-%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85/","text":"L3-012 \u6c34\u679c\u5fcd\u8005 Statement Metadata \u4f5c\u8005: \u9093\u4fca\u8f89\u3001\u7f57\u5fc5\u6210 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB 2010\u5e74\u98ce\u9761\u5168\u7403\u7684\u201c\u6c34\u679c\u5fcd\u8005\u201d\u6e38\u620f\uff0c\u60f3\u5fc5\u5927\u5bb6\u80af\u5b9a\u90fd\u73a9\u8fc7\u5427\uff1f\uff08\u6ca1\u73a9\u8fc7\u4e5f\u6ca1\u5173\u7cfb\u5566~\uff09\u5728\u6e38\u620f\u5f53\u4e2d\uff0c\u753b\u9762\u91cc\u4f1a\u968f\u673a\u5730\u5f39\u5c04\u51fa\u4e00\u7cfb\u5217\u7684\u6c34\u679c\u4e0e\u70b8\u5f39\uff0c\u73a9\u5bb6\u5c3d\u53ef\u80fd\u780d\u6389\u6240\u6709\u7684\u6c34\u679c\u800c\u907f\u514d\u780d\u4e2d\u70b8\u5f39\uff0c\u5c31\u53ef\u4ee5\u5b8c\u6210\u6e38\u620f\u89c4\u5b9a\u7684\u4efb\u52a1\u3002\u5982\u679c\u73a9\u5bb6\u53ef\u4ee5\u4e00\u5200\u780d\u4e0b\u753b\u9762\u5f53\u4e2d\u4e00\u8fde\u4e32\u7684\u6c34\u679c\uff0c\u5219\u4f1a\u6709\u989d\u5916\u7684\u5956\u52b1\uff0c\u5982\u56fe1\u6240\u793a\u3002 \u56fe 1 \u73b0\u5728\u5047\u5982\u4f60\u662f\u201c\u6c34\u679c\u5fcd\u8005\u201d\u6e38\u620f\u7684\u73a9\u5bb6\uff0c\u4f60\u8981\u505a\u7684\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\uff0c\u5c06\u753b\u9762\u5f53\u4e2d\u7684\u6c34\u679c\u4e00\u5200\u780d\u4e0b\u3002\u8fd9\u4e2a\u95ee\u9898\u770b\u4e0a\u53bb\u6709\u4e9b\u590d\u6742\uff0c\u8ba9\u6211\u4eec\u628a\u95ee\u9898\u7b80\u5316\u4e00\u4e9b\u3002\u6211\u4eec\u5c06\u6e38\u620f\u4e16\u754c\u60f3\u8c61\u6210\u4e00\u4e2a\u4e8c\u7ef4\u7684\u5e73\u9762\u3002\u6e38\u620f\u5f53\u4e2d\u7684\u6bcf\u4e2a\u6c34\u679c\u88ab\u7b80\u5316\u6210\u4e00\u6761\u4e00\u6761\u7684\u5782\u76f4\u4e8e\u6c34\u5e73\u7ebf\u7684\u7ad6\u76f4\u7ebf\u6bb5\u3002\u800c\u4e00\u5200\u780d\u4e0b\u6211\u4eec\u4e5f\u4ec5\u8003\u8651\u6210\u80fd\u5426\u627e\u5230\u4e00\u6761\u76f4\u7ebf\uff0c\u4f7f\u4e4b\u53ef\u4ee5\u7a7f\u8fc7\u6240\u6709\u4ee3\u8868\u6c34\u679c\u7684\u7ebf\u6bb5\u3002 \u56fe 2 \u5982\u56fe2\u6240\u793a\uff0c\u5176\u4e2d\u7eff\u8272\u7684\u5782\u76f4\u7ebf\u6bb5\u8868\u793a\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u4e2a\u7684\u6c34\u679c\uff1b\u7070\u8272\u7684\u865a\u7ebf\u5373\u8868\u793a\u7a7f\u8fc7\u6240\u6709\u7ebf\u6bb5\u7684\u67d0\u4e00\u6761\u76f4\u7ebf\u3002\u53ef\u4ee5\u4ece\u4e0a\u56fe\u5f53\u4e2d\u770b\u51fa\uff0c\u5bf9\u4e8e\u8fd9\u6837\u4e00\u7ec4\u7ebf\u6bb5\u7684\u6392\u5217\uff0c\u6211\u4eec\u662f\u53ef\u4ee5\u627e\u5230\u4e00\u5200\u5207\u5f00\u6240\u6709\u6c34\u679c\u7684\u65b9\u6848\u7684\u3002 \u53e6\u5916\uff0c\u6211\u4eec\u7ea6\u5b9a\uff0c\u5982\u679c\u67d0\u6761\u76f4\u7ebf\u6070\u597d\u7a7f\u8fc7\u4e86\u7ebf\u6bb5\u7684\u7aef\u70b9\u4e5f\u8868\u793a\u5b83\u780d\u4e2d\u4e86\u8fd9\u4e2a\u7ebf\u6bb5\u6240\u8868\u793a\u7684\u6c34\u679c\u3002\u5047\u5982\u4f60\u662f\u8fd9\u6837\u4e00\u4e2a\u529f\u80fd\u7684\u5f00\u53d1\u8005\uff0c\u4f60\u8981\u5982\u4f55\u6765\u627e\u5230\u4e00\u6761\u7a7f\u8fc7\u5b83\u4eec\u7684\u76f4\u7ebf\u5462\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u8868\u793a\u6c34\u679c\u7684\u4e2a\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e09\u4e2a\u6574\u6570 x x \u3001 y_1 y_1 \u3001 y_2 y_2 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8868\u793a\u4e00\u6761\u7aef\u70b9\u4e3a (x, y_1) (x, y_1) \u548c (x, y_2) (x, y_2) \u7684\u6c34\u679c\uff0c\u5176\u4e2d y_1 > y_2 y_1 > y_2 \u3002\u6ce8\u610f\uff1a\u7ed9\u51fa\u7684\u6c34\u679c\u8f93\u5165\u96c6\u5408\u4e00\u5b9a\u5b58\u5728\u4e00\u6761\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u7a7f\u8fc7\u7684\u76f4\u7ebf\uff0c\u4e0d\u9700\u8003\u8651\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u3002\u5750\u6807\u4e3a\u533a\u95f4 [-10^6, 10^6) [-10^6, 10^6) \u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7a7f\u8fc7\u6240\u6709\u7ebf\u6bb5\u7684\u76f4\u7ebf\u4e0a\u5177\u6709 \u6574\u6570 \u5750\u6807\u7684\u4efb\u610f\u4e24\u70b9 p_1(x_1, y_1) p_1(x_1, y_1) \u548c p_2(x_2, y_2) p_2(x_2, y_2) \uff0c\u683c\u5f0f\u4e3a x_1\\quad y_1\\quad x_2\\quad y_2 x_1\\quad y_1\\quad x_2\\quad y_2 \u3002\u6ce8\u610f\uff1a\u672c\u9898\u7b54\u6848\u4e0d\u552f\u4e00\uff0c\u7531\u7279\u6b8a\u88c1\u5224\u7a0b\u5e8f\u5224\u5b9a\uff0c\u4f46\u4e00\u5b9a\u5b58\u5728\u56db\u4e2a\u5750\u6807\u5168\u662f\u6574\u6570\u7684\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 5 -30 -52 -84 38 22 -49 -99 -22 -99 48 59 -18 -36 -50 -72 \u8f93\u51fa\u6837\u4f8b -99 -99 -30 -52 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define N 10010 const db eps = 1e-8 ; map < int , int > u , d ; vector < int > p ; int n , lx , ly , rx , ry ; int used [ N ]; int sta [ 2 ][ N ], top [ 2 ]; bool Cu ( int x1 , int y1 , int x2 , int y2 ) { return 1l l * x1 * y2 < 1l l * x2 * y1 ; } bool Cd ( int x1 , int y1 , int x2 , int y2 ) { return 1l l * x1 * y2 > 1l l * x2 * y1 ; } db Y ( db k , int x , int x2 , int y2 ) { return k * ( x - x2 ) + y2 ; } bool ok () { if ( rx - lx == 0 ) return 0 ; db k = ( ry - ly ) * 1.0 / ( rx - lx ); for ( int i = 0 , len = p . size (); i < len ; ++ i ) { int x = p [ i ]; db y = Y ( k , x , rx , ry ); if ( y > u [ x ] || y < d [ x ]) return 0 ; } return 1 ; } void solve () { for ( int i = 2 ; i <= top [ 0 ]; ++ i ) { lx = sta [ 0 ][ i - 1 ], ly = u [ lx ]; rx = sta [ 0 ][ i ], ry = u [ rx ]; if ( ok ()) return ; } for ( int i = 2 ; i <= top [ 1 ]; ++ i ) { lx = sta [ 1 ][ i - 1 ], ly = d [ lx ]; rx = sta [ 1 ][ i ], ry = d [ rx ]; if ( ok ()) return ; } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { p . clear (); memset ( used , 0 , sizeof used ); for ( int i = 1 , x , y1 , y2 ; i <= n ; ++ i ) { scanf ( \"%d%d%d\" , & x , & y1 , & y2 ); if ( u . find ( x ) != u . end ()) { u [ x ] = min ( u [ x ], y1 ); d [ x ] = max ( d [ x ], y2 ); } else { p . push_back ( x ); u [ x ] = y1 ; d [ x ] = y2 ; } } if ( p . size () == 1 ) { lx = p [ 0 ]; ly = u [ p [ 0 ]]; rx = p [ 0 ]; ry = d [ p [ 0 ]]; } else { sort ( p . begin (), p . end ()); top [ 0 ] = top [ 1 ] = 0 ; for ( int i = 0 , len = p . size (); i < len ; ++ i ) { int x1 , x2 , x3 = p [ i ]; while ( top [ 0 ] >= 2 ) { x1 = sta [ 0 ][ top [ 0 ] - 1 ], x2 = sta [ 0 ][ top [ 0 ]]; if ( Cu ( x2 - x1 , u [ x2 ] - u [ x1 ], x3 - x2 , u [ x3 ] - u [ x2 ])) -- top [ 0 ]; else break ; } sta [ 0 ][ ++ top [ 0 ]] = x3 ; while ( top [ 1 ] >= 2 ) { x1 = sta [ 1 ][ top [ 1 ] - 1 ], x2 = sta [ 1 ][ top [ 1 ]]; if ( Cd ( x2 - x1 , d [ x2 ] - d [ x1 ], x3 - x2 , d [ x3 ] - d [ x2 ])) -- top [ 1 ]; else break ; } sta [ 1 ][ ++ top [ 1 ]] = x3 ; // printf(\"%d %d\\n\", sta[0][top[0]], sta[1][top[1]]); } solve (); } printf ( \"%d %d %d %d \\n \" , lx , ly , rx , ry ); } return 0 ; }","title":"L3-012-\u6c34\u679c\u5fcd\u8005"},{"location":"CCCC/L3-012-%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85/#l3-012-\u6c34\u679c\u5fcd\u8005","text":"","title":"L3-012 \u6c34\u679c\u5fcd\u8005"},{"location":"CCCC/L3-012-%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85/#statement","text":"Metadata \u4f5c\u8005: \u9093\u4fca\u8f89\u3001\u7f57\u5fc5\u6210 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB 2010\u5e74\u98ce\u9761\u5168\u7403\u7684\u201c\u6c34\u679c\u5fcd\u8005\u201d\u6e38\u620f\uff0c\u60f3\u5fc5\u5927\u5bb6\u80af\u5b9a\u90fd\u73a9\u8fc7\u5427\uff1f\uff08\u6ca1\u73a9\u8fc7\u4e5f\u6ca1\u5173\u7cfb\u5566~\uff09\u5728\u6e38\u620f\u5f53\u4e2d\uff0c\u753b\u9762\u91cc\u4f1a\u968f\u673a\u5730\u5f39\u5c04\u51fa\u4e00\u7cfb\u5217\u7684\u6c34\u679c\u4e0e\u70b8\u5f39\uff0c\u73a9\u5bb6\u5c3d\u53ef\u80fd\u780d\u6389\u6240\u6709\u7684\u6c34\u679c\u800c\u907f\u514d\u780d\u4e2d\u70b8\u5f39\uff0c\u5c31\u53ef\u4ee5\u5b8c\u6210\u6e38\u620f\u89c4\u5b9a\u7684\u4efb\u52a1\u3002\u5982\u679c\u73a9\u5bb6\u53ef\u4ee5\u4e00\u5200\u780d\u4e0b\u753b\u9762\u5f53\u4e2d\u4e00\u8fde\u4e32\u7684\u6c34\u679c\uff0c\u5219\u4f1a\u6709\u989d\u5916\u7684\u5956\u52b1\uff0c\u5982\u56fe1\u6240\u793a\u3002 \u56fe 1 \u73b0\u5728\u5047\u5982\u4f60\u662f\u201c\u6c34\u679c\u5fcd\u8005\u201d\u6e38\u620f\u7684\u73a9\u5bb6\uff0c\u4f60\u8981\u505a\u7684\u4e00\u4ef6\u4e8b\u60c5\u5c31\u662f\uff0c\u5c06\u753b\u9762\u5f53\u4e2d\u7684\u6c34\u679c\u4e00\u5200\u780d\u4e0b\u3002\u8fd9\u4e2a\u95ee\u9898\u770b\u4e0a\u53bb\u6709\u4e9b\u590d\u6742\uff0c\u8ba9\u6211\u4eec\u628a\u95ee\u9898\u7b80\u5316\u4e00\u4e9b\u3002\u6211\u4eec\u5c06\u6e38\u620f\u4e16\u754c\u60f3\u8c61\u6210\u4e00\u4e2a\u4e8c\u7ef4\u7684\u5e73\u9762\u3002\u6e38\u620f\u5f53\u4e2d\u7684\u6bcf\u4e2a\u6c34\u679c\u88ab\u7b80\u5316\u6210\u4e00\u6761\u4e00\u6761\u7684\u5782\u76f4\u4e8e\u6c34\u5e73\u7ebf\u7684\u7ad6\u76f4\u7ebf\u6bb5\u3002\u800c\u4e00\u5200\u780d\u4e0b\u6211\u4eec\u4e5f\u4ec5\u8003\u8651\u6210\u80fd\u5426\u627e\u5230\u4e00\u6761\u76f4\u7ebf\uff0c\u4f7f\u4e4b\u53ef\u4ee5\u7a7f\u8fc7\u6240\u6709\u4ee3\u8868\u6c34\u679c\u7684\u7ebf\u6bb5\u3002 \u56fe 2 \u5982\u56fe2\u6240\u793a\uff0c\u5176\u4e2d\u7eff\u8272\u7684\u5782\u76f4\u7ebf\u6bb5\u8868\u793a\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u4e2a\u7684\u6c34\u679c\uff1b\u7070\u8272\u7684\u865a\u7ebf\u5373\u8868\u793a\u7a7f\u8fc7\u6240\u6709\u7ebf\u6bb5\u7684\u67d0\u4e00\u6761\u76f4\u7ebf\u3002\u53ef\u4ee5\u4ece\u4e0a\u56fe\u5f53\u4e2d\u770b\u51fa\uff0c\u5bf9\u4e8e\u8fd9\u6837\u4e00\u7ec4\u7ebf\u6bb5\u7684\u6392\u5217\uff0c\u6211\u4eec\u662f\u53ef\u4ee5\u627e\u5230\u4e00\u5200\u5207\u5f00\u6240\u6709\u6c34\u679c\u7684\u65b9\u6848\u7684\u3002 \u53e6\u5916\uff0c\u6211\u4eec\u7ea6\u5b9a\uff0c\u5982\u679c\u67d0\u6761\u76f4\u7ebf\u6070\u597d\u7a7f\u8fc7\u4e86\u7ebf\u6bb5\u7684\u7aef\u70b9\u4e5f\u8868\u793a\u5b83\u780d\u4e2d\u4e86\u8fd9\u4e2a\u7ebf\u6bb5\u6240\u8868\u793a\u7684\u6c34\u679c\u3002\u5047\u5982\u4f60\u662f\u8fd9\u6837\u4e00\u4e2a\u529f\u80fd\u7684\u5f00\u53d1\u8005\uff0c\u4f60\u8981\u5982\u4f55\u6765\u627e\u5230\u4e00\u6761\u7a7f\u8fc7\u5b83\u4eec\u7684\u76f4\u7ebf\u5462\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u8868\u793a\u6c34\u679c\u7684\u4e2a\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e09\u4e2a\u6574\u6570 x x \u3001 y_1 y_1 \u3001 y_2 y_2 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8868\u793a\u4e00\u6761\u7aef\u70b9\u4e3a (x, y_1) (x, y_1) \u548c (x, y_2) (x, y_2) \u7684\u6c34\u679c\uff0c\u5176\u4e2d y_1 > y_2 y_1 > y_2 \u3002\u6ce8\u610f\uff1a\u7ed9\u51fa\u7684\u6c34\u679c\u8f93\u5165\u96c6\u5408\u4e00\u5b9a\u5b58\u5728\u4e00\u6761\u53ef\u4ee5\u5c06\u5176\u5168\u90e8\u7a7f\u8fc7\u7684\u76f4\u7ebf\uff0c\u4e0d\u9700\u8003\u8651\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u3002\u5750\u6807\u4e3a\u533a\u95f4 [-10^6, 10^6) [-10^6, 10^6) \u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7a7f\u8fc7\u6240\u6709\u7ebf\u6bb5\u7684\u76f4\u7ebf\u4e0a\u5177\u6709 \u6574\u6570 \u5750\u6807\u7684\u4efb\u610f\u4e24\u70b9 p_1(x_1, y_1) p_1(x_1, y_1) \u548c p_2(x_2, y_2) p_2(x_2, y_2) \uff0c\u683c\u5f0f\u4e3a x_1\\quad y_1\\quad x_2\\quad y_2 x_1\\quad y_1\\quad x_2\\quad y_2 \u3002\u6ce8\u610f\uff1a\u672c\u9898\u7b54\u6848\u4e0d\u552f\u4e00\uff0c\u7531\u7279\u6b8a\u88c1\u5224\u7a0b\u5e8f\u5224\u5b9a\uff0c\u4f46\u4e00\u5b9a\u5b58\u5728\u56db\u4e2a\u5750\u6807\u5168\u662f\u6574\u6570\u7684\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 5 -30 -52 -84 38 22 -49 -99 -22 -99 48 59 -18 -36 -50 -72 \u8f93\u51fa\u6837\u4f8b -99 -99 -30 -52","title":"Statement"},{"location":"CCCC/L3-012-%E6%B0%B4%E6%9E%9C%E5%BF%8D%E8%80%85/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define N 10010 const db eps = 1e-8 ; map < int , int > u , d ; vector < int > p ; int n , lx , ly , rx , ry ; int used [ N ]; int sta [ 2 ][ N ], top [ 2 ]; bool Cu ( int x1 , int y1 , int x2 , int y2 ) { return 1l l * x1 * y2 < 1l l * x2 * y1 ; } bool Cd ( int x1 , int y1 , int x2 , int y2 ) { return 1l l * x1 * y2 > 1l l * x2 * y1 ; } db Y ( db k , int x , int x2 , int y2 ) { return k * ( x - x2 ) + y2 ; } bool ok () { if ( rx - lx == 0 ) return 0 ; db k = ( ry - ly ) * 1.0 / ( rx - lx ); for ( int i = 0 , len = p . size (); i < len ; ++ i ) { int x = p [ i ]; db y = Y ( k , x , rx , ry ); if ( y > u [ x ] || y < d [ x ]) return 0 ; } return 1 ; } void solve () { for ( int i = 2 ; i <= top [ 0 ]; ++ i ) { lx = sta [ 0 ][ i - 1 ], ly = u [ lx ]; rx = sta [ 0 ][ i ], ry = u [ rx ]; if ( ok ()) return ; } for ( int i = 2 ; i <= top [ 1 ]; ++ i ) { lx = sta [ 1 ][ i - 1 ], ly = d [ lx ]; rx = sta [ 1 ][ i ], ry = d [ rx ]; if ( ok ()) return ; } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { p . clear (); memset ( used , 0 , sizeof used ); for ( int i = 1 , x , y1 , y2 ; i <= n ; ++ i ) { scanf ( \"%d%d%d\" , & x , & y1 , & y2 ); if ( u . find ( x ) != u . end ()) { u [ x ] = min ( u [ x ], y1 ); d [ x ] = max ( d [ x ], y2 ); } else { p . push_back ( x ); u [ x ] = y1 ; d [ x ] = y2 ; } } if ( p . size () == 1 ) { lx = p [ 0 ]; ly = u [ p [ 0 ]]; rx = p [ 0 ]; ry = d [ p [ 0 ]]; } else { sort ( p . begin (), p . end ()); top [ 0 ] = top [ 1 ] = 0 ; for ( int i = 0 , len = p . size (); i < len ; ++ i ) { int x1 , x2 , x3 = p [ i ]; while ( top [ 0 ] >= 2 ) { x1 = sta [ 0 ][ top [ 0 ] - 1 ], x2 = sta [ 0 ][ top [ 0 ]]; if ( Cu ( x2 - x1 , u [ x2 ] - u [ x1 ], x3 - x2 , u [ x3 ] - u [ x2 ])) -- top [ 0 ]; else break ; } sta [ 0 ][ ++ top [ 0 ]] = x3 ; while ( top [ 1 ] >= 2 ) { x1 = sta [ 1 ][ top [ 1 ] - 1 ], x2 = sta [ 1 ][ top [ 1 ]]; if ( Cd ( x2 - x1 , d [ x2 ] - d [ x1 ], x3 - x2 , d [ x3 ] - d [ x2 ])) -- top [ 1 ]; else break ; } sta [ 1 ][ ++ top [ 1 ]] = x3 ; // printf(\"%d %d\\n\", sta[0][top[0]], sta[1][top[1]]); } solve (); } printf ( \"%d %d %d %d \\n \" , lx , ly , rx , ry ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-013-%E9%9D%9E%E5%B8%B8%E5%BC%B9%E7%9A%84%E7%90%83/","text":"L3-013 \u975e\u5e38\u5f39\u7684\u7403 Statement Metadata \u4f5c\u8005: \u4fde\u52c7 \u5355\u4f4d: \u4e0a\u6d77\u4ea4\u901a\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u521a\u4e0a\u9ad8\u4e00\u7684\u68ee\u68ee\u4e3a\u4e86\u5b66\u597d\u7269\u7406\uff0c\u4e70\u4e86\u4e00\u4e2a\u201c\u975e\u5e38\u5f39\u201d\u7684\u7403\u3002\u867d\u7136\u8bf4\u662f\u975e\u5e38\u5f39\u7684\u7403\uff0c\u5176\u5b9e\u4e5f\u5c31\u662f\u4e00\u822c\u7684\u5f39\u529b\u7403\u800c\u5df2\u3002\u68ee\u68ee\u73a9\u4e86\u4e00\u4f1a\u513f\u5f39\u529b\u7403\u540e\u7a81\u7136\u60f3\u5230\uff0c\u5047\u5982\u4ed6\u5728\u5730\u4e0a\u7528\u529b\u5f39\u7403\uff0c\u7403\u6700\u8fdc\u80fd\u5f39\u5230\u591a\u8fdc\u53bb\u5462\uff1f\u4ed6\u4e0d\u592a\u4f1a\uff0c\u4f60\u80fd\u5e2e\u4ed6\u89e3\u51b3\u5417\uff1f\u5f53\u7136\u4e3a\u4e86\u521a\u5b66\u4e60\u7269\u7406\u7684\u68ee\u68ee\uff0c\u6211\u4eec\u5bf9\u73af\u5883\u505a\u4e00\u4e9b\u7b80\u5316\uff1a \u5047\u8bbe\u68ee\u68ee\u662f\u4e00\u4e2a\u8d28\u70b9\uff0c\u4ee5\u68ee\u68ee\u4e3a\u539f\u70b9\u8bbe\u7acb\u5750\u6807\u8f74\uff0c\u5219\u68ee\u68ee\u4f4d\u4e8e(0, 0)\u70b9\u3002 \u5c0f\u7403\u8d28\u91cf\u4e3a w/100 w/100 \u5343\u514b\uff08kg\uff09\uff0c\u91cd\u529b\u52a0\u901f\u5ea6\u4e3a9.8\u7c73/\u79d2\u5e73\u65b9\uff08 m/s^2 m/s^2 \uff09\u3002 \u68ee\u68ee\u5728\u5730\u4e0a\u7528\u529b\u5f39\u7403\u7684\u8fc7\u7a0b\u53ef\u7b80\u5316\u4e3a\u7403\u4ece(0, 0)\u70b9\u4ee5\u67d0\u4e2a\u68ee\u68ee\u9009\u62e9\u7684\u89d2\u5ea6 ang ang ( 0 < ang < \\pi/2 0 < ang < \\pi/2 ) \u5411\u7b2c\u4e00\u8c61\u9650\u629b\u51fa\uff0c\u629b\u51fa\u65f6\u5047\u8bbe\u52a8\u80fd\u4e3a1000 \u7126\u8033\uff08J\uff09\u3002 \u5c0f\u7403\u5728\u7a7a\u4e2d\u4ec5\u53d7\u91cd\u529b\u4f5c\u7528\uff0c\u7403\u7eb5\u5750\u6807\u4e3a0\u65f6\u53ef\u89c6\u4f5c\u843d\u5730\uff0c\u843d\u5730\u65f6\u635f\u5931 p\\% p\\% \u52a8\u80fd\u5e76\u53cd\u5f39\u3002 \u5730\u9762\u53ef\u89c6\u4e3a\u521a\u4f53\uff0c\u5ffd\u7565\u5c0f\u7403\u5f62\u72b6\u3001\u7a7a\u6c14\u963b\u529b\u53ca\u6469\u64e6\u963b\u529b\u7b49\u3002 \u68ee\u68ee\u4e3a\u4f60\u51c6\u5907\u7684\u516c\u5f0f\uff1a \u52a8\u80fd\u516c\u5f0f\uff1a E = m\\times v^2 / 2 E = m\\times v^2 / 2 \u725b\u987f\u529b\u5b66\u516c\u5f0f\uff1a F = m\\times a F = m\\times a \u91cd\u529b\uff1a G = m\\times g G = m\\times g \u5176\u4e2d\uff1a E E - \u52a8\u80fd\uff0c\u5355\u4f4d\u4e3a\u201c\u7126\u8033\u201d m m - \u8d28\u91cf\uff0c\u5355\u4f4d\u4e3a\u201c\u5343\u514b\u201d v v - \u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u201c\u7c73/\u79d2\u201d a a - \u52a0\u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u201c\u7c73/\u79d2\u5e73\u65b9\u201d g g - \u91cd\u529b\u52a0\u901f\u5ea6 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570\uff1a 1 \\le w \\le 1000 1 \\le w \\le 1000 \u548c 1 \\le p \\le 100 1 \\le p \\le 100 \uff0c\u5206\u522b\u8868\u793a\u653e\u5927100\u500d\u7684\u5c0f\u7403\u8d28\u91cf\u3001\u4ee5\u53ca\u635f\u5931\u52a8\u529b\u7684\u767e\u5206\u6bd4 p p \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u8f93\u51fa\u6700\u8fdc\u7684\u6295\u63b7\u8ddd\u79bb\uff0c\u4fdd\u75593\u4f4d\u5c0f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 100 90 \u8f93\u51fa\u6837\u4f8b 226.757 Tutorial \u601d\u8def\uff1a \u5c06\u901f\u5ea6\u5206\u89e3\u6210\u7ad6\u76f4\u65b9\u5411\u548c\u5782\u76f4\u65b9\u5411 \u5f53\u89d2\u5ea6\u4e3a 45\u00b0 45\u00b0 \u65f6, \u5c04\u51fa\u7684\u65f6\u5019\u6c34\u5e73\u65b9\u5411\u6700\u8fdc \u6240\u4ee5\u53ef\u4ee5\u5c06\u7ad6\u76f4\u65b9\u5411\u7684\u901f\u5ea6\u548c\u5782\u76f4\u65b9\u5411\u7684\u901f\u5ea6\u770b\u6210\u662f\u4e00\u6837\u7684 \u7136\u540e\u6bcf\u6b21\u5faa\u73af, \u7b97\u51fa\u901f\u5ea6\u548c\u65f6\u95f4 \u66f4\u65b0\u7b54\u6848 \u7136\u540e\u754c\u5b9a\u4e00\u4e2a\u9608\u503c\u8df3\u51fa\u5c31\u53ef\u4ee5 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const double G = 9.8 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int main () { int w , p ; scanf ( \"%d%d\" , & w , & p ); double m = 1000.0 ; double sun = p * 1.0 / 100 ; sun = 1 - sun ; double weight = w * 1.0 / 100 ; double ans = 0.0 ; while ( 1 ) { double v = sqrt ( m * 1.0 / weight ); double t = 2 * v / G ; m *= sun ; ans += v * t ; if ( t < eps ) break ; } printf ( \"%.3lf \\n \" , ans ); }","title":"L3-013-\u975e\u5e38\u5f39\u7684\u7403"},{"location":"CCCC/L3-013-%E9%9D%9E%E5%B8%B8%E5%BC%B9%E7%9A%84%E7%90%83/#l3-013-\u975e\u5e38\u5f39\u7684\u7403","text":"","title":"L3-013 \u975e\u5e38\u5f39\u7684\u7403"},{"location":"CCCC/L3-013-%E9%9D%9E%E5%B8%B8%E5%BC%B9%E7%9A%84%E7%90%83/#statement","text":"Metadata \u4f5c\u8005: \u4fde\u52c7 \u5355\u4f4d: \u4e0a\u6d77\u4ea4\u901a\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u521a\u4e0a\u9ad8\u4e00\u7684\u68ee\u68ee\u4e3a\u4e86\u5b66\u597d\u7269\u7406\uff0c\u4e70\u4e86\u4e00\u4e2a\u201c\u975e\u5e38\u5f39\u201d\u7684\u7403\u3002\u867d\u7136\u8bf4\u662f\u975e\u5e38\u5f39\u7684\u7403\uff0c\u5176\u5b9e\u4e5f\u5c31\u662f\u4e00\u822c\u7684\u5f39\u529b\u7403\u800c\u5df2\u3002\u68ee\u68ee\u73a9\u4e86\u4e00\u4f1a\u513f\u5f39\u529b\u7403\u540e\u7a81\u7136\u60f3\u5230\uff0c\u5047\u5982\u4ed6\u5728\u5730\u4e0a\u7528\u529b\u5f39\u7403\uff0c\u7403\u6700\u8fdc\u80fd\u5f39\u5230\u591a\u8fdc\u53bb\u5462\uff1f\u4ed6\u4e0d\u592a\u4f1a\uff0c\u4f60\u80fd\u5e2e\u4ed6\u89e3\u51b3\u5417\uff1f\u5f53\u7136\u4e3a\u4e86\u521a\u5b66\u4e60\u7269\u7406\u7684\u68ee\u68ee\uff0c\u6211\u4eec\u5bf9\u73af\u5883\u505a\u4e00\u4e9b\u7b80\u5316\uff1a \u5047\u8bbe\u68ee\u68ee\u662f\u4e00\u4e2a\u8d28\u70b9\uff0c\u4ee5\u68ee\u68ee\u4e3a\u539f\u70b9\u8bbe\u7acb\u5750\u6807\u8f74\uff0c\u5219\u68ee\u68ee\u4f4d\u4e8e(0, 0)\u70b9\u3002 \u5c0f\u7403\u8d28\u91cf\u4e3a w/100 w/100 \u5343\u514b\uff08kg\uff09\uff0c\u91cd\u529b\u52a0\u901f\u5ea6\u4e3a9.8\u7c73/\u79d2\u5e73\u65b9\uff08 m/s^2 m/s^2 \uff09\u3002 \u68ee\u68ee\u5728\u5730\u4e0a\u7528\u529b\u5f39\u7403\u7684\u8fc7\u7a0b\u53ef\u7b80\u5316\u4e3a\u7403\u4ece(0, 0)\u70b9\u4ee5\u67d0\u4e2a\u68ee\u68ee\u9009\u62e9\u7684\u89d2\u5ea6 ang ang ( 0 < ang < \\pi/2 0 < ang < \\pi/2 ) \u5411\u7b2c\u4e00\u8c61\u9650\u629b\u51fa\uff0c\u629b\u51fa\u65f6\u5047\u8bbe\u52a8\u80fd\u4e3a1000 \u7126\u8033\uff08J\uff09\u3002 \u5c0f\u7403\u5728\u7a7a\u4e2d\u4ec5\u53d7\u91cd\u529b\u4f5c\u7528\uff0c\u7403\u7eb5\u5750\u6807\u4e3a0\u65f6\u53ef\u89c6\u4f5c\u843d\u5730\uff0c\u843d\u5730\u65f6\u635f\u5931 p\\% p\\% \u52a8\u80fd\u5e76\u53cd\u5f39\u3002 \u5730\u9762\u53ef\u89c6\u4e3a\u521a\u4f53\uff0c\u5ffd\u7565\u5c0f\u7403\u5f62\u72b6\u3001\u7a7a\u6c14\u963b\u529b\u53ca\u6469\u64e6\u963b\u529b\u7b49\u3002 \u68ee\u68ee\u4e3a\u4f60\u51c6\u5907\u7684\u516c\u5f0f\uff1a \u52a8\u80fd\u516c\u5f0f\uff1a E = m\\times v^2 / 2 E = m\\times v^2 / 2 \u725b\u987f\u529b\u5b66\u516c\u5f0f\uff1a F = m\\times a F = m\\times a \u91cd\u529b\uff1a G = m\\times g G = m\\times g \u5176\u4e2d\uff1a E E - \u52a8\u80fd\uff0c\u5355\u4f4d\u4e3a\u201c\u7126\u8033\u201d m m - \u8d28\u91cf\uff0c\u5355\u4f4d\u4e3a\u201c\u5343\u514b\u201d v v - \u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u201c\u7c73/\u79d2\u201d a a - \u52a0\u901f\u5ea6\uff0c\u5355\u4f4d\u4e3a\u201c\u7c73/\u79d2\u5e73\u65b9\u201d g g - \u91cd\u529b\u52a0\u901f\u5ea6 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570\uff1a 1 \\le w \\le 1000 1 \\le w \\le 1000 \u548c 1 \\le p \\le 100 1 \\le p \\le 100 \uff0c\u5206\u522b\u8868\u793a\u653e\u5927100\u500d\u7684\u5c0f\u7403\u8d28\u91cf\u3001\u4ee5\u53ca\u635f\u5931\u52a8\u529b\u7684\u767e\u5206\u6bd4 p p \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u8f93\u51fa\u6700\u8fdc\u7684\u6295\u63b7\u8ddd\u79bb\uff0c\u4fdd\u75593\u4f4d\u5c0f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 100 90 \u8f93\u51fa\u6837\u4f8b 226.757","title":"Statement"},{"location":"CCCC/L3-013-%E9%9D%9E%E5%B8%B8%E5%BC%B9%E7%9A%84%E7%90%83/#tutorial","text":"\u601d\u8def\uff1a \u5c06\u901f\u5ea6\u5206\u89e3\u6210\u7ad6\u76f4\u65b9\u5411\u548c\u5782\u76f4\u65b9\u5411 \u5f53\u89d2\u5ea6\u4e3a 45\u00b0 45\u00b0 \u65f6, \u5c04\u51fa\u7684\u65f6\u5019\u6c34\u5e73\u65b9\u5411\u6700\u8fdc \u6240\u4ee5\u53ef\u4ee5\u5c06\u7ad6\u76f4\u65b9\u5411\u7684\u901f\u5ea6\u548c\u5782\u76f4\u65b9\u5411\u7684\u901f\u5ea6\u770b\u6210\u662f\u4e00\u6837\u7684 \u7136\u540e\u6bcf\u6b21\u5faa\u73af, \u7b97\u51fa\u901f\u5ea6\u548c\u65f6\u95f4 \u66f4\u65b0\u7b54\u6848 \u7136\u540e\u754c\u5b9a\u4e00\u4e2a\u9608\u503c\u8df3\u51fa\u5c31\u53ef\u4ee5","title":"Tutorial"},{"location":"CCCC/L3-013-%E9%9D%9E%E5%B8%B8%E5%BC%B9%E7%9A%84%E7%90%83/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const double G = 9.8 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e6 + 5 ; const int MOD = 1e9 + 7 ; int main () { int w , p ; scanf ( \"%d%d\" , & w , & p ); double m = 1000.0 ; double sun = p * 1.0 / 100 ; sun = 1 - sun ; double weight = w * 1.0 / 100 ; double ans = 0.0 ; while ( 1 ) { double v = sqrt ( m * 1.0 / weight ); double t = 2 * v / G ; m *= sun ; ans += v * t ; if ( t < eps ) break ; } printf ( \"%.3lf \\n \" , ans ); }","title":"Solution"},{"location":"CCCC/L3-014-%E5%91%A8%E6%B8%B8%E4%B8%96%E7%95%8C/","text":"L3-014 \u5468\u6e38\u4e16\u754c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5468\u6e38\u4e16\u754c\u662f\u4ef6\u6d6a\u6f2b\u4e8b\uff0c\u4f46\u89c4\u5212\u65c5\u884c\u8def\u7ebf\u5c31\u4e0d\u4e00\u5b9a\u4e86\u2026\u2026 \u5168\u4e16\u754c\u6709\u6210\u5343\u4e0a\u4e07\u6761\u822a\u7ebf\u3001\u94c1\u8def\u7ebf\u3001\u5927\u5df4\u7ebf\uff0c\u4ee4\u4eba\u773c\u82b1\u7f2d\u4e71\u3002\u6240\u4ee5\u65c5\u884c\u793e\u4f1a\u9009\u62e9\u90e8\u5206\u8fd0\u8f93\u516c\u53f8\u7ec4\u6210\u8054\u76df\uff0c\u6bcf\u5bb6\u516c\u53f8\u63d0\u4f9b\u4e00\u6761\u7ebf\u8def\uff0c\u7136\u540e\u5e2e\u52a9\u5ba2\u6237\u89c4\u5212\u7531\u8054\u76df\u5185\u4f01\u4e1a\u652f\u6301\u7684\u65c5\u884c\u8def\u7ebf\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5e2e\u65c5\u884c\u793e\u5b9e\u73b0\u4e00\u4e2a\u81ea\u52a8\u89c4\u5212\u8def\u7ebf\u7684\u7a0b\u5e8f\uff0c\u4f7f\u5f97\u5bf9\u4efb\u4f55\u7ed9\u5b9a\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\uff0c\u53ef\u4ee5\u627e\u51fa\u6700\u987a\u7545\u7684\u8def\u7ebf\u3002\u6240\u8c13\u201c\u6700\u987a\u7545\u201d\uff0c\u9996\u5148\u662f\u6307\u4e2d\u9014\u7ecf\u505c\u7ad9\u6700\u5c11\uff1b\u5982\u679c\u7ecf\u505c\u7ad9\u4e00\u6837\u591a\uff0c\u5219\u53d6\u9700\u8981\u6362\u4e58\u7ebf\u8def\u6b21\u6570\u6700\u5c11\u7684\u8def\u7ebf\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u5373\u8054\u76df\u516c\u53f8\u7684\u6570\u91cf\u3002\u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u7b2c i i \u884c\uff08 i=1, \\cdots , N i=1, \\cdots , N \uff09\u63cf\u8ff0\u4e86\u7b2c i i \u5bb6\u516c\u53f8\u6240\u63d0\u4f9b\u7684\u7ebf\u8def\u3002\u683c\u5f0f\u4e3a\uff1a M M S[1] S[2] \\cdots \\cdots S[ M M ] \u5176\u4e2d M M \uff08 \\le 100 \\le 100 \uff09\u662f\u7ecf\u505c\u7ad9\u7684\u6570\u91cf\uff0cS[ i i ]\uff08 i=1, \\cdots , M i=1, \\cdots , M \uff09\u662f\u7ecf\u505c\u7ad9\u7684\u7f16\u53f7\uff08\u75314\u4f4d0-9\u7684\u6570\u5b57\u7ec4\u6210\uff09\u3002\u8fd9\u91cc\u5047\u8bbe\u6bcf\u6761\u7ebf\u8def\u90fd\u662f\u7b80\u5355\u7684\u4e00\u6761\u53ef\u4ee5\u53cc\u5411\u8fd0\u884c\u7684\u94fe\u8def\uff0c\u5e76\u4e14\u8f93\u5165\u4fdd\u8bc1\u662f\u6309\u7167\u6b63\u786e\u7684\u7ecf\u505c\u987a\u5e8f\u7ed9\u51fa\u7684 \u2014\u2014 \u4e5f\u5c31\u662f\u8bf4\uff0c\u4efb\u610f\u4e00\u5bf9\u76f8\u90bb\u7684S[ i i ]\u548cS[ i+1 i+1 ]\uff08 i=1, \\cdots , M-1 i=1, \\cdots , M-1 \uff09\u4e4b\u95f4\u90fd\u4e0d\u5b58\u5728\u5176\u4ed6\u7ecf\u505c\u7ad9\u70b9\u3002\u6211\u4eec\u79f0\u76f8\u90bb\u7ad9\u70b9\u4e4b\u95f4\u7684\u7ebf\u8def\u4e3a\u4e00\u4e2a\u8fd0\u8425\u533a\u95f4\uff0c\u6bcf\u4e2a\u8fd0\u8425\u533a\u95f4\u53ea\u627f\u5305\u7ed9\u4e00\u5bb6\u516c\u53f8\u3002\u73af\u7ebf\u662f\u6709\u53ef\u80fd\u5b58\u5728\u7684\uff0c\u4f46\u4e0d\u4f1a\u4e0d\u7ecf\u505c\u4efb\u4f55\u4e2d\u95f4\u7ad9\u70b9\u5c31\u4ece\u51fa\u53d1\u5730\u56de\u5230\u51fa\u53d1\u5730\u3002\u5f53\u7136\uff0c\u4e0d\u540c\u516c\u53f8\u7684\u7ebf\u8def\u662f\u53ef\u80fd\u5728\u67d0\u4e9b\u7ad9\u70b9\u6709\u4ea4\u53c9\u7684\uff0c\u8fd9\u4e9b\u7ad9\u70b9\u5c31\u662f\u5ba2\u6237\u7684\u6362\u4e58\u70b9\uff0c\u6211\u4eec\u5047\u8bbe\u4efb\u610f\u6362\u4e58\u70b9\u6d89\u53ca\u7684\u4e0d\u540c\u516c\u53f8\u7684\u7ebf\u8def\u90fd\u4e0d\u8d85\u8fc75\u6761\u3002 \u5728\u63cf\u8ff0\u4e86\u8054\u76df\u7ebf\u8def\u4e4b\u540e\uff0c\u9898\u76ee\u5c06\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5ba2\u6237\u7684\u9700\u6c42\uff0c\u5373\u59cb\u53d1\u5730\u7684\u7f16\u53f7\u548c\u76ee\u7684\u5730\u7684\u7f16\u53f7\uff0c\u4e2d\u95f4\u4ee5\u4e00\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5904\u7406\u6bcf\u4e00\u4f4d\u5ba2\u6237\u7684\u9700\u6c42\u3002\u5982\u679c\u6ca1\u6709\u73b0\u6210\u7684\u7ebf\u8def\u53ef\u4ee5\u4f7f\u5176\u5230\u8fbe\u76ee\u7684\u5730\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u201cSorry, no line is available.\u201d\uff1b\u5982\u679c\u76ee\u7684\u5730\u53ef\u8fbe\uff0c\u5219\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u987a\u7545\u8def\u7ebf\u7684\u7ecf\u505c\u7ad9\u6570\u91cf\uff08\u59cb\u53d1\u5730\u548c\u76ee\u7684\u5730\u4e0d\u5305\u62ec\u5728\u5185\uff09\uff0c\u7136\u540e\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u65c5\u884c\u8def\u7ebf\uff1a Go by the line of company #X1 from S1 to S2. Go by the line of company #X2 from S2 to S3. ...... \u5176\u4e2d Xi \u662f\u7ebf\u8def\u627f\u5305\u516c\u53f8\u7684\u7f16\u53f7\uff0c Si \u662f\u7ecf\u505c\u7ad9\u7684\u7f16\u53f7\u3002\u4f46\u5fc5\u987b\u53ea\u8f93\u51fa\u59cb\u53d1\u5730\u3001\u6362\u4e58\u70b9\u548c\u76ee\u7684\u5730\uff0c\u4e0d\u80fd\u8f93\u51fa\u4e2d\u95f4\u7684\u7ecf\u505c\u7ad9\u3002\u9898\u76ee\u4fdd\u8bc1\u6ee1\u8db3\u8981\u6c42\u7684\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 4 7 1001 3212 1003 1204 1005 1306 7797 9 9988 2333 1204 2006 2005 2004 2003 2302 2001 13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011 4 6666 8432 4011 1306 4 3011 3013 6666 2001 2004 3001 2222 6666 \u8f93\u51fa\u6837\u4f8b 2 Go by the line of company #3 from 3011 to 3013. 10 Go by the line of company #4 from 6666 to 1306. Go by the line of company #3 from 1306 to 2302. Go by the line of company #2 from 2302 to 2001. 6 Go by the line of company #2 from 2004 to 1204. Go by the line of company #1 from 1204 to 1306. Go by the line of company #3 from 1306 to 3001. Sorry, no line is available.","title":"L3-014-\u5468\u6e38\u4e16\u754c"},{"location":"CCCC/L3-014-%E5%91%A8%E6%B8%B8%E4%B8%96%E7%95%8C/#l3-014-\u5468\u6e38\u4e16\u754c","text":"","title":"L3-014 \u5468\u6e38\u4e16\u754c"},{"location":"CCCC/L3-014-%E5%91%A8%E6%B8%B8%E4%B8%96%E7%95%8C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5468\u6e38\u4e16\u754c\u662f\u4ef6\u6d6a\u6f2b\u4e8b\uff0c\u4f46\u89c4\u5212\u65c5\u884c\u8def\u7ebf\u5c31\u4e0d\u4e00\u5b9a\u4e86\u2026\u2026 \u5168\u4e16\u754c\u6709\u6210\u5343\u4e0a\u4e07\u6761\u822a\u7ebf\u3001\u94c1\u8def\u7ebf\u3001\u5927\u5df4\u7ebf\uff0c\u4ee4\u4eba\u773c\u82b1\u7f2d\u4e71\u3002\u6240\u4ee5\u65c5\u884c\u793e\u4f1a\u9009\u62e9\u90e8\u5206\u8fd0\u8f93\u516c\u53f8\u7ec4\u6210\u8054\u76df\uff0c\u6bcf\u5bb6\u516c\u53f8\u63d0\u4f9b\u4e00\u6761\u7ebf\u8def\uff0c\u7136\u540e\u5e2e\u52a9\u5ba2\u6237\u89c4\u5212\u7531\u8054\u76df\u5185\u4f01\u4e1a\u652f\u6301\u7684\u65c5\u884c\u8def\u7ebf\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5e2e\u65c5\u884c\u793e\u5b9e\u73b0\u4e00\u4e2a\u81ea\u52a8\u89c4\u5212\u8def\u7ebf\u7684\u7a0b\u5e8f\uff0c\u4f7f\u5f97\u5bf9\u4efb\u4f55\u7ed9\u5b9a\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\uff0c\u53ef\u4ee5\u627e\u51fa\u6700\u987a\u7545\u7684\u8def\u7ebf\u3002\u6240\u8c13\u201c\u6700\u987a\u7545\u201d\uff0c\u9996\u5148\u662f\u6307\u4e2d\u9014\u7ecf\u505c\u7ad9\u6700\u5c11\uff1b\u5982\u679c\u7ecf\u505c\u7ad9\u4e00\u6837\u591a\uff0c\u5219\u53d6\u9700\u8981\u6362\u4e58\u7ebf\u8def\u6b21\u6570\u6700\u5c11\u7684\u8def\u7ebf\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u5373\u8054\u76df\u516c\u53f8\u7684\u6570\u91cf\u3002\u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u7b2c i i \u884c\uff08 i=1, \\cdots , N i=1, \\cdots , N \uff09\u63cf\u8ff0\u4e86\u7b2c i i \u5bb6\u516c\u53f8\u6240\u63d0\u4f9b\u7684\u7ebf\u8def\u3002\u683c\u5f0f\u4e3a\uff1a M M S[1] S[2] \\cdots \\cdots S[ M M ] \u5176\u4e2d M M \uff08 \\le 100 \\le 100 \uff09\u662f\u7ecf\u505c\u7ad9\u7684\u6570\u91cf\uff0cS[ i i ]\uff08 i=1, \\cdots , M i=1, \\cdots , M \uff09\u662f\u7ecf\u505c\u7ad9\u7684\u7f16\u53f7\uff08\u75314\u4f4d0-9\u7684\u6570\u5b57\u7ec4\u6210\uff09\u3002\u8fd9\u91cc\u5047\u8bbe\u6bcf\u6761\u7ebf\u8def\u90fd\u662f\u7b80\u5355\u7684\u4e00\u6761\u53ef\u4ee5\u53cc\u5411\u8fd0\u884c\u7684\u94fe\u8def\uff0c\u5e76\u4e14\u8f93\u5165\u4fdd\u8bc1\u662f\u6309\u7167\u6b63\u786e\u7684\u7ecf\u505c\u987a\u5e8f\u7ed9\u51fa\u7684 \u2014\u2014 \u4e5f\u5c31\u662f\u8bf4\uff0c\u4efb\u610f\u4e00\u5bf9\u76f8\u90bb\u7684S[ i i ]\u548cS[ i+1 i+1 ]\uff08 i=1, \\cdots , M-1 i=1, \\cdots , M-1 \uff09\u4e4b\u95f4\u90fd\u4e0d\u5b58\u5728\u5176\u4ed6\u7ecf\u505c\u7ad9\u70b9\u3002\u6211\u4eec\u79f0\u76f8\u90bb\u7ad9\u70b9\u4e4b\u95f4\u7684\u7ebf\u8def\u4e3a\u4e00\u4e2a\u8fd0\u8425\u533a\u95f4\uff0c\u6bcf\u4e2a\u8fd0\u8425\u533a\u95f4\u53ea\u627f\u5305\u7ed9\u4e00\u5bb6\u516c\u53f8\u3002\u73af\u7ebf\u662f\u6709\u53ef\u80fd\u5b58\u5728\u7684\uff0c\u4f46\u4e0d\u4f1a\u4e0d\u7ecf\u505c\u4efb\u4f55\u4e2d\u95f4\u7ad9\u70b9\u5c31\u4ece\u51fa\u53d1\u5730\u56de\u5230\u51fa\u53d1\u5730\u3002\u5f53\u7136\uff0c\u4e0d\u540c\u516c\u53f8\u7684\u7ebf\u8def\u662f\u53ef\u80fd\u5728\u67d0\u4e9b\u7ad9\u70b9\u6709\u4ea4\u53c9\u7684\uff0c\u8fd9\u4e9b\u7ad9\u70b9\u5c31\u662f\u5ba2\u6237\u7684\u6362\u4e58\u70b9\uff0c\u6211\u4eec\u5047\u8bbe\u4efb\u610f\u6362\u4e58\u70b9\u6d89\u53ca\u7684\u4e0d\u540c\u516c\u53f8\u7684\u7ebf\u8def\u90fd\u4e0d\u8d85\u8fc75\u6761\u3002 \u5728\u63cf\u8ff0\u4e86\u8054\u76df\u7ebf\u8def\u4e4b\u540e\uff0c\u9898\u76ee\u5c06\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e K K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5ba2\u6237\u7684\u9700\u6c42\uff0c\u5373\u59cb\u53d1\u5730\u7684\u7f16\u53f7\u548c\u76ee\u7684\u5730\u7684\u7f16\u53f7\uff0c\u4e2d\u95f4\u4ee5\u4e00\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5904\u7406\u6bcf\u4e00\u4f4d\u5ba2\u6237\u7684\u9700\u6c42\u3002\u5982\u679c\u6ca1\u6709\u73b0\u6210\u7684\u7ebf\u8def\u53ef\u4ee5\u4f7f\u5176\u5230\u8fbe\u76ee\u7684\u5730\uff0c\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u201cSorry, no line is available.\u201d\uff1b\u5982\u679c\u76ee\u7684\u5730\u53ef\u8fbe\uff0c\u5219\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u987a\u7545\u8def\u7ebf\u7684\u7ecf\u505c\u7ad9\u6570\u91cf\uff08\u59cb\u53d1\u5730\u548c\u76ee\u7684\u5730\u4e0d\u5305\u62ec\u5728\u5185\uff09\uff0c\u7136\u540e\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u65c5\u884c\u8def\u7ebf\uff1a Go by the line of company #X1 from S1 to S2. Go by the line of company #X2 from S2 to S3. ...... \u5176\u4e2d Xi \u662f\u7ebf\u8def\u627f\u5305\u516c\u53f8\u7684\u7f16\u53f7\uff0c Si \u662f\u7ecf\u505c\u7ad9\u7684\u7f16\u53f7\u3002\u4f46\u5fc5\u987b\u53ea\u8f93\u51fa\u59cb\u53d1\u5730\u3001\u6362\u4e58\u70b9\u548c\u76ee\u7684\u5730\uff0c\u4e0d\u80fd\u8f93\u51fa\u4e2d\u95f4\u7684\u7ecf\u505c\u7ad9\u3002\u9898\u76ee\u4fdd\u8bc1\u6ee1\u8db3\u8981\u6c42\u7684\u8def\u7ebf\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 4 7 1001 3212 1003 1204 1005 1306 7797 9 9988 2333 1204 2006 2005 2004 2003 2302 2001 13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011 4 6666 8432 4011 1306 4 3011 3013 6666 2001 2004 3001 2222 6666 \u8f93\u51fa\u6837\u4f8b 2 Go by the line of company #3 from 3011 to 3013. 10 Go by the line of company #4 from 6666 to 1306. Go by the line of company #3 from 1306 to 2302. Go by the line of company #2 from 2302 to 2001. 6 Go by the line of company #2 from 2004 to 1204. Go by the line of company #1 from 1204 to 1306. Go by the line of company #3 from 1306 to 3001. Sorry, no line is available.","title":"Statement"},{"location":"CCCC/L3-015-%E7%90%83%E9%98%9F%E2%80%9C%E9%A3%9F%E7%89%A9%E9%93%BE%E2%80%9D/","text":"L3-015 \u7403\u961f\u201c\u98df\u7269\u94fe\u201d Statement Metadata \u4f5c\u8005: \u674e\u6587\u65b0 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 128 MB \u67d0\u56fd\u7684\u8db3\u7403\u8054\u8d5b\u4e2d\u6709 N N \u652f\u53c2\u8d5b\u7403\u961f\uff0c\u7f16\u53f7\u4ece1\u81f3 N N \u3002\u8054\u8d5b\u91c7\u7528\u4e3b\u5ba2\u573a\u53cc\u5faa\u73af\u8d5b\u5236\uff0c\u53c2\u8d5b\u7403\u961f\u4e24\u4e24\u4e4b\u95f4\u5728\u53cc\u65b9\u4e3b\u573a\u5404\u8d5b\u4e00\u573a\u3002 \u8054\u8d5b\u6218\u7f62\uff0c\u7ed3\u679c\u5df2\u7ecf\u5c18\u57c3\u843d\u5b9a\u3002\u6b64\u65f6\uff0c\u8054\u8d5b\u4e3b\u5e2d\u7a81\u53d1\u5947\u60f3\uff0c\u5e0c\u671b\u4ece\u4e2d\u627e\u51fa\u4e00\u6761\u5305\u542b\u6240\u6709\u7403\u961f\u7684\u201c\u98df\u7269\u94fe\u201d\uff0c\u6765\u8bf4\u660e\u8054\u8d5b\u7684\u7cbe\u5f69\u7a0b\u5ea6\u3002\u201c\u98df\u7269\u94fe\u201d\u4e3a\u4e00\u4e2a1\u81f3 N N \u7684\u6392\u5217{ T_1 T_1 T_2 T_2 \\cdots \\cdots T_N T_N }\uff0c\u6ee1\u8db3\uff1a\u7403\u961f T_1 T_1 \u6218\u80dc\u8fc7\u7403\u961f T_2 T_2 \uff0c\u7403\u961f T_2 T_2 \u6218\u80dc\u8fc7\u7403\u961f T_3 T_3 \uff0c \\cdots \\cdots \uff0c\u7403\u961f T_{(N-1)} T_{(N-1)} \u6218\u80dc\u8fc7\u7403\u961f T_N T_N \uff0c\u7403\u961f T_N T_N \u6218\u80dc\u8fc7\u7403\u961f T_1 T_1 \u3002 \u73b0\u5728\u4e3b\u5e2d\u8bf7\u4f60\u4ece\u8054\u8d5b\u7ed3\u679c\u4e2d\u627e\u51fa\u201c\u98df\u7269\u94fe\u201d\u3002\u82e5\u5b58\u5728\u591a\u6761\u201c\u98df\u7269\u94fe\u201d\uff0c\u8bf7\u627e\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u3002 \u6ce8\uff1a\u6392\u5217{ a_1 a_1 a_2 a_2 \\cdots \\cdots a_N a_N }\u5728\u5b57\u5178\u5e8f\u4e0a\u5c0f\u4e8e\u6392\u5217{ b_1 b_1 b_2 b_2 \\cdots \\cdots b_N b_N }\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6574\u6570 K K \uff08 1 \\le K \\le N 1 \\le K \\le N \uff09\uff0c\u6ee1\u8db3\uff1a a_K < b_K a_K < b_K \u4e14\u5bf9\u4e8e\u4efb\u610f\u5c0f\u4e8e K K \u7684\u6b63\u6574\u6570 i i \uff0c a_i=b_i a_i=b_i \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 N N \uff08 2 \\le N \\le 20 2 \\le N \\le 20 \uff09\uff0c\u4e3a\u53c2\u8d5b\u7403\u961f\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c N N \u4e2a\u5b57\u7b26\uff0c\u7ed9\u51fa\u4e86 N\\times N N\\times N \u7684\u8054\u8d5b\u7ed3\u679c\u8868\uff0c\u5176\u4e2d\u7b2c i i \u884c\u7b2c j j \u5217\u7684\u5b57\u7b26\u4e3a\u7403\u961f i i \u5728\u4e3b\u573a\u5bf9\u9635\u7403\u961f j j \u7684\u6bd4\u8d5b\u7ed3\u679c\uff1a W \u8868\u793a\u7403\u961f i i \u6218\u80dc\u7403\u961f j j \uff0c L \u8868\u793a\u7403\u961f i i \u8d1f\u4e8e\u7403\u961f j j \uff0c D \u8868\u793a\u4e24\u961f\u6253\u5e73\uff0c - \u8868\u793a\u65e0\u6548\uff08\u5f53 i=j i=j \u65f6\uff09\u3002\u8f93\u5165\u4e2d\u65e0\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u76ee\u8981\u6c42\u627e\u5230\u201c\u98df\u7269\u94fe\u201d T_1 T_1 T_2 T_2 \\cdots \\cdots T_N T_N \uff0c\u5c06\u8fd9 N N \u4e2a\u6570\u4f9d\u6b21\u8f93\u51fa\u5728\u4e00\u884c\u4e0a\uff0c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u4e0d\u5b58\u5728\u201c\u98df\u7269\u94fe\u201d\uff0c\u8f93\u51fa\u201cNo Solution\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 5 -LWDW W-LDW WW-LW DWW-W DDLW- \u8f93\u51fa\u6837\u4f8b1 1 3 5 4 2 \u8f93\u5165\u6837\u4f8b2 5 -WDDW D-DWL DD-DW DDW-D DDDD- \u8f93\u51fa\u6837\u4f8b2 No Solution Tutorial \u601d\u8def\uff1a \u7528\u4e00\u4e2a\u6570\u7ec4\u6807\u8bb0 vis[i][j] vis[i][j] \u80dc\u8d1f \u904d\u5386\u6bcf\u4e00\u884c \u5982\u679c \u78b0\u5230 W \u90a3\u4e48 vis[i][j] = 1 vis[i][j] = 1 \u5982\u679c \u78b0\u5230 L \u90a3\u4e48 vis[j][i] = 1 vis[j][i] = 1 \u7136\u540e\u98df\u7269\u94fe\u4e2d\u6240\u6709\u961f\u4f0d\u90fd\u6709\u800c\u4e14\u8981\u4fdd\u6301\u5b57\u5178\u5e8f\u6700\u5c0f \u90a3\u4e48\u6beb\u65e0\u7591\u95ee\u7b2c\u4e00\u4e2a\u5fc5\u7136\u662f 1 1 \u6240\u4ee5\u5c31\u4ece dfs(int cur, int step) cur \u8868\u793a\u641c\u5230\u7b2c\u51e0\u652f\u961f\u4f0d step \u8868\u793a\u641c\u5230\u7b2c\u51e0\u6b65\u4e86 \u5982\u679c\u5269\u4e0b\u672a\u6807\u8bb0\u7684\u961f\u4f0d \u90fd\u6ca1\u6709\u6218\u80dc\u961f\u4f0d 1 1 \u7684\u90a3\u4e48\u5c31\u8981\u526a\u53bb\u4e86 \u56e0\u4e3a\u518d\u5f80\u4e0b\u641c\u4e5f\u662f\u4e0d\u80fd\u6784\u6210\u98df\u7269\u94fe\u7684 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string s [ 25 ]; int vis [ 20 ][ 20 ]; map < int , int > m ; vector < int > v ; int ans , n ; void dfs ( int cur , int step ) { if ( ans == 1 ) return ; if ( step == n && ans == -1 ) { if ( vis [ cur ][ 0 ]) ans = 1 ; return ; } else { bool cut = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ i ] == 0 && vis [ i ][ 0 ]) cut = true ; } if ( cut == false ) return ; for ( int i = 0 ; i < n && ans == -1 ; i ++ ) { if ( m [ i ] == 0 && vis [ cur ][ i ]) { v . push_back ( i ); m [ i ] = 1 ; dfs ( i , step + 1 ); if ( ans == -1 ) { m [ i ] = 0 ; v . pop_back (); } else return ; } } } } int main () { memset ( vis , 0 , sizeof ( vis )); scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ]; for ( int j = 0 ; j < n ; j ++ ) if ( s [ i ][ j ] == 'W' ) vis [ i ][ j ] = 1 ; else if ( s [ i ][ j ] == 'L' ) vis [ j ][ i ] = 1 ; } int flag = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( vis [ i ][ 0 ]) { flag = 0 ; break ; } } if ( flag ) printf ( \"No Solution \\n \" ); else { ans = -1 ; v . clear (); m . clear (); v . push_back ( 0 ); m [ 0 ] = 1 ; dfs ( 0 , 1 ); if ( ans == -1 ) printf ( \"No Solution \\n \" ); else { vector < int >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if ( it != v . begin ()) printf ( \" \" ); cout << ( * it ) + 1 ; } cout << endl ; } } }","title":"L3-015-\u7403\u961f\u201c\u98df\u7269\u94fe\u201d"},{"location":"CCCC/L3-015-%E7%90%83%E9%98%9F%E2%80%9C%E9%A3%9F%E7%89%A9%E9%93%BE%E2%80%9D/#l3-015-\u7403\u961f\u98df\u7269\u94fe","text":"","title":"L3-015 \u7403\u961f\u201c\u98df\u7269\u94fe\u201d"},{"location":"CCCC/L3-015-%E7%90%83%E9%98%9F%E2%80%9C%E9%A3%9F%E7%89%A9%E9%93%BE%E2%80%9D/#statement","text":"Metadata \u4f5c\u8005: \u674e\u6587\u65b0 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 128 MB \u67d0\u56fd\u7684\u8db3\u7403\u8054\u8d5b\u4e2d\u6709 N N \u652f\u53c2\u8d5b\u7403\u961f\uff0c\u7f16\u53f7\u4ece1\u81f3 N N \u3002\u8054\u8d5b\u91c7\u7528\u4e3b\u5ba2\u573a\u53cc\u5faa\u73af\u8d5b\u5236\uff0c\u53c2\u8d5b\u7403\u961f\u4e24\u4e24\u4e4b\u95f4\u5728\u53cc\u65b9\u4e3b\u573a\u5404\u8d5b\u4e00\u573a\u3002 \u8054\u8d5b\u6218\u7f62\uff0c\u7ed3\u679c\u5df2\u7ecf\u5c18\u57c3\u843d\u5b9a\u3002\u6b64\u65f6\uff0c\u8054\u8d5b\u4e3b\u5e2d\u7a81\u53d1\u5947\u60f3\uff0c\u5e0c\u671b\u4ece\u4e2d\u627e\u51fa\u4e00\u6761\u5305\u542b\u6240\u6709\u7403\u961f\u7684\u201c\u98df\u7269\u94fe\u201d\uff0c\u6765\u8bf4\u660e\u8054\u8d5b\u7684\u7cbe\u5f69\u7a0b\u5ea6\u3002\u201c\u98df\u7269\u94fe\u201d\u4e3a\u4e00\u4e2a1\u81f3 N N \u7684\u6392\u5217{ T_1 T_1 T_2 T_2 \\cdots \\cdots T_N T_N }\uff0c\u6ee1\u8db3\uff1a\u7403\u961f T_1 T_1 \u6218\u80dc\u8fc7\u7403\u961f T_2 T_2 \uff0c\u7403\u961f T_2 T_2 \u6218\u80dc\u8fc7\u7403\u961f T_3 T_3 \uff0c \\cdots \\cdots \uff0c\u7403\u961f T_{(N-1)} T_{(N-1)} \u6218\u80dc\u8fc7\u7403\u961f T_N T_N \uff0c\u7403\u961f T_N T_N \u6218\u80dc\u8fc7\u7403\u961f T_1 T_1 \u3002 \u73b0\u5728\u4e3b\u5e2d\u8bf7\u4f60\u4ece\u8054\u8d5b\u7ed3\u679c\u4e2d\u627e\u51fa\u201c\u98df\u7269\u94fe\u201d\u3002\u82e5\u5b58\u5728\u591a\u6761\u201c\u98df\u7269\u94fe\u201d\uff0c\u8bf7\u627e\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u3002 \u6ce8\uff1a\u6392\u5217{ a_1 a_1 a_2 a_2 \\cdots \\cdots a_N a_N }\u5728\u5b57\u5178\u5e8f\u4e0a\u5c0f\u4e8e\u6392\u5217{ b_1 b_1 b_2 b_2 \\cdots \\cdots b_N b_N }\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u6574\u6570 K K \uff08 1 \\le K \\le N 1 \\le K \\le N \uff09\uff0c\u6ee1\u8db3\uff1a a_K < b_K a_K < b_K \u4e14\u5bf9\u4e8e\u4efb\u610f\u5c0f\u4e8e K K \u7684\u6b63\u6574\u6570 i i \uff0c a_i=b_i a_i=b_i \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 N N \uff08 2 \\le N \\le 20 2 \\le N \\le 20 \uff09\uff0c\u4e3a\u53c2\u8d5b\u7403\u961f\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c N N \u4e2a\u5b57\u7b26\uff0c\u7ed9\u51fa\u4e86 N\\times N N\\times N \u7684\u8054\u8d5b\u7ed3\u679c\u8868\uff0c\u5176\u4e2d\u7b2c i i \u884c\u7b2c j j \u5217\u7684\u5b57\u7b26\u4e3a\u7403\u961f i i \u5728\u4e3b\u573a\u5bf9\u9635\u7403\u961f j j \u7684\u6bd4\u8d5b\u7ed3\u679c\uff1a W \u8868\u793a\u7403\u961f i i \u6218\u80dc\u7403\u961f j j \uff0c L \u8868\u793a\u7403\u961f i i \u8d1f\u4e8e\u7403\u961f j j \uff0c D \u8868\u793a\u4e24\u961f\u6253\u5e73\uff0c - \u8868\u793a\u65e0\u6548\uff08\u5f53 i=j i=j \u65f6\uff09\u3002\u8f93\u5165\u4e2d\u65e0\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u76ee\u8981\u6c42\u627e\u5230\u201c\u98df\u7269\u94fe\u201d T_1 T_1 T_2 T_2 \\cdots \\cdots T_N T_N \uff0c\u5c06\u8fd9 N N \u4e2a\u6570\u4f9d\u6b21\u8f93\u51fa\u5728\u4e00\u884c\u4e0a\uff0c\u6570\u5b57\u95f4\u4ee51\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u82e5\u4e0d\u5b58\u5728\u201c\u98df\u7269\u94fe\u201d\uff0c\u8f93\u51fa\u201cNo Solution\u201d\u3002 \u8f93\u5165\u6837\u4f8b1 5 -LWDW W-LDW WW-LW DWW-W DDLW- \u8f93\u51fa\u6837\u4f8b1 1 3 5 4 2 \u8f93\u5165\u6837\u4f8b2 5 -WDDW D-DWL DD-DW DDW-D DDDD- \u8f93\u51fa\u6837\u4f8b2 No Solution","title":"Statement"},{"location":"CCCC/L3-015-%E7%90%83%E9%98%9F%E2%80%9C%E9%A3%9F%E7%89%A9%E9%93%BE%E2%80%9D/#tutorial","text":"\u601d\u8def\uff1a \u7528\u4e00\u4e2a\u6570\u7ec4\u6807\u8bb0 vis[i][j] vis[i][j] \u80dc\u8d1f \u904d\u5386\u6bcf\u4e00\u884c \u5982\u679c \u78b0\u5230 W \u90a3\u4e48 vis[i][j] = 1 vis[i][j] = 1 \u5982\u679c \u78b0\u5230 L \u90a3\u4e48 vis[j][i] = 1 vis[j][i] = 1 \u7136\u540e\u98df\u7269\u94fe\u4e2d\u6240\u6709\u961f\u4f0d\u90fd\u6709\u800c\u4e14\u8981\u4fdd\u6301\u5b57\u5178\u5e8f\u6700\u5c0f \u90a3\u4e48\u6beb\u65e0\u7591\u95ee\u7b2c\u4e00\u4e2a\u5fc5\u7136\u662f 1 1 \u6240\u4ee5\u5c31\u4ece dfs(int cur, int step) cur \u8868\u793a\u641c\u5230\u7b2c\u51e0\u652f\u961f\u4f0d step \u8868\u793a\u641c\u5230\u7b2c\u51e0\u6b65\u4e86 \u5982\u679c\u5269\u4e0b\u672a\u6807\u8bb0\u7684\u961f\u4f0d \u90fd\u6ca1\u6709\u6218\u80dc\u961f\u4f0d 1 1 \u7684\u90a3\u4e48\u5c31\u8981\u526a\u53bb\u4e86 \u56e0\u4e3a\u518d\u5f80\u4e0b\u641c\u4e5f\u662f\u4e0d\u80fd\u6784\u6210\u98df\u7269\u94fe\u7684","title":"Tutorial"},{"location":"CCCC/L3-015-%E7%90%83%E9%98%9F%E2%80%9C%E9%A3%9F%E7%89%A9%E9%93%BE%E2%80%9D/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string s [ 25 ]; int vis [ 20 ][ 20 ]; map < int , int > m ; vector < int > v ; int ans , n ; void dfs ( int cur , int step ) { if ( ans == 1 ) return ; if ( step == n && ans == -1 ) { if ( vis [ cur ][ 0 ]) ans = 1 ; return ; } else { bool cut = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ i ] == 0 && vis [ i ][ 0 ]) cut = true ; } if ( cut == false ) return ; for ( int i = 0 ; i < n && ans == -1 ; i ++ ) { if ( m [ i ] == 0 && vis [ cur ][ i ]) { v . push_back ( i ); m [ i ] = 1 ; dfs ( i , step + 1 ); if ( ans == -1 ) { m [ i ] = 0 ; v . pop_back (); } else return ; } } } } int main () { memset ( vis , 0 , sizeof ( vis )); scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; i ++ ) { cin >> s [ i ]; for ( int j = 0 ; j < n ; j ++ ) if ( s [ i ][ j ] == 'W' ) vis [ i ][ j ] = 1 ; else if ( s [ i ][ j ] == 'L' ) vis [ j ][ i ] = 1 ; } int flag = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( vis [ i ][ 0 ]) { flag = 0 ; break ; } } if ( flag ) printf ( \"No Solution \\n \" ); else { ans = -1 ; v . clear (); m . clear (); v . push_back ( 0 ); m [ 0 ] = 1 ; dfs ( 0 , 1 ); if ( ans == -1 ) printf ( \"No Solution \\n \" ); else { vector < int >:: iterator it ; for ( it = v . begin (); it != v . end (); it ++ ) { if ( it != v . begin ()) printf ( \" \" ); cout << ( * it ) + 1 ; } cout << endl ; } } }","title":"Solution"},{"location":"CCCC/L3-016-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/","text":"L3-016 \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7ed3\u6784 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e8c\u53c9\u641c\u7d22\u6811\u6216\u8005\u662f\u4e00\u68f5\u7a7a\u6811\uff0c\u6216\u8005\u662f\u5177\u6709\u4e0b\u5217\u6027\u8d28\u7684\u4e8c\u53c9\u6811\uff1a \u82e5\u5b83\u7684\u5de6\u5b50\u6811\u4e0d\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u5b83\u7684\u6839\u7ed3\u70b9\u7684\u503c\uff1b\u82e5\u5b83\u7684\u53f3\u5b50\u6811\u4e0d\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u5b83\u7684\u6839\u7ed3\u70b9\u7684\u503c\uff1b\u5b83\u7684\u5de6\u3001\u53f3\u5b50\u6811\u4e5f\u5206\u522b\u4e3a\u4e8c\u53c9\u641c\u7d22\u6811\u3002\uff08\u6458\u81ea\u767e\u5ea6\u767e\u79d1\uff09 \u7ed9\u5b9a\u4e00\u7cfb\u5217\u4e92\u4e0d\u76f8\u7b49\u7684\u6574\u6570\uff0c\u5c06\u5b83\u4eec\u987a\u6b21\u63d2\u5165\u4e00\u68f5\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u7136\u540e\u5bf9\u7ed3\u679c\u6811\u7684\u7ed3\u6784\u8fdb\u884c\u63cf\u8ff0\u3002\u4f60\u9700\u8981\u80fd\u5224\u65ad\u7ed9\u5b9a\u7684\u63cf\u8ff0\u662f\u5426\u6b63\u786e\u3002\u4f8b\u5982\u5c06{ 2 4 1 3 0 }\u63d2\u5165\u540e\uff0c\u5f97\u5230\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5219\u9648\u8ff0\u53e5\u5982\u201c2\u662f\u6811\u7684\u6839\u201d\u3001\u201c1\u548c4\u662f\u5144\u5f1f\u7ed3\u70b9\u201d\u3001\u201c3\u548c0\u5728\u540c\u4e00\u5c42\u4e0a\u201d\uff08\u6307\u81ea\u9876\u5411\u4e0b\u7684\u6df1\u5ea6\u76f8\u540c\uff09\u3001\u201c2\u662f4\u7684\u53cc\u4eb2\u7ed3\u70b9\u201d\u3001\u201c3\u662f4\u7684\u5de6\u5b69\u5b50\u201d\u90fd\u662f\u6b63\u786e\u7684\uff1b\u800c\u201c4\u662f2\u7684\u5de6\u5b69\u5b50\u201d\u3001\u201c1\u548c3\u662f\u5144\u5f1f\u7ed3\u70b9\u201d\u90fd\u662f\u4e0d\u6b63\u786e\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6574\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8981\u6c42\u5c06\u4e4b\u987a\u6b21\u63d2\u5165\u4e00\u68f5\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u5f85\u5224\u65ad\u7684\u9648\u8ff0\u53e5\u3002\u9648\u8ff0\u53e5\u6709\u4ee5\u4e0b6\u79cd\uff1a A is the root \uff0c\u5373\" A \u662f\u6811\u7684\u6839\"\uff1b A and B are siblings \uff0c\u5373\" A \u548c B \u662f\u5144\u5f1f\u7ed3\u70b9\"\uff1b A is the parent of B \uff0c\u5373\" A \u662f B \u7684\u53cc\u4eb2\u7ed3\u70b9\"\uff1b A is the left child of B \uff0c\u5373\" A \u662f B \u7684\u5de6\u5b69\u5b50\"\uff1b A is the right child of B \uff0c\u5373\" A \u662f B \u7684\u53f3\u5b69\u5b50\"\uff1b A and B are on the same level \uff0c\u5373\" A \u548c B \u5728\u540c\u4e00\u5c42\u4e0a\"\u3002 \u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u7ed9\u5b9a\u7684\u6574\u6570\u90fd\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u53e5\u9648\u8ff0\uff0c\u5982\u679c\u6b63\u786e\u5219\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \uff0c\u6bcf\u53e5\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 5 2 4 1 3 0 8 2 is the root 1 and 4 are siblings 3 and 0 are on the same level 2 is the parent of 4 3 is the left child of 4 1 is the right child of 2 4 and 0 are on the same level 100 is the right child of 3 \u8f93\u51fa\u6837\u4f8b Yes Yes Yes Yes Yes No No No Solution C++ #include <bits/stdc++.h> using namespace std ; #define N 510 #define INF 0x3f3f3f3f int n , a [ N ]; map < int , int > mp ; struct node { int fa , ls , rs , dep ; node () {} node ( int fa , int dep ) : fa ( fa ), dep ( dep ) { ls = rs = -1 ; } } t [ N ]; int ID ( int x ) { return mp [ x ]; } void insert ( int now , int x ) { int & ls = t [ now ]. ls , & rs = t [ now ]. rs , dep = t [ now ]. dep ; if ( a [ x ] > a [ now ]) { if ( rs == -1 ) { rs = x ; t [ x ] = node ( now , dep + 1 ); return ; } insert ( rs , x ); } else { if ( ls == -1 ) { ls = x ; t [ x ] = node ( now , dep + 1 ); return ; } insert ( ls , x ); } } int u , v ; void out ( int vis ) { if ( ID ( u ) == 0 || ID ( v ) == 0 ) vis = 0 ; puts ( vis ? \"Yes\" : \"No\" ); } int main () { mp . clear (); scanf ( \"%d\" , & n ); scanf ( \"%d\" , a + 1 ); t [ 1 ] = node ( -1 , 0 ); mp [ a [ 1 ]] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); mp [ a [ i ]] = i ; insert ( 1 , i ); } int q ; cin >> q ; char s [ 20 ]; while ( q -- ) { scanf ( \"%d%s\" , & u , s ); if ( s [ 0 ] == 'i' ) { scanf ( \"%s%s\" , s , s ); if ( s [ 1 ] == 'o' ) { if ( ID ( u ) == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } else if ( s [ 0 ] == 'p' ) { scanf ( \"%s%d\" , s , & v ); out ( t [ ID ( v )]. fa == ID ( u )); } else if ( s [ 0 ] == 'l' ) { scanf ( \"%s%s%d\" , s , s , & v ); out ( t [ ID ( v )]. ls == ID ( u )); } else { scanf ( \"%s%s%d\" , s , s , & v ); out ( t [ ID ( v )]. rs == ID ( u )); } } else { scanf ( \"%d\" , & v ); scanf ( \"%s%s\" , s , s ); // cout << s << endl; if ( s [ 0 ] == 's' ) out ( t [ ID ( u )]. fa == t [ ID ( v )]. fa ); else { scanf ( \"%s%s%s\" , s , s , s ); // cout << s << endl; out ( t [ ID ( u )]. dep == t [ ID ( v )]. dep ); } } } return 0 ; }","title":"L3-016-\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7ed3\u6784"},{"location":"CCCC/L3-016-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/#l3-016-\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7ed3\u6784","text":"","title":"L3-016 \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7ed3\u6784"},{"location":"CCCC/L3-016-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e8c\u53c9\u641c\u7d22\u6811\u6216\u8005\u662f\u4e00\u68f5\u7a7a\u6811\uff0c\u6216\u8005\u662f\u5177\u6709\u4e0b\u5217\u6027\u8d28\u7684\u4e8c\u53c9\u6811\uff1a \u82e5\u5b83\u7684\u5de6\u5b50\u6811\u4e0d\u7a7a\uff0c\u5219\u5de6\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5c0f\u4e8e\u5b83\u7684\u6839\u7ed3\u70b9\u7684\u503c\uff1b\u82e5\u5b83\u7684\u53f3\u5b50\u6811\u4e0d\u7a7a\uff0c\u5219\u53f3\u5b50\u6811\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u5747\u5927\u4e8e\u5b83\u7684\u6839\u7ed3\u70b9\u7684\u503c\uff1b\u5b83\u7684\u5de6\u3001\u53f3\u5b50\u6811\u4e5f\u5206\u522b\u4e3a\u4e8c\u53c9\u641c\u7d22\u6811\u3002\uff08\u6458\u81ea\u767e\u5ea6\u767e\u79d1\uff09 \u7ed9\u5b9a\u4e00\u7cfb\u5217\u4e92\u4e0d\u76f8\u7b49\u7684\u6574\u6570\uff0c\u5c06\u5b83\u4eec\u987a\u6b21\u63d2\u5165\u4e00\u68f5\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u7136\u540e\u5bf9\u7ed3\u679c\u6811\u7684\u7ed3\u6784\u8fdb\u884c\u63cf\u8ff0\u3002\u4f60\u9700\u8981\u80fd\u5224\u65ad\u7ed9\u5b9a\u7684\u63cf\u8ff0\u662f\u5426\u6b63\u786e\u3002\u4f8b\u5982\u5c06{ 2 4 1 3 0 }\u63d2\u5165\u540e\uff0c\u5f97\u5230\u4e00\u68f5\u4e8c\u53c9\u641c\u7d22\u6811\uff0c\u5219\u9648\u8ff0\u53e5\u5982\u201c2\u662f\u6811\u7684\u6839\u201d\u3001\u201c1\u548c4\u662f\u5144\u5f1f\u7ed3\u70b9\u201d\u3001\u201c3\u548c0\u5728\u540c\u4e00\u5c42\u4e0a\u201d\uff08\u6307\u81ea\u9876\u5411\u4e0b\u7684\u6df1\u5ea6\u76f8\u540c\uff09\u3001\u201c2\u662f4\u7684\u53cc\u4eb2\u7ed3\u70b9\u201d\u3001\u201c3\u662f4\u7684\u5de6\u5b69\u5b50\u201d\u90fd\u662f\u6b63\u786e\u7684\uff1b\u800c\u201c4\u662f2\u7684\u5de6\u5b69\u5b50\u201d\u3001\u201c1\u548c3\u662f\u5144\u5f1f\u7ed3\u70b9\u201d\u90fd\u662f\u4e0d\u6b63\u786e\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6574\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u8981\u6c42\u5c06\u4e4b\u987a\u6b21\u63d2\u5165\u4e00\u68f5\u521d\u59cb\u4e3a\u7a7a\u7684\u4e8c\u53c9\u641c\u7d22\u6811\u3002\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u53e5\u5f85\u5224\u65ad\u7684\u9648\u8ff0\u53e5\u3002\u9648\u8ff0\u53e5\u6709\u4ee5\u4e0b6\u79cd\uff1a A is the root \uff0c\u5373\" A \u662f\u6811\u7684\u6839\"\uff1b A and B are siblings \uff0c\u5373\" A \u548c B \u662f\u5144\u5f1f\u7ed3\u70b9\"\uff1b A is the parent of B \uff0c\u5373\" A \u662f B \u7684\u53cc\u4eb2\u7ed3\u70b9\"\uff1b A is the left child of B \uff0c\u5373\" A \u662f B \u7684\u5de6\u5b69\u5b50\"\uff1b A is the right child of B \uff0c\u5373\" A \u662f B \u7684\u53f3\u5b69\u5b50\"\uff1b A and B are on the same level \uff0c\u5373\" A \u548c B \u5728\u540c\u4e00\u5c42\u4e0a\"\u3002 \u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u7ed9\u5b9a\u7684\u6574\u6570\u90fd\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u53e5\u9648\u8ff0\uff0c\u5982\u679c\u6b63\u786e\u5219\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \uff0c\u6bcf\u53e5\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 5 2 4 1 3 0 8 2 is the root 1 and 4 are siblings 3 and 0 are on the same level 2 is the parent of 4 3 is the left child of 4 1 is the right child of 2 4 and 0 are on the same level 100 is the right child of 3 \u8f93\u51fa\u6837\u4f8b Yes Yes Yes Yes Yes No No No","title":"Statement"},{"location":"CCCC/L3-016-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define N 510 #define INF 0x3f3f3f3f int n , a [ N ]; map < int , int > mp ; struct node { int fa , ls , rs , dep ; node () {} node ( int fa , int dep ) : fa ( fa ), dep ( dep ) { ls = rs = -1 ; } } t [ N ]; int ID ( int x ) { return mp [ x ]; } void insert ( int now , int x ) { int & ls = t [ now ]. ls , & rs = t [ now ]. rs , dep = t [ now ]. dep ; if ( a [ x ] > a [ now ]) { if ( rs == -1 ) { rs = x ; t [ x ] = node ( now , dep + 1 ); return ; } insert ( rs , x ); } else { if ( ls == -1 ) { ls = x ; t [ x ] = node ( now , dep + 1 ); return ; } insert ( ls , x ); } } int u , v ; void out ( int vis ) { if ( ID ( u ) == 0 || ID ( v ) == 0 ) vis = 0 ; puts ( vis ? \"Yes\" : \"No\" ); } int main () { mp . clear (); scanf ( \"%d\" , & n ); scanf ( \"%d\" , a + 1 ); t [ 1 ] = node ( -1 , 0 ); mp [ a [ 1 ]] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); mp [ a [ i ]] = i ; insert ( 1 , i ); } int q ; cin >> q ; char s [ 20 ]; while ( q -- ) { scanf ( \"%d%s\" , & u , s ); if ( s [ 0 ] == 'i' ) { scanf ( \"%s%s\" , s , s ); if ( s [ 1 ] == 'o' ) { if ( ID ( u ) == 1 ) puts ( \"Yes\" ); else puts ( \"No\" ); } else if ( s [ 0 ] == 'p' ) { scanf ( \"%s%d\" , s , & v ); out ( t [ ID ( v )]. fa == ID ( u )); } else if ( s [ 0 ] == 'l' ) { scanf ( \"%s%s%d\" , s , s , & v ); out ( t [ ID ( v )]. ls == ID ( u )); } else { scanf ( \"%s%s%d\" , s , s , & v ); out ( t [ ID ( v )]. rs == ID ( u )); } } else { scanf ( \"%d\" , & v ); scanf ( \"%s%s\" , s , s ); // cout << s << endl; if ( s [ 0 ] == 's' ) out ( t [ ID ( u )]. fa == t [ ID ( v )]. fa ); else { scanf ( \"%s%s%s\" , s , s , s ); // cout << s << endl; out ( t [ ID ( u )]. dep == t [ ID ( v )]. dep ); } } } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-017-%E6%A3%AE%E6%A3%AE%E5%BF%AB%E9%80%92/","text":"L3-017 \u68ee\u68ee\u5feb\u9012 Statement Metadata \u4f5c\u8005: \u4fde\u52c7 \u5355\u4f4d: \u4e0a\u6d77\u4ea4\u901a\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u5f00\u4e86\u4e00\u5bb6\u5feb\u9012\u516c\u53f8\uff0c\u53eb\u68ee\u68ee\u5feb\u9012\u3002\u56e0\u4e3a\u516c\u53f8\u521a\u521a\u5f00\u5f20\uff0c\u6240\u4ee5\u4e1a\u52a1\u8def\u7ebf\u5f88\u7b80\u5355\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f\u4e00\u6761\u76f4\u7ebf\u4e0a\u7684 N N \u4e2a\u57ce\u5e02\uff0c\u8fd9\u4e9b\u57ce\u5e02\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u4ece0\u5230 (N-1) (N-1) \u7f16\u53f7\u3002\u7531\u4e8e\u9053\u8def\u9650\u5236\uff0c\u7b2c i i \u53f7\u57ce\u5e02\uff08 i=0, \\cdots , N-2 i=0, \\cdots , N-2 \uff09\u4e0e\u7b2c (i+1) (i+1) \u53f7\u57ce\u5e02\u4e2d\u95f4\u5f80\u8fd4\u7684\u8fd0\u8f93\u8d27\u7269\u91cd\u91cf\u5728\u540c\u4e00\u65f6\u523b\u4e0d\u80fd\u8d85\u8fc7 C_i C_i \u516c\u65a4\u3002 \u516c\u53f8\u5f00\u5f20\u540e\u5f88\u5feb\u63a5\u5230\u4e86 Q Q \u5f20\u8ba2\u5355\uff0c\u5176\u4e2d j j \u5f20\u8ba2\u5355\u63cf\u8ff0\u4e86\u67d0\u4e9b\u6307\u5b9a\u7684\u8d27\u7269\u8981\u4ece S_j S_j \u53f7\u57ce\u5e02\u8fd0\u8f93\u5230 T_j T_j \u53f7\u57ce\u5e02\u3002\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u5730\u5047\u8bbe\u6240\u6709\u8d27\u7269\u90fd\u6709\u65e0\u9650\u8d27\u6e90\uff0c\u68ee\u68ee\u4f1a\u4e0d\u5b9a\u65f6\u5730\u6311\u9009\u5176\u4e2d\u4e00\u90e8\u5206\u8d27\u7269\u8fdb\u884c\u8fd0\u8f93\u3002\u5b89\u5168\u8d77\u89c1\uff0c\u8fd9\u4e9b\u8d27\u7269\u4e0d\u4f1a\u5728\u4e2d\u9014\u5378\u8d27\u3002 \u4e3a\u4e86\u8ba9\u516c\u53f8\u6574\u4f53\u6548\u76ca\u66f4\u4f73\uff0c\u68ee\u68ee\u60f3\u77e5\u9053\u5982\u4f55\u5b89\u6392\u8ba2\u5355\u7684\u8fd0\u8f93\uff0c\u80fd\u4f7f\u5f97\u8fd0\u8f93\u7684\u8d27\u7269\u91cd\u91cf\u6700\u5927\u4e14\u7b26\u5408\u9053\u8def\u7684\u9650\u5236\uff1f\u8981\u6ce8\u610f\u7684\u662f\uff0c\u53d1\u8d27\u65f6\u95f4\u6709\u53ef\u80fd\u662f\u4efb\u4f55\u65f6\u523b\uff0c\u6240\u4ee5\u6211\u4eec\u5b89\u6392\u8ba2\u5355\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u4fdd\u8bc1\u5171\u7528\u540c\u4e00\u6761\u9053\u8def\u7684\u6240\u6709\u8d27\u8f66\u7684\u603b\u91cd\u91cf\u4e0d\u8d85\u8f7d\u3002\u4f8b\u5982\u6211\u4eec\u5b89\u63921\u53f7\u57ce\u5e02\u52304\u53f7\u57ce\u5e02\u4ee5\u53ca2\u53f7\u57ce\u5e02\u52304\u53f7\u57ce\u5e02\u4e24\u5f20\u8ba2\u5355\u7684\u8fd0\u8f93\uff0c\u5219\u8fd9\u4e24\u5f20\u8ba2\u5355\u7684\u8fd0\u8f93\u540c\u65f6\u53d72-3\u4ee5\u53ca3-4\u4e24\u6761\u9053\u8def\u7684\u9650\u5236\uff0c\u56e0\u4e3a\u4e24\u5f20\u8ba2\u5355\u7684\u8d27\u7269\u53ef\u80fd\u4f1a\u540c\u65f6\u5728\u8fd9\u4e9b\u9053\u8def\u4e0a\u8fd0\u8f93\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c Q Q \uff08 2 \\le N \\le 10^5 2 \\le N \\le 10^5 , 1 \\le Q \\le 10^5 1 \\le Q \\le 10^5 \uff09\uff0c\u8868\u793a\u603b\u5171\u7684\u57ce\u5e02\u6570\u4ee5\u53ca\u8ba2\u5355\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa (N-1) (N-1) \u4e2a\u6570\uff0c\u987a\u6b21\u8868\u793a\u76f8\u90bb\u4e24\u57ce\u5e02\u95f4\u7684\u9053\u8def\u5141\u8bb8\u7684\u6700\u5927\u8fd0\u8d27\u91cd\u91cf C_i C_i \uff08 i=0, \\cdots , N-2 i=0, \\cdots , N-2 \uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a C_i C_i \u662f\u4e0d\u8d85\u8fc7 2^{31} 2^{31} \u7684\u975e\u8d1f\u6574\u6570\u3002 \u63a5\u4e0b\u6765 Q Q \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u8ba2\u5355\u7684\u8d77\u59cb\u53ca\u7ec8\u6b62\u8fd0\u8f93\u57ce\u5e02\u7f16\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u7f16\u53f7\u5408\u6cd5\uff0c\u5e76\u4e14\u4e0d\u5b58\u5728\u8d77\u70b9\u548c\u7ec8\u70b9\u91cd\u5408\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53ef\u8fd0\u8f93\u8d27\u7269\u7684\u6700\u5927\u91cd\u91cf\u3002 \u8f93\u5165\u6837\u4f8b 10 6 0 7 8 5 2 3 1 9 10 0 9 1 8 2 7 6 3 4 5 4 2 \u8f93\u51fa\u6837\u4f8b 7 \u6837\u4f8b\u63d0\u793a \u6211\u4eec\u9009\u62e9\u6267\u884c\u6700\u540e\u4e24\u5f20\u8ba2\u5355\uff0c\u5373\u628a5\u516c\u65a4\u8d27\u4ece\u57ce\u5e024\u8fd0\u5230\u57ce\u5e022\uff0c\u5e76\u4e14\u628a2\u516c\u65a4\u8d27\u4ece\u57ce\u5e024\u8fd0\u5230\u57ce\u5e025\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u5927\u8fd0\u8f93\u91cf7\u516c\u65a4\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define fi first #define se second #define pii pair<int, int> int n , q ; ll c [ N ]; namespace SEG { struct node { ll Min , lazy ; node () {} node ( ll Min , ll lazy ) : Min ( Min ), lazy ( lazy ) {} void init () { Min = lazy = 0 ; } void add ( ll x ) { Min += x ; lazy += x ; } node operator + ( const node & other ) const { node res ; res . init (); res . Min = min ( Min , other . Min ); return res ; } } a [ N << 2 ]; void build ( int id , int l , int r ) { a [ id ]. init (); if ( l == r ) { a [ id ]. Min = c [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } void pushdown ( int id ) { if ( ! a [ id ]. lazy ) return ; ll & x = a [ id ]. lazy ; a [ id << 1 ]. add ( x ); a [ id << 1 | 1 ]. add ( x ); x = 0 ; } void update ( int id , int l , int r , int ql , int qr , ll v ) { if ( l >= ql && r <= qr ) { a [ id ]. add ( v ); return ; } int mid = ( l + r ) >> 1 ; pushdown ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } ll query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return a [ id ]. Min ; int mid = ( l + r ) >> 1 ; pushdown ( id ); ll res = ( ll ) 1e18 ; if ( ql <= mid ) res = min ( res , query ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) res = min ( res , query ( id << 1 | 1 , mid + 1 , r , ql , qr )); return res ; } } // namespace SEG pii a [ N ]; int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { for ( int i = 1 ; i < n ; ++ i ) scanf ( \"%lld\" , c + i ); ll res = 0 ; int l , r ; SEG :: build ( 1 , 1 , n - 1 ); for ( int i = 1 ; i <= q ; ++ i ) scanf ( \"%d%d\" , & a [ i ]. fi , & a [ i ]. se ); for ( int i = 1 ; i <= q ; ++ i ) { int & l = a [ i ]. fi , & r = a [ i ]. se ; if ( l > r ) swap ( l , r ); ++ l ; } sort ( a + 1 , a + 1 + q , [ & ]( pii a , pii b ) { return a . se < b . se ; }); for ( int i = 1 ; i <= q ; ++ i ) { int l = a [ i ]. fi , r = a [ i ]. se ; ll x = SEG :: query ( 1 , 1 , n - 1 , l , r ); // cout << x << endl; res += x ; SEG :: update ( 1 , 1 , n - 1 , l , r , - x ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"L3-017-\u68ee\u68ee\u5feb\u9012"},{"location":"CCCC/L3-017-%E6%A3%AE%E6%A3%AE%E5%BF%AB%E9%80%92/#l3-017-\u68ee\u68ee\u5feb\u9012","text":"","title":"L3-017 \u68ee\u68ee\u5feb\u9012"},{"location":"CCCC/L3-017-%E6%A3%AE%E6%A3%AE%E5%BF%AB%E9%80%92/#statement","text":"Metadata \u4f5c\u8005: \u4fde\u52c7 \u5355\u4f4d: \u4e0a\u6d77\u4ea4\u901a\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u5f00\u4e86\u4e00\u5bb6\u5feb\u9012\u516c\u53f8\uff0c\u53eb\u68ee\u68ee\u5feb\u9012\u3002\u56e0\u4e3a\u516c\u53f8\u521a\u521a\u5f00\u5f20\uff0c\u6240\u4ee5\u4e1a\u52a1\u8def\u7ebf\u5f88\u7b80\u5355\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f\u4e00\u6761\u76f4\u7ebf\u4e0a\u7684 N N \u4e2a\u57ce\u5e02\uff0c\u8fd9\u4e9b\u57ce\u5e02\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u4ece0\u5230 (N-1) (N-1) \u7f16\u53f7\u3002\u7531\u4e8e\u9053\u8def\u9650\u5236\uff0c\u7b2c i i \u53f7\u57ce\u5e02\uff08 i=0, \\cdots , N-2 i=0, \\cdots , N-2 \uff09\u4e0e\u7b2c (i+1) (i+1) \u53f7\u57ce\u5e02\u4e2d\u95f4\u5f80\u8fd4\u7684\u8fd0\u8f93\u8d27\u7269\u91cd\u91cf\u5728\u540c\u4e00\u65f6\u523b\u4e0d\u80fd\u8d85\u8fc7 C_i C_i \u516c\u65a4\u3002 \u516c\u53f8\u5f00\u5f20\u540e\u5f88\u5feb\u63a5\u5230\u4e86 Q Q \u5f20\u8ba2\u5355\uff0c\u5176\u4e2d j j \u5f20\u8ba2\u5355\u63cf\u8ff0\u4e86\u67d0\u4e9b\u6307\u5b9a\u7684\u8d27\u7269\u8981\u4ece S_j S_j \u53f7\u57ce\u5e02\u8fd0\u8f93\u5230 T_j T_j \u53f7\u57ce\u5e02\u3002\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u5730\u5047\u8bbe\u6240\u6709\u8d27\u7269\u90fd\u6709\u65e0\u9650\u8d27\u6e90\uff0c\u68ee\u68ee\u4f1a\u4e0d\u5b9a\u65f6\u5730\u6311\u9009\u5176\u4e2d\u4e00\u90e8\u5206\u8d27\u7269\u8fdb\u884c\u8fd0\u8f93\u3002\u5b89\u5168\u8d77\u89c1\uff0c\u8fd9\u4e9b\u8d27\u7269\u4e0d\u4f1a\u5728\u4e2d\u9014\u5378\u8d27\u3002 \u4e3a\u4e86\u8ba9\u516c\u53f8\u6574\u4f53\u6548\u76ca\u66f4\u4f73\uff0c\u68ee\u68ee\u60f3\u77e5\u9053\u5982\u4f55\u5b89\u6392\u8ba2\u5355\u7684\u8fd0\u8f93\uff0c\u80fd\u4f7f\u5f97\u8fd0\u8f93\u7684\u8d27\u7269\u91cd\u91cf\u6700\u5927\u4e14\u7b26\u5408\u9053\u8def\u7684\u9650\u5236\uff1f\u8981\u6ce8\u610f\u7684\u662f\uff0c\u53d1\u8d27\u65f6\u95f4\u6709\u53ef\u80fd\u662f\u4efb\u4f55\u65f6\u523b\uff0c\u6240\u4ee5\u6211\u4eec\u5b89\u6392\u8ba2\u5355\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u4fdd\u8bc1\u5171\u7528\u540c\u4e00\u6761\u9053\u8def\u7684\u6240\u6709\u8d27\u8f66\u7684\u603b\u91cd\u91cf\u4e0d\u8d85\u8f7d\u3002\u4f8b\u5982\u6211\u4eec\u5b89\u63921\u53f7\u57ce\u5e02\u52304\u53f7\u57ce\u5e02\u4ee5\u53ca2\u53f7\u57ce\u5e02\u52304\u53f7\u57ce\u5e02\u4e24\u5f20\u8ba2\u5355\u7684\u8fd0\u8f93\uff0c\u5219\u8fd9\u4e24\u5f20\u8ba2\u5355\u7684\u8fd0\u8f93\u540c\u65f6\u53d72-3\u4ee5\u53ca3-4\u4e24\u6761\u9053\u8def\u7684\u9650\u5236\uff0c\u56e0\u4e3a\u4e24\u5f20\u8ba2\u5355\u7684\u8d27\u7269\u53ef\u80fd\u4f1a\u540c\u65f6\u5728\u8fd9\u4e9b\u9053\u8def\u4e0a\u8fd0\u8f93\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c Q Q \uff08 2 \\le N \\le 10^5 2 \\le N \\le 10^5 , 1 \\le Q \\le 10^5 1 \\le Q \\le 10^5 \uff09\uff0c\u8868\u793a\u603b\u5171\u7684\u57ce\u5e02\u6570\u4ee5\u53ca\u8ba2\u5355\u6570\u91cf\u3002 \u7b2c\u4e8c\u884c\u7ed9\u51fa (N-1) (N-1) \u4e2a\u6570\uff0c\u987a\u6b21\u8868\u793a\u76f8\u90bb\u4e24\u57ce\u5e02\u95f4\u7684\u9053\u8def\u5141\u8bb8\u7684\u6700\u5927\u8fd0\u8d27\u91cd\u91cf C_i C_i \uff08 i=0, \\cdots , N-2 i=0, \\cdots , N-2 \uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a C_i C_i \u662f\u4e0d\u8d85\u8fc7 2^{31} 2^{31} \u7684\u975e\u8d1f\u6574\u6570\u3002 \u63a5\u4e0b\u6765 Q Q \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5f20\u8ba2\u5355\u7684\u8d77\u59cb\u53ca\u7ec8\u6b62\u8fd0\u8f93\u57ce\u5e02\u7f16\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u7f16\u53f7\u5408\u6cd5\uff0c\u5e76\u4e14\u4e0d\u5b58\u5728\u8d77\u70b9\u548c\u7ec8\u70b9\u91cd\u5408\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u53ef\u8fd0\u8f93\u8d27\u7269\u7684\u6700\u5927\u91cd\u91cf\u3002 \u8f93\u5165\u6837\u4f8b 10 6 0 7 8 5 2 3 1 9 10 0 9 1 8 2 7 6 3 4 5 4 2 \u8f93\u51fa\u6837\u4f8b 7 \u6837\u4f8b\u63d0\u793a \u6211\u4eec\u9009\u62e9\u6267\u884c\u6700\u540e\u4e24\u5f20\u8ba2\u5355\uff0c\u5373\u628a5\u516c\u65a4\u8d27\u4ece\u57ce\u5e024\u8fd0\u5230\u57ce\u5e022\uff0c\u5e76\u4e14\u628a2\u516c\u65a4\u8d27\u4ece\u57ce\u5e024\u8fd0\u5230\u57ce\u5e025\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u5927\u8fd0\u8f93\u91cf7\u516c\u65a4\u3002","title":"Statement"},{"location":"CCCC/L3-017-%E6%A3%AE%E6%A3%AE%E5%BF%AB%E9%80%92/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define fi first #define se second #define pii pair<int, int> int n , q ; ll c [ N ]; namespace SEG { struct node { ll Min , lazy ; node () {} node ( ll Min , ll lazy ) : Min ( Min ), lazy ( lazy ) {} void init () { Min = lazy = 0 ; } void add ( ll x ) { Min += x ; lazy += x ; } node operator + ( const node & other ) const { node res ; res . init (); res . Min = min ( Min , other . Min ); return res ; } } a [ N << 2 ]; void build ( int id , int l , int r ) { a [ id ]. init (); if ( l == r ) { a [ id ]. Min = c [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } void pushdown ( int id ) { if ( ! a [ id ]. lazy ) return ; ll & x = a [ id ]. lazy ; a [ id << 1 ]. add ( x ); a [ id << 1 | 1 ]. add ( x ); x = 0 ; } void update ( int id , int l , int r , int ql , int qr , ll v ) { if ( l >= ql && r <= qr ) { a [ id ]. add ( v ); return ; } int mid = ( l + r ) >> 1 ; pushdown ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); a [ id ] = a [ id << 1 ] + a [ id << 1 | 1 ]; } ll query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return a [ id ]. Min ; int mid = ( l + r ) >> 1 ; pushdown ( id ); ll res = ( ll ) 1e18 ; if ( ql <= mid ) res = min ( res , query ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) res = min ( res , query ( id << 1 | 1 , mid + 1 , r , ql , qr )); return res ; } } // namespace SEG pii a [ N ]; int main () { // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { for ( int i = 1 ; i < n ; ++ i ) scanf ( \"%lld\" , c + i ); ll res = 0 ; int l , r ; SEG :: build ( 1 , 1 , n - 1 ); for ( int i = 1 ; i <= q ; ++ i ) scanf ( \"%d%d\" , & a [ i ]. fi , & a [ i ]. se ); for ( int i = 1 ; i <= q ; ++ i ) { int & l = a [ i ]. fi , & r = a [ i ]. se ; if ( l > r ) swap ( l , r ); ++ l ; } sort ( a + 1 , a + 1 + q , [ & ]( pii a , pii b ) { return a . se < b . se ; }); for ( int i = 1 ; i <= q ; ++ i ) { int l = a [ i ]. fi , r = a [ i ]. se ; ll x = SEG :: query ( 1 , 1 , n - 1 , l , r ); // cout << x << endl; res += x ; SEG :: update ( 1 , 1 , n - 1 , l , r , - x ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-018-%E6%A3%AE%E6%A3%AE%E7%BE%8E%E5%9B%BE/","text":"L3-018 \u68ee\u68ee\u7f8e\u56fe Statement Metadata \u4f5c\u8005: \u6234\u9f99\u7ff1\u3001\u6731\u5efa\u79d1 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u6700\u8fd1\u60f3\u8ba9\u81ea\u5df1\u7684\u670b\u53cb\u5708\u71a0\u71a0\u751f\u8f89\uff0c\u6240\u4ee5\u4ed6\u51b3\u5b9a\u81ea\u5df1\u5199\u4e2a\u7f8e\u5316\u7167\u7247\u7684\u8f6f\u4ef6\uff0c\u5e76\u8d77\u540d\u4e3a\u68ee\u68ee\u7f8e\u56fe\u3002\u4f17\u6240\u5468\u77e5\uff0c\u5728\u5408\u7167\u4e2d\u7f8e\u5316\u81ea\u5df1\u7684\u9762\u90e8\u800c\u4e0d\u7f8e\u5316\u5408\u7167\u8005\u7684\u9762\u90e8\u662f\u8ba9\u81ea\u5df1\u5360\u636e\u670b\u53cb\u5708\u9ad8\u70b9\u7684\u7edd\u597d\u65b9\u6cd5\uff0c\u56e0\u6b64\u68ee\u68ee\u7f8e\u56fe\u91cc\u5f53\u7136\u5f97\u6709\u8fd9\u4e2a\u529f\u80fd\u3002 \u8fd9\u4e2a\u529f\u80fd\u7684\u7b2c\u4e00\u6b65\u662f\u5c06\u81ea\u5df1\u7684\u9762\u90e8\u9009\u4e2d\u3002\u68ee\u68ee\u9996\u5148\u8ba1\u7b97\u51fa\u4e86\u4e00\u4e2a\u56fe\u50cf\u4e2d\u6240\u6709\u50cf\u7d20\u70b9\u4e0e\u5468\u56f4\u70b9\u7684\u76f8\u4f3c\u7a0b\u5ea6\u7684\u5206\u6570\uff0c\u5206\u6570\u8d8a\u4f4e\u8868\u793a\u67d0\u4e2a\u50cf\u7d20\u70b9\u8d8a\u201c\u50cf\u201d\u4e00\u4e2a\u8f6e\u5ed3\u8fb9\u7f18\u4e0a\u7684\u70b9\u3002 \u68ee\u68ee\u8ba4\u4e3a\uff0c\u4efb\u610f\u8fde\u7eed\u50cf\u7d20\u70b9\u7684\u5f97\u5206\u4e4b\u548c\u8d8a\u4f4e\uff0c\u8868\u793a\u5b83\u4eec\u7ec4\u6210\u7684\u66f2\u7ebf\u548c\u8f6e\u5ed3\u8fb9\u7f18\u7684\u91cd\u5408\u7a0b\u5ea6\u8d8a\u9ad8\u3002\u4e3a\u4e86\u9009\u62e9\u51fa\u4e00\u4e2a\u5b8c\u6574\u7684\u9762\u90e8\uff0c\u68ee\u68ee\u51b3\u5b9a\u8ba9\u7528\u6237\u9009\u62e9\u9762\u90e8\u4e0a\u7684\u4e24\u4e2a\u50cf\u7d20\u70b9A\u548cB\uff0c\u5219\u8fde\u63a5\u8fd9\u4e24\u4e2a\u70b9\u7684\u76f4\u7ebf\u5c31\u5c06\u56fe\u50cf\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u7136\u540e\u5728\u8fd9\u4e24\u90e8\u5206\u4e2d\u5206\u522b\u5bfb\u627e\u4e00\u6761\u4eceA\u5230B\u4e14\u4e0e\u8f6e\u5ed3\u91cd\u5408\u7a0b\u5ea6\u6700\u9ad8\u7684\u66f2\u7ebf\uff0c\u5c31\u53ef\u4ee5\u62fc\u51fa\u7528\u6237\u7684\u9762\u90e8\u4e86\u3002 \u7136\u800c\u68ee\u68ee\u8ba1\u7b97\u51fa\u6765\u5f97\u5206\u77e9\u9635\u540e\uff0c\u7a81\u7136\u53d1\u73b0\u81ea\u5df1\u4e0d\u77e5\u9053\u600e\u4e48\u627e\u5230\u8fd9\u4e24\u6761\u66f2\u7ebf\u4e86\uff0c\u4f60\u80fd\u5e2e\u68ee\u68ee\u5f53\u4e0a\u670b\u53cb\u5708\u7684\u5c0f\u738b\u5b50\u5417\uff1f \u4e3a\u4e86\u89e3\u9898\u65b9\u4fbf\uff0c\u6211\u4eec\u505a\u51fa\u4ee5\u4e0b\u8865\u5145\u8bf4\u660e\uff1a \u56fe\u50cf\u7684\u5de6\u4e0a\u89d2\u662f\u5750\u6807\u539f\u70b9(0,0)\uff0c\u6211\u4eec\u5047\u8bbe\u6240\u6709\u50cf\u7d20\u6309\u77e9\u9635\u683c\u5f0f\u6392\u5217\uff0c\u5176\u5750\u6807\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff08\u5373\u6a2a\u8f74\u5411\u53f3\u4e3a\u6b63\uff0c\u7eb5\u8f74\u5411\u4e0b\u4e3a\u6b63\uff09\u3002 \u5ffd\u7565\u6b63\u597d\u4f4d\u4e8e\u8fde\u63a5A\u548cB\u7684\u76f4\u7ebf\uff08\u6ce8\u610f\u4e0d\u662f\u7ebf\u6bb5\uff09\u4e0a\u7684\u50cf\u7d20\u70b9\uff0c\u5373\u4e0d\u8ba4\u4e3a\u8fd9\u90e8\u5206\u50cf\u7d20\u70b9\u5728\u4efb\u4f55\u4e00\u4e2a\u5212\u5206\u90e8\u5206\u4e0a\uff0c\u56e0\u6b64\u66f2\u7ebf\u4e5f\u4e0d\u80fd\u7ecf\u8fc7\u8fd9\u90e8\u5206\u50cf\u7d20\u70b9\u3002 \u66f2\u7ebf\u662f\u516b\u8fde\u901a\u7684\uff08\u5373\u4efb\u4e00\u50cf\u7d20\u70b9\u53ef\u4e0e\u5176\u5468\u56f4\u76848\u4e2a\u50cf\u7d20\u8fde\u901a\uff09\uff0c\u4f46\u4e3a\u4e86\u8ba1\u7b97\u51c6\u786e\uff0c\u67d0\u50cf\u7d20\u8fde\u63a5\u5bf9\u89d2\u76f8\u90bb\u7684\u659c\u5411\u50cf\u7d20\u65f6\uff0c\u5f97\u5206 \u989d\u5916\u589e\u52a0 \u4e24\u4e2a\u50cf\u7d20\u5206\u6570\u548c\u7684 \\sqrt{2} \\sqrt{2} \u500d\u51cf\u4e00\u3002\u4f8b\u5982\u6837\u4f8b\u4e2d\uff0c\u7ecf\u8fc7\u5750\u6807\u4e3a(3,1)\u548c(4,2)\u7684\u4e24\u4e2a\u50cf\u7d20\u70b9\u7684\u66f2\u7ebf\uff0c\u5176\u5f97\u5206\u5e94\u8be5\u662f\u8fd9\u4e24\u4e2a\u50cf\u7d20\u70b9\u7684\u5206\u6570\u548c(2+2)\uff0c\u518d\u52a0\u4e0a\u989d\u5916\u7684(2+2)\u4e58\u4ee5( \\sqrt{2}-1 \\sqrt{2}-1 )\uff0c\u5373\u7ea6\u4e3a5.66\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M \uff08 5 \\le N, M \\le 100 5 \\le N, M \\le 100 \uff09\uff0c\u8868\u793a\u50cf\u7d20\u5f97\u5206\u77e9\u9635\u7684\u884c\u6570\u548c\u5217\u6570\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c M M \u4e2a\u4e0d\u5927\u4e8e1000\u7684\u975e\u8d1f\u6574\u6570\uff0c\u5373\u4e3a\u50cf\u7d20\u70b9\u7684\u5206\u503c\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u7528\u6237\u9009\u62e9\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u50cf\u7d20\u70b9\u7684\u5750\u6807 (X_{start}, Y_{start}) (X_{start}, Y_{start}) \u548c (X_{end}, Y_{end}) (X_{end}, Y_{end}) \u30024\u4e2a\u6574\u6570\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5212\u5206\u56fe\u7247\u540e\u627e\u5230\u7684\u8f6e\u5ed3\u66f2\u7ebf\u7684\u5f97\u5206\u548c\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d\u3002\u6ce8\u610f\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u5f97\u5206\u4e0d\u8981\u91cd\u590d\u8ba1\u7b97\u3002 \u8f93\u5165\u6837\u4f8b 6 6 9 0 1 9 9 9 9 9 1 2 2 9 9 9 2 0 2 9 9 9 1 1 2 9 9 9 3 3 1 1 9 9 9 9 9 9 2 1 5 4 \u8f93\u51fa\u6837\u4f8b 27.04","title":"L3-018-\u68ee\u68ee\u7f8e\u56fe"},{"location":"CCCC/L3-018-%E6%A3%AE%E6%A3%AE%E7%BE%8E%E5%9B%BE/#l3-018-\u68ee\u68ee\u7f8e\u56fe","text":"","title":"L3-018 \u68ee\u68ee\u7f8e\u56fe"},{"location":"CCCC/L3-018-%E6%A3%AE%E6%A3%AE%E7%BE%8E%E5%9B%BE/#statement","text":"Metadata \u4f5c\u8005: \u6234\u9f99\u7ff1\u3001\u6731\u5efa\u79d1 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u6700\u8fd1\u60f3\u8ba9\u81ea\u5df1\u7684\u670b\u53cb\u5708\u71a0\u71a0\u751f\u8f89\uff0c\u6240\u4ee5\u4ed6\u51b3\u5b9a\u81ea\u5df1\u5199\u4e2a\u7f8e\u5316\u7167\u7247\u7684\u8f6f\u4ef6\uff0c\u5e76\u8d77\u540d\u4e3a\u68ee\u68ee\u7f8e\u56fe\u3002\u4f17\u6240\u5468\u77e5\uff0c\u5728\u5408\u7167\u4e2d\u7f8e\u5316\u81ea\u5df1\u7684\u9762\u90e8\u800c\u4e0d\u7f8e\u5316\u5408\u7167\u8005\u7684\u9762\u90e8\u662f\u8ba9\u81ea\u5df1\u5360\u636e\u670b\u53cb\u5708\u9ad8\u70b9\u7684\u7edd\u597d\u65b9\u6cd5\uff0c\u56e0\u6b64\u68ee\u68ee\u7f8e\u56fe\u91cc\u5f53\u7136\u5f97\u6709\u8fd9\u4e2a\u529f\u80fd\u3002 \u8fd9\u4e2a\u529f\u80fd\u7684\u7b2c\u4e00\u6b65\u662f\u5c06\u81ea\u5df1\u7684\u9762\u90e8\u9009\u4e2d\u3002\u68ee\u68ee\u9996\u5148\u8ba1\u7b97\u51fa\u4e86\u4e00\u4e2a\u56fe\u50cf\u4e2d\u6240\u6709\u50cf\u7d20\u70b9\u4e0e\u5468\u56f4\u70b9\u7684\u76f8\u4f3c\u7a0b\u5ea6\u7684\u5206\u6570\uff0c\u5206\u6570\u8d8a\u4f4e\u8868\u793a\u67d0\u4e2a\u50cf\u7d20\u70b9\u8d8a\u201c\u50cf\u201d\u4e00\u4e2a\u8f6e\u5ed3\u8fb9\u7f18\u4e0a\u7684\u70b9\u3002 \u68ee\u68ee\u8ba4\u4e3a\uff0c\u4efb\u610f\u8fde\u7eed\u50cf\u7d20\u70b9\u7684\u5f97\u5206\u4e4b\u548c\u8d8a\u4f4e\uff0c\u8868\u793a\u5b83\u4eec\u7ec4\u6210\u7684\u66f2\u7ebf\u548c\u8f6e\u5ed3\u8fb9\u7f18\u7684\u91cd\u5408\u7a0b\u5ea6\u8d8a\u9ad8\u3002\u4e3a\u4e86\u9009\u62e9\u51fa\u4e00\u4e2a\u5b8c\u6574\u7684\u9762\u90e8\uff0c\u68ee\u68ee\u51b3\u5b9a\u8ba9\u7528\u6237\u9009\u62e9\u9762\u90e8\u4e0a\u7684\u4e24\u4e2a\u50cf\u7d20\u70b9A\u548cB\uff0c\u5219\u8fde\u63a5\u8fd9\u4e24\u4e2a\u70b9\u7684\u76f4\u7ebf\u5c31\u5c06\u56fe\u50cf\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u7136\u540e\u5728\u8fd9\u4e24\u90e8\u5206\u4e2d\u5206\u522b\u5bfb\u627e\u4e00\u6761\u4eceA\u5230B\u4e14\u4e0e\u8f6e\u5ed3\u91cd\u5408\u7a0b\u5ea6\u6700\u9ad8\u7684\u66f2\u7ebf\uff0c\u5c31\u53ef\u4ee5\u62fc\u51fa\u7528\u6237\u7684\u9762\u90e8\u4e86\u3002 \u7136\u800c\u68ee\u68ee\u8ba1\u7b97\u51fa\u6765\u5f97\u5206\u77e9\u9635\u540e\uff0c\u7a81\u7136\u53d1\u73b0\u81ea\u5df1\u4e0d\u77e5\u9053\u600e\u4e48\u627e\u5230\u8fd9\u4e24\u6761\u66f2\u7ebf\u4e86\uff0c\u4f60\u80fd\u5e2e\u68ee\u68ee\u5f53\u4e0a\u670b\u53cb\u5708\u7684\u5c0f\u738b\u5b50\u5417\uff1f \u4e3a\u4e86\u89e3\u9898\u65b9\u4fbf\uff0c\u6211\u4eec\u505a\u51fa\u4ee5\u4e0b\u8865\u5145\u8bf4\u660e\uff1a \u56fe\u50cf\u7684\u5de6\u4e0a\u89d2\u662f\u5750\u6807\u539f\u70b9(0,0)\uff0c\u6211\u4eec\u5047\u8bbe\u6240\u6709\u50cf\u7d20\u6309\u77e9\u9635\u683c\u5f0f\u6392\u5217\uff0c\u5176\u5750\u6807\u5747\u4e3a\u975e\u8d1f\u6574\u6570\uff08\u5373\u6a2a\u8f74\u5411\u53f3\u4e3a\u6b63\uff0c\u7eb5\u8f74\u5411\u4e0b\u4e3a\u6b63\uff09\u3002 \u5ffd\u7565\u6b63\u597d\u4f4d\u4e8e\u8fde\u63a5A\u548cB\u7684\u76f4\u7ebf\uff08\u6ce8\u610f\u4e0d\u662f\u7ebf\u6bb5\uff09\u4e0a\u7684\u50cf\u7d20\u70b9\uff0c\u5373\u4e0d\u8ba4\u4e3a\u8fd9\u90e8\u5206\u50cf\u7d20\u70b9\u5728\u4efb\u4f55\u4e00\u4e2a\u5212\u5206\u90e8\u5206\u4e0a\uff0c\u56e0\u6b64\u66f2\u7ebf\u4e5f\u4e0d\u80fd\u7ecf\u8fc7\u8fd9\u90e8\u5206\u50cf\u7d20\u70b9\u3002 \u66f2\u7ebf\u662f\u516b\u8fde\u901a\u7684\uff08\u5373\u4efb\u4e00\u50cf\u7d20\u70b9\u53ef\u4e0e\u5176\u5468\u56f4\u76848\u4e2a\u50cf\u7d20\u8fde\u901a\uff09\uff0c\u4f46\u4e3a\u4e86\u8ba1\u7b97\u51c6\u786e\uff0c\u67d0\u50cf\u7d20\u8fde\u63a5\u5bf9\u89d2\u76f8\u90bb\u7684\u659c\u5411\u50cf\u7d20\u65f6\uff0c\u5f97\u5206 \u989d\u5916\u589e\u52a0 \u4e24\u4e2a\u50cf\u7d20\u5206\u6570\u548c\u7684 \\sqrt{2} \\sqrt{2} \u500d\u51cf\u4e00\u3002\u4f8b\u5982\u6837\u4f8b\u4e2d\uff0c\u7ecf\u8fc7\u5750\u6807\u4e3a(3,1)\u548c(4,2)\u7684\u4e24\u4e2a\u50cf\u7d20\u70b9\u7684\u66f2\u7ebf\uff0c\u5176\u5f97\u5206\u5e94\u8be5\u662f\u8fd9\u4e24\u4e2a\u50cf\u7d20\u70b9\u7684\u5206\u6570\u548c(2+2)\uff0c\u518d\u52a0\u4e0a\u989d\u5916\u7684(2+2)\u4e58\u4ee5( \\sqrt{2}-1 \\sqrt{2}-1 )\uff0c\u5373\u7ea6\u4e3a5.66\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c M M \uff08 5 \\le N, M \\le 100 5 \\le N, M \\le 100 \uff09\uff0c\u8868\u793a\u50cf\u7d20\u5f97\u5206\u77e9\u9635\u7684\u884c\u6570\u548c\u5217\u6570\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c M M \u4e2a\u4e0d\u5927\u4e8e1000\u7684\u975e\u8d1f\u6574\u6570\uff0c\u5373\u4e3a\u50cf\u7d20\u70b9\u7684\u5206\u503c\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u7528\u6237\u9009\u62e9\u7684\u8d77\u59cb\u548c\u7ed3\u675f\u50cf\u7d20\u70b9\u7684\u5750\u6807 (X_{start}, Y_{start}) (X_{start}, Y_{start}) \u548c (X_{end}, Y_{end}) (X_{end}, Y_{end}) \u30024\u4e2a\u6574\u6570\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5212\u5206\u56fe\u7247\u540e\u627e\u5230\u7684\u8f6e\u5ed3\u66f2\u7ebf\u7684\u5f97\u5206\u548c\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e\u4e24\u4f4d\u3002\u6ce8\u610f\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u5f97\u5206\u4e0d\u8981\u91cd\u590d\u8ba1\u7b97\u3002 \u8f93\u5165\u6837\u4f8b 6 6 9 0 1 9 9 9 9 9 1 2 2 9 9 9 2 0 2 9 9 9 1 1 2 9 9 9 3 3 1 1 9 9 9 9 9 9 2 1 5 4 \u8f93\u51fa\u6837\u4f8b 27.04","title":"Statement"},{"location":"CCCC/L3-019-%E4%BB%A3%E7%A0%81%E6%8E%92%E7%89%88/","text":"L3-019 \u4ee3\u7801\u6392\u7248 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u7f16\u7a0b\u5927\u8d5b\u4e2d\u8bbe\u8ba1\u6709\u4e00\u4e2a\u6311\u6218\u73af\u8282\uff0c\u9009\u624b\u53ef\u4ee5\u67e5\u770b\u5176\u4ed6\u9009\u624b\u7684\u4ee3\u7801\uff0c\u53d1\u73b0\u9519\u8bef\u540e\uff0c\u63d0\u4ea4\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\u5c06\u5bf9\u624b\u6311\u843d\u9a6c\u4e0b\u3002\u4e3a\u4e86\u51cf\u5c0f\u88ab\u6311\u6218\u7684\u51e0\u7387\uff0c\u6709\u4e9b\u9009\u624b\u4f1a\u6545\u610f\u5c06\u4ee3\u7801\u5199\u5f97\u5f88\u96be\u770b\u61c2\uff0c\u6bd4\u5982\u628a\u6240\u6709\u56de\u8f66\u53bb\u6389\uff0c\u63d0\u4ea4\u6240\u6709\u5185\u5bb9\u90fd\u5728\u4e00\u884c\u7684\u7a0b\u5e8f\uff0c\u4ee4\u6311\u6218\u8005\u671b\u800c\u751f\u754f\u3002 \u4e3a\u4e86\u5bf9\u4ed8\u8fd9\u79cd\u9009\u624b\uff0c\u73b0\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u4ee3\u7801\u6392\u7248\u7a0b\u5e8f\uff0c\u5c06\u5199\u6210\u4e00\u884c\u7684\u7a0b\u5e8f\u91cd\u65b0\u6392\u7248\u3002\u5f53\u7136\u8981\u5199\u4e00\u4e2a\u5b8c\u7f8e\u7684\u6392\u7248\u7a0b\u5e8f\u53ef\u592a\u96be\u4e86\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u5730\u8981\u6c42\u5904\u7406C\u8bed\u8a00\u91cc\u7684for\u3001while\u3001if-else\u8fd9\u4e09\u79cd\u7279\u6b8a\u7ed3\u6784\uff0c\u800c\u5c06\u5176\u4ed6\u6240\u6709\u53e5\u5b50\u90fd\u5f53\u6210\u987a\u5e8f\u6267\u884c\u7684\u8bed\u53e5\u5904\u7406\u3002\u8f93\u51fa\u7684\u8981\u6c42\u5982\u4e0b\uff1a \u9ed8\u8ba4\u7a0b\u5e8f\u8d77\u59cb\u6ca1\u6709\u7f29\u8fdb\uff1b\u6bcf\u4e00\u7ea7\u7f29\u8fdb\u662f 2 \u4e2a\u7a7a\u683c\uff1b \u6bcf\u884c\u5f00\u5934\u9664\u4e86\u89c4\u5b9a\u7684\u7f29\u8fdb\u7a7a\u683c\u5916\uff0c\u4e0d\u8f93\u51fa\u591a\u4f59\u7684\u7a7a\u683c\uff1b \u987a\u5e8f\u6267\u884c\u7684\u7a0b\u5e8f\u4f53\u662f\u4ee5\u5206\u53f7\u201c;\u201d\u7ed3\u5c3e\u7684\uff0c\u9047\u5230\u5206\u53f7\u5c31\u6362\u884c\uff1b \u5728\u4e00\u5bf9\u5927\u62ec\u53f7\u201c{\u201d\u548c\u201c}\u201d\u4e2d\u7684\u7a0b\u5e8f\u4f53\u8f93\u51fa\u65f6\uff0c\u4e24\u7aef\u7684\u5927\u62ec\u53f7\u5355\u72ec\u5360\u4e00\u884c\uff0c\u5185\u90e8\u7a0b\u5e8f\u4f53\u6bcf\u884c\u52a0\u4e00\u7ea7\u7f29\u8fdb\uff0c\u5373\uff1a { \u7a0b\u5e8f\u4f53 } for\u7684\u683c\u5f0f\u4e3a\uff1a for (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } while\u7684\u683c\u5f0f\u4e3a\uff1a while (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } if-else\u7684\u683c\u5f0f\u4e3a\uff1a if (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } else { \u7a0b\u5e8f\u4f53 } \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e0d\u8d85\u8fc7 331 \u4e2a\u5b57\u7b26\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u662f\u4e00\u4e2a\u8bed\u6cd5\u6b63\u786e\u3001\u53ef\u4ee5\u6b63\u5e38\u7f16\u8bd1\u8fd0\u884c\u7684 main \u51fd\u6570\u6a21\u5757\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u9762\u8981\u6c42\u7684\u683c\u5f0f\uff0c\u8f93\u51fa\u6392\u7248\u540e\u7684\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b int main() {int n, i; scanf(\"%d\", &n);if( n>0)n++;else if (n<0) n--; else while(n<10)n++; for(i=0; i<n; i++ ){ printf(\"n=%d\\n\", n);}return 0; } \u8f93\u51fa\u6837\u4f8b int main() { int n, i; scanf(\"%d\", &n); if ( n>0) { n++; } else { if (n<0) { n--; } else { while (n<10) { n++; } } } for (i=0; i<n; i++ ) { printf(\"n=%d\\n\", n); } return 0; }","title":"L3-019-\u4ee3\u7801\u6392\u7248"},{"location":"CCCC/L3-019-%E4%BB%A3%E7%A0%81%E6%8E%92%E7%89%88/#l3-019-\u4ee3\u7801\u6392\u7248","text":"","title":"L3-019 \u4ee3\u7801\u6392\u7248"},{"location":"CCCC/L3-019-%E4%BB%A3%E7%A0%81%E6%8E%92%E7%89%88/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u7f16\u7a0b\u5927\u8d5b\u4e2d\u8bbe\u8ba1\u6709\u4e00\u4e2a\u6311\u6218\u73af\u8282\uff0c\u9009\u624b\u53ef\u4ee5\u67e5\u770b\u5176\u4ed6\u9009\u624b\u7684\u4ee3\u7801\uff0c\u53d1\u73b0\u9519\u8bef\u540e\uff0c\u63d0\u4ea4\u4e00\u7ec4\u6d4b\u8bd5\u6570\u636e\u5c06\u5bf9\u624b\u6311\u843d\u9a6c\u4e0b\u3002\u4e3a\u4e86\u51cf\u5c0f\u88ab\u6311\u6218\u7684\u51e0\u7387\uff0c\u6709\u4e9b\u9009\u624b\u4f1a\u6545\u610f\u5c06\u4ee3\u7801\u5199\u5f97\u5f88\u96be\u770b\u61c2\uff0c\u6bd4\u5982\u628a\u6240\u6709\u56de\u8f66\u53bb\u6389\uff0c\u63d0\u4ea4\u6240\u6709\u5185\u5bb9\u90fd\u5728\u4e00\u884c\u7684\u7a0b\u5e8f\uff0c\u4ee4\u6311\u6218\u8005\u671b\u800c\u751f\u754f\u3002 \u4e3a\u4e86\u5bf9\u4ed8\u8fd9\u79cd\u9009\u624b\uff0c\u73b0\u8bf7\u4f60\u7f16\u5199\u4e00\u4e2a\u4ee3\u7801\u6392\u7248\u7a0b\u5e8f\uff0c\u5c06\u5199\u6210\u4e00\u884c\u7684\u7a0b\u5e8f\u91cd\u65b0\u6392\u7248\u3002\u5f53\u7136\u8981\u5199\u4e00\u4e2a\u5b8c\u7f8e\u7684\u6392\u7248\u7a0b\u5e8f\u53ef\u592a\u96be\u4e86\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u5730\u8981\u6c42\u5904\u7406C\u8bed\u8a00\u91cc\u7684for\u3001while\u3001if-else\u8fd9\u4e09\u79cd\u7279\u6b8a\u7ed3\u6784\uff0c\u800c\u5c06\u5176\u4ed6\u6240\u6709\u53e5\u5b50\u90fd\u5f53\u6210\u987a\u5e8f\u6267\u884c\u7684\u8bed\u53e5\u5904\u7406\u3002\u8f93\u51fa\u7684\u8981\u6c42\u5982\u4e0b\uff1a \u9ed8\u8ba4\u7a0b\u5e8f\u8d77\u59cb\u6ca1\u6709\u7f29\u8fdb\uff1b\u6bcf\u4e00\u7ea7\u7f29\u8fdb\u662f 2 \u4e2a\u7a7a\u683c\uff1b \u6bcf\u884c\u5f00\u5934\u9664\u4e86\u89c4\u5b9a\u7684\u7f29\u8fdb\u7a7a\u683c\u5916\uff0c\u4e0d\u8f93\u51fa\u591a\u4f59\u7684\u7a7a\u683c\uff1b \u987a\u5e8f\u6267\u884c\u7684\u7a0b\u5e8f\u4f53\u662f\u4ee5\u5206\u53f7\u201c;\u201d\u7ed3\u5c3e\u7684\uff0c\u9047\u5230\u5206\u53f7\u5c31\u6362\u884c\uff1b \u5728\u4e00\u5bf9\u5927\u62ec\u53f7\u201c{\u201d\u548c\u201c}\u201d\u4e2d\u7684\u7a0b\u5e8f\u4f53\u8f93\u51fa\u65f6\uff0c\u4e24\u7aef\u7684\u5927\u62ec\u53f7\u5355\u72ec\u5360\u4e00\u884c\uff0c\u5185\u90e8\u7a0b\u5e8f\u4f53\u6bcf\u884c\u52a0\u4e00\u7ea7\u7f29\u8fdb\uff0c\u5373\uff1a { \u7a0b\u5e8f\u4f53 } for\u7684\u683c\u5f0f\u4e3a\uff1a for (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } while\u7684\u683c\u5f0f\u4e3a\uff1a while (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } if-else\u7684\u683c\u5f0f\u4e3a\uff1a if (\u6761\u4ef6) { \u7a0b\u5e8f\u4f53 } else { \u7a0b\u5e8f\u4f53 } \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e0d\u8d85\u8fc7 331 \u4e2a\u5b57\u7b26\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u7684\u662f\u4e00\u4e2a\u8bed\u6cd5\u6b63\u786e\u3001\u53ef\u4ee5\u6b63\u5e38\u7f16\u8bd1\u8fd0\u884c\u7684 main \u51fd\u6570\u6a21\u5757\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u9898\u9762\u8981\u6c42\u7684\u683c\u5f0f\uff0c\u8f93\u51fa\u6392\u7248\u540e\u7684\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b int main() {int n, i; scanf(\"%d\", &n);if( n>0)n++;else if (n<0) n--; else while(n<10)n++; for(i=0; i<n; i++ ){ printf(\"n=%d\\n\", n);}return 0; } \u8f93\u51fa\u6837\u4f8b int main() { int n, i; scanf(\"%d\", &n); if ( n>0) { n++; } else { if (n<0) { n--; } else { while (n<10) { n++; } } } for (i=0; i<n; i++ ) { printf(\"n=%d\\n\", n); } return 0; }","title":"Statement"},{"location":"CCCC/L3-020-%E8%87%B3%E5%A4%9A%E5%88%A0%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6/","text":"L3-020 \u81f3\u591a\u5220\u4e09\u4e2a\u5b57\u7b26 Statement Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5168\u90e8\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5141\u8bb8\u4f60\u81f3\u591a\u5220\u6389\u5176\u4e2d 3 \u4e2a\u5b57\u7b26\uff0c\u7ed3\u679c\u53ef\u80fd\u6709\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u5b57\u7b26\u4e32\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5168\u90e8\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u5728\u533a\u95f4 [4, 10^6 10^6 ] \u5185\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u81f3\u591a\u5220\u6389\u5176\u4e2d 3 \u4e2a\u5b57\u7b26\u540e\u4e0d\u540c\u5b57\u7b26\u4e32\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b ababcc \u8f93\u51fa\u6837\u4f8b 25 \u63d0\u793a\uff1a \u5220\u6389 0 \u4e2a\u5b57\u7b26\u5f97\u5230 \"ababcc\"\u3002 \u5220\u6389 1 \u4e2a\u5b57\u7b26\u5f97\u5230 \"babcc\", \"aabcc\", \"abbcc\", \"abacc\" \u548c \"ababc\"\u3002 \u5220\u6389 2 \u4e2a\u5b57\u7b26\u5f97\u5230 \"abcc\", \"bbcc\", \"bacc\", \"babc\", \"aacc\", \"aabc\", \"abbc\", \"abac\" \u548c \"abab\"\u3002 \u5220\u6389 3 \u4e2a\u5b57\u7b26\u5f97\u5230 \"abc\", \"bcc\", \"acc\", \"bbc\", \"bac\", \"bab\", \"aac\", \"aab\", \"abb\" \u548c \"aba\"\u3002 Tutorial \u601d\u8def\uff1a f[i][j] f[i][j] \u8868\u793a\u5230\u7b2c i i \u4e2a\u5b57\u7b26\uff0c\u5df2\u7ecf\u5220\u53bb\u4e86 j j \u4e2a\u5b57\u7b26\u7684\u65b9\u6848\u6570\u3002 \u6709\u8f6c\u79fb\uff1a f[i][j] = f[i - 1][j] + f[i - 1][j - 1] f[i][j] = f[i - 1][j] + f[i - 1][j - 1] \u4f46\u662f\u8fd9\u6837\u4f1a\u6709\u91cd\u590d\uff0c\u6211\u4eec\u8003\u8651\u4ec0\u4e48\u60c5\u51b5\u4f1a\u91cd\u590d\u3002 \u6bd4\u5982\u8bf4\uff1a aabab \u4e2d\u7684 bab \uff0c\u6211\u4eec\u5220\u53bb ba \uff0c\u5f97\u5230 aab \uff0c\u5220\u53bb ab \u5f97\u5230 aab \uff0c\u4e24\u8005\u662f\u76f8\u540c\u7684 1 2 3 4 5 a a b a b \u6211\u4eec\u5047\u8bbe\u4e4b\u524d\u7684\u6bcf\u4e00\u4f4d\u5b58\u7684\u90fd\u662f\u6ca1\u6709\u91cd\u590d\u7684\u65b9\u6848\u6570 \u5c31\u521a\u624d\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53d1\u73b0\u5f53\u6211\u4eec\u9012\u63a8\u5230\u7b2c 5 5 \u4e2a\u4f4d\u7f6e\u7684\u65f6\u5019\uff0c\u5220\u53bb\u7b2c\u4e09\u4f4d\u548c\u7b2c\u56db\u4f4d\u7684 ba \uff0c\u4f46\u662f\u4fdd\u7559\u7740\u7b2c\u4e94\u4f4d\u7684 b \u90a3\u8fd9\u79cd\u60c5\u51b5\u548c\u9012\u63a8\u5230\u7b2c 3 3 \u4e2a\u4f4d\u7f6e\u7684\u65f6\u5019\uff0c\u4fdd\u7559\u7740\u7b2c 3 3 \u4f4d\u7684 b \u662f\u4e00\u6837\u7684 \u5373\uff1a \\begin{eqnarray*} f[5][2] &=& f[2][0] \\\\ f[5][3] &=& f[2][1] \\end{eqnarray*} \\begin{eqnarray*} f[5][2] &=& f[2][0] \\\\ f[5][3] &=& f[2][1] \\end{eqnarray*} \u51cf\u53bb\u8fd9\u4e9b\u91cd\u590d\u60c5\u51b5\uff0c\u6211\u4eec\u5c31\u80fd\u4fdd\u8bc1\u5df2\u7ecf\u9012\u63a8\u8fc7\u6765\u7684\u60c5\u51b5\u4e2d\u6ca1\u6709\u91cd\u590d\u60c5\u51b5\u3002 \u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u5f53\u524d\u5b57\u7b26 i i \uff0c\u8be5\u5b57\u7b26\u524d\u4e00\u4e2a\u51fa\u73b0\u7684\u4f4d\u7f6e\u662f j j \uff0c\u90a3\u4e48\u6211\u4eec\u8003\u8651\u5220\u53bb i i \u8fd9\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u8fd9\u65f6\u7528\u4e86 x x \u6b21\u5220\u9664\u6b21\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u591a\u82b1\u8d39 i - j - 2 i - j - 2 \u6b21\u7684\u5220\u9664\u6b21\u6570\uff0c\u5c06 (i, j) (i, j) \u4e4b\u95f4\u7684\u5b57\u7b26\u5168\u90e8\u5220\u9664\uff0c\u90a3\u4e48\u8fd9\u79cd\u60c5\u51b5\u7b49\u4ef7\u4e8e\u5220\u9664 j j \u90a3\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u8fd9\u662f\u7528\u4e86 x x \u6b21\u5220\u9664\u6b21\u6570\u7684\u60c5\u51b5\u662f\u76f8\u540c\u7684\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e6 + 10 ; int n , pos [ 220 ]; ll f [ N ][ 4 ]; char s [ N ]; int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); memset ( pos , -1 , sizeof pos ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int d = pos [ s [ i ]]; pos [ s [ i ]] = i ; f [ i ][ 0 ] = f [ i ][ 1 ] = 1 ; for ( int j = 1 ; j < 4 ; ++ j ) { f [ i ][ j ] += f [ i - 1 ][ j ]; f [ i ][ j + 1 ] = f [ i - 1 ][ j ]; if ( d != -1 && j - i + d >= 0 ) f [ i ][ j ] -= f [ d - 1 ][ j - ( i - d )]; } } printf ( \"%lld \\n \" , f [ n ][ 0 ] + f [ n ][ 1 ] + f [ n ][ 2 ] + f [ n ][ 3 ]); return 0 ; }","title":"L3-020-\u81f3\u591a\u5220\u4e09\u4e2a\u5b57\u7b26"},{"location":"CCCC/L3-020-%E8%87%B3%E5%A4%9A%E5%88%A0%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6/#l3-020-\u81f3\u591a\u5220\u4e09\u4e2a\u5b57\u7b26","text":"","title":"L3-020 \u81f3\u591a\u5220\u4e09\u4e2a\u5b57\u7b26"},{"location":"CCCC/L3-020-%E8%87%B3%E5%A4%9A%E5%88%A0%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6/#statement","text":"Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5168\u90e8\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5141\u8bb8\u4f60\u81f3\u591a\u5220\u6389\u5176\u4e2d 3 \u4e2a\u5b57\u7b26\uff0c\u7ed3\u679c\u53ef\u80fd\u6709\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u5b57\u7b26\u4e32\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u5168\u90e8\u7531\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u5728\u533a\u95f4 [4, 10^6 10^6 ] \u5185\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u81f3\u591a\u5220\u6389\u5176\u4e2d 3 \u4e2a\u5b57\u7b26\u540e\u4e0d\u540c\u5b57\u7b26\u4e32\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b ababcc \u8f93\u51fa\u6837\u4f8b 25 \u63d0\u793a\uff1a \u5220\u6389 0 \u4e2a\u5b57\u7b26\u5f97\u5230 \"ababcc\"\u3002 \u5220\u6389 1 \u4e2a\u5b57\u7b26\u5f97\u5230 \"babcc\", \"aabcc\", \"abbcc\", \"abacc\" \u548c \"ababc\"\u3002 \u5220\u6389 2 \u4e2a\u5b57\u7b26\u5f97\u5230 \"abcc\", \"bbcc\", \"bacc\", \"babc\", \"aacc\", \"aabc\", \"abbc\", \"abac\" \u548c \"abab\"\u3002 \u5220\u6389 3 \u4e2a\u5b57\u7b26\u5f97\u5230 \"abc\", \"bcc\", \"acc\", \"bbc\", \"bac\", \"bab\", \"aac\", \"aab\", \"abb\" \u548c \"aba\"\u3002","title":"Statement"},{"location":"CCCC/L3-020-%E8%87%B3%E5%A4%9A%E5%88%A0%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6/#tutorial","text":"\u601d\u8def\uff1a f[i][j] f[i][j] \u8868\u793a\u5230\u7b2c i i \u4e2a\u5b57\u7b26\uff0c\u5df2\u7ecf\u5220\u53bb\u4e86 j j \u4e2a\u5b57\u7b26\u7684\u65b9\u6848\u6570\u3002 \u6709\u8f6c\u79fb\uff1a f[i][j] = f[i - 1][j] + f[i - 1][j - 1] f[i][j] = f[i - 1][j] + f[i - 1][j - 1] \u4f46\u662f\u8fd9\u6837\u4f1a\u6709\u91cd\u590d\uff0c\u6211\u4eec\u8003\u8651\u4ec0\u4e48\u60c5\u51b5\u4f1a\u91cd\u590d\u3002 \u6bd4\u5982\u8bf4\uff1a aabab \u4e2d\u7684 bab \uff0c\u6211\u4eec\u5220\u53bb ba \uff0c\u5f97\u5230 aab \uff0c\u5220\u53bb ab \u5f97\u5230 aab \uff0c\u4e24\u8005\u662f\u76f8\u540c\u7684 1 2 3 4 5 a a b a b \u6211\u4eec\u5047\u8bbe\u4e4b\u524d\u7684\u6bcf\u4e00\u4f4d\u5b58\u7684\u90fd\u662f\u6ca1\u6709\u91cd\u590d\u7684\u65b9\u6848\u6570 \u5c31\u521a\u624d\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53d1\u73b0\u5f53\u6211\u4eec\u9012\u63a8\u5230\u7b2c 5 5 \u4e2a\u4f4d\u7f6e\u7684\u65f6\u5019\uff0c\u5220\u53bb\u7b2c\u4e09\u4f4d\u548c\u7b2c\u56db\u4f4d\u7684 ba \uff0c\u4f46\u662f\u4fdd\u7559\u7740\u7b2c\u4e94\u4f4d\u7684 b \u90a3\u8fd9\u79cd\u60c5\u51b5\u548c\u9012\u63a8\u5230\u7b2c 3 3 \u4e2a\u4f4d\u7f6e\u7684\u65f6\u5019\uff0c\u4fdd\u7559\u7740\u7b2c 3 3 \u4f4d\u7684 b \u662f\u4e00\u6837\u7684 \u5373\uff1a \\begin{eqnarray*} f[5][2] &=& f[2][0] \\\\ f[5][3] &=& f[2][1] \\end{eqnarray*} \\begin{eqnarray*} f[5][2] &=& f[2][0] \\\\ f[5][3] &=& f[2][1] \\end{eqnarray*} \u51cf\u53bb\u8fd9\u4e9b\u91cd\u590d\u60c5\u51b5\uff0c\u6211\u4eec\u5c31\u80fd\u4fdd\u8bc1\u5df2\u7ecf\u9012\u63a8\u8fc7\u6765\u7684\u60c5\u51b5\u4e2d\u6ca1\u6709\u91cd\u590d\u60c5\u51b5\u3002 \u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u5f53\u524d\u5b57\u7b26 i i \uff0c\u8be5\u5b57\u7b26\u524d\u4e00\u4e2a\u51fa\u73b0\u7684\u4f4d\u7f6e\u662f j j \uff0c\u90a3\u4e48\u6211\u4eec\u8003\u8651\u5220\u53bb i i \u8fd9\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u8fd9\u65f6\u7528\u4e86 x x \u6b21\u5220\u9664\u6b21\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u591a\u82b1\u8d39 i - j - 2 i - j - 2 \u6b21\u7684\u5220\u9664\u6b21\u6570\uff0c\u5c06 (i, j) (i, j) \u4e4b\u95f4\u7684\u5b57\u7b26\u5168\u90e8\u5220\u9664\uff0c\u90a3\u4e48\u8fd9\u79cd\u60c5\u51b5\u7b49\u4ef7\u4e8e\u5220\u9664 j j \u90a3\u4e2a\u5b57\u7b26\uff0c\u5e76\u4e14\u8fd9\u662f\u7528\u4e86 x x \u6b21\u5220\u9664\u6b21\u6570\u7684\u60c5\u51b5\u662f\u76f8\u540c\u7684\u3002","title":"Tutorial"},{"location":"CCCC/L3-020-%E8%87%B3%E5%A4%9A%E5%88%A0%E4%B8%89%E4%B8%AA%E5%AD%97%E7%AC%A6/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int N = 1e6 + 10 ; int n , pos [ 220 ]; ll f [ N ][ 4 ]; char s [ N ]; int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); memset ( pos , -1 , sizeof pos ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int d = pos [ s [ i ]]; pos [ s [ i ]] = i ; f [ i ][ 0 ] = f [ i ][ 1 ] = 1 ; for ( int j = 1 ; j < 4 ; ++ j ) { f [ i ][ j ] += f [ i - 1 ][ j ]; f [ i ][ j + 1 ] = f [ i - 1 ][ j ]; if ( d != -1 && j - i + d >= 0 ) f [ i ][ j ] -= f [ d - 1 ][ j - ( i - d )]; } } printf ( \"%lld \\n \" , f [ n ][ 0 ] + f [ n ][ 1 ] + f [ n ][ 2 ] + f [ n ][ 3 ]); return 0 ; }","title":"Solution"},{"location":"CCCC/L3-021-%E7%A5%9E%E5%9D%9B/","text":"L3-021 \u795e\u575b Statement Metadata \u4f5c\u8005: \u9093\u4fca\u8f89 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 8000 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u53e4\u8001\u7684\u8fc8\u745e\u57ce\uff0c\u5dcd\u7136\u5c79\u7acb\u7740 n \u5757\u795e\u77f3\u3002\u957f\u8001\u4eec\u5546\u8bae\uff0c\u9009\u53d6 3 \u5757\u795e\u77f3\u56f4\u6210\u4e00\u4e2a\u795e\u575b\u3002\u56e0\u4e3a\u795e\u575b\u7684\u80fd\u91cf\u5f3a\u5ea6\u4e0e\u5b83\u7684\u9762\u79ef\u6210\u53cd\u6bd4\uff0c\u56e0\u6b64\u795e\u575b\u7684\u9762\u79ef\u8d8a\u5c0f\u8d8a\u597d\u3002\u7279\u6b8a\u5730\uff0c\u5982\u679c\u6709\u4e24\u5757\u795e\u77f3\u5750\u6807\u76f8\u540c\uff0c\u6216\u8005\u4e09\u5757\u795e\u77f3\u5171\u7ebf\uff0c\u795e\u575b\u7684\u9762\u79ef\u4e3a 0.000 \u3002 \u957f\u8001\u4eec\u53d1\u73b0\u8fd9\u4e2a\u95ee\u9898\u6ca1\u6709\u90a3\u4e48\u7b80\u5355\uff0c\u4e8e\u662f\u59d4\u6258\u4f60\u7f16\u7a0b\u89e3\u51b3\u8fd9\u4e2a\u96be\u9898\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 n\uff083 \\le \\le n \\le \\le 5000\uff09\u3002\u968f\u540e n \u884c\uff0c\u6bcf\u884c\u6709\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u8868\u793a\u795e\u77f3\u7684\u6a2a\u5750\u6807\u3001\u7eb5\u5750\u6807\uff08 -10^9 \\le -10^9 \\le \u6a2a\u5750\u6807\u3001\u7eb5\u5750\u6807 < 10^9 < 10^9 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u795e\u575b\u7684\u6700\u5c0f\u9762\u79ef\uff0c\u56db\u820d\u4e94\u5165\u4fdd\u7559 3 \u4f4d\u5c0f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 8 3 4 2 4 1 1 4 1 0 3 3 0 1 3 4 2 \u8f93\u51fa\u6837\u4f8b 0.500 \u6837\u4f8b\u89e3\u91ca \u8f93\u51fa\u7684\u6570\u503c\u7b49\u4e8e\u56fe\u4e2d\u7ea2\u8272\u6216\u7d2b\u8272\u6846\u7ebf\u7684\u4e09\u89d2\u5f62\u7684\u9762\u79ef\u3002 \u9e23\u8c22\u6d59\u6c5f\u5e08\u8303\u5927\u5b66\u4f0d\u6cf0\u709c\u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define pii pair<int, int> #define fi first #define se second #define N 5010 int n , m ; int x [ N ], y [ N ]; pii cor [ N ]; ll Cross ( pii a , pii b ) { return abs ( 1l l * a . fi * b . se - 1l l * b . fi * a . se ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d%d\" , x + i , y + i ); ll res = ( ll ) 1e18 ; for ( int i = 1 ; i <= n ; ++ i ) { m = 0 ; for ( int j = 1 ; j <= n ; ++ j ) if ( i != j ) { ++ m ; cor [ m ]. fi = x [ j ] - x [ i ]; cor [ m ]. se = y [ j ] - y [ i ]; } sort ( cor + 1 , cor + 1 + m , []( pii a , pii b ) { return 1l l * a . fi * b . se < 1l l * b . fi * a . se ; }); for ( int j = 2 ; j <= m ; ++ j ) res = min ( res , Cross ( cor [ j - 1 ], cor [ j ])); } printf ( \"%.3f \\n \" , res * 0.5 ); } return 0 ; }","title":"L3-021-\u795e\u575b"},{"location":"CCCC/L3-021-%E7%A5%9E%E5%9D%9B/#l3-021-\u795e\u575b","text":"","title":"L3-021 \u795e\u575b"},{"location":"CCCC/L3-021-%E7%A5%9E%E5%9D%9B/#statement","text":"Metadata \u4f5c\u8005: \u9093\u4fca\u8f89 \u5355\u4f4d: \u6e05\u534e\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 8000 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u53e4\u8001\u7684\u8fc8\u745e\u57ce\uff0c\u5dcd\u7136\u5c79\u7acb\u7740 n \u5757\u795e\u77f3\u3002\u957f\u8001\u4eec\u5546\u8bae\uff0c\u9009\u53d6 3 \u5757\u795e\u77f3\u56f4\u6210\u4e00\u4e2a\u795e\u575b\u3002\u56e0\u4e3a\u795e\u575b\u7684\u80fd\u91cf\u5f3a\u5ea6\u4e0e\u5b83\u7684\u9762\u79ef\u6210\u53cd\u6bd4\uff0c\u56e0\u6b64\u795e\u575b\u7684\u9762\u79ef\u8d8a\u5c0f\u8d8a\u597d\u3002\u7279\u6b8a\u5730\uff0c\u5982\u679c\u6709\u4e24\u5757\u795e\u77f3\u5750\u6807\u76f8\u540c\uff0c\u6216\u8005\u4e09\u5757\u795e\u77f3\u5171\u7ebf\uff0c\u795e\u575b\u7684\u9762\u79ef\u4e3a 0.000 \u3002 \u957f\u8001\u4eec\u53d1\u73b0\u8fd9\u4e2a\u95ee\u9898\u6ca1\u6709\u90a3\u4e48\u7b80\u5355\uff0c\u4e8e\u662f\u59d4\u6258\u4f60\u7f16\u7a0b\u89e3\u51b3\u8fd9\u4e2a\u96be\u9898\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 n\uff083 \\le \\le n \\le \\le 5000\uff09\u3002\u968f\u540e n \u884c\uff0c\u6bcf\u884c\u6709\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u8868\u793a\u795e\u77f3\u7684\u6a2a\u5750\u6807\u3001\u7eb5\u5750\u6807\uff08 -10^9 \\le -10^9 \\le \u6a2a\u5750\u6807\u3001\u7eb5\u5750\u6807 < 10^9 < 10^9 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u795e\u575b\u7684\u6700\u5c0f\u9762\u79ef\uff0c\u56db\u820d\u4e94\u5165\u4fdd\u7559 3 \u4f4d\u5c0f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 8 3 4 2 4 1 1 4 1 0 3 3 0 1 3 4 2 \u8f93\u51fa\u6837\u4f8b 0.500","title":"Statement"},{"location":"CCCC/L3-021-%E7%A5%9E%E5%9D%9B/#\u6837\u4f8b\u89e3\u91ca","text":"\u8f93\u51fa\u7684\u6570\u503c\u7b49\u4e8e\u56fe\u4e2d\u7ea2\u8272\u6216\u7d2b\u8272\u6846\u7ebf\u7684\u4e09\u89d2\u5f62\u7684\u9762\u79ef\u3002 \u9e23\u8c22\u6d59\u6c5f\u5e08\u8303\u5927\u5b66\u4f0d\u6cf0\u709c\u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01","title":"\u6837\u4f8b\u89e3\u91ca"},{"location":"CCCC/L3-021-%E7%A5%9E%E5%9D%9B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define pii pair<int, int> #define fi first #define se second #define N 5010 int n , m ; int x [ N ], y [ N ]; pii cor [ N ]; ll Cross ( pii a , pii b ) { return abs ( 1l l * a . fi * b . se - 1l l * b . fi * a . se ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d%d\" , x + i , y + i ); ll res = ( ll ) 1e18 ; for ( int i = 1 ; i <= n ; ++ i ) { m = 0 ; for ( int j = 1 ; j <= n ; ++ j ) if ( i != j ) { ++ m ; cor [ m ]. fi = x [ j ] - x [ i ]; cor [ m ]. se = y [ j ] - y [ i ]; } sort ( cor + 1 , cor + 1 + m , []( pii a , pii b ) { return 1l l * a . fi * b . se < 1l l * b . fi * a . se ; }); for ( int j = 2 ; j <= m ; ++ j ) res = min ( res , Cross ( cor [ j - 1 ], cor [ j ])); } printf ( \"%.3f \\n \" , res * 0.5 ); } return 0 ; }","title":"Solution"},{"location":"CCCC/L3-022-%E5%9C%B0%E9%93%81%E4%B8%80%E6%97%A5%E6%B8%B8/","text":"L3-022 \u5730\u94c1\u4e00\u65e5\u6e38 Statement Metadata \u4f5c\u8005: \u6234\u9f99\u7ff1 \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 550 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u559c\u6b22\u5750\u5730\u94c1\u3002\u8fd9\u4e2a\u5047\u671f\uff0c\u4ed6\u7ec8\u4e8e\u6765\u5230\u4e86\u4f20\u8bf4\u4e2d\u7684\u5730\u94c1\u4e4b\u57ce\u2014\u2014\u9b54\u90fd\uff0c\u6253\u7b97\u597d\u597d\u8fc7\u4e00\u628a\u5750\u5730\u94c1\u7684\u763e\uff01 \u9b54\u90fd\u5730\u94c1\u7684\u8ba1\u4ef7\u89c4\u5219\u662f\uff1a\u8d77\u6b65\u4ef7 2 \u5143\uff0c\u51fa\u53d1\u7ad9\u4e0e\u5230\u8fbe\u7ad9\u7684\u6700\u77ed\u8ddd\u79bb\uff08\u5373 \u8ba1\u8d39\u8ddd\u79bb \uff09\u6bcf K \u516c\u91cc\u589e\u52a0 1 \u5143\u8f66\u8d39\u3002 \u4f8b\u5982\u53d6 K = 10\uff0c\u52a8\u5b89\u5bfa\u7ad9\u79bb\u9b54\u90fd\u7eff\u6865\u7ad9\u4e3a 40 \u516c\u91cc\uff0c\u5219\u8f66\u8d39\u4e3a 2 + 4 = 6 \u5143\u3002 \u4e3a\u4e86\u83b7\u5f97\u6700\u5927\u7684\u6ee1\u8db3\u611f\uff0c\u68ee\u68ee\u51b3\u5b9a\u7528\u4ee5\u4e0b\u7684\u65b9\u5f0f\u5750\u5730\u94c1\uff1a\u5728\u67d0\u4e00\u7ad9\u4e0a\u8f66\uff08\u4e0d\u59a8\u8bbe\u4e3a\u5730\u94c1\u7ad9 A \uff09\uff0c\u5219\u5bf9\u4e8e\u6240\u6709\u8f66\u8d39\u76f8\u540c\u7684\u5230\u8fbe\u7ad9\uff0c\u68ee\u68ee\u53ea\u4f1a\u5728\u8ba1\u8d39\u8ddd\u79bb\u6700\u8fdc\u7684\u7ad9\u6216\u7ebf\u8def\u672b\u7aef\u7ad9\u70b9\u51fa\u7ad9\uff0c\u7136\u540e\u7528\u68ee\u68ee\u7f8e\u56fe App \u5728\u7ad9\u70b9\u5916\u62cd\u4e00\u5f20\u8ba4\u8bc1\u7167\uff0c\u518d\u6309\u540c\u6837\u7684\u65b9\u5f0f\u524d\u5f80\u4e0b\u4e00\u4e2a\u7ad9\u70b9\u3002 \u5750\u7740\u5750\u7740\uff0c\u68ee\u68ee\u7a81\u7136\u597d\u5947\u8d77\u6765\uff1a\u5728\u7ed9\u5b9a\u51fa\u53d1\u7ad9\u7684\u60c5\u51b5\u4e0b\uff08\u5728\u51fa\u53d1\u65f6\u68ee\u68ee\u4e5f\u4f1a\u62cd\u4e00\u5f20\u7167\uff09\uff0c\u4ed6\u7684\u6574\u4e2a\u65c5\u7a0b\u4e2d\u80fd\u591f\u7559\u4e0b\u54ea\u4e9b\u7ad9\u70b9\u7684\u8ba4\u8bc1\u7167\uff1f \u5730\u94c1\u662f\u94c1\u8def\u8fd0\u8f93\u7684\u4e00\u79cd\u5f62\u5f0f\uff0c\u6307\u5728\u5730\u4e0b\u8fd0\u884c\u4e3a\u4e3b\u7684\u57ce\u5e02\u8f68\u9053\u4ea4\u901a\u7cfb\u7edf\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5730\u94c1\u7531\u82e5\u5e72\u4e2a\u7ad9\u70b9\u7ec4\u6210\uff0c\u5e76\u6709\u591a\u6761\u4e0d\u540c\u7684\u7ebf\u8def\u53cc\u5411\u884c\u9a76\uff0c\u53ef\u7c7b\u6bd4\u516c\u4ea4\u8f66\uff0c\u5f53\u4e24\u6761\u6216\u66f4\u591a\u6761\u7ebf\u8def\u7ecf\u8fc7\u540c\u4e00\u4e2a\u7ad9\u70b9\u65f6\uff0c\u53ef\u8fdb\u884c \u6362\u4e58 \uff0c\u66f4\u6362\u81ea\u5df1\u6240\u4e58\u5750\u7684\u7ebf\u8def\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c\u9b54\u90fd 1 \u53f7\u7ebf\u548c 2 \u53f7\u7ebf\u90fd\u7ecf\u8fc7\u4eba\u6c11\u5e7f\u573a\u7ad9\uff0c\u5219\u4e58\u5750 1 \u53f7\u7ebf\u5230\u8fbe\u4eba\u6c11\u5e7f\u573a\u65f6\u5c31\u53ef\u4ee5\u6362\u4e58\u5230 2 \u53f7\u7ebf\u524d\u5f80 2 \u53f7\u7ebf\u7684\u5404\u4e2a\u7ad9\u70b9\u3002\u6362\u4e58\u4e0d\u9700\u51fa\u7ad9\uff08\u4e5f\u62cd\u4e0d\u5230\u8ba4\u8bc1\u7167\uff09\uff0c\u56e0\u6b64\u68ee\u68ee\u4e58\u5750\u5730\u94c1\u65f6\u6362\u4e58\u4e0d\u53d7\u9650\u5236\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e09\u4e2a\u6b63\u6574\u6570 N \u3001 M \u548c K \uff0c\u8868\u793a\u9b54\u90fd\u5730\u94c1\u6709 N \u4e2a\u8f66\u7ad9 (1 \u2264 N \u2264 200)\uff0c M \u6761\u7ebf\u8def (1 \u2264 M \u2264 1500)\uff0c\u6700\u77ed\u8ddd\u79bb\u6bcf\u8d85\u8fc7 K \u516c\u91cc (1 \u2264 K \u2264 10 6 )\uff0c\u52a0 1 \u5143\u8f66\u8d39\u3002 \u63a5\u4e0b\u6765 M \u884c\uff0c\u6bcf\u884c\u7531\u4ee5\u4e0b\u683c\u5f0f\u7ec4\u6210\uff1a <\u7ad9\u70b91><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b92><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b93> \u2026 <\u7ad9\u70b9X-1><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b9X> \u5176\u4e2d\u7ad9\u70b9\u662f\u4e00\u4e2a 1 \u5230 N \u7684\u7f16\u53f7\uff1b\u4e24\u4e2a\u7ad9\u70b9\u7f16\u53f7\u4e4b\u95f4\u7684\u8ddd\u79bb\u6307\u4e24\u4e2a\u7ad9\u5728\u8be5\u7ebf\u8def\u4e0a\u7684\u8ddd\u79bb\u3002\u4e24\u7ad9\u4e4b\u95f4\u8ddd\u79bb\u662f\u4e00\u4e2a\u4e0d\u5927\u4e8e 10 6 \u7684\u6b63\u6574\u6570\u3002\u4e00\u6761\u7ebf\u8def\u4e0a\u7684\u7ad9\u70b9\u4e92\u4e0d\u76f8\u540c\u3002 \u6ce8\u610f \uff1a\u4e24\u4e2a\u7ad9\u4e4b\u95f4\u53ef\u80fd\u6709\u591a\u6761\u76f4\u63a5\u8fde\u63a5\u7684\u7ebf\u8def\uff0c\u4e14\u8ddd\u79bb\u4e0d\u4e00\u5b9a\u76f8\u7b49\u3002 \u518d\u63a5\u4e0b\u6765\u6709\u4e00\u4e2a\u6b63\u6574\u6570 Q (1 \u2264 Q \u2264 200)\uff0c\u8868\u793a\u68ee\u68ee\u5c1d\u8bd5\u4ece Q \u4e2a\u7ad9\u70b9\u51fa\u53d1\u3002 \u6700\u540e\u6709 Q \u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6b63\u6574\u6570 X i \uff0c\u8868\u793a\u68ee\u68ee\u5c1d\u8bd5\u4ece\u7f16\u53f7\u4e3a X i \u7684\u7ad9\u70b9\u51fa\u53d1\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u68ee\u68ee\u6bcf\u4e2a\u5c1d\u8bd5\u7684\u7ad9\u70b9\uff0c\u8f93\u51fa\u4e00\u884c\u82e5\u5e72\u4e2a\u6574\u6570\uff0c\u8868\u793a\u80fd\u591f\u5230\u8fbe\u7684\u7ad9\u70b9\u7f16\u53f7\u3002\u7ad9\u70b9\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 6 2 6 1 6 2 4 3 1 4 5 6 2 6 6 4 2 3 4 5 \u8f93\u51fa\u6837\u4f8b 1 2 4 5 6 1 2 3 4 5 6 1 2 4 5 6 1 2 4 5 6","title":"L3-022-\u5730\u94c1\u4e00\u65e5\u6e38"},{"location":"CCCC/L3-022-%E5%9C%B0%E9%93%81%E4%B8%80%E6%97%A5%E6%B8%B8/#l3-022-\u5730\u94c1\u4e00\u65e5\u6e38","text":"","title":"L3-022 \u5730\u94c1\u4e00\u65e5\u6e38"},{"location":"CCCC/L3-022-%E5%9C%B0%E9%93%81%E4%B8%80%E6%97%A5%E6%B8%B8/#statement","text":"Metadata \u4f5c\u8005: \u6234\u9f99\u7ff1 \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 550 ms \u5185\u5b58\u9650\u5236: 64 MB \u68ee\u68ee\u559c\u6b22\u5750\u5730\u94c1\u3002\u8fd9\u4e2a\u5047\u671f\uff0c\u4ed6\u7ec8\u4e8e\u6765\u5230\u4e86\u4f20\u8bf4\u4e2d\u7684\u5730\u94c1\u4e4b\u57ce\u2014\u2014\u9b54\u90fd\uff0c\u6253\u7b97\u597d\u597d\u8fc7\u4e00\u628a\u5750\u5730\u94c1\u7684\u763e\uff01 \u9b54\u90fd\u5730\u94c1\u7684\u8ba1\u4ef7\u89c4\u5219\u662f\uff1a\u8d77\u6b65\u4ef7 2 \u5143\uff0c\u51fa\u53d1\u7ad9\u4e0e\u5230\u8fbe\u7ad9\u7684\u6700\u77ed\u8ddd\u79bb\uff08\u5373 \u8ba1\u8d39\u8ddd\u79bb \uff09\u6bcf K \u516c\u91cc\u589e\u52a0 1 \u5143\u8f66\u8d39\u3002 \u4f8b\u5982\u53d6 K = 10\uff0c\u52a8\u5b89\u5bfa\u7ad9\u79bb\u9b54\u90fd\u7eff\u6865\u7ad9\u4e3a 40 \u516c\u91cc\uff0c\u5219\u8f66\u8d39\u4e3a 2 + 4 = 6 \u5143\u3002 \u4e3a\u4e86\u83b7\u5f97\u6700\u5927\u7684\u6ee1\u8db3\u611f\uff0c\u68ee\u68ee\u51b3\u5b9a\u7528\u4ee5\u4e0b\u7684\u65b9\u5f0f\u5750\u5730\u94c1\uff1a\u5728\u67d0\u4e00\u7ad9\u4e0a\u8f66\uff08\u4e0d\u59a8\u8bbe\u4e3a\u5730\u94c1\u7ad9 A \uff09\uff0c\u5219\u5bf9\u4e8e\u6240\u6709\u8f66\u8d39\u76f8\u540c\u7684\u5230\u8fbe\u7ad9\uff0c\u68ee\u68ee\u53ea\u4f1a\u5728\u8ba1\u8d39\u8ddd\u79bb\u6700\u8fdc\u7684\u7ad9\u6216\u7ebf\u8def\u672b\u7aef\u7ad9\u70b9\u51fa\u7ad9\uff0c\u7136\u540e\u7528\u68ee\u68ee\u7f8e\u56fe App \u5728\u7ad9\u70b9\u5916\u62cd\u4e00\u5f20\u8ba4\u8bc1\u7167\uff0c\u518d\u6309\u540c\u6837\u7684\u65b9\u5f0f\u524d\u5f80\u4e0b\u4e00\u4e2a\u7ad9\u70b9\u3002 \u5750\u7740\u5750\u7740\uff0c\u68ee\u68ee\u7a81\u7136\u597d\u5947\u8d77\u6765\uff1a\u5728\u7ed9\u5b9a\u51fa\u53d1\u7ad9\u7684\u60c5\u51b5\u4e0b\uff08\u5728\u51fa\u53d1\u65f6\u68ee\u68ee\u4e5f\u4f1a\u62cd\u4e00\u5f20\u7167\uff09\uff0c\u4ed6\u7684\u6574\u4e2a\u65c5\u7a0b\u4e2d\u80fd\u591f\u7559\u4e0b\u54ea\u4e9b\u7ad9\u70b9\u7684\u8ba4\u8bc1\u7167\uff1f \u5730\u94c1\u662f\u94c1\u8def\u8fd0\u8f93\u7684\u4e00\u79cd\u5f62\u5f0f\uff0c\u6307\u5728\u5730\u4e0b\u8fd0\u884c\u4e3a\u4e3b\u7684\u57ce\u5e02\u8f68\u9053\u4ea4\u901a\u7cfb\u7edf\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5730\u94c1\u7531\u82e5\u5e72\u4e2a\u7ad9\u70b9\u7ec4\u6210\uff0c\u5e76\u6709\u591a\u6761\u4e0d\u540c\u7684\u7ebf\u8def\u53cc\u5411\u884c\u9a76\uff0c\u53ef\u7c7b\u6bd4\u516c\u4ea4\u8f66\uff0c\u5f53\u4e24\u6761\u6216\u66f4\u591a\u6761\u7ebf\u8def\u7ecf\u8fc7\u540c\u4e00\u4e2a\u7ad9\u70b9\u65f6\uff0c\u53ef\u8fdb\u884c \u6362\u4e58 \uff0c\u66f4\u6362\u81ea\u5df1\u6240\u4e58\u5750\u7684\u7ebf\u8def\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c\u9b54\u90fd 1 \u53f7\u7ebf\u548c 2 \u53f7\u7ebf\u90fd\u7ecf\u8fc7\u4eba\u6c11\u5e7f\u573a\u7ad9\uff0c\u5219\u4e58\u5750 1 \u53f7\u7ebf\u5230\u8fbe\u4eba\u6c11\u5e7f\u573a\u65f6\u5c31\u53ef\u4ee5\u6362\u4e58\u5230 2 \u53f7\u7ebf\u524d\u5f80 2 \u53f7\u7ebf\u7684\u5404\u4e2a\u7ad9\u70b9\u3002\u6362\u4e58\u4e0d\u9700\u51fa\u7ad9\uff08\u4e5f\u62cd\u4e0d\u5230\u8ba4\u8bc1\u7167\uff09\uff0c\u56e0\u6b64\u68ee\u68ee\u4e58\u5750\u5730\u94c1\u65f6\u6362\u4e58\u4e0d\u53d7\u9650\u5236\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e09\u4e2a\u6b63\u6574\u6570 N \u3001 M \u548c K \uff0c\u8868\u793a\u9b54\u90fd\u5730\u94c1\u6709 N \u4e2a\u8f66\u7ad9 (1 \u2264 N \u2264 200)\uff0c M \u6761\u7ebf\u8def (1 \u2264 M \u2264 1500)\uff0c\u6700\u77ed\u8ddd\u79bb\u6bcf\u8d85\u8fc7 K \u516c\u91cc (1 \u2264 K \u2264 10 6 )\uff0c\u52a0 1 \u5143\u8f66\u8d39\u3002 \u63a5\u4e0b\u6765 M \u884c\uff0c\u6bcf\u884c\u7531\u4ee5\u4e0b\u683c\u5f0f\u7ec4\u6210\uff1a <\u7ad9\u70b91><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b92><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b93> \u2026 <\u7ad9\u70b9X-1><\u7a7a\u683c><\u8ddd\u79bb><\u7a7a\u683c><\u7ad9\u70b9X> \u5176\u4e2d\u7ad9\u70b9\u662f\u4e00\u4e2a 1 \u5230 N \u7684\u7f16\u53f7\uff1b\u4e24\u4e2a\u7ad9\u70b9\u7f16\u53f7\u4e4b\u95f4\u7684\u8ddd\u79bb\u6307\u4e24\u4e2a\u7ad9\u5728\u8be5\u7ebf\u8def\u4e0a\u7684\u8ddd\u79bb\u3002\u4e24\u7ad9\u4e4b\u95f4\u8ddd\u79bb\u662f\u4e00\u4e2a\u4e0d\u5927\u4e8e 10 6 \u7684\u6b63\u6574\u6570\u3002\u4e00\u6761\u7ebf\u8def\u4e0a\u7684\u7ad9\u70b9\u4e92\u4e0d\u76f8\u540c\u3002 \u6ce8\u610f \uff1a\u4e24\u4e2a\u7ad9\u4e4b\u95f4\u53ef\u80fd\u6709\u591a\u6761\u76f4\u63a5\u8fde\u63a5\u7684\u7ebf\u8def\uff0c\u4e14\u8ddd\u79bb\u4e0d\u4e00\u5b9a\u76f8\u7b49\u3002 \u518d\u63a5\u4e0b\u6765\u6709\u4e00\u4e2a\u6b63\u6574\u6570 Q (1 \u2264 Q \u2264 200)\uff0c\u8868\u793a\u68ee\u68ee\u5c1d\u8bd5\u4ece Q \u4e2a\u7ad9\u70b9\u51fa\u53d1\u3002 \u6700\u540e\u6709 Q \u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6b63\u6574\u6570 X i \uff0c\u8868\u793a\u68ee\u68ee\u5c1d\u8bd5\u4ece\u7f16\u53f7\u4e3a X i \u7684\u7ad9\u70b9\u51fa\u53d1\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u68ee\u68ee\u6bcf\u4e2a\u5c1d\u8bd5\u7684\u7ad9\u70b9\uff0c\u8f93\u51fa\u4e00\u884c\u82e5\u5e72\u4e2a\u6574\u6570\uff0c\u8868\u793a\u80fd\u591f\u5230\u8fbe\u7684\u7ad9\u70b9\u7f16\u53f7\u3002\u7ad9\u70b9\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 6 2 6 1 6 2 4 3 1 4 5 6 2 6 6 4 2 3 4 5 \u8f93\u51fa\u6837\u4f8b 1 2 4 5 6 1 2 3 4 5 6 1 2 4 5 6 1 2 4 5 6","title":"Statement"},{"location":"CCCC/L3-023-%E8%AE%A1%E7%AE%97%E5%9B%BE/","text":"L3-023 \u8ba1\u7b97\u56fe Statement Metadata \u4f5c\u8005: \u9648\u7fd4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u8ba1\u7b97\u56fe\u201d\uff08computational graph\uff09\u662f\u73b0\u4ee3\u6df1\u5ea6\u5b66\u4e60\u7cfb\u7edf\u7684\u57fa\u7840\u6267\u884c\u5f15\u64ce\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u8868\u793a\u4efb\u610f\u6570\u5b66\u8868\u8fbe\u5f0f\u7684\u65b9\u6cd5\uff0c\u4f8b\u5982\u7528\u6709\u5411\u65e0\u73af\u56fe\u8868\u793a\u7684\u795e\u7ecf\u7f51\u7edc\u3002 \u56fe\u4e2d\u7684\u8282\u70b9\u8868\u793a\u57fa\u672c\u64cd\u4f5c\u6216\u8f93\u5165\u53d8\u91cf\uff0c\u8fb9\u8868\u793a\u8282\u70b9\u4e4b\u95f4\u7684\u4e2d\u95f4\u503c\u7684\u4f9d\u8d56\u6027\u3002 \u4f8b\u5982\uff0c\u4e0b\u56fe\u5c31\u662f\u4e00\u4e2a\u51fd\u6570 f(x_1,x_2)=\\ln x_1 + x_1 x_2 - \\sin x_2 f(x_1,x_2)=\\ln x_1 + x_1 x_2 - \\sin x_2 \u7684\u8ba1\u7b97\u56fe\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e2a\u8ba1\u7b97\u56fe\uff0c\u8bf7\u4f60\u6839\u636e\u6240\u6709\u8f93\u5165\u53d8\u91cf\u8ba1\u7b97\u51fd\u6570\u503c\u53ca\u5176\u504f\u5bfc\u6570\uff08\u5373\u68af\u5ea6\uff09\u3002 \u4f8b\u5982\uff0c\u7ed9\u5b9a\u8f93\u5165$ x_1 = 2, x_2 = 5 $\uff0c\u4e0a\u8ff0\u8ba1\u7b97\u56fe\u83b7\u5f97\u51fd\u6570\u503c $ f(2,5)=ln (2) + 2times 5 - sin (5) = 11.652$\uff1b\u5e76\u4e14\u6839\u636e\u5fae\u5206\u94fe\u5f0f\u6cd5\u5219\uff0c\u4e0a\u56fe\u5f97\u5230\u7684\u68af\u5ea6 \\nabla f = [\\partial f / \\partial x_1 , \\partial f / \\partial x_2 ] = [ 1/x_1 + x_2 , x_1 - \\cos x_2] = [5.500,1.716] \\nabla f = [\\partial f / \\partial x_1 , \\partial f / \\partial x_2 ] = [ 1/x_1 + x_2 , x_1 - \\cos x_2] = [5.500,1.716] \u3002 \u77e5\u9053\u4f60\u5df2\u7ecf\u628a\u5fae\u79ef\u5206\u5fd8\u4e86\uff0c\u6240\u4ee5\u8fd9\u91cc\u53ea\u8981\u6c42\u4f60\u5904\u7406\u51e0\u4e2a\u7b80\u5355\u7684\u7b97\u5b50\uff1a\u52a0\u6cd5\u3001\u51cf\u6cd5\u3001\u4e58\u6cd5\u3001\u6307\u6570\uff08 e^x e^x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 exp(x) \u51fd\u6570\uff09\u3001\u5bf9\u6570\uff08 \\ln x \\ln x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 log(x) \u51fd\u6570\uff09\u548c\u6b63\u5f26\u51fd\u6570\uff08 \\sin x \\sin x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 sin(x) \u51fd\u6570\uff09\u3002 \u53cb\u60c5\u63d0\u9192\uff1a \u5e38\u6570\u7684\u5bfc\u6570\u662f 0\uff1b x x \u7684\u5bfc\u6570\u662f 1\uff1b e^x e^x \u7684\u5bfc\u6570\u8fd8\u662f e^x e^x \uff1b \\ln x \\ln x \u7684\u5bfc\u6570\u662f 1/x 1/x \uff1b \\sin x \\sin x \u7684\u5bfc\u6570\u662f \\cos x \\cos x \u3002 \u56de\u987e\u4e00\u4e0b\u4ec0\u4e48\u662f \u504f\u5bfc\u6570 \uff1a\u5728\u6570\u5b66\u4e2d\uff0c\u4e00\u4e2a\u591a\u53d8\u91cf\u7684\u51fd\u6570\u7684\u504f\u5bfc\u6570\uff0c\u5c31\u662f\u5b83\u5173\u4e8e\u5176\u4e2d\u4e00\u4e2a\u53d8\u91cf\u7684\u5bfc\u6570\u800c\u4fdd\u6301\u5176\u4ed6\u53d8\u91cf\u6052\u5b9a\u3002\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53\u6211\u4eec\u5bf9 x_1 x_1 \u6c42\u504f\u5bfc\u6570 \\partial f / \\partial x_1 \\partial f / \\partial x_1 \u65f6\uff0c\u5c31\u5c06 x_2 x_2 \u5f53\u6210\u5e38\u6570\uff0c\u6240\u4ee5\u5f97\u5230 \\ln x_1 \\ln x_1 \u7684\u5bfc\u6570\u662f 1/x_1 1/x_1 \uff0c x_1 x_2 x_1 x_2 \u7684\u5bfc\u6570\u662f x_2 x_2 \uff0c \\sin x_2 \\sin x_2 \u7684\u5bfc\u6570\u662f 0\u3002 \u56de\u987e\u4e00\u4e0b \u94fe\u5f0f\u6cd5\u5219 \uff1a\u590d\u5408\u51fd\u6570\u7684\u5bfc\u6570\u662f\u6784\u6210\u590d\u5408\u8fd9\u6709\u9650\u4e2a\u51fd\u6570\u5728\u76f8\u5e94\u70b9\u7684\u5bfc\u6570\u7684\u4e58\u79ef\uff0c\u5373\u82e5\u6709 u=f(y) u=f(y) \uff0c y=g(x) y=g(x) \uff0c\u5219 du/dx = du/dy \\cdot dy/dx du/dx = du/dy \\cdot dy/dx \u3002\u4f8b\u5982\u5bf9 \\sin (\\ln x) \\sin (\\ln x) \u6c42\u5bfc\uff0c\u5c31\u5f97\u5230 \\cos (\\ln x) \\cdot (1/x) \\cos (\\ln x) \\cdot (1/x) \u3002 \u5982\u679c\u4f60\u6ce8\u610f\u89c2\u5bdf\uff0c\u53ef\u4ee5\u53d1\u73b0\u5728\u8ba1\u7b97\u56fe\u4e2d\uff0c\u8ba1\u7b97\u51fd\u6570\u503c\u662f\u4e00\u4e2a\u4ece\u5de6\u5411\u53f3\u8fdb\u884c\u7684\u8ba1\u7b97\uff0c\u800c\u8ba1\u7b97\u504f\u5bfc\u6570\u5219\u6b63\u597d\u76f8\u53cd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 5\\times 10^4 \\le 5\\times 10^4 \uff09\uff0c\u4e3a\u8ba1\u7b97\u56fe\u4e2d\u7684\u9876\u70b9\u6570\u3002 \u4ee5\u4e0b N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7b2c i i \u4e2a\u9876\u70b9\u7684\u4fe1\u606f\uff0c\u5176\u4e2d i=0, 1, \\cdots , N-1 i=0, 1, \\cdots , N-1 \u3002\u7b2c\u4e00\u4e2a\u503c\u662f\u9876\u70b9\u7684\u7c7b\u578b\u7f16\u53f7\uff0c\u5206\u522b\u4e3a\uff1a 0 \u4ee3\u8868\u8f93\u5165\u53d8\u91cf 1 \u4ee3\u8868\u52a0\u6cd5\uff0c\u5bf9\u5e94 x_1 + x_2 x_1 + x_2 2 \u4ee3\u8868\u51cf\u6cd5\uff0c\u5bf9\u5e94 x_1 - x_2 x_1 - x_2 3 \u4ee3\u8868\u4e58\u6cd5\uff0c\u5bf9\u5e94 x_1 \\times x_2 x_1 \\times x_2 4 \u4ee3\u8868\u6307\u6570\uff0c\u5bf9\u5e94 e^x e^x 5 \u4ee3\u8868\u5bf9\u6570\uff0c\u5bf9\u5e94 \\ln x \\ln x 6 \u4ee3\u8868\u6b63\u5f26\u51fd\u6570\uff0c\u5bf9\u5e94 \\sin x \\sin x \u5bf9\u4e8e\u8f93\u5165\u53d8\u91cf\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u7684\u53cc\u7cbe\u5ea6\u6d6e\u70b9\u6570\u503c\uff1b\u5bf9\u4e8e\u5355\u76ee\u7b97\u5b50\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u5bf9\u5e94\u7684\u5355\u4e2a\u53d8\u91cf\u7684\u9876\u70b9\u7f16\u53f7\uff08\u7f16\u53f7\u4ece 0 \u5f00\u59cb\uff09\uff1b\u5bf9\u4e8e\u53cc\u76ee\u7b97\u5b50\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u5bf9\u5e94\u4e24\u4e2a\u53d8\u91cf\u7684\u9876\u70b9\u7f16\u53f7\u3002 \u9898\u76ee\u4fdd\u8bc1\u53ea\u6709\u4e00\u4e2a\u8f93\u51fa\u9876\u70b9\uff08\u5373\u6ca1\u6709\u51fa\u8fb9\u7684\u9876\u70b9\uff0c\u4f8b\u5982\u4e0a\u56fe\u6700\u53f3\u8fb9\u7684 - \uff09\uff0c\u4e14\u8ba1\u7b97\u8fc7\u7a0b\u4e0d\u4f1a\u8d85\u8fc7\u53cc\u7cbe\u5ea6\u6d6e\u70b9\u6570\u7684\u8ba1\u7b97\u7cbe\u5ea6\u8303\u56f4\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u7ed9\u5b9a\u8ba1\u7b97\u56fe\u7684\u51fd\u6570\u503c\u3002\u5728\u7b2c\u4e8c\u884c\u987a\u5e8f\u8f93\u51fa\u51fd\u6570\u5bf9\u4e8e\u6bcf\u4e2a\u53d8\u91cf\u7684\u504f\u5bfc\u6570\u7684\u503c\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u504f\u5bfc\u6570\u7684\u8f93\u51fa\u987a\u5e8f\u4e0e\u8f93\u5165\u53d8\u91cf\u7684\u51fa\u73b0\u987a\u5e8f\u76f8\u540c\u3002\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 3 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 7 0 2.0 0 5.0 5 0 3 0 1 6 1 1 2 3 2 5 4 \u8f93\u51fa\u6837\u4f8b 11.652 5.500 1.716","title":"L3-023-\u8ba1\u7b97\u56fe"},{"location":"CCCC/L3-023-%E8%AE%A1%E7%AE%97%E5%9B%BE/#l3-023-\u8ba1\u7b97\u56fe","text":"","title":"L3-023 \u8ba1\u7b97\u56fe"},{"location":"CCCC/L3-023-%E8%AE%A1%E7%AE%97%E5%9B%BE/#statement","text":"Metadata \u4f5c\u8005: \u9648\u7fd4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u8ba1\u7b97\u56fe\u201d\uff08computational graph\uff09\u662f\u73b0\u4ee3\u6df1\u5ea6\u5b66\u4e60\u7cfb\u7edf\u7684\u57fa\u7840\u6267\u884c\u5f15\u64ce\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u8868\u793a\u4efb\u610f\u6570\u5b66\u8868\u8fbe\u5f0f\u7684\u65b9\u6cd5\uff0c\u4f8b\u5982\u7528\u6709\u5411\u65e0\u73af\u56fe\u8868\u793a\u7684\u795e\u7ecf\u7f51\u7edc\u3002 \u56fe\u4e2d\u7684\u8282\u70b9\u8868\u793a\u57fa\u672c\u64cd\u4f5c\u6216\u8f93\u5165\u53d8\u91cf\uff0c\u8fb9\u8868\u793a\u8282\u70b9\u4e4b\u95f4\u7684\u4e2d\u95f4\u503c\u7684\u4f9d\u8d56\u6027\u3002 \u4f8b\u5982\uff0c\u4e0b\u56fe\u5c31\u662f\u4e00\u4e2a\u51fd\u6570 f(x_1,x_2)=\\ln x_1 + x_1 x_2 - \\sin x_2 f(x_1,x_2)=\\ln x_1 + x_1 x_2 - \\sin x_2 \u7684\u8ba1\u7b97\u56fe\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e2a\u8ba1\u7b97\u56fe\uff0c\u8bf7\u4f60\u6839\u636e\u6240\u6709\u8f93\u5165\u53d8\u91cf\u8ba1\u7b97\u51fd\u6570\u503c\u53ca\u5176\u504f\u5bfc\u6570\uff08\u5373\u68af\u5ea6\uff09\u3002 \u4f8b\u5982\uff0c\u7ed9\u5b9a\u8f93\u5165$ x_1 = 2, x_2 = 5 $\uff0c\u4e0a\u8ff0\u8ba1\u7b97\u56fe\u83b7\u5f97\u51fd\u6570\u503c $ f(2,5)=ln (2) + 2times 5 - sin (5) = 11.652$\uff1b\u5e76\u4e14\u6839\u636e\u5fae\u5206\u94fe\u5f0f\u6cd5\u5219\uff0c\u4e0a\u56fe\u5f97\u5230\u7684\u68af\u5ea6 \\nabla f = [\\partial f / \\partial x_1 , \\partial f / \\partial x_2 ] = [ 1/x_1 + x_2 , x_1 - \\cos x_2] = [5.500,1.716] \\nabla f = [\\partial f / \\partial x_1 , \\partial f / \\partial x_2 ] = [ 1/x_1 + x_2 , x_1 - \\cos x_2] = [5.500,1.716] \u3002 \u77e5\u9053\u4f60\u5df2\u7ecf\u628a\u5fae\u79ef\u5206\u5fd8\u4e86\uff0c\u6240\u4ee5\u8fd9\u91cc\u53ea\u8981\u6c42\u4f60\u5904\u7406\u51e0\u4e2a\u7b80\u5355\u7684\u7b97\u5b50\uff1a\u52a0\u6cd5\u3001\u51cf\u6cd5\u3001\u4e58\u6cd5\u3001\u6307\u6570\uff08 e^x e^x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 exp(x) \u51fd\u6570\uff09\u3001\u5bf9\u6570\uff08 \\ln x \\ln x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 log(x) \u51fd\u6570\uff09\u548c\u6b63\u5f26\u51fd\u6570\uff08 \\sin x \\sin x \uff0c\u5373\u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684 sin(x) \u51fd\u6570\uff09\u3002 \u53cb\u60c5\u63d0\u9192\uff1a \u5e38\u6570\u7684\u5bfc\u6570\u662f 0\uff1b x x \u7684\u5bfc\u6570\u662f 1\uff1b e^x e^x \u7684\u5bfc\u6570\u8fd8\u662f e^x e^x \uff1b \\ln x \\ln x \u7684\u5bfc\u6570\u662f 1/x 1/x \uff1b \\sin x \\sin x \u7684\u5bfc\u6570\u662f \\cos x \\cos x \u3002 \u56de\u987e\u4e00\u4e0b\u4ec0\u4e48\u662f \u504f\u5bfc\u6570 \uff1a\u5728\u6570\u5b66\u4e2d\uff0c\u4e00\u4e2a\u591a\u53d8\u91cf\u7684\u51fd\u6570\u7684\u504f\u5bfc\u6570\uff0c\u5c31\u662f\u5b83\u5173\u4e8e\u5176\u4e2d\u4e00\u4e2a\u53d8\u91cf\u7684\u5bfc\u6570\u800c\u4fdd\u6301\u5176\u4ed6\u53d8\u91cf\u6052\u5b9a\u3002\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u5f53\u6211\u4eec\u5bf9 x_1 x_1 \u6c42\u504f\u5bfc\u6570 \\partial f / \\partial x_1 \\partial f / \\partial x_1 \u65f6\uff0c\u5c31\u5c06 x_2 x_2 \u5f53\u6210\u5e38\u6570\uff0c\u6240\u4ee5\u5f97\u5230 \\ln x_1 \\ln x_1 \u7684\u5bfc\u6570\u662f 1/x_1 1/x_1 \uff0c x_1 x_2 x_1 x_2 \u7684\u5bfc\u6570\u662f x_2 x_2 \uff0c \\sin x_2 \\sin x_2 \u7684\u5bfc\u6570\u662f 0\u3002 \u56de\u987e\u4e00\u4e0b \u94fe\u5f0f\u6cd5\u5219 \uff1a\u590d\u5408\u51fd\u6570\u7684\u5bfc\u6570\u662f\u6784\u6210\u590d\u5408\u8fd9\u6709\u9650\u4e2a\u51fd\u6570\u5728\u76f8\u5e94\u70b9\u7684\u5bfc\u6570\u7684\u4e58\u79ef\uff0c\u5373\u82e5\u6709 u=f(y) u=f(y) \uff0c y=g(x) y=g(x) \uff0c\u5219 du/dx = du/dy \\cdot dy/dx du/dx = du/dy \\cdot dy/dx \u3002\u4f8b\u5982\u5bf9 \\sin (\\ln x) \\sin (\\ln x) \u6c42\u5bfc\uff0c\u5c31\u5f97\u5230 \\cos (\\ln x) \\cdot (1/x) \\cos (\\ln x) \\cdot (1/x) \u3002 \u5982\u679c\u4f60\u6ce8\u610f\u89c2\u5bdf\uff0c\u53ef\u4ee5\u53d1\u73b0\u5728\u8ba1\u7b97\u56fe\u4e2d\uff0c\u8ba1\u7b97\u51fd\u6570\u503c\u662f\u4e00\u4e2a\u4ece\u5de6\u5411\u53f3\u8fdb\u884c\u7684\u8ba1\u7b97\uff0c\u800c\u8ba1\u7b97\u504f\u5bfc\u6570\u5219\u6b63\u597d\u76f8\u53cd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 5\\times 10^4 \\le 5\\times 10^4 \uff09\uff0c\u4e3a\u8ba1\u7b97\u56fe\u4e2d\u7684\u9876\u70b9\u6570\u3002 \u4ee5\u4e0b N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7b2c i i \u4e2a\u9876\u70b9\u7684\u4fe1\u606f\uff0c\u5176\u4e2d i=0, 1, \\cdots , N-1 i=0, 1, \\cdots , N-1 \u3002\u7b2c\u4e00\u4e2a\u503c\u662f\u9876\u70b9\u7684\u7c7b\u578b\u7f16\u53f7\uff0c\u5206\u522b\u4e3a\uff1a 0 \u4ee3\u8868\u8f93\u5165\u53d8\u91cf 1 \u4ee3\u8868\u52a0\u6cd5\uff0c\u5bf9\u5e94 x_1 + x_2 x_1 + x_2 2 \u4ee3\u8868\u51cf\u6cd5\uff0c\u5bf9\u5e94 x_1 - x_2 x_1 - x_2 3 \u4ee3\u8868\u4e58\u6cd5\uff0c\u5bf9\u5e94 x_1 \\times x_2 x_1 \\times x_2 4 \u4ee3\u8868\u6307\u6570\uff0c\u5bf9\u5e94 e^x e^x 5 \u4ee3\u8868\u5bf9\u6570\uff0c\u5bf9\u5e94 \\ln x \\ln x 6 \u4ee3\u8868\u6b63\u5f26\u51fd\u6570\uff0c\u5bf9\u5e94 \\sin x \\sin x \u5bf9\u4e8e\u8f93\u5165\u53d8\u91cf\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u7684\u53cc\u7cbe\u5ea6\u6d6e\u70b9\u6570\u503c\uff1b\u5bf9\u4e8e\u5355\u76ee\u7b97\u5b50\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u5bf9\u5e94\u7684\u5355\u4e2a\u53d8\u91cf\u7684\u9876\u70b9\u7f16\u53f7\uff08\u7f16\u53f7\u4ece 0 \u5f00\u59cb\uff09\uff1b\u5bf9\u4e8e\u53cc\u76ee\u7b97\u5b50\uff0c\u540e\u9762\u4f1a\u8ddf\u5b83\u5bf9\u5e94\u4e24\u4e2a\u53d8\u91cf\u7684\u9876\u70b9\u7f16\u53f7\u3002 \u9898\u76ee\u4fdd\u8bc1\u53ea\u6709\u4e00\u4e2a\u8f93\u51fa\u9876\u70b9\uff08\u5373\u6ca1\u6709\u51fa\u8fb9\u7684\u9876\u70b9\uff0c\u4f8b\u5982\u4e0a\u56fe\u6700\u53f3\u8fb9\u7684 - \uff09\uff0c\u4e14\u8ba1\u7b97\u8fc7\u7a0b\u4e0d\u4f1a\u8d85\u8fc7\u53cc\u7cbe\u5ea6\u6d6e\u70b9\u6570\u7684\u8ba1\u7b97\u7cbe\u5ea6\u8303\u56f4\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u7ed9\u5b9a\u8ba1\u7b97\u56fe\u7684\u51fd\u6570\u503c\u3002\u5728\u7b2c\u4e8c\u884c\u987a\u5e8f\u8f93\u51fa\u51fd\u6570\u5bf9\u4e8e\u6bcf\u4e2a\u53d8\u91cf\u7684\u504f\u5bfc\u6570\u7684\u503c\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u504f\u5bfc\u6570\u7684\u8f93\u51fa\u987a\u5e8f\u4e0e\u8f93\u5165\u53d8\u91cf\u7684\u51fa\u73b0\u987a\u5e8f\u76f8\u540c\u3002\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 3 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 7 0 2.0 0 5.0 5 0 3 0 1 6 1 1 2 3 2 5 4 \u8f93\u51fa\u6837\u4f8b 11.652 5.500 1.716","title":"Statement"},{"location":"CCCC/L3-024-Oriol%E5%92%8CDavid/","text":"L3-024 Oriol\u548cDavid Statement Metadata \u4f5c\u8005: \u674e\u6587\u65b0 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 256 MB Oriol \u548c David \u5728\u4e00\u4e2a\u8fb9\u957f\u4e3a 16 \u5355\u4f4d\u957f\u5ea6\u7684\u6b63\u65b9\u5f62\u533a\u57df\u5185\uff0c\u521d\u59cb\u4f4d\u7f6e\u5206\u522b\u4e3a\uff087, 7\uff09\u548c\uff088, 8\uff09\u3002\u73b0\u5728\u6709 20 \u7ec4\u3001\u6bcf\u7ec4\u5305\u542b 20 \u4e2a\u4f4d\u7f6e\u9700\u8981\u4ed6\u4eec\u8bbf\u95ee\uff0c\u4f4d\u7f6e\u4ee5\u5750\u6807\uff08x, y\uff09\u7684\u5f62\u5f0f\u7ed9\u51fa\uff0c\u8981\u6c42\u5728\u65f6\u95f4 120 \u79d2\u5185\u8bbf\u95ee\u5c3d\u53ef\u80fd\u591a\u7684\u70b9\u3002\uff08x\u548cy\u5747\u4e3a\u6b63\u6574\u6570\uff0c\u4e140 \u2264 x < 16\uff0c0 \u2264 y < 16\uff09 \u6ce8\u610f\u4e8b\u9879\uff1a * \u9488\u5bf9\u4efb\u610f\u4e00\u4e2a\u4f4d\u7f6e\uff0cOriol\u6216David\u4e2d\u7684\u4e00\u4eba\u5230\u8fbe\u5373\u89c6\u4e3a\u8bbf\u95ee\u6210\u529f\uff1b * Oriol\u548cDavid\u5fc5\u987b\u4ece\u7b2c 1 \u7ec4\u4f4d\u7f6e\u5f00\u59cb\u8bbf\u95ee\uff0c\u4e14\u5fc5\u987b\u8bbf\u95ee\u5b8c\u7b2c i \u7ec4\u5168\u90e820\u4e2a\u4f4d\u7f6e\u4e4b\u540e\uff0c\u624d\u53ef\u4ee5\u5f00\u59cb\u7b2c i + 1 \u7ec4 20 \u4e2a\u4f4d\u7f6e\u7684\u8bbf\u95ee\u3002\u540c\u7ec4\u95f4\u5404\u4f4d\u7f6e\u7684\u8bbf\u95ee\u987a\u5e8f\u53ef\u81ea\u7531\u51b3\u5b9a\uff1b * Oriol\u548cDavid\u5728\u5b8c\u6210\u5f53\u524d\u7ec4\u4f4d\u7f6e\u7684\u8bbf\u95ee\u540e\uff0c\u65e0\u9700\u8fd4\u56de\u5f00\u59cb\u4f4d\u7f6e\u3001\u53ef\u4ee5\u7acb\u5373\u5f00\u59cb\u4e0b\u4e00\u7ec4\u4f4d\u7f6e\u7684\u8bbf\u95ee\uff1b * Oriol\u548cDavid\u53ef\u4ee5\u5411\u4efb\u610f\u65b9\u5411\u79fb\u52a8\uff0c\u79fb\u52a8\u65f6\u901f\u7387\u4e3a 2 \u5355\u4f4d\u957f\u5ea6/\u79d2\uff1b\u79fb\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u65e0\u4efb\u4f55\u969c\u788d\u7269\u963b\u62e6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6b63\u6574\u6570 T (T \u2264 10)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765\u7ed9\u51fa T \u7ec4\u6570\u636e\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u5165\u5305\u542b 20 \u7ec4\uff0c\u6bcf\u7ec4 1 \u884c\uff0c\u6bcf\u884c\u7531 20 \u4e2a\u5750\u6807\u7ec4\u6210\uff0c\u6bcf\u4e2a\u5750\u6807\u7531 2 \u4e2a\u6574\u6570 x \u548c y \u7ec4\u6210\uff0c\u4ee3\u8868 Oriol \u548c David \u8981\u8bbf\u95ee\u7684 20 \u7ec4 20 \u4e2a\u4f4d\u7f6e\u7684\u5750\u6807\uff1b0 \u2264 x < 16\uff0c0 \u2264 y < 16\uff0c\u5747\u7528\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u7684\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570N\uff0c\u4ee3\u8868\u5206\u914d\u65b9\u6848\u8bbf\u95ee\u8fc7\u7684\u4f4d\u7f6e\u7ec4\u6570\uff1b \u63a5\u4e0b\u6765\u7684N\u7ec4\u6bcf\u7ec4\u7684\u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 Ba \u548c Bb\uff0c\u5206\u522b\u4ee3\u8868\u6bcf\u7ec4\u5206\u914d\u65b9\u6848\u4e2d Oriol \u548c David \u8d1f\u8d23\u8bbf\u95ee\u7684\u4f4d\u7f6e\u6570\uff0c\u7b2c\u4e8c\u884c\u548c\u7b2c\u4e09\u884c\u5206\u522b\u5305\u542b Ba \u548c Bb \u4e2a\u6574\u6570 i\uff0c\u5206\u522b\u4ee3\u8868 Oriol \u548c David \u8d1f\u8d23\u8bbf\u95ee\u7684\u4f4d\u7f6e\u5728\u7ec4\u5185\u7684\u5e8f\u53f7\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u3002 0 \u2264 N \u2264 20\uff0c0 \u2264 Ba \u2264 20\uff0c0 \u2264 Bb \u2264 20\uff0c0 \u2264 i \u2264 19\u3002 \u8f93\u5165\u6837\u4f8b 1 5 5 3 13 8 7 13 6 6 11 2 0 1 14 9 15 8 9 3 12 4 6 2 10 2 5 4 9 4 1 15 0 11 4 10 0 15 5 10 14 1 0 14 8 0 7 6 8 4 12 12 8 9 8 10 14 9 4 13 4 9 1 2 1 0 2 11 10 7 15 9 6 13 11 3 5 4 5 10 7 7 3 8 13 15 0 5 4 2 8 7 14 4 13 11 1 8 15 4 5 4 7 7 10 6 7 13 4 6 2 9 13 1 12 10 7 10 5 5 11 5 8 12 12 11 5 12 9 2 2 11 15 5 14 0 0 14 0 2 5 7 3 10 1 2 8 4 2 4 8 9 14 1 11 1 9 15 7 3 3 1 9 10 14 7 3 15 5 5 15 3 2 12 11 8 10 3 3 11 5 7 4 6 11 6 1 4 10 11 13 12 4 3 4 1 3 7 5 13 11 3 11 9 8 12 9 14 10 11 13 5 5 4 11 1 12 13 2 10 14 5 15 10 15 11 0 3 6 7 11 4 9 15 0 12 14 10 10 13 11 10 4 9 12 0 13 6 6 7 10 11 15 6 14 1 2 4 9 8 5 4 0 13 11 5 3 13 3 9 8 2 4 13 14 12 12 14 2 8 15 2 8 4 9 13 10 8 5 2 13 12 6 4 4 10 6 14 13 11 5 12 1 6 0 11 2 8 15 12 4 13 8 8 2 9 7 7 13 0 9 0 0 4 0 2 3 10 2 7 3 9 4 2 13 11 11 1 8 11 15 11 2 8 11 10 15 7 9 13 15 15 10 1 2 11 9 14 6 5 5 2 13 6 8 7 14 8 5 15 14 5 6 4 10 14 12 3 14 0 5 4 1 0 14 13 14 12 5 5 9 1 2 2 12 4 8 1 15 7 11 10 5 15 7 6 8 11 10 7 13 14 0 12 2 9 12 4 5 3 8 8 13 7 12 15 15 12 9 15 6 14 3 9 6 15 12 7 9 4 15 0 10 6 2 3 2 6 3 14 6 10 13 3 10 15 9 10 0 7 0 14 15 1 2 13 9 11 11 10 3 6 13 0 14 11 2 9 8 15 5 3 9 13 11 1 1 0 9 5 4 4 9 4 13 10 1 12 11 4 2 0 4 1 7 4 10 4 0 2 1 2 0 13 2 11 10 0 5 15 3 15 11 8 1 12 5 8 5 7 5 7 7 2 4 0 4 7 3 12 6 9 15 5 12 14 11 15 10 8 11 4 10 4 14 13 10 4 4 2 12 9 12 15 13 0 12 0 14 3 1 10 15 15 11 1 12 3 0 5 2 15 10 8 4 9 1 8 0 1 13 2 7 12 13 14 10 6 0 13 15 13 7 14 15 9 4 8 2 7 3 7 11 2 13 5 0 13 5 4 0 12 2 3 2 11 15 9 2 9 7 3 7 4 5 14 5 14 12 9 13 12 11 2 14 2 6 6 12 5 15 13 11 2 0 9 13 7 1 7 11 4 4 2 10 0 8 5 3 6 13 2 7 2 15 6 8 3 5 8 11 12 5 9 9 4 14 3 2 14 2 2 1 9 11 8 10 2 14 12 15 0 13 4 7 0 0 0 6 0 1 4 13 4 3 3 10 15 2 10 10 11 15 8 5 6 15 9 8 2 7 15 14 1 10 14 6 13 6 0 15 4 1 3 12 7 8 12 4 0 10 7 10 0 14 13 5 11 1 15 6 1 12 13 14 6 12 9 0 6 8 3 15 5 4 4 2 15 10 3 6 13 12 8 4 15 3 1 5 7 1 6 14 8 6 2 6 11 3 4 4 \u8f93\u51fa\u6837\u4f8b 2 10 10 1 2 3 4 5 6 7 8 9 0 11 12 13 14 15 16 17 18 19 10 1 19 1 0 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 10 \u6ce8\u610f\uff1a\u6837\u4f8b\u53ea\u4ee3\u8868\u683c\u5f0f\uff0c\u4e0d\u5177\u6709\u7279\u522b\u542b\u4e49\u3002 \u8bc4\u5206\u65b9\u5f0f \u672c\u9898\u6309\u7167\u4f60\u7ed9\u51fa\u7684\u65b9\u6848\u7684\u4f18\u826f\u7a0b\u5ea6\u8bc4\u5b9a\u5206\u6570\u3002 \u5177\u4f53\u8bc4\u5206\u89c4\u5219\u5982\u4e0b\uff1a \u672c\u9898\u6240\u6709\u6570\u636e\u70b9\u8f93\u5165\u5747\u4e3a\u4e00\u6837\u7684\u6570\u636e\uff1b \u8bc4\u5206\u65f6\uff0c\u5047\u5b9a\u8f93\u5165\u6709 X \u7ec4\u6570\u636e\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u4e3a\u4f60\u7684\u7a0b\u5e8f\u5728\u6240\u6709 X \u7ec4\u6570\u636e\u4e2d\u7b54\u6848\u7684\u5e73\u5747\u503c\uff1b \u4f8b\u5982\uff0c\u4f60\u5bf9 3 \u7ec4\u6570\u636e\uff0c\u5206\u522b\u8bbf\u95ee\u4e86 3 \u4e2a\u30015 \u4e2a\u30018 \u4e2a\u70b9\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u4e3a 5.33333\u2026 \u7279\u522b\u7684\uff0c\u5982\u679c\u4f60\u8f93\u51fa\u7684\u7b54\u6848\u4e2d\u6709\u4efb\u610f\u4e00\u7ec4\u4e0d\u5408\u6cd5\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u6052\u5b9a\u4e3a 0\uff1b \u8f93\u51fa\u65b9\u6848\u884c\u8d70\u8d85\u8fc7 120 \u79d2\u4ecd\u7136\u5408\u6cd5\uff0c\u7b54\u6848\u8ba1\u7b97\u65f6\u53ea\u8ba1\u7b97 120 \u79d2\u5185\u7684\u90e8\u5206\uff1b \u8bc4\u6d4b\u65f6\uff0c\u4ece 0 \u5f00\u59cb\u7684\u6d4b\u8bd5\u70b9\u7684\u6807\u51c6\u7b54\u6848\u4f9d\u6b21\u589e\u5927\uff0c\u53ea\u6709\u8bc4\u5206\u7b54\u6848\u8d85\u8fc7\u6807\u51c6\u7b54\u6848\u65f6\uff0c\u4f60\u624d\u53ef\u4ee5\u5f97\u5230\u5bf9\u5e94\u6d4b\u8bd5\u70b9\u7684\u5206\u6570\u3002 \u4e0d\u5408\u6cd5\u7684\u60c5\u51b5\u5982\u4e0b\uff1a * \u8f93\u51fa\u683c\u5f0f\u4e0d\u6b63\u786e\uff1b * \u91cd\u590d\u8bbf\u95ee\u81ea\u5df1\u5df2\u8bbf\u95ee\u7684\u70b9\uff1b\uff08\u4f46\u53ef\u4ee5\u7ecf\u8fc7\uff09 * \u8bbf\u95ee\u4e0d\u5b58\u5728\u7684\u70b9\u3002 \u90e8\u5206\u8bc4\u5206\u6807\u51c6\u7b54\u6848\u5982\u4e0b\uff1a * \u7b2c 0 \u53f7\u70b9\uff1a20\uff1b\uff08\u5373\u9700\u8981\u8bbf\u95ee\u5e73\u5747 20 \u4e2a\u70b9\u624d\u53ef\u4ee5\u83b7\u5f97\u8be5\u70b9\u5206\u6570\uff09 * \u7b2c 1 \u53f7\u70b9\uff1a70\uff1b\uff08\u540c\u4e0a\uff09 * \u7b2c 2 \u53f7\u70b9\uff1a90\uff1b * \u7b2c 7 \u53f7\u70b9\uff1a150\u3002","title":"L3-024-Oriol\u548cDavid"},{"location":"CCCC/L3-024-Oriol%E5%92%8CDavid/#l3-024-oriol\u548cdavid","text":"","title":"L3-024 Oriol\u548cDavid"},{"location":"CCCC/L3-024-Oriol%E5%92%8CDavid/#statement","text":"Metadata \u4f5c\u8005: \u674e\u6587\u65b0 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 256 MB Oriol \u548c David \u5728\u4e00\u4e2a\u8fb9\u957f\u4e3a 16 \u5355\u4f4d\u957f\u5ea6\u7684\u6b63\u65b9\u5f62\u533a\u57df\u5185\uff0c\u521d\u59cb\u4f4d\u7f6e\u5206\u522b\u4e3a\uff087, 7\uff09\u548c\uff088, 8\uff09\u3002\u73b0\u5728\u6709 20 \u7ec4\u3001\u6bcf\u7ec4\u5305\u542b 20 \u4e2a\u4f4d\u7f6e\u9700\u8981\u4ed6\u4eec\u8bbf\u95ee\uff0c\u4f4d\u7f6e\u4ee5\u5750\u6807\uff08x, y\uff09\u7684\u5f62\u5f0f\u7ed9\u51fa\uff0c\u8981\u6c42\u5728\u65f6\u95f4 120 \u79d2\u5185\u8bbf\u95ee\u5c3d\u53ef\u80fd\u591a\u7684\u70b9\u3002\uff08x\u548cy\u5747\u4e3a\u6b63\u6574\u6570\uff0c\u4e140 \u2264 x < 16\uff0c0 \u2264 y < 16\uff09 \u6ce8\u610f\u4e8b\u9879\uff1a * \u9488\u5bf9\u4efb\u610f\u4e00\u4e2a\u4f4d\u7f6e\uff0cOriol\u6216David\u4e2d\u7684\u4e00\u4eba\u5230\u8fbe\u5373\u89c6\u4e3a\u8bbf\u95ee\u6210\u529f\uff1b * Oriol\u548cDavid\u5fc5\u987b\u4ece\u7b2c 1 \u7ec4\u4f4d\u7f6e\u5f00\u59cb\u8bbf\u95ee\uff0c\u4e14\u5fc5\u987b\u8bbf\u95ee\u5b8c\u7b2c i \u7ec4\u5168\u90e820\u4e2a\u4f4d\u7f6e\u4e4b\u540e\uff0c\u624d\u53ef\u4ee5\u5f00\u59cb\u7b2c i + 1 \u7ec4 20 \u4e2a\u4f4d\u7f6e\u7684\u8bbf\u95ee\u3002\u540c\u7ec4\u95f4\u5404\u4f4d\u7f6e\u7684\u8bbf\u95ee\u987a\u5e8f\u53ef\u81ea\u7531\u51b3\u5b9a\uff1b * Oriol\u548cDavid\u5728\u5b8c\u6210\u5f53\u524d\u7ec4\u4f4d\u7f6e\u7684\u8bbf\u95ee\u540e\uff0c\u65e0\u9700\u8fd4\u56de\u5f00\u59cb\u4f4d\u7f6e\u3001\u53ef\u4ee5\u7acb\u5373\u5f00\u59cb\u4e0b\u4e00\u7ec4\u4f4d\u7f6e\u7684\u8bbf\u95ee\uff1b * Oriol\u548cDavid\u53ef\u4ee5\u5411\u4efb\u610f\u65b9\u5411\u79fb\u52a8\uff0c\u79fb\u52a8\u65f6\u901f\u7387\u4e3a 2 \u5355\u4f4d\u957f\u5ea6/\u79d2\uff1b\u79fb\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u65e0\u4efb\u4f55\u969c\u788d\u7269\u963b\u62e6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6b63\u6574\u6570 T (T \u2264 10)\uff0c\u8868\u793a\u6570\u636e\u7ec4\u6570\u3002\u63a5\u4e0b\u6765\u7ed9\u51fa T \u7ec4\u6570\u636e\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u5165\u5305\u542b 20 \u7ec4\uff0c\u6bcf\u7ec4 1 \u884c\uff0c\u6bcf\u884c\u7531 20 \u4e2a\u5750\u6807\u7ec4\u6210\uff0c\u6bcf\u4e2a\u5750\u6807\u7531 2 \u4e2a\u6574\u6570 x \u548c y \u7ec4\u6210\uff0c\u4ee3\u8868 Oriol \u548c David \u8981\u8bbf\u95ee\u7684 20 \u7ec4 20 \u4e2a\u4f4d\u7f6e\u7684\u5750\u6807\uff1b0 \u2264 x < 16\uff0c0 \u2264 y < 16\uff0c\u5747\u7528\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u7ec4\u6570\u636e\u8f93\u51fa\u7684\u7b2c\u4e00\u884c\u662f\u4e00\u4e2a\u6574\u6570N\uff0c\u4ee3\u8868\u5206\u914d\u65b9\u6848\u8bbf\u95ee\u8fc7\u7684\u4f4d\u7f6e\u7ec4\u6570\uff1b \u63a5\u4e0b\u6765\u7684N\u7ec4\u6bcf\u7ec4\u7684\u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570 Ba \u548c Bb\uff0c\u5206\u522b\u4ee3\u8868\u6bcf\u7ec4\u5206\u914d\u65b9\u6848\u4e2d Oriol \u548c David \u8d1f\u8d23\u8bbf\u95ee\u7684\u4f4d\u7f6e\u6570\uff0c\u7b2c\u4e8c\u884c\u548c\u7b2c\u4e09\u884c\u5206\u522b\u5305\u542b Ba \u548c Bb \u4e2a\u6574\u6570 i\uff0c\u5206\u522b\u4ee3\u8868 Oriol \u548c David \u8d1f\u8d23\u8bbf\u95ee\u7684\u4f4d\u7f6e\u5728\u7ec4\u5185\u7684\u5e8f\u53f7\uff08\u4ece0\u5f00\u59cb\u8ba1\u6570\uff09\u3002 0 \u2264 N \u2264 20\uff0c0 \u2264 Ba \u2264 20\uff0c0 \u2264 Bb \u2264 20\uff0c0 \u2264 i \u2264 19\u3002 \u8f93\u5165\u6837\u4f8b 1 5 5 3 13 8 7 13 6 6 11 2 0 1 14 9 15 8 9 3 12 4 6 2 10 2 5 4 9 4 1 15 0 11 4 10 0 15 5 10 14 1 0 14 8 0 7 6 8 4 12 12 8 9 8 10 14 9 4 13 4 9 1 2 1 0 2 11 10 7 15 9 6 13 11 3 5 4 5 10 7 7 3 8 13 15 0 5 4 2 8 7 14 4 13 11 1 8 15 4 5 4 7 7 10 6 7 13 4 6 2 9 13 1 12 10 7 10 5 5 11 5 8 12 12 11 5 12 9 2 2 11 15 5 14 0 0 14 0 2 5 7 3 10 1 2 8 4 2 4 8 9 14 1 11 1 9 15 7 3 3 1 9 10 14 7 3 15 5 5 15 3 2 12 11 8 10 3 3 11 5 7 4 6 11 6 1 4 10 11 13 12 4 3 4 1 3 7 5 13 11 3 11 9 8 12 9 14 10 11 13 5 5 4 11 1 12 13 2 10 14 5 15 10 15 11 0 3 6 7 11 4 9 15 0 12 14 10 10 13 11 10 4 9 12 0 13 6 6 7 10 11 15 6 14 1 2 4 9 8 5 4 0 13 11 5 3 13 3 9 8 2 4 13 14 12 12 14 2 8 15 2 8 4 9 13 10 8 5 2 13 12 6 4 4 10 6 14 13 11 5 12 1 6 0 11 2 8 15 12 4 13 8 8 2 9 7 7 13 0 9 0 0 4 0 2 3 10 2 7 3 9 4 2 13 11 11 1 8 11 15 11 2 8 11 10 15 7 9 13 15 15 10 1 2 11 9 14 6 5 5 2 13 6 8 7 14 8 5 15 14 5 6 4 10 14 12 3 14 0 5 4 1 0 14 13 14 12 5 5 9 1 2 2 12 4 8 1 15 7 11 10 5 15 7 6 8 11 10 7 13 14 0 12 2 9 12 4 5 3 8 8 13 7 12 15 15 12 9 15 6 14 3 9 6 15 12 7 9 4 15 0 10 6 2 3 2 6 3 14 6 10 13 3 10 15 9 10 0 7 0 14 15 1 2 13 9 11 11 10 3 6 13 0 14 11 2 9 8 15 5 3 9 13 11 1 1 0 9 5 4 4 9 4 13 10 1 12 11 4 2 0 4 1 7 4 10 4 0 2 1 2 0 13 2 11 10 0 5 15 3 15 11 8 1 12 5 8 5 7 5 7 7 2 4 0 4 7 3 12 6 9 15 5 12 14 11 15 10 8 11 4 10 4 14 13 10 4 4 2 12 9 12 15 13 0 12 0 14 3 1 10 15 15 11 1 12 3 0 5 2 15 10 8 4 9 1 8 0 1 13 2 7 12 13 14 10 6 0 13 15 13 7 14 15 9 4 8 2 7 3 7 11 2 13 5 0 13 5 4 0 12 2 3 2 11 15 9 2 9 7 3 7 4 5 14 5 14 12 9 13 12 11 2 14 2 6 6 12 5 15 13 11 2 0 9 13 7 1 7 11 4 4 2 10 0 8 5 3 6 13 2 7 2 15 6 8 3 5 8 11 12 5 9 9 4 14 3 2 14 2 2 1 9 11 8 10 2 14 12 15 0 13 4 7 0 0 0 6 0 1 4 13 4 3 3 10 15 2 10 10 11 15 8 5 6 15 9 8 2 7 15 14 1 10 14 6 13 6 0 15 4 1 3 12 7 8 12 4 0 10 7 10 0 14 13 5 11 1 15 6 1 12 13 14 6 12 9 0 6 8 3 15 5 4 4 2 15 10 3 6 13 12 8 4 15 3 1 5 7 1 6 14 8 6 2 6 11 3 4 4 \u8f93\u51fa\u6837\u4f8b 2 10 10 1 2 3 4 5 6 7 8 9 0 11 12 13 14 15 16 17 18 19 10 1 19 1 0 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 10 \u6ce8\u610f\uff1a\u6837\u4f8b\u53ea\u4ee3\u8868\u683c\u5f0f\uff0c\u4e0d\u5177\u6709\u7279\u522b\u542b\u4e49\u3002 \u8bc4\u5206\u65b9\u5f0f \u672c\u9898\u6309\u7167\u4f60\u7ed9\u51fa\u7684\u65b9\u6848\u7684\u4f18\u826f\u7a0b\u5ea6\u8bc4\u5b9a\u5206\u6570\u3002 \u5177\u4f53\u8bc4\u5206\u89c4\u5219\u5982\u4e0b\uff1a \u672c\u9898\u6240\u6709\u6570\u636e\u70b9\u8f93\u5165\u5747\u4e3a\u4e00\u6837\u7684\u6570\u636e\uff1b \u8bc4\u5206\u65f6\uff0c\u5047\u5b9a\u8f93\u5165\u6709 X \u7ec4\u6570\u636e\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u4e3a\u4f60\u7684\u7a0b\u5e8f\u5728\u6240\u6709 X \u7ec4\u6570\u636e\u4e2d\u7b54\u6848\u7684\u5e73\u5747\u503c\uff1b \u4f8b\u5982\uff0c\u4f60\u5bf9 3 \u7ec4\u6570\u636e\uff0c\u5206\u522b\u8bbf\u95ee\u4e86 3 \u4e2a\u30015 \u4e2a\u30018 \u4e2a\u70b9\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u4e3a 5.33333\u2026 \u7279\u522b\u7684\uff0c\u5982\u679c\u4f60\u8f93\u51fa\u7684\u7b54\u6848\u4e2d\u6709\u4efb\u610f\u4e00\u7ec4\u4e0d\u5408\u6cd5\uff0c\u5219\u4f60\u7684\u8bc4\u5206\u7b54\u6848\u6052\u5b9a\u4e3a 0\uff1b \u8f93\u51fa\u65b9\u6848\u884c\u8d70\u8d85\u8fc7 120 \u79d2\u4ecd\u7136\u5408\u6cd5\uff0c\u7b54\u6848\u8ba1\u7b97\u65f6\u53ea\u8ba1\u7b97 120 \u79d2\u5185\u7684\u90e8\u5206\uff1b \u8bc4\u6d4b\u65f6\uff0c\u4ece 0 \u5f00\u59cb\u7684\u6d4b\u8bd5\u70b9\u7684\u6807\u51c6\u7b54\u6848\u4f9d\u6b21\u589e\u5927\uff0c\u53ea\u6709\u8bc4\u5206\u7b54\u6848\u8d85\u8fc7\u6807\u51c6\u7b54\u6848\u65f6\uff0c\u4f60\u624d\u53ef\u4ee5\u5f97\u5230\u5bf9\u5e94\u6d4b\u8bd5\u70b9\u7684\u5206\u6570\u3002 \u4e0d\u5408\u6cd5\u7684\u60c5\u51b5\u5982\u4e0b\uff1a * \u8f93\u51fa\u683c\u5f0f\u4e0d\u6b63\u786e\uff1b * \u91cd\u590d\u8bbf\u95ee\u81ea\u5df1\u5df2\u8bbf\u95ee\u7684\u70b9\uff1b\uff08\u4f46\u53ef\u4ee5\u7ecf\u8fc7\uff09 * \u8bbf\u95ee\u4e0d\u5b58\u5728\u7684\u70b9\u3002 \u90e8\u5206\u8bc4\u5206\u6807\u51c6\u7b54\u6848\u5982\u4e0b\uff1a * \u7b2c 0 \u53f7\u70b9\uff1a20\uff1b\uff08\u5373\u9700\u8981\u8bbf\u95ee\u5e73\u5747 20 \u4e2a\u70b9\u624d\u53ef\u4ee5\u83b7\u5f97\u8be5\u70b9\u5206\u6570\uff09 * \u7b2c 1 \u53f7\u70b9\uff1a70\uff1b\uff08\u540c\u4e0a\uff09 * \u7b2c 2 \u53f7\u70b9\uff1a90\uff1b * \u7b2c 7 \u53f7\u70b9\uff1a150\u3002","title":"Statement"},{"location":"CCCC/L3-025-%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86/","text":"L3-025 \u90a3\u5c31\u522b\u62c5\u5fc3\u4e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u56fe\u8f6c\u81ea\u201c\u82f1\u5f0f\u6ca1\u54c1\u7b11\u8bdd\u767e\u79d1\u201d\u7684\u65b0\u6d6a\u5fae\u535a \u2014\u2014 \u6240\u4ee5\u65e0\u8bba\u6709\u6ca1\u6709\u9047\u5230\u96be\u9898\uff0c\u5176\u5b9e\u90fd\u4e0d\u7528\u62c5\u5fc3\u3002 \u535a\u4e3b\u5c06\u8fd9\u79cd\u903b\u8f91\u63a8\u6f14\u79f0\u4e3a\u201c\u903b\u8f91\u81ea\u6d3d\u201d\uff0c\u5373\u4ece\u67d0\u4e2a\u547d\u9898\u51fa\u53d1\u7684\u6240\u6709\u63a8\u7406\u8def\u5f84\u90fd\u4f1a\u5c06\u7ed3\u8bba\u5f15\u5bfc\u5230\u540c\u4e00\u4e2a\u6700\u7ec8\u547d\u9898\uff08\u5f00\u73a9\u7b11\u7684\uff0c\u5343\u4e07\u522b\u4ee5\u4e3a\u8fd9\u662f\u771f\u6b63\u7684\u903b\u8f91\u81ea\u6d3d\u7684\u5b9a\u4e49\u2026\u2026\uff09\u3002\u73b0\u7ed9\u5b9a\u4e00\u4e2a\u66f4\u4e3a\u590d\u6742\u7684\u903b\u8f91\u63a8\u7406\u56fe\uff0c\u672c\u9898\u5c31\u8bf7\u4f60\u68c0\u67e5\u4ece\u4e00\u4e2a\u7ed9\u5b9a\u547d\u9898\u5230\u53e6\u4e00\u4e2a\u547d\u9898\u7684\u63a8\u7406\u662f\u5426\u662f\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\uff0c\u4ee5\u53ca\u5b58\u5728\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\u3002\u4f8b\u5982\u4e0a\u56fe\uff0c\u4ece\u201c\u4f60\u9047\u5230\u96be\u9898\u4e86\u5417\uff1f\u201d\u5230\u201c\u90a3\u5c31\u522b\u62c5\u5fc3\u4e86\u201d\u5c31\u662f\u4e00\u79cd\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\u63a8\u7406\uff0c\u4e00\u5171\u6709 3 \u6761\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 500 1 < N \\le 500 \uff09\u548c M M \uff0c\u5206\u522b\u4e3a\u547d\u9898\u4e2a\u6570\u548c\u63a8\u7406\u4e2a\u6570\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u547d\u9898\u4ece 1 \u5230 N N \u7f16\u53f7\u3002 \u63a5\u4e0b\u6765 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u547d\u9898\u4e4b\u95f4\u7684\u63a8\u7406\u5173\u7cfb\uff0c\u5373\u4e24\u4e2a\u547d\u9898\u7684\u7f16\u53f7 S1 S2 \uff0c\u8868\u793a\u53ef\u4ee5\u4ece S1 \u63a8\u51fa S2 \u3002\u9898\u76ee\u4fdd\u8bc1\u4efb\u610f\u4e24\u547d\u9898\u4e4b\u95f4\u53ea\u5b58\u5728\u6700\u591a\u4e00\u79cd\u63a8\u7406\u5173\u7cfb\uff0c\u4e14\u4efb\u4e00\u547d\u9898\u4e0d\u80fd\u5faa\u73af\u81ea\u8bc1\uff08\u5373\u4ece\u8be5\u547d\u9898\u51fa\u53d1\u63a8\u51fa\u8be5\u547d\u9898\u81ea\u5df1\uff09\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u5f85\u68c0\u9a8c\u7684\u4e24\u4e2a\u547d\u9898\u7684\u7f16\u53f7 A B \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u4ece A \u5230 B \u6709\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\uff0c\u7136\u540e\u8f93\u51fa Yes \u5982\u679c\u63a8\u7406\u662f\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\uff0c\u6216 No \u5982\u679c\u4e0d\u662f\u3002 \u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u6570\u636e\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u5165\u6837\u4f8b 1 7 8 7 6 7 4 6 5 4 1 5 2 5 3 2 1 3 1 7 1 \u8f93\u51fa\u6837\u4f8b 1 3 Yes \u8f93\u5165\u6837\u4f8b 2 7 8 7 6 7 4 6 5 4 1 5 2 5 3 6 1 3 1 7 1 \u8f93\u51fa\u6837\u4f8b 2 3 No Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e2 + 10 ; int n , m , st , ed , in [ N ], out [ N ], vis [ N ]; ll f [ N ]; vector < vector < int >> G ; void bfs ( int st ) { queue < int > que ; que . push ( st ); vis [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { if ( ! vis [ v ]) { vis [ v ] = 1 ; que . push ( v ); } } } } void topo ( int st ) { queue < int > que ; que . push ( st ); f [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { f [ v ] += f [ u ]; if ( -- in [ v ] == 0 ) { que . push ( v ); } } } } int main () { scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); memset ( vis , 0 , sizeof vis ); memset ( f , 0 , sizeof f ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); } scanf ( \"%d%d\" , & st , & ed ); bfs ( st ); for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( vis [ u ] && vis [ v ]) { ++ out [ u ]; ++ in [ v ]; } } } int ok = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ] && out [ i ] == 0 ) { ++ ok ; } } topo ( st ); cout << f [ ed ] << ' ' << (( f [ ed ] > 0 && ok == 1 ) ? \"Yes\" : \"No\" ) << endl ; return 0 ; }","title":"L3-025-\u90a3\u5c31\u522b\u62c5\u5fc3\u4e86"},{"location":"CCCC/L3-025-%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86/#l3-025-\u90a3\u5c31\u522b\u62c5\u5fc3\u4e86","text":"","title":"L3-025 \u90a3\u5c31\u522b\u62c5\u5fc3\u4e86"},{"location":"CCCC/L3-025-%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u56fe\u8f6c\u81ea\u201c\u82f1\u5f0f\u6ca1\u54c1\u7b11\u8bdd\u767e\u79d1\u201d\u7684\u65b0\u6d6a\u5fae\u535a \u2014\u2014 \u6240\u4ee5\u65e0\u8bba\u6709\u6ca1\u6709\u9047\u5230\u96be\u9898\uff0c\u5176\u5b9e\u90fd\u4e0d\u7528\u62c5\u5fc3\u3002 \u535a\u4e3b\u5c06\u8fd9\u79cd\u903b\u8f91\u63a8\u6f14\u79f0\u4e3a\u201c\u903b\u8f91\u81ea\u6d3d\u201d\uff0c\u5373\u4ece\u67d0\u4e2a\u547d\u9898\u51fa\u53d1\u7684\u6240\u6709\u63a8\u7406\u8def\u5f84\u90fd\u4f1a\u5c06\u7ed3\u8bba\u5f15\u5bfc\u5230\u540c\u4e00\u4e2a\u6700\u7ec8\u547d\u9898\uff08\u5f00\u73a9\u7b11\u7684\uff0c\u5343\u4e07\u522b\u4ee5\u4e3a\u8fd9\u662f\u771f\u6b63\u7684\u903b\u8f91\u81ea\u6d3d\u7684\u5b9a\u4e49\u2026\u2026\uff09\u3002\u73b0\u7ed9\u5b9a\u4e00\u4e2a\u66f4\u4e3a\u590d\u6742\u7684\u903b\u8f91\u63a8\u7406\u56fe\uff0c\u672c\u9898\u5c31\u8bf7\u4f60\u68c0\u67e5\u4ece\u4e00\u4e2a\u7ed9\u5b9a\u547d\u9898\u5230\u53e6\u4e00\u4e2a\u547d\u9898\u7684\u63a8\u7406\u662f\u5426\u662f\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\uff0c\u4ee5\u53ca\u5b58\u5728\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\u3002\u4f8b\u5982\u4e0a\u56fe\uff0c\u4ece\u201c\u4f60\u9047\u5230\u96be\u9898\u4e86\u5417\uff1f\u201d\u5230\u201c\u90a3\u5c31\u522b\u62c5\u5fc3\u4e86\u201d\u5c31\u662f\u4e00\u79cd\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\u63a8\u7406\uff0c\u4e00\u5171\u6709 3 \u6761\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 500 1 < N \\le 500 \uff09\u548c M M \uff0c\u5206\u522b\u4e3a\u547d\u9898\u4e2a\u6570\u548c\u63a8\u7406\u4e2a\u6570\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u547d\u9898\u4ece 1 \u5230 N N \u7f16\u53f7\u3002 \u63a5\u4e0b\u6765 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u547d\u9898\u4e4b\u95f4\u7684\u63a8\u7406\u5173\u7cfb\uff0c\u5373\u4e24\u4e2a\u547d\u9898\u7684\u7f16\u53f7 S1 S2 \uff0c\u8868\u793a\u53ef\u4ee5\u4ece S1 \u63a8\u51fa S2 \u3002\u9898\u76ee\u4fdd\u8bc1\u4efb\u610f\u4e24\u547d\u9898\u4e4b\u95f4\u53ea\u5b58\u5728\u6700\u591a\u4e00\u79cd\u63a8\u7406\u5173\u7cfb\uff0c\u4e14\u4efb\u4e00\u547d\u9898\u4e0d\u80fd\u5faa\u73af\u81ea\u8bc1\uff08\u5373\u4ece\u8be5\u547d\u9898\u51fa\u53d1\u63a8\u51fa\u8be5\u547d\u9898\u81ea\u5df1\uff09\u3002 \u6700\u540e\u4e00\u884c\u7ed9\u51fa\u5f85\u68c0\u9a8c\u7684\u4e24\u4e2a\u547d\u9898\u7684\u7f16\u53f7 A B \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u4ece A \u5230 B \u6709\u591a\u5c11\u79cd\u4e0d\u540c\u7684\u63a8\u7406\u8def\u5f84\uff0c\u7136\u540e\u8f93\u51fa Yes \u5982\u679c\u63a8\u7406\u662f\u201c\u903b\u8f91\u81ea\u6d3d\u201d\u7684\uff0c\u6216 No \u5982\u679c\u4e0d\u662f\u3002 \u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u6570\u636e\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u5165\u6837\u4f8b 1 7 8 7 6 7 4 6 5 4 1 5 2 5 3 2 1 3 1 7 1 \u8f93\u51fa\u6837\u4f8b 1 3 Yes \u8f93\u5165\u6837\u4f8b 2 7 8 7 6 7 4 6 5 4 1 5 2 5 3 6 1 3 1 7 1 \u8f93\u51fa\u6837\u4f8b 2 3 No","title":"Statement"},{"location":"CCCC/L3-025-%E9%82%A3%E5%B0%B1%E5%88%AB%E6%8B%85%E5%BF%83%E4%BA%86/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e2 + 10 ; int n , m , st , ed , in [ N ], out [ N ], vis [ N ]; ll f [ N ]; vector < vector < int >> G ; void bfs ( int st ) { queue < int > que ; que . push ( st ); vis [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { if ( ! vis [ v ]) { vis [ v ] = 1 ; que . push ( v ); } } } } void topo ( int st ) { queue < int > que ; que . push ( st ); f [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { f [ v ] += f [ u ]; if ( -- in [ v ] == 0 ) { que . push ( v ); } } } } int main () { scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); memset ( vis , 0 , sizeof vis ); memset ( f , 0 , sizeof f ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); } scanf ( \"%d%d\" , & st , & ed ); bfs ( st ); for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( vis [ u ] && vis [ v ]) { ++ out [ u ]; ++ in [ v ]; } } } int ok = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ] && out [ i ] == 0 ) { ++ ok ; } } topo ( st ); cout << f [ ed ] << ' ' << (( f [ ed ] > 0 && ok == 1 ) ? \"Yes\" : \"No\" ) << endl ; return 0 ; }","title":"Solution"},{"location":"CCCC/L3-026-%E4%BC%A0%E9%80%81%E9%97%A8/","text":"L3-026 \u4f20\u9001\u95e8 Statement Metadata \u4f5c\u8005: WENG, Caizhi \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3500 ms \u5185\u5b58\u9650\u5236: 512 MB \u5e73\u9762\u4e0a\u6709 2n 2n \u4e2a\u70b9\uff0c\u5b83\u4eec\u7684\u5750\u6807\u5206\u522b\u662f (1, 0), (2, 0), \\cdots (n, 0) (1, 0), (2, 0), \\cdots (n, 0) \u548c (1, 10^9), (2, 10^9), \\cdots, (n, 10^9) (1, 10^9), (2, 10^9), \\cdots, (n, 10^9) \u3002\u6211\u4eec\u79f0\u8fd9\u4e9b\u70b9\u4e2d\u6240\u6709 y y \u5750\u6807\u4e3a 0 0 \u7684\u70b9\u4e3a\u201c\u8d77\u70b9\u201d\uff0c\u6240\u6709 y y \u5750\u6807\u4e3a 10^9 10^9 \u7684\u70b9\u4e3a\u7ec8\u70b9\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u5c06\u4ece\u5750\u6807\u4e3a (x, 0) (x, 0) \u7684\u8d77\u70b9\u51fa\u53d1\u5411 y y \u8f74\u6b63\u65b9\u5411\u79fb\u52a8\u3002\u663e\u7136\uff0c\u8be5\u673a\u5668\u4eba\u6700\u540e\u4f1a\u5230\u8fbe\u67d0\u4e2a\u7ec8\u70b9\uff0c\u6211\u4eec\u8bbe\u8be5\u7ec8\u70b9\u7684 x x \u5750\u6807\u4e3a f(x) f(x) \u3002 \u5728\u4e0a\u8ff0\u6761\u4ef6\u4e0b\uff0c\u663e\u7136\u6709 f(x) = x f(x) = x \u3002\u4e0d\u8fc7\u8fd9\u6837\u7684\u6570\u5b66\u6a21\u578b\u5c31\u592a\u65e0\u8da3\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u5bf9\u4e0a\u8ff0\u6570\u5b66\u6a21\u578b\u505a\u4e00\u4e9b\u5c0f\u5c0f\u7684\u6539\u53d8\u3002\u6211\u4eec\u5c06\u4f1a\u5bf9\u6a21\u578b\u8fdb\u884c q q \u6b21\u4fee\u6539\uff0c\u6bcf\u4e00\u6b21\u4fee\u6539\u90fd\u662f\u4ee5\u4e0b\u4e24\u79cd\u64cd\u4f5c\u4e4b\u4e00\uff1a + x' x' x'' x'' y y : \u5728 (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u589e\u52a0\u4e00\u5bf9\u4f20\u9001\u95e8\u3002\u5f53\u673a\u5668\u4eba\u78b0\u5230\u5176\u4e2d\u4e00\u4e2a\u4f20\u9001\u95e8\u65f6\uff0c\u5b83\u4f1a\u7acb\u523b\u88ab\u4f20\u9001\u5230\u53e6\u4e00\u4e2a\u4f20\u9001\u95e8\u5904\u3002\u6570\u636e\u4fdd\u8bc1\u8fdb\u884c\u8be5\u64cd\u4f5c\u65f6\uff0c (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u5f53\u524d\u4e0d\u5b58\u5728\u4f20\u9001\u95e8\u3002 - x' x' x'' x'' y y : \u79fb\u9664 (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u7684\u4e00\u5bf9\u4f20\u9001\u95e8\u3002\u6570\u636e\u4fdd\u8bc1\u8fd9\u5bf9\u4f20\u9001\u95e8\u5b58\u5728\u3002 \u6c42\u6bcf\u6b21\u4fee\u6539\u540e \\sum\\limits_{x=1}^n xf(x) \\sum\\limits_{x=1}^n xf(x) \u7684\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 n n \u4e0e q q ( 2 \\le n \\le 10^5 2 \\le n \\le 10^5 , 1 \\le q \\le 10^5 1 \\le q \\le 10^5 )\uff0c\u4ee3\u8868\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u6570\u91cf\u4ee5\u53ca\u4fee\u6539\u7684\u6b21\u6570\u3002 \u63a5\u4e0b\u6765 q q \u884c\u4e2d\uff0c\u7b2c i i \u884c\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26 op_i op_i \u4ee5\u53ca\u4e09\u4e2a\u6574\u6570 x'_i x'_i , x''_i x''_i and y_i y_i ( op_i in {text{ +' (ascii: 43)}, \\text{ -' (ascii: 45)}}-' (ascii: 45)}} op_i in {text{<code>+' (ascii: 43)}, \\text{</code>-' (ascii: 45)}}-' (ascii: 45)}} , 1 \\le x'_i < x''_i \\le n 1 \\le x'_i < x''_i \\le n , 1 \\le y_i < 10^9 1 \\le y_i < 10^9 )\uff0c\u4ee3\u8868\u7b2c i i \u6b21\u4fee\u6539\u7684\u5185\u5bb9\u3002\u4fee\u6539\u987a\u5e8f\u4e0e\u8f93\u5165\u987a\u5e8f\u76f8\u540c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa q q \u884c\uff0c\u5176\u4e2d\u7b2c i i \u884c\u5305\u542b\u4e00\u4e2a\u6574\u6570\u4ee3\u8868\u7b2c i i \u6b21\u4fee\u6539\u540e\u7684\u7b54\u6848\u3002 \u8f93\u5165\u6837\u4f8b 5 4 + 1 3 1 + 1 4 3 + 2 5 2 - 1 4 3 \u8f93\u51fa\u6837\u4f8b 51 48 39 42 \u6837\u4f8b\u89e3\u91ca \u4fee\u6539 | f(1) f(1) | f(2) f(2) | f(3) f(3) | f(4) f(4) | f(5) f(5) | \u7ed3\u679c \u2014 | \u2014 + 1 3 1 | 3 | 2 | 1 | 4 | 5 | 51 + 1 4 3 | 3 | 2 | 4 | 1 | 5 | 48 + 2 5 2 | 3 | 5 | 4 | 1 | 2 | 39 - 1 4 3 | 3 | 5 | 1 | 4 | 2 | 42","title":"L3-026-\u4f20\u9001\u95e8"},{"location":"CCCC/L3-026-%E4%BC%A0%E9%80%81%E9%97%A8/#l3-026-\u4f20\u9001\u95e8","text":"","title":"L3-026 \u4f20\u9001\u95e8"},{"location":"CCCC/L3-026-%E4%BC%A0%E9%80%81%E9%97%A8/#statement","text":"Metadata \u4f5c\u8005: WENG, Caizhi \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3500 ms \u5185\u5b58\u9650\u5236: 512 MB \u5e73\u9762\u4e0a\u6709 2n 2n \u4e2a\u70b9\uff0c\u5b83\u4eec\u7684\u5750\u6807\u5206\u522b\u662f (1, 0), (2, 0), \\cdots (n, 0) (1, 0), (2, 0), \\cdots (n, 0) \u548c (1, 10^9), (2, 10^9), \\cdots, (n, 10^9) (1, 10^9), (2, 10^9), \\cdots, (n, 10^9) \u3002\u6211\u4eec\u79f0\u8fd9\u4e9b\u70b9\u4e2d\u6240\u6709 y y \u5750\u6807\u4e3a 0 0 \u7684\u70b9\u4e3a\u201c\u8d77\u70b9\u201d\uff0c\u6240\u6709 y y \u5750\u6807\u4e3a 10^9 10^9 \u7684\u70b9\u4e3a\u7ec8\u70b9\u3002\u4e00\u4e2a\u673a\u5668\u4eba\u5c06\u4ece\u5750\u6807\u4e3a (x, 0) (x, 0) \u7684\u8d77\u70b9\u51fa\u53d1\u5411 y y \u8f74\u6b63\u65b9\u5411\u79fb\u52a8\u3002\u663e\u7136\uff0c\u8be5\u673a\u5668\u4eba\u6700\u540e\u4f1a\u5230\u8fbe\u67d0\u4e2a\u7ec8\u70b9\uff0c\u6211\u4eec\u8bbe\u8be5\u7ec8\u70b9\u7684 x x \u5750\u6807\u4e3a f(x) f(x) \u3002 \u5728\u4e0a\u8ff0\u6761\u4ef6\u4e0b\uff0c\u663e\u7136\u6709 f(x) = x f(x) = x \u3002\u4e0d\u8fc7\u8fd9\u6837\u7684\u6570\u5b66\u6a21\u578b\u5c31\u592a\u65e0\u8da3\u4e86\uff0c\u56e0\u6b64\u6211\u4eec\u5bf9\u4e0a\u8ff0\u6570\u5b66\u6a21\u578b\u505a\u4e00\u4e9b\u5c0f\u5c0f\u7684\u6539\u53d8\u3002\u6211\u4eec\u5c06\u4f1a\u5bf9\u6a21\u578b\u8fdb\u884c q q \u6b21\u4fee\u6539\uff0c\u6bcf\u4e00\u6b21\u4fee\u6539\u90fd\u662f\u4ee5\u4e0b\u4e24\u79cd\u64cd\u4f5c\u4e4b\u4e00\uff1a + x' x' x'' x'' y y : \u5728 (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u589e\u52a0\u4e00\u5bf9\u4f20\u9001\u95e8\u3002\u5f53\u673a\u5668\u4eba\u78b0\u5230\u5176\u4e2d\u4e00\u4e2a\u4f20\u9001\u95e8\u65f6\uff0c\u5b83\u4f1a\u7acb\u523b\u88ab\u4f20\u9001\u5230\u53e6\u4e00\u4e2a\u4f20\u9001\u95e8\u5904\u3002\u6570\u636e\u4fdd\u8bc1\u8fdb\u884c\u8be5\u64cd\u4f5c\u65f6\uff0c (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u5f53\u524d\u4e0d\u5b58\u5728\u4f20\u9001\u95e8\u3002 - x' x' x'' x'' y y : \u79fb\u9664 (x', y) (x', y) \u4e0e (x'', y) (x'', y) \u5904\u7684\u4e00\u5bf9\u4f20\u9001\u95e8\u3002\u6570\u636e\u4fdd\u8bc1\u8fd9\u5bf9\u4f20\u9001\u95e8\u5b58\u5728\u3002 \u6c42\u6bcf\u6b21\u4fee\u6539\u540e \\sum\\limits_{x=1}^n xf(x) \\sum\\limits_{x=1}^n xf(x) \u7684\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 n n \u4e0e q q ( 2 \\le n \\le 10^5 2 \\le n \\le 10^5 , 1 \\le q \\le 10^5 1 \\le q \\le 10^5 )\uff0c\u4ee3\u8868\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u6570\u91cf\u4ee5\u53ca\u4fee\u6539\u7684\u6b21\u6570\u3002 \u63a5\u4e0b\u6765 q q \u884c\u4e2d\uff0c\u7b2c i i \u884c\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26 op_i op_i \u4ee5\u53ca\u4e09\u4e2a\u6574\u6570 x'_i x'_i , x''_i x''_i and y_i y_i ( op_i in {text{ +' (ascii: 43)}, \\text{ -' (ascii: 45)}}-' (ascii: 45)}} op_i in {text{<code>+' (ascii: 43)}, \\text{</code>-' (ascii: 45)}}-' (ascii: 45)}} , 1 \\le x'_i < x''_i \\le n 1 \\le x'_i < x''_i \\le n , 1 \\le y_i < 10^9 1 \\le y_i < 10^9 )\uff0c\u4ee3\u8868\u7b2c i i \u6b21\u4fee\u6539\u7684\u5185\u5bb9\u3002\u4fee\u6539\u987a\u5e8f\u4e0e\u8f93\u5165\u987a\u5e8f\u76f8\u540c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa q q \u884c\uff0c\u5176\u4e2d\u7b2c i i \u884c\u5305\u542b\u4e00\u4e2a\u6574\u6570\u4ee3\u8868\u7b2c i i \u6b21\u4fee\u6539\u540e\u7684\u7b54\u6848\u3002 \u8f93\u5165\u6837\u4f8b 5 4 + 1 3 1 + 1 4 3 + 2 5 2 - 1 4 3 \u8f93\u51fa\u6837\u4f8b 51 48 39 42 \u6837\u4f8b\u89e3\u91ca \u4fee\u6539 | f(1) f(1) | f(2) f(2) | f(3) f(3) | f(4) f(4) | f(5) f(5) | \u7ed3\u679c \u2014 | \u2014 + 1 3 1 | 3 | 2 | 1 | 4 | 5 | 51 + 1 4 3 | 3 | 2 | 4 | 1 | 5 | 48 + 2 5 2 | 3 | 5 | 4 | 1 | 2 | 39 - 1 4 3 | 3 | 5 | 1 | 4 | 2 | 42","title":"Statement"},{"location":"CCCC/L3-027-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/","text":"L3-027 \u53ef\u601c\u7684\u590d\u6742\u5ea6 Statement Metadata \u4f5c\u8005: \u5409\u5982\u4e00 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 8000 ms \u5185\u5b58\u9650\u5236: 256 MB \u53ef\u601c\u6709\u4e00\u4e2a\u6570\u7ec4 A A \uff0c\u5b9a\u4e49\u5b83\u7684\u590d\u6742\u5ea6 c(A) c(A) \u7b49\u4e8e\u5b83\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4\u4e2a\u6570\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c c([1,1,1]) = 3 c([1,1,1]) = 3 \uff0c\u56e0\u4e3a [1,1,1] [1,1,1] \u53ea\u6709 3 3 \u4e2a\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4 [1] [1] \u3001 [1,1] [1,1] \u548c [1,1,1] [1,1,1] \uff1b\u800c c([1,2,1]) = 5 c([1,2,1]) = 5 \uff0c\u5b83\u5305\u542b 5 5 \u4e2a\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4 [1] [1] \u3001 [2] [2] \u3001 [1,2] [1,2] \u3001 [2,1] [2,1] \u3001 [1,2,1] [1,2,1] \u3002 \u53ef\u601c\u6253\u7b97\u51fa\u4e00\u9053\u548c\u590d\u6742\u5ea6\u76f8\u5173\u7684\u9898\u76ee\u3002\u4f17\u6240\u5468\u77e5\uff0c\u5f15\u5165\u968f\u673a\u6027\u5f80\u5f80\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u7b80\u5355\u7684\u9898\u76ee\u8131\u80ce\u6362\u9aa8\u3002\u73b0\u5728\uff0c\u53ef\u601c\u624b\u4e0a\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u6b63\u6574\u6570\u6570\u7ec4 x x \u548c\u4e00\u4e2a\u6b63\u6574\u6570 m m \u3002\u63a5\u7740\uff0c\u53ef\u601c\u4f1a\u72ec\u7acb\u5730\u968f\u673a\u4ea7\u751f n n \u4e2a [1,m] [1,m] \u4e2d\u7684\u968f\u673a\u6574\u6570 y_i y_i \uff0c\u5e76\u628a x_i x_i \u4fee\u6539\u4e3a mx_i+y_i mx_i+y_i \u3002 \u663e\u7136\uff0c\u4e00\u5171\u6709 N=m^n N=m^n \u79cd\u53ef\u80fd\u7684\u7ed3\u679c\u6570\u7ec4\u3002\u73b0\u5728\uff0c\u53ef\u601c\u60f3\u8ba9\u4f60\u6c42\u51fa\u8fd9 N N \u4e2a\u6570\u7ec4\u7684\u590d\u6742\u5ea6\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 t t ( 1 \\le t \\le 5 1 \\le t \\le 5 ) \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u7b2c\u4e00\u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 n n \u548c m m ( 1 \\le n \\le 100, 1 \\le m \\le 10^9 1 \\le n \\le 100, 1 \\le m \\le 10^9 )\uff0c\u7b2c\u4e8c\u884c\u662f n n \u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570\u8868\u793a\u6570\u7ec4 x x \u7684\u521d\u59cb\u503c ( 1 \\le x_i \\le 10^9 1 \\le x_i \\le 10^9 )\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002\u7b54\u6848\u53ef\u80fd\u5f88\u5927\uff0c\u4f60\u53ea\u9700\u8981\u8f93\u51fa\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 4 3 2 1 1 1 3 2 1 2 1 5 2 1 2 1 2 1 10 2 80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045 \u8f93\u51fa\u6837\u4f8b 36 44 404 44616","title":"L3-027-\u53ef\u601c\u7684\u590d\u6742\u5ea6"},{"location":"CCCC/L3-027-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/#l3-027-\u53ef\u601c\u7684\u590d\u6742\u5ea6","text":"","title":"L3-027 \u53ef\u601c\u7684\u590d\u6742\u5ea6"},{"location":"CCCC/L3-027-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/#statement","text":"Metadata \u4f5c\u8005: \u5409\u5982\u4e00 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 8000 ms \u5185\u5b58\u9650\u5236: 256 MB \u53ef\u601c\u6709\u4e00\u4e2a\u6570\u7ec4 A A \uff0c\u5b9a\u4e49\u5b83\u7684\u590d\u6742\u5ea6 c(A) c(A) \u7b49\u4e8e\u5b83\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4\u4e2a\u6570\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c c([1,1,1]) = 3 c([1,1,1]) = 3 \uff0c\u56e0\u4e3a [1,1,1] [1,1,1] \u53ea\u6709 3 3 \u4e2a\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4 [1] [1] \u3001 [1,1] [1,1] \u548c [1,1,1] [1,1,1] \uff1b\u800c c([1,2,1]) = 5 c([1,2,1]) = 5 \uff0c\u5b83\u5305\u542b 5 5 \u4e2a\u672c\u8d28\u4e0d\u540c\u7684\u5b50\u533a\u95f4 [1] [1] \u3001 [2] [2] \u3001 [1,2] [1,2] \u3001 [2,1] [2,1] \u3001 [1,2,1] [1,2,1] \u3002 \u53ef\u601c\u6253\u7b97\u51fa\u4e00\u9053\u548c\u590d\u6742\u5ea6\u76f8\u5173\u7684\u9898\u76ee\u3002\u4f17\u6240\u5468\u77e5\uff0c\u5f15\u5165\u968f\u673a\u6027\u5f80\u5f80\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u7b80\u5355\u7684\u9898\u76ee\u8131\u80ce\u6362\u9aa8\u3002\u73b0\u5728\uff0c\u53ef\u601c\u624b\u4e0a\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u6b63\u6574\u6570\u6570\u7ec4 x x \u548c\u4e00\u4e2a\u6b63\u6574\u6570 m m \u3002\u63a5\u7740\uff0c\u53ef\u601c\u4f1a\u72ec\u7acb\u5730\u968f\u673a\u4ea7\u751f n n \u4e2a [1,m] [1,m] \u4e2d\u7684\u968f\u673a\u6574\u6570 y_i y_i \uff0c\u5e76\u628a x_i x_i \u4fee\u6539\u4e3a mx_i+y_i mx_i+y_i \u3002 \u663e\u7136\uff0c\u4e00\u5171\u6709 N=m^n N=m^n \u79cd\u53ef\u80fd\u7684\u7ed3\u679c\u6570\u7ec4\u3002\u73b0\u5728\uff0c\u53ef\u601c\u60f3\u8ba9\u4f60\u6c42\u51fa\u8fd9 N N \u4e2a\u6570\u7ec4\u7684\u590d\u6742\u5ea6\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6574\u6570 t t ( 1 \\le t \\le 5 1 \\le t \\le 5 ) \u8868\u793a\u6570\u636e\u7ec4\u6570\u3002 \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u7b2c\u4e00\u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 n n \u548c m m ( 1 \\le n \\le 100, 1 \\le m \\le 10^9 1 \\le n \\le 100, 1 \\le m \\le 10^9 )\uff0c\u7b2c\u4e8c\u884c\u662f n n \u4e2a\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570\u8868\u793a\u6570\u7ec4 x x \u7684\u521d\u59cb\u503c ( 1 \\le x_i \\le 10^9 1 \\le x_i \\le 10^9 )\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u4e8e\u6bcf\u7ec4\u6570\u636e\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002\u7b54\u6848\u53ef\u80fd\u5f88\u5927\uff0c\u4f60\u53ea\u9700\u8981\u8f93\u51fa\u5bf9 998244353 998244353 \u53d6\u6a21\u540e\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 4 3 2 1 1 1 3 2 1 2 1 5 2 1 2 1 2 1 10 2 80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045 \u8f93\u51fa\u6837\u4f8b 36 44 404 44616","title":"Statement"},{"location":"CCCC/L3-028-%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8/","text":"L3-028 \u68ee\u68ee\u65c5\u6e38 Statement Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 128 MB \u597d\u4e45\u6ca1\u51fa\u53bb\u65c5\u6e38\u5566\uff01\u68ee\u68ee\u51b3\u5b9a\u53bb Z \u7701\u65c5\u6e38\u4e00\u4e0b\u3002 Z \u7701\u6709 n n \u5ea7\u57ce\u5e02\uff08\u4ece 1 1 \u5230 n n \u7f16\u53f7\uff09\u4ee5\u53ca m m \u6761\u8fde\u63a5\u4e24\u5ea7\u57ce\u5e02\u7684\u6709\u5411\u65c5\u884c\u7ebf\u8def\uff08\u4f8b\u5982\u81ea\u9a7e\u3001\u957f\u9014\u6c7d\u8f66\u3001\u706b\u8f66\u3001\u98de\u673a\u3001\u8f6e\u8239\u7b49\uff09\uff0c\u6bcf\u6b21\u7ecf\u8fc7\u4e00\u6761\u65c5\u884c\u7ebf\u8def\u65f6\u90fd\u9700\u8981\u652f\u4ed8\u8be5\u7ebf\u8def\u7684\u8d39\u7528\uff08\u4f46\u8fd9\u4e2a\u6536\u8d39\u6807\u51c6\u53ef\u80fd\u4e0d\u6b62\u4e00\u79cd\uff0c\u4f8b\u5982\u8f66\u7968\u8ddf\u673a\u7968\u4e00\u822c\u4e0d\u662f\u4e00\u4e2a\u4ef7\u683c\uff09\u3002 Z \u7701\u4e3a\u4e86\u9f13\u52b1\u5927\u5bb6\u5728\u7701\u5185\u591a\u901b\u901b\uff0c\u63a8\u51fa\u4e86 \u65c5\u6e38\u91d1\u8ba1\u5212 \uff1a\u5728 i i \u53f7\u57ce\u5e02\u53ef\u4ee5\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a_i a_i \u5143\u65c5\u6e38\u91d1\uff08\u53ea\u8981\u73b0\u91d1\u8db3\u591f\uff0c\u53ef\u4ee5\u65e0\u9650\u6b21\u5151\u6362\uff09\u3002\u57ce\u5e02\u95f4\u7684\u4ea4\u901a\u5373\u53ef\u4ee5\u4f7f\u7528\u73b0\u91d1\u652f\u4ed8\u8def\u8d39\uff0c\u4e5f\u53ef\u4ee5\u7528\u65c5\u6e38\u91d1\u652f\u4ed8\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5f53\u901a\u8fc7\u7b2c j j \u6761\u65c5\u884c\u7ebf\u8def\u65f6\uff0c\u53ef\u4ee5\u7528 c_j c_j \u5143\u73b0\u91d1 \u6216 d_j d_j \u5143\u65c5\u6e38\u91d1\u652f\u4ed8\u8def\u8d39\u3002 \u6ce8\u610f\uff1a \u6bcf\u6b21\u53ea\u80fd\u9009\u62e9\u4e00\u79cd\u652f\u4ed8\u65b9\u5f0f\uff0c\u4e0d\u53ef\u540c\u65f6\u4f7f\u7528\u73b0\u91d1\u548c\u65c5\u6e38\u91d1\u6df7\u5408\u652f\u4ed8\u3002\u4f46\u5bf9\u4e8e\u4e0d\u540c\u7684\u7ebf\u8def\uff0c\u65c5\u5ba2\u53ef\u4ee5\u81ea\u7531\u9009\u62e9\u4e0d\u540c\u7684\u652f\u4ed8\u65b9\u5f0f\u3002 \u68ee\u68ee\u51b3\u5b9a\u4ece 1 1 \u53f7\u57ce\u5e02\u51fa\u53d1\uff0c\u5230 n n \u53f7\u57ce\u5e02\u53bb\u3002\u4ed6\u6253\u7b97\u5728\u51fa\u53d1\u524d\u51c6\u5907\u4e00\u4e9b\u73b0\u91d1\uff0c\u5e76\u5728\u9014\u4e2d\u7684\u67d0\u4e2a\u57ce\u5e02\u5c06\u5269\u4f59\u73b0\u91d1 \u5168\u90e8 \u6362\u6210\u65c5\u6e38\u91d1\u540e\u7ee7\u7eed\u65c5\u6e38\uff0c\u76f4\u5230\u5230\u8fbe n n \u53f7\u57ce\u5e02\u4e3a\u6b62\u3002\u5f53\u7136\uff0c\u4ed6\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728 1 1 \u53f7\u57ce\u5e02\u5c31\u5151\u6362\u65c5\u6e38\u91d1\uff0c\u6216\u5168\u90e8\u4f7f\u7528\u73b0\u91d1\u5b8c\u6210\u65c5\u7a0b\u3002 Z \u7701\u653f\u5e9c\u4f1a\u6839\u636e\u6bcf\u4e2a\u57ce\u5e02\u53c2\u4e0e\u6d3b\u52a8\u7684\u60c5\u51b5\u8c03\u6574\u6c47\u7387\uff08\u5373\u8c03\u6574\u5728\u67d0\u4e2a\u57ce\u5e02 1 1 \u5143\u73b0\u91d1\u80fd\u6362\u591a\u5c11\u65c5\u6e38\u91d1\uff09\u3002\u73b0\u5728\u4f60\u9700\u8981\u5e2e\u52a9\u68ee\u68ee\u8ba1\u7b97\u4e00\u4e0b\uff0c\u5728\u6bcf\u6b21\u8c03\u6574\u4e4b\u540e\u6700\u5c11\u9700\u8981\u643a\u5e26\u591a\u5c11\u73b0\u91d1\u624d\u80fd\u5b8c\u6210\u4ed6\u7684\u65c5\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6574\u6570 n n \uff0c m m \u4e0e q q \uff08 1 \\le n \\le 10^5 1 \\le n \\le 10^5 \uff0c 1 \\le m \\le 2 \\times 10^5 1 \\le m \\le 2 \\times 10^5 \uff0c 1 \\le q \\le 10^5 1 \\le q \\le 10^5 \uff09\uff0c\u4f9d\u6b21\u8868\u793a\u57ce\u5e02\u7684\u6570\u91cf\u3001\u65c5\u884c\u7ebf\u8def\u7684\u6570\u91cf\u4ee5\u53ca\u6c47\u7387\u8c03\u6574\u7684\u6b21\u6570\u3002 \u63a5\u4e0b\u6765 m m \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u56db\u4e2a\u6574\u6570 u u \uff0c v v \uff0c c c \u4e0e d d \uff08 1 \\le u, v \\le n 1 \\le u, v \\le n \uff0c 1 \\le c, d \\le 10^9 1 \\le c, d \\le 10^9 \uff09\uff0c\u8868\u793a\u4e00\u6761\u4ece u u \u53f7\u57ce\u5e02\u901a\u5411 v v \u53f7\u57ce\u5e02\u7684\u6709\u5411\u65c5\u884c\u7ebf\u8def\u3002\u6bcf\u6b21\u901a\u8fc7\u8be5\u7ebf\u8def\u9700\u8981\u652f\u4ed8 c c \u5143\u73b0\u91d1\u6216 d d \u5143\u65c5\u6e38\u91d1\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u8f93\u5165\u4fdd\u8bc1\u4ece 1 1 \u53f7\u57ce\u5e02\u51fa\u53d1\uff0c\u4e00\u5b9a\u53ef\u4ee5\u901a\u8fc7\u82e5\u5e72\u6761\u7ebf\u8def\u5230\u8fbe n n \u53f7\u57ce\u5e02\uff0c\u4f46\u4e24\u57ce\u5e02\u95f4\u7684\u65c5\u884c\u7ebf\u8def\u53ef\u80fd\u4e0d\u6b62\u4e00\u6761\uff0c\u5bf9\u5e94\u4e0d\u540c\u7684\u6536\u8d39\u6807\u51c6\uff1b\u4e5f\u5141\u8bb8\u5728\u57ce\u5e02\u5185\u90e8\u6e38\u73a9\uff08\u5373 u u \u548c v v \u76f8\u540c\uff09\u3002 \u63a5\u4e0b\u6765\u7684\u4e00\u884c\u8f93\u5165 n n \u4e2a\u6574\u6570 a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n \uff08 1 \\le a_i \\le 10^9 1 \\le a_i \\le 10^9 \uff09\uff0c\u5176\u4e2d a_i a_i \u8868\u793a\u4e00\u5f00\u59cb\u5728 i i \u53f7\u57ce\u5e02\u80fd\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a_i a_i \u4e2a\u65c5\u6e38\u91d1\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u63a5\u4e0b\u6765 q q \u884c\u63cf\u8ff0\u6c47\u7387\u7684\u8c03\u6574\u3002\u7b2c i i \u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 x_i x_i \u4e0e a'_i a'_i \uff08 1 \\le x_i \\le n 1 \\le x_i \\le n \uff0c 1 \\le a'_i \\le 10^9 1 \\le a'_i \\le 10^9 \uff09\uff0c\u8868\u793a\u7b2c i i \u6b21\u6c47\u7387\u8c03\u6574\u540e\uff0c x_i x_i \u53f7\u57ce\u5e02\u80fd\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a'_i a'_i \u4e2a\u65c5\u6e38\u91d1\uff0c\u800c\u5176\u5b83\u57ce\u5e02\u65c5\u6e38\u91d1\u6c47\u7387\u4e0d\u53d8\u3002 \u8bf7\u6ce8\u610f\uff1a \u6bcf\u6b21\u6c47\u7387\u8c03\u6574\u90fd\u662f\u5728\u4e0a\u4e00\u6b21\u6c47\u7387\u8c03\u6574\u7684\u57fa\u7840\u4e0a\u8fdb\u884c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u5728\u5bf9\u5e94\u7684\u4e00\u884c\u4e2d\u8f93\u51fa\u8c03\u6574\u540e\u68ee\u68ee\u81f3\u5c11\u9700\u8981\u51c6\u5907\u591a\u5c11\u73b0\u91d1\uff0c\u624d\u80fd\u6309\u4ed6\u7684\u8ba1\u5212\u4ece 1 1 \u53f7\u57ce\u5e02\u65c5\u884c\u5230 n n \u53f7\u57ce\u5e02\u3002 \u518d\u6b21\u63d0\u9192\uff1a \u5982\u679c\u68ee\u68ee\u51b3\u5b9a\u5728\u9014\u4e2d\u7684\u67d0\u4e2a\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff0c\u90a3\u4e48\u4ed6\u5fc5\u987b\u5c06\u5269\u4f59\u73b0\u91d1 \u5168\u90e8\u3001\u4e00\u6b21\u6027 \u5151\u6362\uff0c\u5269\u4e0b\u7684\u65c5\u9014\u5c06\u5b8c\u5168\u4f7f\u7528\u65c5\u6e38\u91d1\u652f\u4ed8\u3002 \u8f93\u5165\u6837\u4f8b 6 11 3 1 2 3 5 1 3 8 4 2 4 4 6 3 1 8 6 1 3 10 8 2 3 2 8 3 4 5 3 3 5 10 7 3 3 2 3 4 6 10 12 5 6 10 6 3 4 5 2 5 100 1 2 2 1 1 17 \u8f93\u51fa\u6837\u4f8b 8 8 1 \u6837\u4f8b\u89e3\u91ca \u5bf9\u4e8e\u7b2c\u4e00\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 2 \\to 4 \\to 6 1 \\to 2 \\to 4 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 2 2 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff1b \u5bf9\u4e8e\u7b2c\u4e8c\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 2 \\to 3 \\to 4 \\to 6 1 \\to 2 \\to 3 \\to 4 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 3 3 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff1b \u5bf9\u4e8e\u7b2c\u4e09\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 3 \\to 5 \\to 6 1 \\to 3 \\to 5 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 1 1 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\u3002","title":"L3-028-\u68ee\u68ee\u65c5\u6e38"},{"location":"CCCC/L3-028-%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8/#l3-028-\u68ee\u68ee\u65c5\u6e38","text":"","title":"L3-028 \u68ee\u68ee\u65c5\u6e38"},{"location":"CCCC/L3-028-%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8/#statement","text":"Metadata \u4f5c\u8005: DAI, Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 128 MB \u597d\u4e45\u6ca1\u51fa\u53bb\u65c5\u6e38\u5566\uff01\u68ee\u68ee\u51b3\u5b9a\u53bb Z \u7701\u65c5\u6e38\u4e00\u4e0b\u3002 Z \u7701\u6709 n n \u5ea7\u57ce\u5e02\uff08\u4ece 1 1 \u5230 n n \u7f16\u53f7\uff09\u4ee5\u53ca m m \u6761\u8fde\u63a5\u4e24\u5ea7\u57ce\u5e02\u7684\u6709\u5411\u65c5\u884c\u7ebf\u8def\uff08\u4f8b\u5982\u81ea\u9a7e\u3001\u957f\u9014\u6c7d\u8f66\u3001\u706b\u8f66\u3001\u98de\u673a\u3001\u8f6e\u8239\u7b49\uff09\uff0c\u6bcf\u6b21\u7ecf\u8fc7\u4e00\u6761\u65c5\u884c\u7ebf\u8def\u65f6\u90fd\u9700\u8981\u652f\u4ed8\u8be5\u7ebf\u8def\u7684\u8d39\u7528\uff08\u4f46\u8fd9\u4e2a\u6536\u8d39\u6807\u51c6\u53ef\u80fd\u4e0d\u6b62\u4e00\u79cd\uff0c\u4f8b\u5982\u8f66\u7968\u8ddf\u673a\u7968\u4e00\u822c\u4e0d\u662f\u4e00\u4e2a\u4ef7\u683c\uff09\u3002 Z \u7701\u4e3a\u4e86\u9f13\u52b1\u5927\u5bb6\u5728\u7701\u5185\u591a\u901b\u901b\uff0c\u63a8\u51fa\u4e86 \u65c5\u6e38\u91d1\u8ba1\u5212 \uff1a\u5728 i i \u53f7\u57ce\u5e02\u53ef\u4ee5\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a_i a_i \u5143\u65c5\u6e38\u91d1\uff08\u53ea\u8981\u73b0\u91d1\u8db3\u591f\uff0c\u53ef\u4ee5\u65e0\u9650\u6b21\u5151\u6362\uff09\u3002\u57ce\u5e02\u95f4\u7684\u4ea4\u901a\u5373\u53ef\u4ee5\u4f7f\u7528\u73b0\u91d1\u652f\u4ed8\u8def\u8d39\uff0c\u4e5f\u53ef\u4ee5\u7528\u65c5\u6e38\u91d1\u652f\u4ed8\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5f53\u901a\u8fc7\u7b2c j j \u6761\u65c5\u884c\u7ebf\u8def\u65f6\uff0c\u53ef\u4ee5\u7528 c_j c_j \u5143\u73b0\u91d1 \u6216 d_j d_j \u5143\u65c5\u6e38\u91d1\u652f\u4ed8\u8def\u8d39\u3002 \u6ce8\u610f\uff1a \u6bcf\u6b21\u53ea\u80fd\u9009\u62e9\u4e00\u79cd\u652f\u4ed8\u65b9\u5f0f\uff0c\u4e0d\u53ef\u540c\u65f6\u4f7f\u7528\u73b0\u91d1\u548c\u65c5\u6e38\u91d1\u6df7\u5408\u652f\u4ed8\u3002\u4f46\u5bf9\u4e8e\u4e0d\u540c\u7684\u7ebf\u8def\uff0c\u65c5\u5ba2\u53ef\u4ee5\u81ea\u7531\u9009\u62e9\u4e0d\u540c\u7684\u652f\u4ed8\u65b9\u5f0f\u3002 \u68ee\u68ee\u51b3\u5b9a\u4ece 1 1 \u53f7\u57ce\u5e02\u51fa\u53d1\uff0c\u5230 n n \u53f7\u57ce\u5e02\u53bb\u3002\u4ed6\u6253\u7b97\u5728\u51fa\u53d1\u524d\u51c6\u5907\u4e00\u4e9b\u73b0\u91d1\uff0c\u5e76\u5728\u9014\u4e2d\u7684\u67d0\u4e2a\u57ce\u5e02\u5c06\u5269\u4f59\u73b0\u91d1 \u5168\u90e8 \u6362\u6210\u65c5\u6e38\u91d1\u540e\u7ee7\u7eed\u65c5\u6e38\uff0c\u76f4\u5230\u5230\u8fbe n n \u53f7\u57ce\u5e02\u4e3a\u6b62\u3002\u5f53\u7136\uff0c\u4ed6\u4e5f\u53ef\u4ee5\u9009\u62e9\u5728 1 1 \u53f7\u57ce\u5e02\u5c31\u5151\u6362\u65c5\u6e38\u91d1\uff0c\u6216\u5168\u90e8\u4f7f\u7528\u73b0\u91d1\u5b8c\u6210\u65c5\u7a0b\u3002 Z \u7701\u653f\u5e9c\u4f1a\u6839\u636e\u6bcf\u4e2a\u57ce\u5e02\u53c2\u4e0e\u6d3b\u52a8\u7684\u60c5\u51b5\u8c03\u6574\u6c47\u7387\uff08\u5373\u8c03\u6574\u5728\u67d0\u4e2a\u57ce\u5e02 1 1 \u5143\u73b0\u91d1\u80fd\u6362\u591a\u5c11\u65c5\u6e38\u91d1\uff09\u3002\u73b0\u5728\u4f60\u9700\u8981\u5e2e\u52a9\u68ee\u68ee\u8ba1\u7b97\u4e00\u4e0b\uff0c\u5728\u6bcf\u6b21\u8c03\u6574\u4e4b\u540e\u6700\u5c11\u9700\u8981\u643a\u5e26\u591a\u5c11\u73b0\u91d1\u624d\u80fd\u5b8c\u6210\u4ed6\u7684\u65c5\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6574\u6570 n n \uff0c m m \u4e0e q q \uff08 1 \\le n \\le 10^5 1 \\le n \\le 10^5 \uff0c 1 \\le m \\le 2 \\times 10^5 1 \\le m \\le 2 \\times 10^5 \uff0c 1 \\le q \\le 10^5 1 \\le q \\le 10^5 \uff09\uff0c\u4f9d\u6b21\u8868\u793a\u57ce\u5e02\u7684\u6570\u91cf\u3001\u65c5\u884c\u7ebf\u8def\u7684\u6570\u91cf\u4ee5\u53ca\u6c47\u7387\u8c03\u6574\u7684\u6b21\u6570\u3002 \u63a5\u4e0b\u6765 m m \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u56db\u4e2a\u6574\u6570 u u \uff0c v v \uff0c c c \u4e0e d d \uff08 1 \\le u, v \\le n 1 \\le u, v \\le n \uff0c 1 \\le c, d \\le 10^9 1 \\le c, d \\le 10^9 \uff09\uff0c\u8868\u793a\u4e00\u6761\u4ece u u \u53f7\u57ce\u5e02\u901a\u5411 v v \u53f7\u57ce\u5e02\u7684\u6709\u5411\u65c5\u884c\u7ebf\u8def\u3002\u6bcf\u6b21\u901a\u8fc7\u8be5\u7ebf\u8def\u9700\u8981\u652f\u4ed8 c c \u5143\u73b0\u91d1\u6216 d d \u5143\u65c5\u6e38\u91d1\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u8f93\u5165\u4fdd\u8bc1\u4ece 1 1 \u53f7\u57ce\u5e02\u51fa\u53d1\uff0c\u4e00\u5b9a\u53ef\u4ee5\u901a\u8fc7\u82e5\u5e72\u6761\u7ebf\u8def\u5230\u8fbe n n \u53f7\u57ce\u5e02\uff0c\u4f46\u4e24\u57ce\u5e02\u95f4\u7684\u65c5\u884c\u7ebf\u8def\u53ef\u80fd\u4e0d\u6b62\u4e00\u6761\uff0c\u5bf9\u5e94\u4e0d\u540c\u7684\u6536\u8d39\u6807\u51c6\uff1b\u4e5f\u5141\u8bb8\u5728\u57ce\u5e02\u5185\u90e8\u6e38\u73a9\uff08\u5373 u u \u548c v v \u76f8\u540c\uff09\u3002 \u63a5\u4e0b\u6765\u7684\u4e00\u884c\u8f93\u5165 n n \u4e2a\u6574\u6570 a_1, a_2, \\cdots, a_n a_1, a_2, \\cdots, a_n \uff08 1 \\le a_i \\le 10^9 1 \\le a_i \\le 10^9 \uff09\uff0c\u5176\u4e2d a_i a_i \u8868\u793a\u4e00\u5f00\u59cb\u5728 i i \u53f7\u57ce\u5e02\u80fd\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a_i a_i \u4e2a\u65c5\u6e38\u91d1\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u63a5\u4e0b\u6765 q q \u884c\u63cf\u8ff0\u6c47\u7387\u7684\u8c03\u6574\u3002\u7b2c i i \u884c\u8f93\u5165\u4e24\u4e2a\u6574\u6570 x_i x_i \u4e0e a'_i a'_i \uff08 1 \\le x_i \\le n 1 \\le x_i \\le n \uff0c 1 \\le a'_i \\le 10^9 1 \\le a'_i \\le 10^9 \uff09\uff0c\u8868\u793a\u7b2c i i \u6b21\u6c47\u7387\u8c03\u6574\u540e\uff0c x_i x_i \u53f7\u57ce\u5e02\u80fd\u7528 1 1 \u5143\u73b0\u91d1\u5151\u6362 a'_i a'_i \u4e2a\u65c5\u6e38\u91d1\uff0c\u800c\u5176\u5b83\u57ce\u5e02\u65c5\u6e38\u91d1\u6c47\u7387\u4e0d\u53d8\u3002 \u8bf7\u6ce8\u610f\uff1a \u6bcf\u6b21\u6c47\u7387\u8c03\u6574\u90fd\u662f\u5728\u4e0a\u4e00\u6b21\u6c47\u7387\u8c03\u6574\u7684\u57fa\u7840\u4e0a\u8fdb\u884c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u5728\u5bf9\u5e94\u7684\u4e00\u884c\u4e2d\u8f93\u51fa\u8c03\u6574\u540e\u68ee\u68ee\u81f3\u5c11\u9700\u8981\u51c6\u5907\u591a\u5c11\u73b0\u91d1\uff0c\u624d\u80fd\u6309\u4ed6\u7684\u8ba1\u5212\u4ece 1 1 \u53f7\u57ce\u5e02\u65c5\u884c\u5230 n n \u53f7\u57ce\u5e02\u3002 \u518d\u6b21\u63d0\u9192\uff1a \u5982\u679c\u68ee\u68ee\u51b3\u5b9a\u5728\u9014\u4e2d\u7684\u67d0\u4e2a\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff0c\u90a3\u4e48\u4ed6\u5fc5\u987b\u5c06\u5269\u4f59\u73b0\u91d1 \u5168\u90e8\u3001\u4e00\u6b21\u6027 \u5151\u6362\uff0c\u5269\u4e0b\u7684\u65c5\u9014\u5c06\u5b8c\u5168\u4f7f\u7528\u65c5\u6e38\u91d1\u652f\u4ed8\u3002 \u8f93\u5165\u6837\u4f8b 6 11 3 1 2 3 5 1 3 8 4 2 4 4 6 3 1 8 6 1 3 10 8 2 3 2 8 3 4 5 3 3 5 10 7 3 3 2 3 4 6 10 12 5 6 10 6 3 4 5 2 5 100 1 2 2 1 1 17 \u8f93\u51fa\u6837\u4f8b 8 8 1 \u6837\u4f8b\u89e3\u91ca \u5bf9\u4e8e\u7b2c\u4e00\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 2 \\to 4 \\to 6 1 \\to 2 \\to 4 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 2 2 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff1b \u5bf9\u4e8e\u7b2c\u4e8c\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 2 \\to 3 \\to 4 \\to 6 1 \\to 2 \\to 3 \\to 4 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 3 3 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\uff1b \u5bf9\u4e8e\u7b2c\u4e09\u6b21\u6c47\u7387\u8c03\u6574\uff0c\u68ee\u68ee\u53ef\u4ee5\u6cbf\u7740 1 \\to 3 \\to 5 \\to 6 1 \\to 3 \\to 5 \\to 6 \u7684\u7ebf\u8def\u65c5\u884c\uff0c\u5e76\u5728 1 1 \u53f7\u57ce\u5e02\u5151\u6362\u65c5\u6e38\u91d1\u3002","title":"Statement"},{"location":"CCCC/L3-029-%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6/","text":"L3-029 \u8fd8\u539f\u6587\u4ef6 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4efd\u91cd\u8981\u6587\u4ef6\u88ab\u6495\u6210\u4e24\u534a\uff0c\u5176\u4e2d\u4e00\u534a\u8fd8\u88ab\u9001\u8fdb\u4e86\u788e\u7eb8\u673a\u3002\u6211\u4eec\u5c06\u788e\u7eb8\u673a\u91cc\u627e\u5230\u7684\u7eb8\u6761\u8fdb\u884c\u7f16\u53f7\uff0c\u5982\u56fe 1 \u6240\u793a\u3002\u7136\u540e\u6839\u636e\u65ad\u53e3\u7684\u6298\u7ebf\u5f62\u72b6\u8ddf\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u8fdb\u884c\u5339\u914d\uff0c\u6700\u540e\u8fd8\u539f\u6210\u56fe 2 \u7684\u6837\u5b50\u3002\u8981\u6c42\u4f60\u8f93\u51fa\u8fd8\u539f\u540e\u7eb8\u6761\u7684\u6b63\u786e\u62fc\u63a5\u987a\u5e8f\u3002 \u56fe1 \u7eb8\u6761\u7f16\u53f7 \u56fe2 \u8fd8\u539f\u7ed3\u679c \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^5 1 < N \\le 10^5 \uff09\uff0c\u4e3a\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u4e0a\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u4e2a\u6570\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u4ece\u5de6\u5230\u53f3 N N \u4e2a\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u503c\uff08\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u7684\u975e\u8d1f\u6574\u6570\uff09\u3002 \u968f\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u4e3a\u788e\u7eb8\u673a\u91cc\u7684\u7eb8\u6761\u6570\u91cf\u3002\u63a5\u4e0b\u53bb\u6709 M M \u884c\uff0c\u5176\u4e2d\u7b2c i i \u884c\u7ed9\u51fa\u7f16\u53f7\u4e3a i i \uff08 1\\le i \\le M 1\\le i \\le M \uff09\u7684\u7eb8\u6761\u7684\u65ad\u53e3\u4fe1\u606f\uff0c\u683c\u5f0f\u4e3a\uff1a K h[1] h[2] ... h[K] \u5176\u4e2d K \u662f\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7 10^4 +1 10^4 +1 \uff09\uff0c\u540e\u9762\u662f\u4ece\u5de6\u5230\u53f3 K \u4e2a\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u503c\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u8fd9\u4e2a\u201c\u9ad8\u5ea6\u201d\u8ddf\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u4e0a\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u662f\u4e00\u81f4\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd8\u539f\u540e\u7eb8\u6761\u7684\u6b63\u786e\u62fc\u63a5\u987a\u5e8f\u3002\u7eb8\u6761\u7f16\u53f7\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u9898\u76ee\u6570\u636e\u4fdd\u8bc1\u5b58\u5728\u552f\u4e00\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 17 95 70 80 97 97 68 58 58 80 72 88 81 81 68 68 60 80 6 4 68 58 58 80 3 81 68 68 3 95 70 80 3 68 60 80 5 80 72 88 81 81 4 80 97 97 68 \u8f93\u51fa\u6837\u4f8b 3 6 1 5 2 4","title":"L3-029-\u8fd8\u539f\u6587\u4ef6"},{"location":"CCCC/L3-029-%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6/#l3-029-\u8fd8\u539f\u6587\u4ef6","text":"","title":"L3-029 \u8fd8\u539f\u6587\u4ef6"},{"location":"CCCC/L3-029-%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4efd\u91cd\u8981\u6587\u4ef6\u88ab\u6495\u6210\u4e24\u534a\uff0c\u5176\u4e2d\u4e00\u534a\u8fd8\u88ab\u9001\u8fdb\u4e86\u788e\u7eb8\u673a\u3002\u6211\u4eec\u5c06\u788e\u7eb8\u673a\u91cc\u627e\u5230\u7684\u7eb8\u6761\u8fdb\u884c\u7f16\u53f7\uff0c\u5982\u56fe 1 \u6240\u793a\u3002\u7136\u540e\u6839\u636e\u65ad\u53e3\u7684\u6298\u7ebf\u5f62\u72b6\u8ddf\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u8fdb\u884c\u5339\u914d\uff0c\u6700\u540e\u8fd8\u539f\u6210\u56fe 2 \u7684\u6837\u5b50\u3002\u8981\u6c42\u4f60\u8f93\u51fa\u8fd8\u539f\u540e\u7eb8\u6761\u7684\u6b63\u786e\u62fc\u63a5\u987a\u5e8f\u3002 \u56fe1 \u7eb8\u6761\u7f16\u53f7 \u56fe2 \u8fd8\u539f\u7ed3\u679c \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 1 < N \\le 10^5 1 < N \\le 10^5 \uff09\uff0c\u4e3a\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u4e0a\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u4e2a\u6570\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u4ece\u5de6\u5230\u53f3 N N \u4e2a\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u503c\uff08\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u7684\u975e\u8d1f\u6574\u6570\uff09\u3002 \u968f\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u4e3a\u788e\u7eb8\u673a\u91cc\u7684\u7eb8\u6761\u6570\u91cf\u3002\u63a5\u4e0b\u53bb\u6709 M M \u884c\uff0c\u5176\u4e2d\u7b2c i i \u884c\u7ed9\u51fa\u7f16\u53f7\u4e3a i i \uff08 1\\le i \\le M 1\\le i \\le M \uff09\u7684\u7eb8\u6761\u7684\u65ad\u53e3\u4fe1\u606f\uff0c\u683c\u5f0f\u4e3a\uff1a K h[1] h[2] ... h[K] \u5176\u4e2d K \u662f\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7 10^4 +1 10^4 +1 \uff09\uff0c\u540e\u9762\u662f\u4ece\u5de6\u5230\u53f3 K \u4e2a\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u503c\u3002\u4e3a\u7b80\u5355\u8d77\u89c1\uff0c\u8fd9\u4e2a\u201c\u9ad8\u5ea6\u201d\u8ddf\u6ca1\u6709\u5207\u788e\u7684\u534a\u5f20\u7eb8\u4e0a\u65ad\u53e3\u6298\u7ebf\u89d2\u70b9\u7684\u9ad8\u5ea6\u662f\u4e00\u81f4\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8fd8\u539f\u540e\u7eb8\u6761\u7684\u6b63\u786e\u62fc\u63a5\u987a\u5e8f\u3002\u7eb8\u6761\u7f16\u53f7\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u9898\u76ee\u6570\u636e\u4fdd\u8bc1\u5b58\u5728\u552f\u4e00\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 17 95 70 80 97 97 68 58 58 80 72 88 81 81 68 68 60 80 6 4 68 58 58 80 3 81 68 68 3 95 70 80 3 68 60 80 5 80 72 88 81 81 4 80 97 97 68 \u8f93\u51fa\u6837\u4f8b 3 6 1 5 2 4","title":"Statement"},{"location":"CCCC/L3-030-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/","text":"L3-030 \u53ef\u601c\u7684\u7b80\u5355\u9898 Statement Metadata \u4f5c\u8005: \u5409\u5982\u4e00 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 10000 ms \u5185\u5b58\u9650\u5236: 512 MB \u4e5d\u6761\u53ef\u601c\u53bb\u5e74\u51fa\u4e86\u4e00\u9053\u9898\uff0c\u5bfc\u81f4\u4e00\u4f17\u53c2\u8d5b\u9ad8\u624b\u60e8\u906d\u56e2\u706d\u3002\u4eca\u5e74\u5979\u51fa\u4e86\u4e00\u9053\u7b80\u5355\u9898 \u2014\u2014 \u6253\u7b97\u6309\u7167\u5982\u4e0b\u7684\u65b9\u5f0f\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684\u6574\u6570\u6570\u5217 A A : \u6700\u5f00\u59cb\uff0c\u6570\u5217 A A \u4e3a\u7a7a\u3002 \u53ef\u601c\u4f1a\u4ece\u533a\u95f4 [1,n] [1,n] \u4e2d\u7b49\u6982\u7387\u968f\u673a\u4e00\u4e2a\u6574\u6570 i i \u52a0\u5165\u5230\u6570\u5217 A A \u4e2d\u3002 \u5982\u679c\u4e0d\u5b58\u5728\u4e00\u4e2a\u5927\u4e8e 1 1 \u7684\u6b63\u6574\u6570 w w \uff0c\u6ee1\u8db3 A A \u4e2d\u6240\u6709\u5143\u7d20\u90fd\u662f w w \u7684\u500d\u6570\uff0c\u6570\u7ec4 A A \u5c06\u4f1a\u4f5c\u4e3a\u968f\u673a\u751f\u6210\u7684\u7ed3\u679c\u8fd4\u56de\u3002\u5426\u5219\uff0c\u53ef\u601c\u5c06\u4f1a\u8fd4\u56de\u7b2c\u4e8c\u6b65\uff0c\u7ee7\u7eed\u589e\u52a0 A A \u7684\u957f\u5ea6\u3002 \u73b0\u5728\uff0c\u53ef\u601c\u544a\u8bc9\u4e86\u4f60\u6570\u5217 n n \u7684\u503c\uff0c\u5979\u5e0c\u671b\u4f60\u8ba1\u7b97\u8fd4\u56de\u7684\u6570\u5217 A A \u7684\u671f\u671b\u957f\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 n, p n, p (1 \\le n \\le 10^{11}, n < p \\le 10^{12}) (1 \\le n \\le 10^{11}, n < p \\le 10^{12}) \uff0c p p \u662f\u4e00\u4e2a\u8d28\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u7b54\u6848\u5bf9 p p \u53d6\u6a21\u7684\u503c\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u7b54\u6848\u7684\u6700\u7b80\u5206\u6570\u8868\u793a\u4e3a \\frac{x}{y} \\frac{x}{y} \uff0c\u4f60\u9700\u8981\u8f93\u51fa\u6700\u5c0f\u7684\u975e\u8d1f\u6574\u6570 z z \u6ee1\u8db3 y \\times z \\equiv x \\text{ mod } p y \\times z \\equiv x \\text{ mod } p \u3002 \u8f93\u5165\u6837\u4f8b 1 2 998244353 \u8f93\u51fa\u6837\u4f8b 1 2 \u8f93\u5165\u6837\u4f8b 2 100000000 998244353 \u8f93\u51fa\u6837\u4f8b 2 3056898","title":"L3-030-\u53ef\u601c\u7684\u7b80\u5355\u9898"},{"location":"CCCC/L3-030-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/#l3-030-\u53ef\u601c\u7684\u7b80\u5355\u9898","text":"","title":"L3-030 \u53ef\u601c\u7684\u7b80\u5355\u9898"},{"location":"CCCC/L3-030-%E5%8F%AF%E6%80%9C%E7%9A%84%E7%AE%80%E5%8D%95%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: \u5409\u5982\u4e00 \u5355\u4f4d: \u5317\u4eac\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 10000 ms \u5185\u5b58\u9650\u5236: 512 MB \u4e5d\u6761\u53ef\u601c\u53bb\u5e74\u51fa\u4e86\u4e00\u9053\u9898\uff0c\u5bfc\u81f4\u4e00\u4f17\u53c2\u8d5b\u9ad8\u624b\u60e8\u906d\u56e2\u706d\u3002\u4eca\u5e74\u5979\u51fa\u4e86\u4e00\u9053\u7b80\u5355\u9898 \u2014\u2014 \u6253\u7b97\u6309\u7167\u5982\u4e0b\u7684\u65b9\u5f0f\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684\u6574\u6570\u6570\u5217 A A : \u6700\u5f00\u59cb\uff0c\u6570\u5217 A A \u4e3a\u7a7a\u3002 \u53ef\u601c\u4f1a\u4ece\u533a\u95f4 [1,n] [1,n] \u4e2d\u7b49\u6982\u7387\u968f\u673a\u4e00\u4e2a\u6574\u6570 i i \u52a0\u5165\u5230\u6570\u5217 A A \u4e2d\u3002 \u5982\u679c\u4e0d\u5b58\u5728\u4e00\u4e2a\u5927\u4e8e 1 1 \u7684\u6b63\u6574\u6570 w w \uff0c\u6ee1\u8db3 A A \u4e2d\u6240\u6709\u5143\u7d20\u90fd\u662f w w \u7684\u500d\u6570\uff0c\u6570\u7ec4 A A \u5c06\u4f1a\u4f5c\u4e3a\u968f\u673a\u751f\u6210\u7684\u7ed3\u679c\u8fd4\u56de\u3002\u5426\u5219\uff0c\u53ef\u601c\u5c06\u4f1a\u8fd4\u56de\u7b2c\u4e8c\u6b65\uff0c\u7ee7\u7eed\u589e\u52a0 A A \u7684\u957f\u5ea6\u3002 \u73b0\u5728\uff0c\u53ef\u601c\u544a\u8bc9\u4e86\u4f60\u6570\u5217 n n \u7684\u503c\uff0c\u5979\u5e0c\u671b\u4f60\u8ba1\u7b97\u8fd4\u56de\u7684\u6570\u5217 A A \u7684\u671f\u671b\u957f\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u4e00\u884c\u4e24\u4e2a\u6574\u6570 n, p n, p (1 \\le n \\le 10^{11}, n < p \\le 10^{12}) (1 \\le n \\le 10^{11}, n < p \\le 10^{12}) \uff0c p p \u662f\u4e00\u4e2a\u8d28\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u7b54\u6848\u5bf9 p p \u53d6\u6a21\u7684\u503c\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u7b54\u6848\u7684\u6700\u7b80\u5206\u6570\u8868\u793a\u4e3a \\frac{x}{y} \\frac{x}{y} \uff0c\u4f60\u9700\u8981\u8f93\u51fa\u6700\u5c0f\u7684\u975e\u8d1f\u6574\u6570 z z \u6ee1\u8db3 y \\times z \\equiv x \\text{ mod } p y \\times z \\equiv x \\text{ mod } p \u3002 \u8f93\u5165\u6837\u4f8b 1 2 998244353 \u8f93\u51fa\u6837\u4f8b 1 2 \u8f93\u5165\u6837\u4f8b 2 100000000 998244353 \u8f93\u51fa\u6837\u4f8b 2 3056898","title":"Statement"},{"location":"PAT-Advanced-Level/1001-A%2BB%20Format/","text":"1001 A+B Format Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Calculate a + b a + b and output the sum in standard format \u2013 that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification Each input file contains one test case. Each case contains a pair of integers a a and b b where -10^6 \\le a, b \\le 10^6 -10^6 \\le a, b \\le 10^6 . The numbers are separated by a space. Output Specification For each test case, you should output the sum of a a and b b in one line. The sum must be written in the standard format. Sample Input -1000000 9 Sample Output -999,991 Solution C++ #include <bits/stdc++.h> using namespace std ; void tran ( int x ) { string s1 = \"\" , s2 = \"\" ; int i , j , flag = 0 ; if ( x ) { if ( x < 0 ) flag = 1 , x *= -1 ; while ( x ) { s1 += x % 10 + '0' ; x /= 10 ; } int len1 = s1 . size (); if ( len1 >= 4 ) { for ( i = 0 ; i < len1 ; i ++ ) { if ( i % 3 == 0 && i ) s2 += \",\" ; s2 += s1 [ i ]; } } else s2 = s1 ; if ( flag ) cout << \"-\" ; int len2 = s2 . size (); for ( i = len2 - 1 ; i >= 0 ; i -- ) cout << s2 [ i ]; } else cout << \"0\" ; cout << \" \\n \" ; } int main () { int a , b ; cin >> a >> b ; a += b ; tran ( a ); }","title":"1001-A+B Format"},{"location":"PAT-Advanced-Level/1001-A%2BB%20Format/#1001-ab-format","text":"","title":"1001 A+B Format"},{"location":"PAT-Advanced-Level/1001-A%2BB%20Format/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Calculate a + b a + b and output the sum in standard format \u2013 that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification Each input file contains one test case. Each case contains a pair of integers a a and b b where -10^6 \\le a, b \\le 10^6 -10^6 \\le a, b \\le 10^6 . The numbers are separated by a space. Output Specification For each test case, you should output the sum of a a and b b in one line. The sum must be written in the standard format. Sample Input -1000000 9 Sample Output -999,991","title":"Statement"},{"location":"PAT-Advanced-Level/1001-A%2BB%20Format/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; void tran ( int x ) { string s1 = \"\" , s2 = \"\" ; int i , j , flag = 0 ; if ( x ) { if ( x < 0 ) flag = 1 , x *= -1 ; while ( x ) { s1 += x % 10 + '0' ; x /= 10 ; } int len1 = s1 . size (); if ( len1 >= 4 ) { for ( i = 0 ; i < len1 ; i ++ ) { if ( i % 3 == 0 && i ) s2 += \",\" ; s2 += s1 [ i ]; } } else s2 = s1 ; if ( flag ) cout << \"-\" ; int len2 = s2 . size (); for ( i = len2 - 1 ; i >= 0 ; i -- ) cout << s2 [ i ]; } else cout << \"0\" ; cout << \" \\n \" ; } int main () { int a , b ; cin >> a >> b ; a += b ; tran ( a ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1002-A%2BB%20for%20Polynomials/","text":"1002 A+B for Polynomials Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to find A+B A+B where A A and B B are two polynomials. Input Specification Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K K N_1 N_1 a_{N_1} a_{N_1} N_2 N_2 a_{N_2} a_{N_2} \u2026 N_K N_K a_{N_K} a_{N_K} where K K is the number of nonzero terms in the polynomial, N_i N_i and a_{N_i} a_{N_i} ( i=1, 2, \\cdots , K i=1, 2, \\cdots , K ) are the exponents and coefficients, respectively. It is given that 1 \\le K \\le 10 1 \\le K \\le 10 \uff0c 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 . Output Specification For each test case you should output the sum of A A and B B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2","title":"1002-A+B for Polynomials"},{"location":"PAT-Advanced-Level/1002-A%2BB%20for%20Polynomials/#1002-ab-for-polynomials","text":"","title":"1002 A+B for Polynomials"},{"location":"PAT-Advanced-Level/1002-A%2BB%20for%20Polynomials/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to find A+B A+B where A A and B B are two polynomials. Input Specification Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K K N_1 N_1 a_{N_1} a_{N_1} N_2 N_2 a_{N_2} a_{N_2} \u2026 N_K N_K a_{N_K} a_{N_K} where K K is the number of nonzero terms in the polynomial, N_i N_i and a_{N_i} a_{N_i} ( i=1, 2, \\cdots , K i=1, 2, \\cdots , K ) are the exponents and coefficients, respectively. It is given that 1 \\le K \\le 10 1 \\le K \\le 10 \uff0c 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 . Output Specification For each test case you should output the sum of A A and B B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2","title":"Statement"},{"location":"PAT-Advanced-Level/1003-Emergency/","text":"1003 Emergency Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification Each input file contains one test case. For each test case, the first line contains 4 positive integers: N N ( \\le 500 \\le 500 ) - the number of cities (and the cities are numbered from 0 to N-1 N-1 ), M M - the number of roads, C_1 C_1 and C_2 C_2 - the cities that you are currently in and that you must save, respectively. The next line contains N N integers, where the i i -th integer is the number of rescue teams in the i i -th city. Then M M lines follow, each describes a road with three integers c_1 c_1 , c_2 c_2 and L L , which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C_1 C_1 to C_2 C_2 . Output Specification For each test case, print in one line two numbers: the number of different shortest paths between C_1 C_1 and C_2 C_2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Sample Output 2 4","title":"1003-Emergency"},{"location":"PAT-Advanced-Level/1003-Emergency/#1003-emergency","text":"","title":"1003 Emergency"},{"location":"PAT-Advanced-Level/1003-Emergency/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification Each input file contains one test case. For each test case, the first line contains 4 positive integers: N N ( \\le 500 \\le 500 ) - the number of cities (and the cities are numbered from 0 to N-1 N-1 ), M M - the number of roads, C_1 C_1 and C_2 C_2 - the cities that you are currently in and that you must save, respectively. The next line contains N N integers, where the i i -th integer is the number of rescue teams in the i i -th city. Then M M lines follow, each describes a road with three integers c_1 c_1 , c_2 c_2 and L L , which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C_1 C_1 to C_2 C_2 . Output Specification For each test case, print in one line two numbers: the number of different shortest paths between C_1 C_1 and C_2 C_2 , and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Sample Output 2 4","title":"Statement"},{"location":"PAT-Advanced-Level/1004-Counting%20Leaves/","text":"1004 Counting Leaves Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Specification Each input file contains one test case. Each case starts with a line containing 0<N<100 0<N<100 , the number of nodes in a tree, and M M ( <N <N ), the number of non-leaf nodes. Then M M lines follow, each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID 's of its children. For the sake of simplicity, let us fix the root ID to be 01 . The input ends with N N being 0. That case must NOT be processed. Output Specification For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line. Sample Input 2 1 01 1 02 Sample Output 0 1 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , m , Max , ans [ N ]; vector < vector < int >> G ; void dfs ( int u , int dep ) { Max = max ( Max , dep ); if ( G [ u ]. size () == 0 ) { ++ ans [ dep ]; } for ( auto & v : G [ u ]) { dfs ( v , dep + 1 ); } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { memset ( ans , 0 , sizeof ans ); G . clear (); G . resize ( n + 10 ); Max = 0 ; for ( int i = 1 , sze , u ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & sze ); for ( int j = 1 , v ; j <= sze ; ++ j ) { scanf ( \"%d\" , & v ); G [ u ]. push_back ( v ); } } dfs ( 1 , 0 ); for ( int i = 0 ; i <= Max ; ++ i ) { printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == Max ]); } } return 0 ; }","title":"1004-Counting Leaves"},{"location":"PAT-Advanced-Level/1004-Counting%20Leaves/#1004-counting-leaves","text":"","title":"1004 Counting Leaves"},{"location":"PAT-Advanced-Level/1004-Counting%20Leaves/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. Input Specification Each input file contains one test case. Each case starts with a line containing 0<N<100 0<N<100 , the number of nodes in a tree, and M M ( <N <N ), the number of non-leaf nodes. Then M M lines follow, each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID 's of its children. For the sake of simplicity, let us fix the root ID to be 01 . The input ends with N N being 0. That case must NOT be processed. Output Specification For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line. Sample Input 2 1 01 1 02 Sample Output 0 1","title":"Statement"},{"location":"PAT-Advanced-Level/1004-Counting%20Leaves/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , m , Max , ans [ N ]; vector < vector < int >> G ; void dfs ( int u , int dep ) { Max = max ( Max , dep ); if ( G [ u ]. size () == 0 ) { ++ ans [ dep ]; } for ( auto & v : G [ u ]) { dfs ( v , dep + 1 ); } } int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { memset ( ans , 0 , sizeof ans ); G . clear (); G . resize ( n + 10 ); Max = 0 ; for ( int i = 1 , sze , u ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & sze ); for ( int j = 1 , v ; j <= sze ; ++ j ) { scanf ( \"%d\" , & v ); G [ u ]. push_back ( v ); } } dfs ( 1 , 0 ); for ( int i = 0 ; i <= Max ; ++ i ) { printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == Max ]); } } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1005-Spell%20It%20Right/","text":"1005 Spell It Right Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a non-negative integer N N , your task is to compute the sum of all the digits of N N , and output every digit of the sum in English. Input Specification Each input file contains one test case. Each case occupies one line which contains an N N ( \\le 10^{100} \\le 10^{100} ). Output Specification For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input 12345 Sample Output one five Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string tran ( int x ) { string s = \"\" ; if ( x == 0 ) return \"0\" ; while ( x ) { s += x % 10 + '0' ; x /= 10 ; } return s ; } int main () { string s ; cin >> s ; int len = s . size (); int sum = 0 ; for ( int i = 0 ; i < len ; i ++ ) sum += s [ i ] - '0' ; map < char , string > m ; m [ '0' ] = \"zero\" ; m [ '1' ] = \"one\" ; m [ '2' ] = \"two\" ; m [ '3' ] = \"three\" ; m [ '4' ] = \"four\" ; m [ '5' ] = \"five\" ; m [ '6' ] = \"six\" ; m [ '7' ] = \"seven\" ; m [ '8' ] = \"eight\" ; m [ '9' ] = \"nine\" ; string ans = tran ( sum ); len = ans . size (); for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( i != len - 1 ) printf ( \" \" ); cout << m [ ans [ i ]]; } cout << endl ; }","title":"1005-Spell It Right"},{"location":"PAT-Advanced-Level/1005-Spell%20It%20Right/#1005-spell-it-right","text":"","title":"1005 Spell It Right"},{"location":"PAT-Advanced-Level/1005-Spell%20It%20Right/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a non-negative integer N N , your task is to compute the sum of all the digits of N N , and output every digit of the sum in English. Input Specification Each input file contains one test case. Each case occupies one line which contains an N N ( \\le 10^{100} \\le 10^{100} ). Output Specification For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input 12345 Sample Output one five","title":"Statement"},{"location":"PAT-Advanced-Level/1005-Spell%20It%20Right/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string tran ( int x ) { string s = \"\" ; if ( x == 0 ) return \"0\" ; while ( x ) { s += x % 10 + '0' ; x /= 10 ; } return s ; } int main () { string s ; cin >> s ; int len = s . size (); int sum = 0 ; for ( int i = 0 ; i < len ; i ++ ) sum += s [ i ] - '0' ; map < char , string > m ; m [ '0' ] = \"zero\" ; m [ '1' ] = \"one\" ; m [ '2' ] = \"two\" ; m [ '3' ] = \"three\" ; m [ '4' ] = \"four\" ; m [ '5' ] = \"five\" ; m [ '6' ] = \"six\" ; m [ '7' ] = \"seven\" ; m [ '8' ] = \"eight\" ; m [ '9' ] = \"nine\" ; string ans = tran ( sum ); len = ans . size (); for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( i != len - 1 ) printf ( \" \" ); cout << m [ ans [ i ]]; } cout << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1006-Sign%20In%20and%20Sign%20Out/","text":"1006 Sign In and Sign Out Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M M , which is the total number of records, followed by M M lines, each in the format: ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS , and ID_number is a string with no more than 15 characters. Output Specification For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input 3 CS301111 15:30:28 17:00:10 SC3021234 08:00:00 11:25:25 CS301133 21:45:00 21:58:40 Sample Output SC3021234 CS301133 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , max = INT_MIN , min = INT_MAX , a , b , c , tot1 , tot2 , d , e , f ; cin >> n ; string s_max = \"\" , s_min = \"\" , s ; for ( i = 0 ; i < n ; i ++ ) { cin >> s ; scanf ( \"%d:%d:%d\" , & a , & b , & c ); scanf ( \"%d:%d:%d\" , & d , & e , & f ); tot1 = a * 3600 + b * 60 + c , tot2 = d * 3600 + e * 60 + f ; if ( tot2 > max ) { max = tot2 ; s_max = s ; } if ( tot1 < min ) { min = tot1 ; s_min = s ; } } cout << s_min << \" \" << s_max << endl ; }","title":"1006-Sign In and Sign Out"},{"location":"PAT-Advanced-Level/1006-Sign%20In%20and%20Sign%20Out/#1006-sign-in-and-sign-out","text":"","title":"1006 Sign In and Sign Out"},{"location":"PAT-Advanced-Level/1006-Sign%20In%20and%20Sign%20Out/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in's and out's, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M M , which is the total number of records, followed by M M lines, each in the format: ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS , and ID_number is a string with no more than 15 characters. Output Specification For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input 3 CS301111 15:30:28 17:00:10 SC3021234 08:00:00 11:25:25 CS301133 21:45:00 21:58:40 Sample Output SC3021234 CS301133","title":"Statement"},{"location":"PAT-Advanced-Level/1006-Sign%20In%20and%20Sign%20Out/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , max = INT_MIN , min = INT_MAX , a , b , c , tot1 , tot2 , d , e , f ; cin >> n ; string s_max = \"\" , s_min = \"\" , s ; for ( i = 0 ; i < n ; i ++ ) { cin >> s ; scanf ( \"%d:%d:%d\" , & a , & b , & c ); scanf ( \"%d:%d:%d\" , & d , & e , & f ); tot1 = a * 3600 + b * 60 + c , tot2 = d * 3600 + e * 60 + f ; if ( tot2 > max ) { max = tot2 ; s_max = s ; } if ( tot1 < min ) { min = tot1 ; s_min = s ; } } cout << s_min << \" \" << s_max << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1007-Maximum%20Subsequence%20Sum/","text":"1007 Maximum Subsequence Sum Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of K K integers { N_1 N_1 , N_2 N_2 , \u2026, N_K N_K }. A continuous subsequence is defined to be { N_i N_i , N_{i+1} N_{i+1} , \u2026, N_j N_j } where 1 \\le i \\le j \\le K 1 \\le i \\le j \\le K . The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K K ( \\le 10000 \\le 10000 ). The second line contains K K numbers, separated by a space. Output Specification For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i i and j j (as shown by the sample case). If all the K K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input 10 -10 1 2 3 4 -5 -23 3 7 -21 Sample Output 10 1 4 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; int main () { int n ; cin >> n ; int l , r , ans = -1 , num , temp = 0 , vis , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ]); if ( i == 0 || flag ) { vis = arr [ i ]; flag = 0 ; } temp += arr [ i ]; if ( temp < 0 ) { temp = 0 ; flag = 1 ; continue ; } if ( temp > ans ) { ans = temp ; l = vis ; r = arr [ i ]; } } if ( ans != -1 ) printf ( \"%d %d %d \\n \" , ans , l , r ); else printf ( \"%d %d %d \\n \" , 0 , arr [ 0 ], arr [ n - 1 ]); }","title":"1007-Maximum Subsequence Sum"},{"location":"PAT-Advanced-Level/1007-Maximum%20Subsequence%20Sum/#1007-maximum-subsequence-sum","text":"","title":"1007 Maximum Subsequence Sum"},{"location":"PAT-Advanced-Level/1007-Maximum%20Subsequence%20Sum/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of K K integers { N_1 N_1 , N_2 N_2 , \u2026, N_K N_K }. A continuous subsequence is defined to be { N_i N_i , N_{i+1} N_{i+1} , \u2026, N_j N_j } where 1 \\le i \\le j \\le K 1 \\le i \\le j \\le K . The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K K ( \\le 10000 \\le 10000 ). The second line contains K K numbers, separated by a space. Output Specification For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i i and j j (as shown by the sample case). If all the K K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input 10 -10 1 2 3 4 -5 -23 3 7 -21 Sample Output 10 1 4","title":"Statement"},{"location":"PAT-Advanced-Level/1007-Maximum%20Subsequence%20Sum/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 5 ; const int MOD = 1e9 + 7 ; int arr [ maxn ]; int main () { int n ; cin >> n ; int l , r , ans = -1 , num , temp = 0 , vis , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & arr [ i ]); if ( i == 0 || flag ) { vis = arr [ i ]; flag = 0 ; } temp += arr [ i ]; if ( temp < 0 ) { temp = 0 ; flag = 1 ; continue ; } if ( temp > ans ) { ans = temp ; l = vis ; r = arr [ i ]; } } if ( ans != -1 ) printf ( \"%d %d %d \\n \" , ans , l , r ); else printf ( \"%d %d %d \\n \" , 0 , arr [ 0 ], arr [ n - 1 ]); }","title":"Solution"},{"location":"PAT-Advanced-Level/1008-Elevator/","text":"1008 Elevator Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The highest building in our city has only one elevator. A request list is made up with N N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0 th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification Each input file contains one test case. Each case contains a positive integer N N , followed by N N positive numbers. All the numbers in the input are less than 100. Output Specification For each test case, print the total time on a single line. Sample Input 3 2 3 1 Sample Output 41 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int N , stay = 0 , t , i , total = 0 ; cin >> N ; for ( i = 0 ; i < N ; i ++ ) { cin >> t ; if ( t == stay ) total += 5 ; else if ( t > stay ) total += ( t - stay ) * 6 + 5 ; else if ( t < stay ) total += ( stay - t ) * 4 + 5 ; stay = t ; } cout << total << endl ; }","title":"1008-Elevator"},{"location":"PAT-Advanced-Level/1008-Elevator/#1008-elevator","text":"","title":"1008 Elevator"},{"location":"PAT-Advanced-Level/1008-Elevator/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The highest building in our city has only one elevator. A request list is made up with N N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0 th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification Each input file contains one test case. Each case contains a positive integer N N , followed by N N positive numbers. All the numbers in the input are less than 100. Output Specification For each test case, print the total time on a single line. Sample Input 3 2 3 1 Sample Output 41","title":"Statement"},{"location":"PAT-Advanced-Level/1008-Elevator/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int N , stay = 0 , t , i , total = 0 ; cin >> N ; for ( i = 0 ; i < N ; i ++ ) { cin >> t ; if ( t == stay ) total += 5 ; else if ( t > stay ) total += ( t - stay ) * 6 + 5 ; else if ( t < stay ) total += ( stay - t ) * 4 + 5 ; stay = t ; } cout << total << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1009-Product%20of%20Polynomials/","text":"1009 Product of Polynomials Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to find A\\times B A\\times B where A A and B B are two polynomials. Input Specification Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K K N_1 N_1 a_{N_1} a_{N_1} N_2 N_2 a_{N_2} a_{N_2} \u2026 N_K N_K a_{N_K} a_{N_K} where K K is the number of nonzero terms in the polynomial, N_i N_i and a_{N_i} a_{N_i} ( i=1, 2, \\cdots , K i=1, 2, \\cdots , K ) are the exponents and coefficients, respectively. It is given that 1\\le K \\le 10 1\\le K \\le 10 , 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 . Output Specification For each test case you should output the product of A A and B B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 3 3.6 2 6.0 1 1.6","title":"1009-Product of Polynomials"},{"location":"PAT-Advanced-Level/1009-Product%20of%20Polynomials/#1009-product-of-polynomials","text":"","title":"1009 Product of Polynomials"},{"location":"PAT-Advanced-Level/1009-Product%20of%20Polynomials/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to find A\\times B A\\times B where A A and B B are two polynomials. Input Specification Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K K N_1 N_1 a_{N_1} a_{N_1} N_2 N_2 a_{N_2} a_{N_2} \u2026 N_K N_K a_{N_K} a_{N_K} where K K is the number of nonzero terms in the polynomial, N_i N_i and a_{N_i} a_{N_i} ( i=1, 2, \\cdots , K i=1, 2, \\cdots , K ) are the exponents and coefficients, respectively. It is given that 1\\le K \\le 10 1\\le K \\le 10 , 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 0 \\le N_K < \\cdots < N_2 < N_1 \\le 1000 . Output Specification For each test case you should output the product of A A and B B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 3 3.6 2 6.0 1 1.6","title":"Statement"},{"location":"PAT-Advanced-Level/1010-Radix/","text":"1010 Radix Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes , if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N_1 N_1 and N_2 N_2 , your task is to find the radix of one number while that of the other is given. Input Specification Each input file contains one test case. Each case occupies a line which contains 4 positive integers: N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a - z } where 0-9 represent the decimal numbers 0-9, and a - z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output Specification For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible . If the solution is not unique, output the smallest possible radix. Sample Input 1 6 110 1 10 Sample Output 1 2 Sample Input 2 1 ab 1 2 Sample Output 2 Impossible","title":"1010-Radix"},{"location":"PAT-Advanced-Level/1010-Radix/#1010-radix","text":"","title":"1010 Radix"},{"location":"PAT-Advanced-Level/1010-Radix/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes , if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N_1 N_1 and N_2 N_2 , your task is to find the radix of one number while that of the other is given. Input Specification Each input file contains one test case. Each case occupies a line which contains 4 positive integers: N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a - z } where 0-9 represent the decimal numbers 0-9, and a - z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output Specification For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible . If the solution is not unique, output the smallest possible radix. Sample Input 1 6 110 1 10 Sample Output 1 2 Sample Input 2 1 ab 1 2 Sample Output 2 Impossible","title":"Statement"},{"location":"PAT-Advanced-Level/1011-World%20Cup%20Betting/","text":"1011 World Cup Betting Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results \u2013 namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%. For example, 3 games' odds are given as the following: W T L 1.1 2.5 1.7 1.2 3.1 1.6 4.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3 rd game, T for the 2 nd game, and T for the 1 st game. If each bet takes 2 yuans, then the maximum profit would be (4.1\\times 3.1\\times 2.5\\times 65\\%-1)\\times 2 = 39.31 (4.1\\times 3.1\\times 2.5\\times 65\\%-1)\\times 2 = 39.31 yuans (accurate up to 2 decimal places). Input Specification Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W , T and L . Output Specification For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1.1 2.5 1.7 1.2 3.1 1.6 4.1 1.2 1.1 Sample Output T T W 39.31 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { double W , T , L , total = 1.0 , MAX ; int i ; for ( i = 0 ; i < 3 ; i ++ ) { cin >> W >> T >> L ; MAX = max ( max ( W , T ), L ); if ( MAX == W ) { total *= W ; cout << \"W \" ; } else if ( MAX == T ) { total *= T ; cout << \"T \" ; } else if ( MAX == L ) { total *= L ; cout << \"L \" ; } } printf ( \"%.2lf \\n \" , ( total * 0.65 - 1 ) * 2 ); }","title":"1011-World Cup Betting"},{"location":"PAT-Advanced-Level/1011-World%20Cup%20Betting/#1011-world-cup-betting","text":"","title":"1011 World Cup Betting"},{"location":"PAT-Advanced-Level/1011-World%20Cup%20Betting/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a \"Triple Winning\" game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results \u2013 namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner's odd would be the product of the three odds times 65%. For example, 3 games' odds are given as the following: W T L 1.1 2.5 1.7 1.2 3.1 1.6 4.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3 rd game, T for the 2 nd game, and T for the 1 st game. If each bet takes 2 yuans, then the maximum profit would be (4.1\\times 3.1\\times 2.5\\times 65\\%-1)\\times 2 = 39.31 (4.1\\times 3.1\\times 2.5\\times 65\\%-1)\\times 2 = 39.31 yuans (accurate up to 2 decimal places). Input Specification Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W , T and L . Output Specification For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1.1 2.5 1.7 1.2 3.1 1.6 4.1 1.2 1.1 Sample Output T T W 39.31","title":"Statement"},{"location":"PAT-Advanced-Level/1011-World%20Cup%20Betting/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { double W , T , L , total = 1.0 , MAX ; int i ; for ( i = 0 ; i < 3 ; i ++ ) { cin >> W >> T >> L ; MAX = max ( max ( W , T ), L ); if ( MAX == W ) { total *= W ; cout << \"W \" ; } else if ( MAX == T ) { total *= T ; cout << \"T \" ; } else if ( MAX == L ) { total *= L ; cout << \"L \" ; } } printf ( \"%.2lf \\n \" , ( total * 0.65 - 1 ) * 2 ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1012-The%20Best%20Rank/","text":"1012 The Best Rank Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks \u2013 that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C , M , E and A - Average of 4 students are given as the following: StudentID C M E A 310101 98 85 88 90 310102 70 95 88 84 310103 82 87 94 88 310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1 st one has done the best in C Programming Language, while the 2 nd one in Mathematics, the 3 rd one in English, and the last one in average. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N N and M M ( \\le 2000 \\le 2000 ), which are the total number of students, and the number of students who would check their ranks, respectively. Then N N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C , M and E . Then there are M M lines, each containing a student ID. Output Specification For each of the M M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A > > C > > M > > E . Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output N/A . Sample Input 5 6 310101 98 85 88 310102 70 95 88 310103 82 87 94 310104 91 91 91 310105 85 90 90 310101 310102 310103 310104 310105 999999 Sample Output 1 C 1 M 1 E 1 A 3 A N/A Solution C++ #include <bits/stdc++.h> using namespace std ; #define maxn 2000 struct pp { string ID ; int C , M , E , A , flag = 0 ; int rank_C , rank_M , rank_E , rank_A , rank_min = INT_MAX ; char c ; } p [ maxn ]; int comp1 ( pp x , pp y ) { return x . C > y . C ; } int comp2 ( pp x , pp y ) { return x . M > y . M ; } int comp3 ( pp x , pp y ) { return x . E > y . E ; } int comp4 ( pp x , pp y ) { return x . A > y . A ; } int main () { int N , M , i , j , flag ; cin >> N >> M ; map < string , pp > q ; string s ; for ( i = 0 ; i < N ; i ++ ) { cin >> s ; scanf ( \"%d%d%d\" , & q [ s ]. C , & q [ s ]. M , & q [ s ]. E ); q [ s ]. A = ( q [ s ]. C + q [ s ]. M + q [ s ]. E ) / 3 ; q [ s ]. flag = 1 ; p [ i ]. ID = s , p [ i ]. C = q [ s ]. C , p [ i ]. M = q [ s ]. M , p [ i ]. E = q [ s ]. E , p [ i ]. A = q [ s ]. A ; } sort ( p , p + i , comp1 ); q [ p [ 0 ]. ID ]. rank_C = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. C != q [ p [ j - 1 ]. ID ]. C ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_C = flag ; } sort ( p , p + i , comp2 ); q [ p [ 0 ]. ID ]. rank_M = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. M != q [ p [ j - 1 ]. ID ]. M ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_M = flag ; } sort ( p , p + i , comp3 ); q [ p [ 0 ]. ID ]. rank_E = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. E != q [ p [ j - 1 ]. ID ]. E ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_E = flag ; } sort ( p , p + i , comp4 ); q [ p [ 0 ]. ID ]. rank_A = 1 , flag = 1 , j = 0 ; if ( q [ p [ j ]. ID ]. rank_E < q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_E ; q [ p [ j ]. ID ]. c = 'E' ; } if ( q [ p [ j ]. ID ]. rank_M <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_M ; q [ p [ j ]. ID ]. c = 'M' ; } if ( q [ p [ j ]. ID ]. rank_C <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_C ; q [ p [ j ]. ID ]. c = 'C' ; } if ( q [ p [ j ]. ID ]. rank_A <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_A ; q [ p [ j ]. ID ]. c = 'A' ; } for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. A != q [ p [ j - 1 ]. ID ]. A ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_A = flag ; if ( q [ p [ j ]. ID ]. rank_E < q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_E ; q [ p [ j ]. ID ]. c = 'E' ; } if ( q [ p [ j ]. ID ]. rank_M <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_M ; q [ p [ j ]. ID ]. c = 'M' ; } if ( q [ p [ j ]. ID ]. rank_C <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_C ; q [ p [ j ]. ID ]. c = 'C' ; } if ( q [ p [ j ]. ID ]. rank_A <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_A ; q [ p [ j ]. ID ]. c = 'A' ; } } for ( i = 0 ; i < M ; i ++ ) { cin >> s ; if ( q [ s ]. flag ) cout << q [ s ]. rank_min << \" \" << q [ s ]. c << endl ; else cout << \"N/A \\n \" ; } }","title":"1012-The Best Rank"},{"location":"PAT-Advanced-Level/1012-The%20Best%20Rank/#1012-the-best-rank","text":"","title":"1012 The Best Rank"},{"location":"PAT-Advanced-Level/1012-The%20Best%20Rank/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks \u2013 that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C , M , E and A - Average of 4 students are given as the following: StudentID C M E A 310101 98 85 88 90 310102 70 95 88 84 310103 82 87 94 88 310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1 st one has done the best in C Programming Language, while the 2 nd one in Mathematics, the 3 rd one in English, and the last one in average. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N N and M M ( \\le 2000 \\le 2000 ), which are the total number of students, and the number of students who would check their ranks, respectively. Then N N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C , M and E . Then there are M M lines, each containing a student ID. Output Specification For each of the M M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A > > C > > M > > E . Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output N/A . Sample Input 5 6 310101 98 85 88 310102 70 95 88 310103 82 87 94 310104 91 91 91 310105 85 90 90 310101 310102 310103 310104 310105 999999 Sample Output 1 C 1 M 1 E 1 A 3 A N/A","title":"Statement"},{"location":"PAT-Advanced-Level/1012-The%20Best%20Rank/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define maxn 2000 struct pp { string ID ; int C , M , E , A , flag = 0 ; int rank_C , rank_M , rank_E , rank_A , rank_min = INT_MAX ; char c ; } p [ maxn ]; int comp1 ( pp x , pp y ) { return x . C > y . C ; } int comp2 ( pp x , pp y ) { return x . M > y . M ; } int comp3 ( pp x , pp y ) { return x . E > y . E ; } int comp4 ( pp x , pp y ) { return x . A > y . A ; } int main () { int N , M , i , j , flag ; cin >> N >> M ; map < string , pp > q ; string s ; for ( i = 0 ; i < N ; i ++ ) { cin >> s ; scanf ( \"%d%d%d\" , & q [ s ]. C , & q [ s ]. M , & q [ s ]. E ); q [ s ]. A = ( q [ s ]. C + q [ s ]. M + q [ s ]. E ) / 3 ; q [ s ]. flag = 1 ; p [ i ]. ID = s , p [ i ]. C = q [ s ]. C , p [ i ]. M = q [ s ]. M , p [ i ]. E = q [ s ]. E , p [ i ]. A = q [ s ]. A ; } sort ( p , p + i , comp1 ); q [ p [ 0 ]. ID ]. rank_C = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. C != q [ p [ j - 1 ]. ID ]. C ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_C = flag ; } sort ( p , p + i , comp2 ); q [ p [ 0 ]. ID ]. rank_M = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. M != q [ p [ j - 1 ]. ID ]. M ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_M = flag ; } sort ( p , p + i , comp3 ); q [ p [ 0 ]. ID ]. rank_E = 1 , flag = 1 ; for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. E != q [ p [ j - 1 ]. ID ]. E ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_E = flag ; } sort ( p , p + i , comp4 ); q [ p [ 0 ]. ID ]. rank_A = 1 , flag = 1 , j = 0 ; if ( q [ p [ j ]. ID ]. rank_E < q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_E ; q [ p [ j ]. ID ]. c = 'E' ; } if ( q [ p [ j ]. ID ]. rank_M <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_M ; q [ p [ j ]. ID ]. c = 'M' ; } if ( q [ p [ j ]. ID ]. rank_C <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_C ; q [ p [ j ]. ID ]. c = 'C' ; } if ( q [ p [ j ]. ID ]. rank_A <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_A ; q [ p [ j ]. ID ]. c = 'A' ; } for ( j = 1 ; j < i ; j ++ ) { if ( q [ p [ j ]. ID ]. A != q [ p [ j - 1 ]. ID ]. A ) flag = j + 1 ; q [ p [ j ]. ID ]. rank_A = flag ; if ( q [ p [ j ]. ID ]. rank_E < q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_E ; q [ p [ j ]. ID ]. c = 'E' ; } if ( q [ p [ j ]. ID ]. rank_M <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_M ; q [ p [ j ]. ID ]. c = 'M' ; } if ( q [ p [ j ]. ID ]. rank_C <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_C ; q [ p [ j ]. ID ]. c = 'C' ; } if ( q [ p [ j ]. ID ]. rank_A <= q [ p [ j ]. ID ]. rank_min ) { q [ p [ j ]. ID ]. rank_min = q [ p [ j ]. ID ]. rank_A ; q [ p [ j ]. ID ]. c = 'A' ; } } for ( i = 0 ; i < M ; i ++ ) { cin >> s ; if ( q [ s ]. flag ) cout << q [ s ]. rank_min << \" \" << q [ s ]. c << endl ; else cout << \"N/A \\n \" ; } }","title":"Solution"},{"location":"PAT-Advanced-Level/1013-Battle%20Over%20Cities/","text":"1013 Battle Over Cities Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting city_1 city_1 - city_2 city_2 and city_1 city_1 - city_3 city_3 . Then if city_1 city_1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city_2 city_2 - city_3 city_3 . Input Specification Each input file contains one test case. Each case starts with a line containing 3 numbers N N ( <1000 <1000 ), M M and K K , which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N N . Finally there is a line containing K K numbers, which represent the cities we concern. Output Specification For each of the K K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input 3 2 3 1 2 1 3 1 2 3 Sample Output 1 0 0","title":"1013-Battle Over Cities"},{"location":"PAT-Advanced-Level/1013-Battle%20Over%20Cities/#1013-battle-over-cities","text":"","title":"1013 Battle Over Cities"},{"location":"PAT-Advanced-Level/1013-Battle%20Over%20Cities/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting city_1 city_1 - city_2 city_2 and city_1 city_1 - city_3 city_3 . Then if city_1 city_1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city_2 city_2 - city_3 city_3 . Input Specification Each input file contains one test case. Each case starts with a line containing 3 numbers N N ( <1000 <1000 ), M M and K K , which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N N . Finally there is a line containing K K numbers, which represent the cities we concern. Output Specification For each of the K K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input 3 2 3 1 2 1 3 1 2 3 Sample Output 1 0 0","title":"Statement"},{"location":"PAT-Advanced-Level/1014-Waiting%20in%20Line/","text":"1014 Waiting in Line Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose a bank has N N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M M customers. Hence when all the N N lines are full, all the customers after (and including) the (NM+1) (NM+1) st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customer_i Customer_i will take T_i T_i minutes to have his/her transaction processed. The first N N customers are assumed to be served at 8:00am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer_1 customer_1 is served at window_1 window_1 while customer_2 customer_2 is served at window_2 window_2 . Customer_3 Customer_3 will wait in front of window_1 window_1 and customer_4 customer_4 will wait in front of window_2 window_2 . Customer_5 Customer_5 will wait behind the yellow line. At 08:01, customer_1 customer_1 is done and customer_5 customer_5 enters the line in front of window_1 window_1 since that line seems shorter now. Customer_2 Customer_2 will leave at 08:02, customer_4 customer_4 at 08:06, customer_3 customer_3 at 08:07, and finally customer_5 customer_5 at 08:10. Input Specification Each input file contains one test case. Each case starts with a line containing 4 positive integers: N N ( \\le 20 \\le 20 , number of windows), M M ( \\le 10 \\le 10 , the maximum capacity of each line inside the yellow line), K K ( \\le 1000 \\le 1000 , number of customers), and Q Q ( \\le 1000 \\le 1000 , number of customer queries). The next line contains K K positive integers, which are the processing time of the K K customers. The last line contains Q Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K K . Output Specification For each of the Q Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead. Sample Input 2 2 7 5 1 2 6 4 3 534 2 3 4 5 6 7 Sample Output 08:07 08:06 08:10 17:00 Sorry \u9e23\u8c22\u7528\u6237 \u4e0d\u523076kg\u4e0d\u6539\u540d \u548c \u5f90\u5411\u8363 \u8865\u5145\u6570\u636e\uff01","title":"1014-Waiting in Line"},{"location":"PAT-Advanced-Level/1014-Waiting%20in%20Line/#1014-waiting-in-line","text":"","title":"1014 Waiting in Line"},{"location":"PAT-Advanced-Level/1014-Waiting%20in%20Line/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose a bank has N N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M M customers. Hence when all the N N lines are full, all the customers after (and including) the (NM+1) (NM+1) st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customer_i Customer_i will take T_i T_i minutes to have his/her transaction processed. The first N N customers are assumed to be served at 8:00am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer_1 customer_1 is served at window_1 window_1 while customer_2 customer_2 is served at window_2 window_2 . Customer_3 Customer_3 will wait in front of window_1 window_1 and customer_4 customer_4 will wait in front of window_2 window_2 . Customer_5 Customer_5 will wait behind the yellow line. At 08:01, customer_1 customer_1 is done and customer_5 customer_5 enters the line in front of window_1 window_1 since that line seems shorter now. Customer_2 Customer_2 will leave at 08:02, customer_4 customer_4 at 08:06, customer_3 customer_3 at 08:07, and finally customer_5 customer_5 at 08:10. Input Specification Each input file contains one test case. Each case starts with a line containing 4 positive integers: N N ( \\le 20 \\le 20 , number of windows), M M ( \\le 10 \\le 10 , the maximum capacity of each line inside the yellow line), K K ( \\le 1000 \\le 1000 , number of customers), and Q Q ( \\le 1000 \\le 1000 , number of customer queries). The next line contains K K positive integers, which are the processing time of the K K customers. The last line contains Q Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K K . Output Specification For each of the Q Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead. Sample Input 2 2 7 5 1 2 6 4 3 534 2 3 4 5 6 7 Sample Output 08:07 08:06 08:10 17:00 Sorry \u9e23\u8c22\u7528\u6237 \u4e0d\u523076kg\u4e0d\u6539\u540d \u548c \u5f90\u5411\u8363 \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1015-Reversible%20Primes/","text":"1015 Reversible Primes Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A reversible prime in any number system is a prime whose \"reverse\" in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime. Now given any two positive integers N N ( < 10^5 < 10^5 ) and D D ( 1 < D \\le 10 1 < D \\le 10 ), you are supposed to tell if N N is a reversible prime with radix D D . Input Specification The input file consists of several test cases. Each case occupies a line which contains two integers N N and D D . The input is finished by a negative N N . Output Specification For each test case, print in one line Yes if N N is a reversible prime with radix D D , or No if not. Sample Input 73 10 23 2 23 10 -2 Sample Output Yes Yes No","title":"1015-Reversible Primes"},{"location":"PAT-Advanced-Level/1015-Reversible%20Primes/#1015-reversible-primes","text":"","title":"1015 Reversible Primes"},{"location":"PAT-Advanced-Level/1015-Reversible%20Primes/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A reversible prime in any number system is a prime whose \"reverse\" in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime. Now given any two positive integers N N ( < 10^5 < 10^5 ) and D D ( 1 < D \\le 10 1 < D \\le 10 ), you are supposed to tell if N N is a reversible prime with radix D D . Input Specification The input file consists of several test cases. Each case occupies a line which contains two integers N N and D D . The input is finished by a negative N N . Output Specification For each test case, print in one line Yes if N N is a reversible prime with radix D D , or No if not. Sample Input 73 10 23 2 23 10 -2 Sample Output Yes Yes No","title":"Statement"},{"location":"PAT-Advanced-Level/1016-Phone%20Bills/","text":"1016 Phone Bills Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N N ( \\le 1000 \\le 1000 ), followed by N N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date ( MM:dd:HH:mm ), and the word on-line or off-line . For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers' names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date ( dd:HH:mm ), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input 10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10 10 CYLL 01:01:06:01 on-line CYLL 01:28:16:05 off-line CYJJ 01:01:07:00 off-line CYLL 01:01:08:03 off-line CYJJ 01:01:05:59 on-line aaa 01:01:01:03 on-line aaa 01:02:00:01 on-line CYLL 01:28:15:41 on-line aaa 01:05:02:24 on-line aaa 01:04:23:59 off-line Sample Output CYJJ 01 01:05:59 01:07:00 61 $12.10 Total amount: $12.10 CYLL 01 01:06:01 01:08:03 122 $24.40 28:15:41 28:16:05 24 $3.85 Total amount: $28.25 aaa 01 02:00:01 04:23:59 4318 $638.80 Total amount: $638.80","title":"1016-Phone Bills"},{"location":"PAT-Advanced-Level/1016-Phone%20Bills/#1016-phone-bills","text":"","title":"1016 Phone Bills"},{"location":"PAT-Advanced-Level/1016-Phone%20Bills/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N N ( \\le 1000 \\le 1000 ), followed by N N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date ( MM:dd:HH:mm ), and the word on-line or off-line . For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers' names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date ( dd:HH:mm ), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input 10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10 10 CYLL 01:01:06:01 on-line CYLL 01:28:16:05 off-line CYJJ 01:01:07:00 off-line CYLL 01:01:08:03 off-line CYJJ 01:01:05:59 on-line aaa 01:01:01:03 on-line aaa 01:02:00:01 on-line CYLL 01:28:15:41 on-line aaa 01:05:02:24 on-line aaa 01:04:23:59 off-line Sample Output CYJJ 01 01:05:59 01:07:00 61 $12.10 Total amount: $12.10 CYLL 01 01:06:01 01:08:03 122 $24.40 28:15:41 28:16:05 24 $3.85 Total amount: $28.25 aaa 01 02:00:01 04:23:59 4318 $638.80 Total amount: $638.80","title":"Statement"},{"location":"PAT-Advanced-Level/1017-Queueing%20at%20Bank/","text":"1017 Queueing at Bank Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose a bank has K K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T T and the processing time P P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 10^4 \\le 10^4 ) - the total number of customers, and K K ( \\le 100 \\le 100 ) - the number of windows. Then N N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input 7 3 07:55:00 16 17:00:01 2 07:59:59 15 08:01:00 60 08:00:00 30 08:00:02 2 08:03:00 10 Sample Output 8.2","title":"1017-Queueing at Bank"},{"location":"PAT-Advanced-Level/1017-Queueing%20at%20Bank/#1017-queueing-at-bank","text":"","title":"1017 Queueing at Bank"},{"location":"PAT-Advanced-Level/1017-Queueing%20at%20Bank/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose a bank has K K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour. Now given the arriving time T T and the processing time P P of each customer, you are supposed to tell the average waiting time of all the customers. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 10^4 \\le 10^4 ) - the total number of customers, and K K ( \\le 100 \\le 100 ) - the number of windows. Then N N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time. Notice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average. Output Specification For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place. Sample Input 7 3 07:55:00 16 17:00:01 2 07:59:59 15 08:01:00 60 08:00:00 30 08:00:02 2 08:03:00 10 Sample Output 8.2","title":"Statement"},{"location":"PAT-Advanced-Level/1018-Public%20Bike%20Management/","text":"1018 Public Bike Management Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S S is the current number of bikes stored at S S . Given that the maximum capacity of each station is 10. To solve the problem at S_3 S_3 , we have 2 different shortest paths: PBMC -> S_1 S_1 -> S_3 S_3 . In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S_1 S_1 and then take 5 bikes to S_3 S_3 , so that both stations will be in perfect conditions. PBMC -> S_2 S_2 -> S_3 S_3 . This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen. Input Specification Each input file contains one test case. For each case, the first line contains 4 numbers: C_{max} C_{max} ( \\le 100 \\le 100 ), always an even number, is the maximum capacity of each station; N N ( \\le 500 \\le 500 ), the total number of stations; S_p S_p , the index of the problem station (the stations are numbered from 1 to N N , and PBMC is represented by the vertex 0); and M M , the number of roads. The second line contains N N non-negative numbers C_i C_i ( i=1,\\cdots ,N i=1,\\cdots ,N ) where each C_i C_i is the current number of bikes at S_i S_i respectively. Then M M lines follow, each contains 3 numbers: S_i S_i , S_j S_j , and T_{ij} T_{ij} which describe the time T_{ij} T_{ij} taken to move betwen stations S_i S_i and S_j S_j . All the numbers in a line are separated by a space. Output Specification For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0->S_1->\\cdots ->S_p 0->S_1->\\cdots ->S_p . Finally after another space, output the number of bikes that we must take back to PBMC after the condition of S_p S_p is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge's data guarantee that such a path is unique. Sample Input 10 3 3 5 6 7 0 0 1 1 0 2 1 0 3 3 1 3 1 2 3 1 Sample Output 3 0->2->3 0","title":"1018-Public Bike Management"},{"location":"PAT-Advanced-Level/1018-Public%20Bike%20Management/#1018-public-bike-management","text":"","title":"1018 Public Bike Management"},{"location":"PAT-Advanced-Level/1018-Public%20Bike%20Management/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S S is the current number of bikes stored at S S . Given that the maximum capacity of each station is 10. To solve the problem at S_3 S_3 , we have 2 different shortest paths: PBMC -> S_1 S_1 -> S_3 S_3 . In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S_1 S_1 and then take 5 bikes to S_3 S_3 , so that both stations will be in perfect conditions. PBMC -> S_2 S_2 -> S_3 S_3 . This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen. Input Specification Each input file contains one test case. For each case, the first line contains 4 numbers: C_{max} C_{max} ( \\le 100 \\le 100 ), always an even number, is the maximum capacity of each station; N N ( \\le 500 \\le 500 ), the total number of stations; S_p S_p , the index of the problem station (the stations are numbered from 1 to N N , and PBMC is represented by the vertex 0); and M M , the number of roads. The second line contains N N non-negative numbers C_i C_i ( i=1,\\cdots ,N i=1,\\cdots ,N ) where each C_i C_i is the current number of bikes at S_i S_i respectively. Then M M lines follow, each contains 3 numbers: S_i S_i , S_j S_j , and T_{ij} T_{ij} which describe the time T_{ij} T_{ij} taken to move betwen stations S_i S_i and S_j S_j . All the numbers in a line are separated by a space. Output Specification For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0->S_1->\\cdots ->S_p 0->S_1->\\cdots ->S_p . Finally after another space, output the number of bikes that we must take back to PBMC after the condition of S_p S_p is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge's data guarantee that such a path is unique. Sample Input 10 3 3 5 6 7 0 0 1 1 0 2 1 0 3 3 1 3 1 2 3 1 Sample Output 3 0->2->3 0","title":"Statement"},{"location":"PAT-Advanced-Level/1019-General%20Palindromic%20Number/","text":"1019 General Palindromic Number Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A number that will be the same when it is written forwards or backwards is known as a Palindromic Number . For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N > 0 N > 0 in base b \\ge 2 b \\ge 2 , where it is written in standard notation with k+1 k+1 digits a_i a_i as \\sum_{i=0}^k (a_ib^i) \\sum_{i=0}^k (a_ib^i) . Here, as usual, 0 \\le a_i < b 0 \\le a_i < b for all i i and a_k a_k is non-zero. Then N N is palindromic if and only if a_i = a_{k-i} a_i = a_{k-i} for all i i . Zero is written 0 in any base and is also palindromic by definition. Given any positive decimal integer N N and a base b b , you are supposed to tell if N N is a palindromic number in base b b . Input Specification Each input file contains one test case. Each case consists of two positive numbers N N and b b , where 0 < N \\le 10^9 0 < N \\le 10^9 is the decimal number and 2 \\le b \\le 10^9 2 \\le b \\le 10^9 is the base. The numbers are separated by a space. Output Specification For each test case, first print in one line Yes if N N is a palindromic number in base b b , or No if not. Then in the next line, print N N as the number in base b b in the form \" a_k a_k a_{k-1} a_{k-1} \u2026 a_0 a_0 \". Notice that there must be no extra space at the end of output. Sample Input 1 27 2 Sample Output 1 Yes 1 1 0 1 1 Sample Input 2 121 5 Sample Output 2 No 4 4 1 \u9e23\u8c22\u7f51\u53cb\u201cCCPC\u62ff\u4e0d\u5230\u724c\u4e0d\u6539\u540d\u201d\u4fee\u6b63\u6570\u636e\uff01","title":"1019-General Palindromic Number"},{"location":"PAT-Advanced-Level/1019-General%20Palindromic%20Number/#1019-general-palindromic-number","text":"","title":"1019 General Palindromic Number"},{"location":"PAT-Advanced-Level/1019-General%20Palindromic%20Number/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A number that will be the same when it is written forwards or backwards is known as a Palindromic Number . For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N > 0 N > 0 in base b \\ge 2 b \\ge 2 , where it is written in standard notation with k+1 k+1 digits a_i a_i as \\sum_{i=0}^k (a_ib^i) \\sum_{i=0}^k (a_ib^i) . Here, as usual, 0 \\le a_i < b 0 \\le a_i < b for all i i and a_k a_k is non-zero. Then N N is palindromic if and only if a_i = a_{k-i} a_i = a_{k-i} for all i i . Zero is written 0 in any base and is also palindromic by definition. Given any positive decimal integer N N and a base b b , you are supposed to tell if N N is a palindromic number in base b b . Input Specification Each input file contains one test case. Each case consists of two positive numbers N N and b b , where 0 < N \\le 10^9 0 < N \\le 10^9 is the decimal number and 2 \\le b \\le 10^9 2 \\le b \\le 10^9 is the base. The numbers are separated by a space. Output Specification For each test case, first print in one line Yes if N N is a palindromic number in base b b , or No if not. Then in the next line, print N N as the number in base b b in the form \" a_k a_k a_{k-1} a_{k-1} \u2026 a_0 a_0 \". Notice that there must be no extra space at the end of output. Sample Input 1 27 2 Sample Output 1 Yes 1 1 0 1 1 Sample Input 2 121 5 Sample Output 2 No 4 4 1 \u9e23\u8c22\u7f51\u53cb\u201cCCPC\u62ff\u4e0d\u5230\u724c\u4e0d\u6539\u540d\u201d\u4fee\u6b63\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1020-Tree%20Traversals/","text":"1020 Tree Traversals Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 30 \\le 30 ), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 Sample Output 4 1 6 3 5 7 2","title":"1020-Tree Traversals"},{"location":"PAT-Advanced-Level/1020-Tree%20Traversals/#1020-tree-traversals","text":"","title":"1020 Tree Traversals"},{"location":"PAT-Advanced-Level/1020-Tree%20Traversals/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 30 \\le 30 ), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 Sample Output 4 1 6 3 5 7 2","title":"Statement"},{"location":"PAT-Advanced-Level/1021-Deepest%20Root/","text":"1021 Deepest Root Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root . Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^4 \\le 10^4 ) which is the number of nodes, and hence the nodes are numbered from 1 to N N . Then N-1 N-1 lines follow, each describes an edge by given the two adjacent nodes' numbers. Output Specification For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph. Sample Input 1 5 1 2 1 3 1 4 2 5 Sample Output 1 3 4 5 Sample Input 2 5 1 3 1 4 2 5 3 4 Sample Output 2 Error: 2 components","title":"1021-Deepest Root"},{"location":"PAT-Advanced-Level/1021-Deepest%20Root/#1021-deepest-root","text":"","title":"1021 Deepest Root"},{"location":"PAT-Advanced-Level/1021-Deepest%20Root/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root . Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^4 \\le 10^4 ) which is the number of nodes, and hence the nodes are numbered from 1 to N N . Then N-1 N-1 lines follow, each describes an edge by given the two adjacent nodes' numbers. Output Specification For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph. Sample Input 1 5 1 2 1 3 1 4 2 5 Sample Output 1 3 4 5 Sample Input 2 5 1 3 1 4 2 5 3 4 Sample Output 2 Error: 2 components","title":"Statement"},{"location":"PAT-Advanced-Level/1022-Digital%20Library/","text":"1022 Digital Library Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID's. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^4 \\le 10^4 ) which is the total number of books. Then N N blocks follow, each contains the information of a book in 6 lines: Line #1: the 7-digit ID number; Line #2: the book title \u2013 a string of no more than 80 characters; Line #3: the author \u2013 a string of no more than 80 characters; Line #4: the key words \u2013 each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space; Line #5: the publisher \u2013 a string of no more than 80 characters; Line #6: the published year \u2013 a 4-digit number which is in the range [1000, 3000]. It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers. After the book information, there is a line containing a positive integer M M ( \\le 1000 \\le 1000 ) which is the number of user's search queries. Then M M lines follow, each in one of the formats shown below: 1: a book title 2: name of an author 3: a key word 4: name of a publisher 5: a 4-digit number representing the year Output Specification For each query, first print the original query in a line, then output the resulting book ID's in increasing order, each occupying a line. If no book is found, print Not Found instead. Sample Input 3 1111111 The Testing Book Yue Chen test code debug sort keywords ZUCS Print 2011 3333333 Another Testing Book Yue Chen test code sort keywords ZUCS Print2 2012 2222222 The Testing Book CYLL keywords debug book ZUCS Print2 2011 6 1: The Testing Book 2: Yue Chen 3: keywords 4: ZUCS Print 5: 2011 3: blablabla Sample Output 1: The Testing Book 1111111 2222222 2: Yue Chen 1111111 3333333 3: keywords 1111111 2222222 3333333 4: ZUCS Print 1111111 5: 2011 1111111 2222222 3: blablabla Not Found","title":"1022-Digital Library"},{"location":"PAT-Advanced-Level/1022-Digital%20Library/#1022-digital-library","text":"","title":"1022 Digital Library"},{"location":"PAT-Advanced-Level/1022-Digital%20Library/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID's. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^4 \\le 10^4 ) which is the total number of books. Then N N blocks follow, each contains the information of a book in 6 lines: Line #1: the 7-digit ID number; Line #2: the book title \u2013 a string of no more than 80 characters; Line #3: the author \u2013 a string of no more than 80 characters; Line #4: the key words \u2013 each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space; Line #5: the publisher \u2013 a string of no more than 80 characters; Line #6: the published year \u2013 a 4-digit number which is in the range [1000, 3000]. It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers. After the book information, there is a line containing a positive integer M M ( \\le 1000 \\le 1000 ) which is the number of user's search queries. Then M M lines follow, each in one of the formats shown below: 1: a book title 2: name of an author 3: a key word 4: name of a publisher 5: a 4-digit number representing the year Output Specification For each query, first print the original query in a line, then output the resulting book ID's in increasing order, each occupying a line. If no book is found, print Not Found instead. Sample Input 3 1111111 The Testing Book Yue Chen test code debug sort keywords ZUCS Print 2011 3333333 Another Testing Book Yue Chen test code sort keywords ZUCS Print2 2012 2222222 The Testing Book CYLL keywords debug book ZUCS Print2 2011 6 1: The Testing Book 2: Yue Chen 3: keywords 4: ZUCS Print 5: 2011 3: blablabla Sample Output 1: The Testing Book 1111111 2222222 2: Yue Chen 1111111 3333333 3: keywords 1111111 2222222 3333333 4: ZUCS Print 1111111 5: 2011 1111111 2222222 3: blablabla Not Found","title":"Statement"},{"location":"PAT-Advanced-Level/1023-Have%20Fun%20with%20Numbers/","text":"1023 Have Fun with Numbers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again! Now you are suppose to check if there are more numbers with this property. That is, double a given number with k k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number. Input Specification Each input contains one test case. Each case contains one positive integer with no more than 20 digits. Output Specification For each test case, first print in a line \"Yes\" if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or \"No\" if not. Then in the next line, print the doubled number. Sample Input 1234567899 Sample Output Yes 2469135798 Solution C++ #include <bits/stdc++.h> using namespace std ; string time ( string s ) { int i , len = s . size (), num = 0 ; string s1 ; for ( i = len - 1 ; i >= 0 ; i -- ) { num += ( s [ i ] - '0' ) * 2 ; s1 += num % 10 + '0' ; num /= 10 ; } if ( num ) s1 += num + '0' ; return s1 ; } int main () { string s , s1 ; cin >> s ; s1 = time ( s ); int len1 = s1 . size (), i , ans [ 10 ] = { 0 }, len = s . size (); for ( i = 0 ; i < len ; i ++ ) ans [ s [ i ] - '0' ] ++ ; for ( i = 0 ; i < len ; i ++ ) ans [ s1 [ i ] - '0' ] -- ; for ( i = 0 ; i < 10 ; i ++ ) { if ( ans [ i ]) { cout << \"No \\n \" ; goto a ; } } cout << \"Yes \\n \" ; a : for ( i = len1 - 1 ; i >= 0 ; i -- ) cout << s1 [ i ]; cout << endl ; }","title":"1023-Have Fun with Numbers"},{"location":"PAT-Advanced-Level/1023-Have%20Fun%20with%20Numbers/#1023-have-fun-with-numbers","text":"","title":"1023 Have Fun with Numbers"},{"location":"PAT-Advanced-Level/1023-Have%20Fun%20with%20Numbers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again! Now you are suppose to check if there are more numbers with this property. That is, double a given number with k k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number. Input Specification Each input contains one test case. Each case contains one positive integer with no more than 20 digits. Output Specification For each test case, first print in a line \"Yes\" if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or \"No\" if not. Then in the next line, print the doubled number. Sample Input 1234567899 Sample Output Yes 2469135798","title":"Statement"},{"location":"PAT-Advanced-Level/1023-Have%20Fun%20with%20Numbers/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; string time ( string s ) { int i , len = s . size (), num = 0 ; string s1 ; for ( i = len - 1 ; i >= 0 ; i -- ) { num += ( s [ i ] - '0' ) * 2 ; s1 += num % 10 + '0' ; num /= 10 ; } if ( num ) s1 += num + '0' ; return s1 ; } int main () { string s , s1 ; cin >> s ; s1 = time ( s ); int len1 = s1 . size (), i , ans [ 10 ] = { 0 }, len = s . size (); for ( i = 0 ; i < len ; i ++ ) ans [ s [ i ] - '0' ] ++ ; for ( i = 0 ; i < len ; i ++ ) ans [ s1 [ i ] - '0' ] -- ; for ( i = 0 ; i < 10 ; i ++ ) { if ( ans [ i ]) { cout << \"No \\n \" ; goto a ; } } cout << \"Yes \\n \" ; a : for ( i = len1 - 1 ; i >= 0 ; i -- ) cout << s1 [ i ]; cout << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1024-Palindromic%20Number/","text":"1024 Palindromic Number Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A number that will be the same when it is written forwards or backwards is known as a Palindromic Number . For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484. Given any positive integer N N , you are supposed to find its paired palindromic number and the number of steps taken to find it. Input Specification Each input file contains one test case. Each case consists of two positive numbers N N and K K , where N N ( \\le 10^{10} \\le 10^{10} ) is the initial numer and K K ( \\le 100 \\le 100 ) is the maximum number of steps. The numbers are separated by a space. Output Specification For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N N , and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K K steps, just output the number obtained at the K K th step and K K instead. Sample Input 1 67 3 Sample Output 1 484 2 Sample Input 2 69 3 Sample Output 2 1353 3","title":"1024-Palindromic Number"},{"location":"PAT-Advanced-Level/1024-Palindromic%20Number/#1024-palindromic-number","text":"","title":"1024 Palindromic Number"},{"location":"PAT-Advanced-Level/1024-Palindromic%20Number/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A number that will be the same when it is written forwards or backwards is known as a Palindromic Number . For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484. Given any positive integer N N , you are supposed to find its paired palindromic number and the number of steps taken to find it. Input Specification Each input file contains one test case. Each case consists of two positive numbers N N and K K , where N N ( \\le 10^{10} \\le 10^{10} ) is the initial numer and K K ( \\le 100 \\le 100 ) is the maximum number of steps. The numbers are separated by a space. Output Specification For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N N , and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K K steps, just output the number obtained at the K K th step and K K instead. Sample Input 1 67 3 Sample Output 1 484 2 Sample Input 2 69 3 Sample Output 2 1353 3","title":"Statement"},{"location":"PAT-Advanced-Level/1025-PAT%20Ranking/","text":"1025 PAT Ranking Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification Each input file contains one test case. For each case, the first line contains a positive number N N ( \\le 100 \\le 100 ), the number of test locations. Then N N ranklists follow, each starts with a line containing a positive integer K K ( \\le 300 \\le 300 ), the number of testees, and then K K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rank The locations are numbered from 1 to N N . The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input 2 5 1234567890001 95 1234567890005 100 1234567890003 95 1234567890002 77 1234567890004 85 4 1234567890013 65 1234567890011 25 1234567890014 100 1234567890012 85 Sample Output 9 1234567890005 1 1 1 1234567890014 1 2 1 1234567890001 3 1 2 1234567890003 3 1 2 1234567890004 5 1 4 1234567890012 5 2 2 1234567890002 7 1 5 1234567890013 8 2 3 1234567890011 9 2 4","title":"1025-PAT Ranking"},{"location":"PAT-Advanced-Level/1025-PAT%20Ranking/#1025-pat-ranking","text":"","title":"1025 PAT Ranking"},{"location":"PAT-Advanced-Level/1025-PAT%20Ranking/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification Each input file contains one test case. For each case, the first line contains a positive number N N ( \\le 100 \\le 100 ), the number of test locations. Then N N ranklists follow, each starts with a line containing a positive integer K K ( \\le 300 \\le 300 ), the number of testees, and then K K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rank The locations are numbered from 1 to N N . The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input 2 5 1234567890001 95 1234567890005 100 1234567890003 95 1234567890002 77 1234567890004 85 4 1234567890013 65 1234567890011 25 1234567890014 100 1234567890012 85 Sample Output 9 1234567890005 1 1 1 1234567890014 1 2 1 1234567890001 3 1 2 1234567890003 3 1 2 1234567890004 5 1 4 1234567890012 5 2 2 1234567890002 7 1 5 1234567890013 8 2 3 1234567890011 9 2 4","title":"Statement"},{"location":"PAT-Advanced-Level/1026-Table%20Tennis/","text":"1026 Table Tennis Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours. Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day. One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the privilege to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players. Input Specification Each input file contains one test case. For each case, the first line contains an integer N ( \\le \\le 10000) - the total number of pairs of players. Then N lines follow, each contains 2 times and a VIP tag: HH:MM:SS - the arriving time, P - the playing time in minutes of a pair of players, and tag - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players' info, there are 2 positive integers: K ( \\le \\le 100) - the number of tables, and M ( < < K) - the number of VIP tables. The last line contains M table numbers. Output Specification For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed. Sample Input 10 20:52:00 10 0 08:00:00 20 0 08:02:00 30 0 20:51:00 10 0 08:10:00 30 0 08:12:00 10 1 20:40:00 13 0 08:01:30 15 1 20:53:00 10 1 20:54:00 10 0 3 1 2 Sample Output 08:00:00 08:00:00 0 08:01:30 08:01:30 0 08:02:00 08:02:00 0 08:12:00 08:16:30 5 08:10:00 08:20:00 10 20:40:00 20:40:00 0 20:51:00 20:51:00 0 20:52:00 20:52:00 0 20:53:00 20:53:00 0 4 3 2 \u9e23\u8c22\u7528\u6237 \u9ec4\u5353\u658c \u8865\u5145\u6570\u636e\uff01\u9e23\u8c22\u7528\u6237 \u5f90\u5411\u8363 \u4fee\u6b63\u6807\u7a0b\uff01","title":"1026-Table Tennis"},{"location":"PAT-Advanced-Level/1026-Table%20Tennis/#1026-table-tennis","text":"","title":"1026 Table Tennis"},{"location":"PAT-Advanced-Level/1026-Table%20Tennis/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours. Your job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day. One thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the privilege to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players. Input Specification Each input file contains one test case. For each case, the first line contains an integer N ( \\le \\le 10000) - the total number of pairs of players. Then N lines follow, each contains 2 times and a VIP tag: HH:MM:SS - the arriving time, P - the playing time in minutes of a pair of players, and tag - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players' info, there are 2 positive integers: K ( \\le \\le 100) - the number of tables, and M ( < < K) - the number of VIP tables. The last line contains M table numbers. Output Specification For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed. Sample Input 10 20:52:00 10 0 08:00:00 20 0 08:02:00 30 0 20:51:00 10 0 08:10:00 30 0 08:12:00 10 1 20:40:00 13 0 08:01:30 15 1 20:53:00 10 1 20:54:00 10 0 3 1 2 Sample Output 08:00:00 08:00:00 0 08:01:30 08:01:30 0 08:02:00 08:02:00 0 08:12:00 08:16:30 5 08:10:00 08:20:00 10 20:40:00 20:40:00 0 20:51:00 20:51:00 0 20:52:00 20:52:00 0 20:53:00 20:53:00 0 4 3 2 \u9e23\u8c22\u7528\u6237 \u9ec4\u5353\u658c \u8865\u5145\u6570\u636e\uff01\u9e23\u8c22\u7528\u6237 \u5f90\u5411\u8363 \u4fee\u6b63\u6807\u7a0b\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1027-Colors%20in%20Mars/","text":"1027 Colors in Mars Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red , the middle 2 digits for Green , and the last 2 digits for Blue . The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Specification Each input file contains one test case which occupies a line containing the three decimal color values. Output Specification For each test case you should output the Mars RGB value in the following format: first output # , then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left. Sample Input 15 43 71 Sample Output #123456 Solution C++ #include <bits/stdc++.h> using namespace std ; string tran ( int x ) { int a , b ; a = x % 13 ; x /= 13 ; b = x % 13 ; string s = \"\" ; if ( b <= 9 ) s += b + '0' ; else s += 'A' + b - 10 ; if ( a <= 9 ) s += a + '0' ; else s += 'A' + a - 10 ; return s ; } int main () { int a , b , c ; cin >> a >> b >> c ; cout << \"#\" << tran ( a ) << tran ( b ) << tran ( c ) << endl ; }","title":"1027-Colors in Mars"},{"location":"PAT-Advanced-Level/1027-Colors%20in%20Mars/#1027-colors-in-mars","text":"","title":"1027 Colors in Mars"},{"location":"PAT-Advanced-Level/1027-Colors%20in%20Mars/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red , the middle 2 digits for Green , and the last 2 digits for Blue . The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Specification Each input file contains one test case which occupies a line containing the three decimal color values. Output Specification For each test case you should output the Mars RGB value in the following format: first output # , then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left. Sample Input 15 43 71 Sample Output #123456","title":"Statement"},{"location":"PAT-Advanced-Level/1027-Colors%20in%20Mars/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; string tran ( int x ) { int a , b ; a = x % 13 ; x /= 13 ; b = x % 13 ; string s = \"\" ; if ( b <= 9 ) s += b + '0' ; else s += 'A' + b - 10 ; if ( a <= 9 ) s += a + '0' ; else s += 'A' + a - 10 ; return s ; } int main () { int a , b , c ; cin >> a >> b >> c ; cout << \"#\" << tran ( a ) << tran ( b ) << tran ( c ) << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1028-List%20Sorting/","text":"1028 List Sorting Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Excel can sort records according to any column. Now you are supposed to imitate this function. Input Specification Each input file contains one test case. For each case, the first line contains two integers N N ( \\le 10^5 \\le 10^5 ) and C C , where N N is the number of records and C C is the column that you are supposed to sort the records with. Then N N lines follow, each contains a record of a student. A student's record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive). Output Specification For each test case, output the sorting result in N N lines. That is, if C C = 1 then the records must be sorted in increasing order according to ID's; if C C = 2 then the records must be sorted in non-decreasing order according to names; and if C C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID's in increasing order. Sample Input 1 3 1 000007 James 85 000010 Amy 90 000001 Zoe 60 Sample Output 1 000001 Zoe 60 000007 James 85 000010 Amy 90 Sample Input 2 4 2 000007 James 85 000010 Amy 90 000001 Zoe 60 000002 James 98 Sample Output 2 000010 Amy 90 000002 James 98 000007 James 85 000001 Zoe 60 Sample Input 3 4 3 000007 James 85 000010 Amy 90 000001 Zoe 60 000002 James 9 Sample Output 3 000002 James 9 000001 Zoe 60 000007 James 85 000010 Amy 90 \u9e23\u8c22\u7528\u6237 wangzhj \u8865\u5145\u6570\u636e\uff01 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int id , g ; char name [ 10 ]; } a [ maxn ]; bool comp_1 ( Node x , Node y ) { return x . id < y . id ; } bool comp_2 ( Node x , Node y ) { if ( strcmp ( x . name , y . name ) == 0 ) return x . id < y . id ; return strcmp ( x . name , y . name ) > 0 ? 0 : 1 ; } bool comp_3 ( Node x , Node y ) { if ( x . g == y . g ) return x . id < y . id ; return x . g < y . g ; } int main () { int n , c ; scanf ( \"%d%d\" , & n , & c ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d%s%d\" , & a [ i ]. id , & a [ i ]. name , & a [ i ]. g ); if ( c == 1 ) sort ( a , a + n , comp_1 ); else if ( c == 2 ) sort ( a , a + n , comp_2 ); else if ( c == 3 ) sort ( a , a + n , comp_3 ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%06d %s %d \\n \" , a [ i ]. id , a [ i ]. name , a [ i ]. g ); }","title":"1028-List Sorting"},{"location":"PAT-Advanced-Level/1028-List%20Sorting/#1028-list-sorting","text":"","title":"1028 List Sorting"},{"location":"PAT-Advanced-Level/1028-List%20Sorting/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Excel can sort records according to any column. Now you are supposed to imitate this function. Input Specification Each input file contains one test case. For each case, the first line contains two integers N N ( \\le 10^5 \\le 10^5 ) and C C , where N N is the number of records and C C is the column that you are supposed to sort the records with. Then N N lines follow, each contains a record of a student. A student's record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive). Output Specification For each test case, output the sorting result in N N lines. That is, if C C = 1 then the records must be sorted in increasing order according to ID's; if C C = 2 then the records must be sorted in non-decreasing order according to names; and if C C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID's in increasing order. Sample Input 1 3 1 000007 James 85 000010 Amy 90 000001 Zoe 60 Sample Output 1 000001 Zoe 60 000007 James 85 000010 Amy 90 Sample Input 2 4 2 000007 James 85 000010 Amy 90 000001 Zoe 60 000002 James 98 Sample Output 2 000010 Amy 90 000002 James 98 000007 James 85 000001 Zoe 60 Sample Input 3 4 3 000007 James 85 000010 Amy 90 000001 Zoe 60 000002 James 9 Sample Output 3 000002 James 9 000001 Zoe 60 000007 James 85 000010 Amy 90 \u9e23\u8c22\u7528\u6237 wangzhj \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1028-List%20Sorting/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { int id , g ; char name [ 10 ]; } a [ maxn ]; bool comp_1 ( Node x , Node y ) { return x . id < y . id ; } bool comp_2 ( Node x , Node y ) { if ( strcmp ( x . name , y . name ) == 0 ) return x . id < y . id ; return strcmp ( x . name , y . name ) > 0 ? 0 : 1 ; } bool comp_3 ( Node x , Node y ) { if ( x . g == y . g ) return x . id < y . id ; return x . g < y . g ; } int main () { int n , c ; scanf ( \"%d%d\" , & n , & c ); for ( int i = 0 ; i < n ; i ++ ) scanf ( \"%d%s%d\" , & a [ i ]. id , & a [ i ]. name , & a [ i ]. g ); if ( c == 1 ) sort ( a , a + n , comp_1 ); else if ( c == 2 ) sort ( a , a + n , comp_2 ); else if ( c == 3 ) sort ( a , a + n , comp_3 ); for ( int i = 0 ; i < n ; i ++ ) printf ( \"%06d %s %d \\n \" , a [ i ]. id , a [ i ]. name , a [ i ]. g ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1029-Median/","text":"1029 Median Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13. Given two increasing sequences of integers, you are asked to find their median. Input Specification Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N ( \\le 2\\times 10^5 \\le 2\\times 10^5 ) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int . Output Specification For each test case you should output the median of the two given sequences in a line. Sample Input 4 11 12 13 14 5 9 10 15 16 17 Sample Output 13","title":"1029-Median"},{"location":"PAT-Advanced-Level/1029-Median/#1029-median","text":"","title":"1029 Median"},{"location":"PAT-Advanced-Level/1029-Median/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13. Given two increasing sequences of integers, you are asked to find their median. Input Specification Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N ( \\le 2\\times 10^5 \\le 2\\times 10^5 ) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int . Output Specification For each test case you should output the median of the two given sequences in a line. Sample Input 4 11 12 13 14 5 9 10 15 16 17 Sample Output 13","title":"Statement"},{"location":"PAT-Advanced-Level/1030-Travel%20Plan/","text":"1030 Travel Plan Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A traveler's map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification Each input file contains one test case. Each case starts with a line containing 4 positive integers N N , M M , S S , and D D , where N N ( \\le 500 \\le 500 ) is the number of cities (and hence the cities are numbered from 0 to N-1 N-1 ); M M is the number of highways; S S and D D are the starting and the destination cities, respectively. Then M M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input 4 5 0 3 0 1 1 20 1 3 2 30 0 3 4 10 0 2 2 20 2 3 1 20 Sample Output 0 2 3 3 40","title":"1030-Travel Plan"},{"location":"PAT-Advanced-Level/1030-Travel%20Plan/#1030-travel-plan","text":"","title":"1030 Travel Plan"},{"location":"PAT-Advanced-Level/1030-Travel%20Plan/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A traveler's map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification Each input file contains one test case. Each case starts with a line containing 4 positive integers N N , M M , S S , and D D , where N N ( \\le 500 \\le 500 ) is the number of cities (and hence the cities are numbered from 0 to N-1 N-1 ); M M is the number of highways; S S and D D are the starting and the destination cities, respectively. Then M M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input 4 5 0 3 0 1 1 20 1 3 2 30 0 3 4 10 0 2 2 20 2 3 1 20 Sample Output 0 2 3 3 40","title":"Statement"},{"location":"PAT-Advanced-Level/1031-Hello%20World%20for%20U/","text":"1031 Hello World for U Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given any string of N N ( \\ge 5 \\ge 5 ) characters, you are asked to form the characters into the shape of U . For example, helloworld can be printed as: h d e l l r lowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n_1 n_1 characters, then left to right along the bottom line with n_2 n_2 characters, and finally bottom-up along the vertical line with n_3 n_3 characters. And more, we would like U to be as squared as possible \u2013 that is, it must be satisfied that n_1 = n_3 = max n_1 = n_3 = max { k k | k \\le n_2 k \\le n_2 for all 3 \\le n_2 \\le N 3 \\le n_2 \\le N } with n_1 + n_2 + n_3 - 2 = N n_1 + n_2 + n_3 - 2 = N . Input Specification Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification For each test case, print the input string in the shape of U as specified in the description. Sample Input helloworld! Sample Output h ! e d l l lowor","title":"1031-Hello World for U"},{"location":"PAT-Advanced-Level/1031-Hello%20World%20for%20U/#1031-hello-world-for-u","text":"","title":"1031 Hello World for U"},{"location":"PAT-Advanced-Level/1031-Hello%20World%20for%20U/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given any string of N N ( \\ge 5 \\ge 5 ) characters, you are asked to form the characters into the shape of U . For example, helloworld can be printed as: h d e l l r lowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n_1 n_1 characters, then left to right along the bottom line with n_2 n_2 characters, and finally bottom-up along the vertical line with n_3 n_3 characters. And more, we would like U to be as squared as possible \u2013 that is, it must be satisfied that n_1 = n_3 = max n_1 = n_3 = max { k k | k \\le n_2 k \\le n_2 for all 3 \\le n_2 \\le N 3 \\le n_2 \\le N } with n_1 + n_2 + n_3 - 2 = N n_1 + n_2 + n_3 - 2 = N . Input Specification Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification For each test case, print the input string in the shape of U as specified in the description. Sample Input helloworld! Sample Output h ! e d l l lowor","title":"Statement"},{"location":"PAT-Advanced-Level/1032-Sharing/","text":"1032 Sharing Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1. Figure 1 You are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1). Input Specification Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N N ( \\le 10^5 \\le 10^5 ), where the two addresses are the addresses of the first nodes of the two words, and N N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node. Output Specification For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead. Sample Input 1 11111 22222 9 67890 i 00002 00010 a 12345 00003 g -1 12345 D 67890 00002 n 00003 22222 B 23456 11111 L 00001 23456 e 67890 00001 o 00010 Sample Output 1 67890 Sample Input 2 00001 00002 4 00001 a 10001 10001 s -1 00002 a 10002 10002 t -1 Sample Output 2 -1","title":"1032-Sharing"},{"location":"PAT-Advanced-Level/1032-Sharing/#1032-sharing","text":"","title":"1032 Sharing"},{"location":"PAT-Advanced-Level/1032-Sharing/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1. Figure 1 You are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1). Input Specification Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N N ( \\le 10^5 \\le 10^5 ), where the two addresses are the addresses of the first nodes of the two words, and N N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node. Output Specification For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead. Sample Input 1 11111 22222 9 67890 i 00002 00010 a 12345 00003 g -1 12345 D 67890 00002 n 00003 22222 B 23456 11111 L 00001 23456 e 67890 00001 o 00010 Sample Output 1 67890 Sample Input 2 00001 00002 4 00001 a 10001 10001 s -1 00002 a 10002 10002 t -1 Sample Output 2 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1033-To%20Fill%20or%20Not%20to%20Fill/","text":"1033 To Fill or Not to Fill Statement Metadata \u4f5c\u8005: ZHANG, Guochuan \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive numbers: C_{max} C_{max} ( \\le \\le 100), the maximum capacity of the tank; D D ( \\le \\le 30000), the distance between Hangzhou and the destination city; D_{avg} D_{avg} ( \\le \\le 20), the average distance per unit gas that the car can run; and N N ( \\le \\le 500), the total number of gas stations. Then N N lines follow, each contains a pair of non-negative numbers: P_i P_i , the unit gas price, and D_i D_i ( \\le D \\le D ), the distance between this station and Hangzhou, for i=1,\\cdots ,N i=1,\\cdots ,N . All the numbers in a line are separated by a space. Output Specification For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1 50 1300 12 8 6.00 1250 7.00 600 7.00 150 7.10 0 7.20 200 7.50 400 7.30 1000 6.85 300 Sample Output 1 749.17 Sample Input 2 50 1300 12 2 7.10 0 7.00 600 Sample Output 2 The maximum travel distance = 1200.00","title":"1033-To Fill or Not to Fill"},{"location":"PAT-Advanced-Level/1033-To%20Fill%20or%20Not%20to%20Fill/#1033-to-fill-or-not-to-fill","text":"","title":"1033 To Fill or Not to Fill"},{"location":"PAT-Advanced-Level/1033-To%20Fill%20or%20Not%20to%20Fill/#statement","text":"Metadata \u4f5c\u8005: ZHANG, Guochuan \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive numbers: C_{max} C_{max} ( \\le \\le 100), the maximum capacity of the tank; D D ( \\le \\le 30000), the distance between Hangzhou and the destination city; D_{avg} D_{avg} ( \\le \\le 20), the average distance per unit gas that the car can run; and N N ( \\le \\le 500), the total number of gas stations. Then N N lines follow, each contains a pair of non-negative numbers: P_i P_i , the unit gas price, and D_i D_i ( \\le D \\le D ), the distance between this station and Hangzhou, for i=1,\\cdots ,N i=1,\\cdots ,N . All the numbers in a line are separated by a space. Output Specification For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1 50 1300 12 8 6.00 1250 7.00 600 7.00 150 7.10 0 7.20 200 7.50 400 7.30 1000 6.85 300 Sample Output 1 749.17 Sample Input 2 50 1300 12 2 7.10 0 7.00 600 Sample Output 2 The maximum travel distance = 1200.00","title":"Statement"},{"location":"PAT-Advanced-Level/1034-Head%20of%20a%20Gang/","text":"1034 Head of a Gang Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB One way that the police finds the head of a gang is to check people's phone calls. If there is a phone call between A A and B B , we say that A A and B B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A \"Gang\" is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K K . In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification Each input file contains one test case. For each case, the first line contains two positive numbers N N and K K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N N lines follow, each in the following format: Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A - Z . A time length is a positive integer which is no more than 1000 minutes. Output Specification For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1 8 59 AAA BBB 10 BBB AAA 20 AAA CCC 40 DDD EEE 5 EEE DDD 70 FFF GGG 30 GGG HHH 20 HHH FFF 10 Sample Output 1 2 AAA 3 GGG 3 Sample Input 2 8 70 AAA BBB 10 BBB AAA 20 AAA CCC 40 DDD EEE 5 EEE DDD 70 FFF GGG 30 GGG HHH 20 HHH FFF 10 Sample Output 2 0","title":"1034-Head of a Gang"},{"location":"PAT-Advanced-Level/1034-Head%20of%20a%20Gang/#1034-head-of-a-gang","text":"","title":"1034 Head of a Gang"},{"location":"PAT-Advanced-Level/1034-Head%20of%20a%20Gang/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB One way that the police finds the head of a gang is to check people's phone calls. If there is a phone call between A A and B B , we say that A A and B B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A \"Gang\" is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K K . In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification Each input file contains one test case. For each case, the first line contains two positive numbers N N and K K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N N lines follow, each in the following format: Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A - Z . A time length is a positive integer which is no more than 1000 minutes. Output Specification For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1 8 59 AAA BBB 10 BBB AAA 20 AAA CCC 40 DDD EEE 5 EEE DDD 70 FFF GGG 30 GGG HHH 20 HHH FFF 10 Sample Output 1 2 AAA 3 GGG 3 Sample Input 2 8 70 AAA BBB 10 BBB AAA 20 AAA CCC 40 DDD EEE 5 EEE DDD 70 FFF GGG 30 GGG HHH 20 HHH FFF 10 Sample Output 2 0","title":"Statement"},{"location":"PAT-Advanced-Level/1035-Password/","text":"1035 Password Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l ( L in lowercase), or 0 (zero) from O ( o in uppercase). One solution is to replace 1 (one) by @ , 0 (zero) by % , l by L , and O by o . Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords. Input Specification Each input file contains one test case. Each case contains a positive integer N N ( \\le 1000 \\le 1000 ), followed by N N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space. Output Specification For each test case, first print the number M M of accounts that have been modified, then print in the following M M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead. Sample Input 1 3 Team000002 Rlsp0dfa Team000003 perfectpwd Team000001 R1spOdfa Sample Output 1 2 Team000002 RLsp%dfa Team000001 R@spodfa Sample Input 2 1 team110 abcdefg332 Sample Output 2 There is 1 account and no account is modified Sample Input 3 2 team110 abcdefg222 team220 abcdefg333 Sample Output 3 There are 2 accounts and no account is modified Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 struct pp { string s1 , s2 ; } a [ MAXN ]; int main () { int n , i , j , total = 0 , len , flag ; cin >> n ; string s1 , s2 ; map < char , char > q ; q [ '1' ] = '@' , q [ '0' ] = '%' , q [ 'l' ] = 'L' , q [ 'O' ] = 'o' ; for ( i = 0 ; i < n ; i ++ ) { flag = 0 ; cin >> s1 >> s2 ; len = s2 . size (); for ( j = 0 ; j < len ; j ++ ) { if ( s2 [ j ] == '1' || s2 [ j ] == '0' || s2 [ j ] == 'l' || s2 [ j ] == 'O' ) { flag = 1 ; s2 [ j ] = q [ s2 [ j ]]; } } if ( flag ) { a [ total ]. s1 = s1 , a [ total ]. s2 = s2 ; total ++ ; } } if ( total ) { cout << total << endl ; for ( i = 0 ; i < total ; i ++ ) cout << a [ i ]. s1 << \" \" << a [ i ]. s2 << endl ; } else if ( n == 1 ) printf ( \"There is 1 account and no account is modified \\n \" ); else if ( n > 1 ) printf ( \"There are %d accounts and no account is modified \\n \" , n ); }","title":"1035-Password"},{"location":"PAT-Advanced-Level/1035-Password/#1035-password","text":"","title":"1035 Password"},{"location":"PAT-Advanced-Level/1035-Password/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l ( L in lowercase), or 0 (zero) from O ( o in uppercase). One solution is to replace 1 (one) by @ , 0 (zero) by % , l by L , and O by o . Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords. Input Specification Each input file contains one test case. Each case contains a positive integer N N ( \\le 1000 \\le 1000 ), followed by N N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space. Output Specification For each test case, first print the number M M of accounts that have been modified, then print in the following M M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead. Sample Input 1 3 Team000002 Rlsp0dfa Team000003 perfectpwd Team000001 R1spOdfa Sample Output 1 2 Team000002 RLsp%dfa Team000001 R@spodfa Sample Input 2 1 team110 abcdefg332 Sample Output 2 There is 1 account and no account is modified Sample Input 3 2 team110 abcdefg222 team220 abcdefg333 Sample Output 3 There are 2 accounts and no account is modified","title":"Statement"},{"location":"PAT-Advanced-Level/1035-Password/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 struct pp { string s1 , s2 ; } a [ MAXN ]; int main () { int n , i , j , total = 0 , len , flag ; cin >> n ; string s1 , s2 ; map < char , char > q ; q [ '1' ] = '@' , q [ '0' ] = '%' , q [ 'l' ] = 'L' , q [ 'O' ] = 'o' ; for ( i = 0 ; i < n ; i ++ ) { flag = 0 ; cin >> s1 >> s2 ; len = s2 . size (); for ( j = 0 ; j < len ; j ++ ) { if ( s2 [ j ] == '1' || s2 [ j ] == '0' || s2 [ j ] == 'l' || s2 [ j ] == 'O' ) { flag = 1 ; s2 [ j ] = q [ s2 [ j ]]; } } if ( flag ) { a [ total ]. s1 = s1 , a [ total ]. s2 = s2 ; total ++ ; } } if ( total ) { cout << total << endl ; for ( i = 0 ; i < total ; i ++ ) cout << a [ i ]. s1 << \" \" << a [ i ]. s2 << endl ; } else if ( n == 1 ) printf ( \"There is 1 account and no account is modified \\n \" ); else if ( n > 1 ) printf ( \"There are %d accounts and no account is modified \\n \" , n ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1036-Boys%20vs%20Girls/","text":"1036 Boys vs Girls Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification Each input file contains one test case. Each case contains a positive integer N N , followed by N N lines of student information. Each line contains a student's name , gender , ID and grade , separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference grade_F-grade_M grade_F-grade_M . If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead. Sample Input 1 3 Joe M Math990112 89 Mike M CS991301 100 Mary F EE990830 95 Sample Output 1 Mary EE990830 Joe Math990112 6 Sample Input 2 1 Jean M AA980920 60 Sample Output 2 Absent Jean AA980920 NA Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , num , max = INT_MIN , min = INT_MAX ; string s1 , s2 , male_name = \"\" , male_ID = \"\" , female_name = \"\" , female_ID = \"\" ; char c ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> s1 ; scanf ( \" %c\" , & c ); cin >> s2 >> num ; if ( c == 'M' ) { if ( num < min ) { male_name = s1 ; male_ID = s2 ; min = num ; } } else { if ( num > max ) { max = num ; female_name = s1 ; female_ID = s2 ; } } } int flag = 1 ; if ( female_name != \"\" ) cout << female_name << \" \" << female_ID << endl ; else cout << \"Absent \\n \" , flag = 0 ; if ( male_name != \"\" ) cout << male_name << \" \" << male_ID << endl ; else cout << \"Absent \\n \" , flag = 0 ; if ( flag ) cout << max - min << endl ; else cout << \"NA \\n \" ; }","title":"1036-Boys vs Girls"},{"location":"PAT-Advanced-Level/1036-Boys%20vs%20Girls/#1036-boys-vs-girls","text":"","title":"1036 Boys vs Girls"},{"location":"PAT-Advanced-Level/1036-Boys%20vs%20Girls/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification Each input file contains one test case. Each case contains a positive integer N N , followed by N N lines of student information. Each line contains a student's name , gender , ID and grade , separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference grade_F-grade_M grade_F-grade_M . If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead. Sample Input 1 3 Joe M Math990112 89 Mike M CS991301 100 Mary F EE990830 95 Sample Output 1 Mary EE990830 Joe Math990112 6 Sample Input 2 1 Jean M AA980920 60 Sample Output 2 Absent Jean AA980920 NA","title":"Statement"},{"location":"PAT-Advanced-Level/1036-Boys%20vs%20Girls/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , num , max = INT_MIN , min = INT_MAX ; string s1 , s2 , male_name = \"\" , male_ID = \"\" , female_name = \"\" , female_ID = \"\" ; char c ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> s1 ; scanf ( \" %c\" , & c ); cin >> s2 >> num ; if ( c == 'M' ) { if ( num < min ) { male_name = s1 ; male_ID = s2 ; min = num ; } } else { if ( num > max ) { max = num ; female_name = s1 ; female_ID = s2 ; } } } int flag = 1 ; if ( female_name != \"\" ) cout << female_name << \" \" << female_ID << endl ; else cout << \"Absent \\n \" , flag = 0 ; if ( male_name != \"\" ) cout << male_name << \" \" << male_ID << endl ; else cout << \"Absent \\n \" , flag = 0 ; if ( flag ) cout << max - min << endl ; else cout << \"NA \\n \" ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1037-Magic%20Coupon/","text":"1037 Magic Coupon Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The magic shop in Mars is offering some magic coupons. Each coupon has an integer N N printed on it, meaning that when you use this coupon with a product, you may get N N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N N to this bonus product, you will have to pay the shop N N times the value of the bonus product\u2026 but hey, magically, they have some coupons with negative N N 's! For example, given a set of coupons { 1 2 4 -1 -1 }, and a set of product values { 7 6 -2 -2 -3 -3 } (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification Each input file contains one test case. For each case, the first line contains the number of coupons N_C N_C , followed by a line with N_C N_C coupon integers. Then the next line contains the number of products N_P N_P , followed by a line with N_P N_P product values. Here 1\\le N_C, N_P \\le 10^5 1\\le N_C, N_P \\le 10^5 , and it is guaranteed that all the numbers will not exceed 2^{30} 2^{30} . Output Specification For each test case, simply print in a line the maximum amount of money you can get back. Sample Input 4 1 2 4 -1 4 7 6 -2 -3 Sample Output 43","title":"1037-Magic Coupon"},{"location":"PAT-Advanced-Level/1037-Magic%20Coupon/#1037-magic-coupon","text":"","title":"1037 Magic Coupon"},{"location":"PAT-Advanced-Level/1037-Magic%20Coupon/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The magic shop in Mars is offering some magic coupons. Each coupon has an integer N N printed on it, meaning that when you use this coupon with a product, you may get N N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N N to this bonus product, you will have to pay the shop N N times the value of the bonus product\u2026 but hey, magically, they have some coupons with negative N N 's! For example, given a set of coupons { 1 2 4 -1 -1 }, and a set of product values { 7 6 -2 -2 -3 -3 } (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification Each input file contains one test case. For each case, the first line contains the number of coupons N_C N_C , followed by a line with N_C N_C coupon integers. Then the next line contains the number of products N_P N_P , followed by a line with N_P N_P product values. Here 1\\le N_C, N_P \\le 10^5 1\\le N_C, N_P \\le 10^5 , and it is guaranteed that all the numbers will not exceed 2^{30} 2^{30} . Output Specification For each test case, simply print in a line the maximum amount of money you can get back. Sample Input 4 1 2 4 -1 4 7 6 -2 -3 Sample Output 43","title":"Statement"},{"location":"PAT-Advanced-Level/1038-Recover%20the%20Smallest%20Number/","text":"1038 Recover the Smallest Number Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification Each input file contains one test case. Each case gives a positive integer N N ( \\le 10^4 \\le 10^4 ) followed by N N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification For each test case, print the smallest number in one line. Notice that the first digit must not be zero. Sample Input 5 32 321 3214 0229 87 Sample Output 22932132143287","title":"1038-Recover the Smallest Number"},{"location":"PAT-Advanced-Level/1038-Recover%20the%20Smallest%20Number/#1038-recover-the-smallest-number","text":"","title":"1038 Recover the Smallest Number"},{"location":"PAT-Advanced-Level/1038-Recover%20the%20Smallest%20Number/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification Each input file contains one test case. Each case gives a positive integer N N ( \\le 10^4 \\le 10^4 ) followed by N N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification For each test case, print the smallest number in one line. Notice that the first digit must not be zero. Sample Input 5 32 321 3214 0229 87 Sample Output 22932132143287","title":"Statement"},{"location":"PAT-Advanced-Level/1039-Course%20List%20for%20Student/","text":"1039 Course List for Student Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 40,000 \\le 40,000 ), the number of students who look for their course lists, and K K ( \\le 2,500 \\le 2,500 ), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K K ) in the following format: for each course i i , first the course index i i and the number of registered students N_i N_i ( \\le 200 \\le 200 ) are given in a line. Then in the next line, N_i N_i student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification For each test case, print your results in N N lines. Each line corresponds to one student, in the following format: first print the student's name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input 11 5 4 7 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 1 4 ANN0 BOB5 JAY9 LOR6 2 7 ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6 3 1 BOB5 5 9 AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9 Sample Output ZOE1 2 4 5 ANN0 3 1 2 5 BOB5 5 1 2 3 4 5 JOE4 1 2 JAY9 4 1 2 4 5 FRA8 3 2 4 5 DON2 2 4 5 AMY7 1 5 KAT3 3 2 4 5 LOR6 4 1 2 4 5 NON9 0","title":"1039-Course List for Student"},{"location":"PAT-Advanced-Level/1039-Course%20List%20for%20Student/#1039-course-list-for-student","text":"","title":"1039 Course List for Student"},{"location":"PAT-Advanced-Level/1039-Course%20List%20for%20Student/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 40,000 \\le 40,000 ), the number of students who look for their course lists, and K K ( \\le 2,500 \\le 2,500 ), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K K ) in the following format: for each course i i , first the course index i i and the number of registered students N_i N_i ( \\le 200 \\le 200 ) are given in a line. Then in the next line, N_i N_i student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification For each test case, print your results in N N lines. Each line corresponds to one student, in the following format: first print the student's name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input 11 5 4 7 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 1 4 ANN0 BOB5 JAY9 LOR6 2 7 ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6 3 1 BOB5 5 9 AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9 Sample Output ZOE1 2 4 5 ANN0 3 1 2 5 BOB5 5 1 2 3 4 5 JOE4 1 2 JAY9 4 1 2 4 5 FRA8 3 2 4 5 DON2 2 4 5 AMY7 1 5 KAT3 3 2 4 5 LOR6 4 1 2 4 5 NON9 0","title":"Statement"},{"location":"PAT-Advanced-Level/1040-Longest%20Symmetric%20String/","text":"1040 Longest Symmetric String Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&TAP symmetric? , the longest symmetric sub-string is s PAT&TAP s , hence you must output 11 . Input Specification Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification For each test case, simply print the maximum length in a line. Sample Input Is PAT&TAP symmetric? Sample Output 11","title":"1040-Longest Symmetric String"},{"location":"PAT-Advanced-Level/1040-Longest%20Symmetric%20String/#1040-longest-symmetric-string","text":"","title":"1040 Longest Symmetric String"},{"location":"PAT-Advanced-Level/1040-Longest%20Symmetric%20String/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&TAP symmetric? , the longest symmetric sub-string is s PAT&TAP s , hence you must output 11 . Input Specification Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification For each test case, simply print the maximum length in a line. Sample Input Is PAT&TAP symmetric? Sample Output 11","title":"Statement"},{"location":"PAT-Advanced-Level/1041-Be%20Unique/","text":"1041 Be Unique Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [ 1, 10^4 1, 10^4 ]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins. Input Specification Each input file contains one test case. Each case contains a line which begins with a positive integer N N ( \\le 10^5 \\le 10^5 ) and then followed by N N bets. The numbers are separated by a space. Output Specification For each test case, print the winning number in a line. If there is no winner, print None instead. Sample Input 1 7 5 31 5 88 67 88 17 Sample Output 1 31 Sample Input 2 5 888 666 666 888 888 Sample Output 2 None Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n , num ; scanf ( \"%d\" , & n ); map < int , int > m ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); m [ num ] ++ ; if ( m [ num ] == 1 ) ans . pb ( num ); } vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( m [ * it ] == 1 ) { printf ( \"%d \\n \" , * it ); break ; } } if ( it == ans . end ()) printf ( \"None \\n \" ); }","title":"1041-Be Unique"},{"location":"PAT-Advanced-Level/1041-Be%20Unique/#1041-be-unique","text":"","title":"1041 Be Unique"},{"location":"PAT-Advanced-Level/1041-Be%20Unique/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [ 1, 10^4 1, 10^4 ]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins. Input Specification Each input file contains one test case. Each case contains a line which begins with a positive integer N N ( \\le 10^5 \\le 10^5 ) and then followed by N N bets. The numbers are separated by a space. Output Specification For each test case, print the winning number in a line. If there is no winner, print None instead. Sample Input 1 7 5 31 5 88 67 88 17 Sample Output 1 31 Sample Input 2 5 888 666 666 888 888 Sample Output 2 None","title":"Statement"},{"location":"PAT-Advanced-Level/1041-Be%20Unique/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n , num ; scanf ( \"%d\" , & n ); map < int , int > m ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); m [ num ] ++ ; if ( m [ num ] == 1 ) ans . pb ( num ); } vector < int >:: iterator it ; for ( it = ans . begin (); it != ans . end (); it ++ ) { if ( m [ * it ] == 1 ) { printf ( \"%d \\n \" , * it ); break ; } } if ( it == ans . end ()) printf ( \"None \\n \" ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1042-Shuffling%20Machine/","text":"1042 Shuffling Machine Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid \"inside jobs\" where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines . Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 where \"S\" stands for \"Spade\", \"H\" for \"Heart\", \"C\" for \"Club\", \"D\" for \"Diamond\", and \"J\" for \"Joker\". A given order is a permutation of distinct integers in [1, 54]. If the number at the i i -th position is j j , it means to move the card from position i i to position j j . For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer K K ( \\le 20 \\le 20 ) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input 2 36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5","title":"1042-Shuffling Machine"},{"location":"PAT-Advanced-Level/1042-Shuffling%20Machine/#1042-shuffling-machine","text":"","title":"1042 Shuffling Machine"},{"location":"PAT-Advanced-Level/1042-Shuffling%20Machine/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid \"inside jobs\" where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines . Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 where \"S\" stands for \"Spade\", \"H\" for \"Heart\", \"C\" for \"Club\", \"D\" for \"Diamond\", and \"J\" for \"Joker\". A given order is a permutation of distinct integers in [1, 54]. If the number at the i i -th position is j j , it means to move the card from position i i to position j j . For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer K K ( \\le 20 \\le 20 ) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input 2 36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5","title":"Statement"},{"location":"PAT-Advanced-Level/1043-Is%20It%20a%20Binary%20Search%20Tree/","text":"1043 Is It a Binary Search Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ). Then N N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES , print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 7 8 6 5 7 10 8 11 Sample Output 1 YES 5 7 6 8 11 10 8 Sample Input 2 7 8 10 11 8 6 7 5 Sample Output 2 YES 11 8 10 7 5 6 8 Sample Input 3 7 8 6 8 5 10 9 11 Sample Output 3 NO","title":"1043-Is It a Binary Search Tree"},{"location":"PAT-Advanced-Level/1043-Is%20It%20a%20Binary%20Search%20Tree/#1043-is-it-a-binary-search-tree","text":"","title":"1043 Is It a Binary Search Tree"},{"location":"PAT-Advanced-Level/1043-Is%20It%20a%20Binary%20Search%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. If we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST. Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ). Then N N integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES , print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 7 8 6 5 7 10 8 11 Sample Output 1 YES 5 7 6 8 11 10 8 Sample Input 2 7 8 10 11 8 6 7 5 Sample Output 2 YES 11 8 10 7 5 6 8 Sample Input 3 7 8 6 8 5 10 9 11 Sample Output 3 NO","title":"Statement"},{"location":"PAT-Advanced-Level/1044-Shopping%20in%20Mars/","text":"1044 Shopping in Mars Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15). Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15). Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15). Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of diamonds on the chain, and M M ( \\le 10^8 \\le 10^8 ), the amount that the customer has to pay. Then the next line contains N N positive numbers D_1 \\cdots D_N D_1 \\cdots D_N ( D_i\\le 10^3 D_i\\le 10^3 for all i=1, \\cdots , N i=1, \\cdots , N ) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification For each test case, print i-j in a line for each pair of i \\le \\le j such that D D i + \u2026 + D D j = M M . Note that if there are more than one solution, all the solutions must be printed in increasing order of i . If there is no solution, output i-j for pairs of i \\le \\le j such that D D i + \u2026 + D D j > M > M with ( D D i + \u2026 + D D j - M - M ) minimized. Again all the solutions must be printed in increasing order of i . It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1 16 15 3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13 Sample Output 1 1-5 4-6 7-8 11-11 Sample Input 2 5 13 2 4 5 7 9 Sample Output 2 2-4 4-5","title":"1044-Shopping in Mars"},{"location":"PAT-Advanced-Level/1044-Shopping%20in%20Mars/#1044-shopping-in-mars","text":"","title":"1044 Shopping in Mars"},{"location":"PAT-Advanced-Level/1044-Shopping%20in%20Mars/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15). Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15). Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15). Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of diamonds on the chain, and M M ( \\le 10^8 \\le 10^8 ), the amount that the customer has to pay. Then the next line contains N N positive numbers D_1 \\cdots D_N D_1 \\cdots D_N ( D_i\\le 10^3 D_i\\le 10^3 for all i=1, \\cdots , N i=1, \\cdots , N ) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification For each test case, print i-j in a line for each pair of i \\le \\le j such that D D i + \u2026 + D D j = M M . Note that if there are more than one solution, all the solutions must be printed in increasing order of i . If there is no solution, output i-j for pairs of i \\le \\le j such that D D i + \u2026 + D D j > M > M with ( D D i + \u2026 + D D j - M - M ) minimized. Again all the solutions must be printed in increasing order of i . It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1 16 15 3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13 Sample Output 1 1-5 4-6 7-8 11-11 Sample Input 2 5 13 2 4 5 7 9 Sample Output 2 2-4 4-5","title":"Statement"},{"location":"PAT-Advanced-Level/1045-Favorite%20Color%20Stripe/","text":"1045 Favorite Color Stripe Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva's favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 200 \\le 200 ) which is the total number of colors involved (and hence the colors are numbered from 1 to N N ). Then the next line starts with a positive integer M M ( \\le 200 \\le 200 ) followed by M M Eva's favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L L ( \\le 10^4 \\le 10^4 ) which is the length of the given stripe, followed by L L colors on the stripe. All the numbers in a line a separated by a space. Output Specification For each test case, simply print in a line the maximum length of Eva's favorite stripe. Sample Input 6 5 2 3 1 5 6 12 2 2 4 1 5 5 6 3 1 1 5 6 Sample Output 7","title":"1045-Favorite Color Stripe"},{"location":"PAT-Advanced-Level/1045-Favorite%20Color%20Stripe/#1045-favorite-color-stripe","text":"","title":"1045 Favorite Color Stripe"},{"location":"PAT-Advanced-Level/1045-Favorite%20Color%20Stripe/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva's favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 200 \\le 200 ) which is the total number of colors involved (and hence the colors are numbered from 1 to N N ). Then the next line starts with a positive integer M M ( \\le 200 \\le 200 ) followed by M M Eva's favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L L ( \\le 10^4 \\le 10^4 ) which is the length of the given stripe, followed by L L colors on the stripe. All the numbers in a line a separated by a space. Output Specification For each test case, simply print in a line the maximum length of Eva's favorite stripe. Sample Input 6 5 2 3 1 5 6 12 2 2 4 1 5 5 6 3 1 1 5 6 Sample Output 7","title":"Statement"},{"location":"PAT-Advanced-Level/1046-Shortest%20Distance/","text":"1046 Shortest Distance Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The task is really simple: given N N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification Each input file contains one test case. For each case, the first line contains an integer N N (in [ 3, 10^5 3, 10^5 ]), followed by N N integer distances D_1 D_1 D_2 D_2 \\cdots \\cdots D_N D_N , where D_i D_i is the distance between the i i -th and the (i+1) (i+1) -st exits, and D_N D_N is between the N N -th and the 1 st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M M ( \\le 10^4 \\le 10^4 ), with M M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N N . It is guaranteed that the total round trip distance is no more than 10^7 10^7 . Output Specification For each test case, print your results in M M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input 5 1 2 4 14 9 3 1 3 2 5 4 1 Sample Output 3 10 7","title":"1046-Shortest Distance"},{"location":"PAT-Advanced-Level/1046-Shortest%20Distance/#1046-shortest-distance","text":"","title":"1046 Shortest Distance"},{"location":"PAT-Advanced-Level/1046-Shortest%20Distance/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The task is really simple: given N N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification Each input file contains one test case. For each case, the first line contains an integer N N (in [ 3, 10^5 3, 10^5 ]), followed by N N integer distances D_1 D_1 D_2 D_2 \\cdots \\cdots D_N D_N , where D_i D_i is the distance between the i i -th and the (i+1) (i+1) -st exits, and D_N D_N is between the N N -th and the 1 st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M M ( \\le 10^4 \\le 10^4 ), with M M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N N . It is guaranteed that the total round trip distance is no more than 10^7 10^7 . Output Specification For each test case, print your results in M M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input 5 1 2 4 14 9 3 1 3 2 5 4 1 Sample Output 3 10 7","title":"Statement"},{"location":"PAT-Advanced-Level/1047-Student%20List%20for%20Course/","text":"1047 Student List for Course Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 40,000 \\le 40,000 ), the total number of students, and K K ( \\le 2,500 \\le 2,500 ), the total number of courses. Then N N lines follow, each contains a student's name (3 capital English letters plus a one-digit number), a positive number C C ( \\le 20 \\le 20 ) which is the number of courses that this student has registered, and then followed by C C course numbers. For the sake of simplicity, the courses are numbered from 1 to K K . Output Specification For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students' names in alphabetical order. Each name occupies a line. Sample Input 10 5 ZOE1 2 4 5 ANN0 3 5 2 1 BOB5 5 3 4 2 1 5 JOE4 1 2 JAY9 4 1 2 5 4 FRA8 3 4 2 5 DON2 2 4 5 AMY7 1 5 KAT3 3 5 4 2 LOR6 4 2 4 1 5 Sample Output 1 4 ANN0 BOB5 JAY9 LOR6 2 7 ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6 3 1 BOB5 4 7 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 5 9 AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1","title":"1047-Student List for Course"},{"location":"PAT-Advanced-Level/1047-Student%20List%20for%20Course/#1047-student-list-for-course","text":"","title":"1047 Student List for Course"},{"location":"PAT-Advanced-Level/1047-Student%20List%20for%20Course/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses. Input Specification Each input file contains one test case. For each case, the first line contains 2 numbers: N N ( \\le 40,000 \\le 40,000 ), the total number of students, and K K ( \\le 2,500 \\le 2,500 ), the total number of courses. Then N N lines follow, each contains a student's name (3 capital English letters plus a one-digit number), a positive number C C ( \\le 20 \\le 20 ) which is the number of courses that this student has registered, and then followed by C C course numbers. For the sake of simplicity, the courses are numbered from 1 to K K . Output Specification For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students' names in alphabetical order. Each name occupies a line. Sample Input 10 5 ZOE1 2 4 5 ANN0 3 5 2 1 BOB5 5 3 4 2 1 5 JOE4 1 2 JAY9 4 1 2 5 4 FRA8 3 4 2 5 DON2 2 4 5 AMY7 1 5 KAT3 3 5 4 2 LOR6 4 2 4 1 5 Sample Output 1 4 ANN0 BOB5 JAY9 LOR6 2 7 ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6 3 1 BOB5 4 7 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 5 9 AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1","title":"Statement"},{"location":"PAT-Advanced-Level/1048-Find%20Coins/","text":"1048 Find Coins Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10^5 10^5 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: N N ( \\le 10^5 \\le 10^5 , the total number of coins) and M M ( \\le 10^3 \\le 10^3 , the amount of money Eva has to pay). The second line contains N N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the two face values V_1 V_1 and V_2 V_2 (separated by a space) such that V_1 + V_2 = M V_1 + V_2 = M and V_1 \\le V_2 V_1 \\le V_2 . If such a solution is not unique, output the one with the smallest V_1 V_1 . If there is no solution, output No Solution instead. Sample Input 1 8 15 1 2 8 7 2 4 11 15 Sample Output 1 4 11 Sample Input 2 7 14 1 8 7 2 4 11 15 Sample Output 2 No Solution","title":"1048-Find Coins"},{"location":"PAT-Advanced-Level/1048-Find%20Coins/#1048-find-coins","text":"","title":"1048 Find Coins"},{"location":"PAT-Advanced-Level/1048-Find%20Coins/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10^5 10^5 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: N N ( \\le 10^5 \\le 10^5 , the total number of coins) and M M ( \\le 10^3 \\le 10^3 , the amount of money Eva has to pay). The second line contains N N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the two face values V_1 V_1 and V_2 V_2 (separated by a space) such that V_1 + V_2 = M V_1 + V_2 = M and V_1 \\le V_2 V_1 \\le V_2 . If such a solution is not unique, output the one with the smallest V_1 V_1 . If there is no solution, output No Solution instead. Sample Input 1 8 15 1 2 8 7 2 4 11 15 Sample Output 1 4 11 Sample Input 2 7 14 1 8 7 2 4 11 15 Sample Output 2 No Solution","title":"Statement"},{"location":"PAT-Advanced-Level/1049-Counting%20Ones/","text":"1049 Counting Ones Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The task is simple: given any positive integer N N , you are supposed to count the total number of 1's in the decimal form of the integers from 1 to N N . For example, given N N being 12, there are five 1's in 1, 10, 11, and 12. Input Specification Each input file contains one test case which gives the positive N N ( \\le 2^{30} \\le 2^{30} ). Output Specification For each test case, print the number of 1's in one line. Sample Input 12 Sample Output 5","title":"1049-Counting Ones"},{"location":"PAT-Advanced-Level/1049-Counting%20Ones/#1049-counting-ones","text":"","title":"1049 Counting Ones"},{"location":"PAT-Advanced-Level/1049-Counting%20Ones/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The task is simple: given any positive integer N N , you are supposed to count the total number of 1's in the decimal form of the integers from 1 to N N . For example, given N N being 12, there are five 1's in 1, 10, 11, and 12. Input Specification Each input file contains one test case which gives the positive N N ( \\le 2^{30} \\le 2^{30} ). Output Specification For each test case, print the number of 1's in one line. Sample Input 12 Sample Output 5","title":"Statement"},{"location":"PAT-Advanced-Level/1050-String%20Subtraction/","text":"1050 String Subtraction Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB Given two strings S_1 S_1 and S_2 S_2 , S = S_1 - S_2 S = S_1 - S_2 is defined to be the remaining string after taking all the characters in S_2 S_2 from S_1 S_1 . Your task is simply to calculate S_1 - S_2 S_1 - S_2 for any given strings. However, it might not be that simple to do it fast . Input Specification Each input file contains one test case. Each case consists of two lines which gives S_1 S_1 and S_2 S_2 , respectively. The string lengths of both strings are no more than 10^4 10^4 . It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string. Output Specification For each test case, print S_1 - S_2 S_1 - S_2 in one line. Sample Input They are students. aeiou Sample Output Thy r stdnts. Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; getline ( cin , s1 ); getline ( cin , s2 ); map < char , int > p ; int len1 = s1 . size (), len2 = s2 . size (), i ; for ( i = 0 ; i < len2 ; i ++ ) p [ s2 [ i ]] = 1 ; for ( i = 0 ; i < len1 ; i ++ ) { if ( ! p [ s1 [ i ]]) cout << s1 [ i ]; } cout << endl ; }","title":"1050-String Subtraction"},{"location":"PAT-Advanced-Level/1050-String%20Subtraction/#1050-string-subtraction","text":"","title":"1050 String Subtraction"},{"location":"PAT-Advanced-Level/1050-String%20Subtraction/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB Given two strings S_1 S_1 and S_2 S_2 , S = S_1 - S_2 S = S_1 - S_2 is defined to be the remaining string after taking all the characters in S_2 S_2 from S_1 S_1 . Your task is simply to calculate S_1 - S_2 S_1 - S_2 for any given strings. However, it might not be that simple to do it fast . Input Specification Each input file contains one test case. Each case consists of two lines which gives S_1 S_1 and S_2 S_2 , respectively. The string lengths of both strings are no more than 10^4 10^4 . It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string. Output Specification For each test case, print S_1 - S_2 S_1 - S_2 in one line. Sample Input They are students. aeiou Sample Output Thy r stdnts.","title":"Statement"},{"location":"PAT-Advanced-Level/1050-String%20Subtraction/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; getline ( cin , s1 ); getline ( cin , s2 ); map < char , int > p ; int len1 = s1 . size (), len2 = s2 . size (), i ; for ( i = 0 ; i < len2 ; i ++ ) p [ s2 [ i ]] = 1 ; for ( i = 0 ; i < len1 ; i ++ ) { if ( ! p [ s1 [ i ]]) cout << s1 [ i ]; } cout << endl ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1051-Pop%20Sequence/","text":"1051 Pop Sequence Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a stack which can keep M M numbers at most. Push N N numbers in the order of 1, 2, 3, \u2026, N N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M M is 5 and N N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M M (the maximum capacity of the stack), N N (the length of push sequence), and K K (the number of pop sequences to be checked). Then K K lines follow, each contains a pop sequence of N N numbers. All the numbers in a line are separated by a space. Output Specification For each pop sequence, print in one line \"YES\" if it is indeed a possible pop sequence of the stack, or \"NO\" if not. Sample Input 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output YES NO NO YES NO","title":"1051-Pop Sequence"},{"location":"PAT-Advanced-Level/1051-Pop%20Sequence/#1051-pop-sequence","text":"","title":"1051 Pop Sequence"},{"location":"PAT-Advanced-Level/1051-Pop%20Sequence/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a stack which can keep M M numbers at most. Push N N numbers in the order of 1, 2, 3, \u2026, N N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M M is 5 and N N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M M (the maximum capacity of the stack), N N (the length of push sequence), and K K (the number of pop sequences to be checked). Then K K lines follow, each contains a pop sequence of N N numbers. All the numbers in a line are separated by a space. Output Specification For each pop sequence, print in one line \"YES\" if it is indeed a possible pop sequence of the stack, or \"NO\" if not. Sample Input 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output YES NO NO YES NO","title":"Statement"},{"location":"PAT-Advanced-Level/1052-Linked%20List%20Sorting/","text":"1052 Linked List Sorting Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification Each input file contains one test case. For each case, the first line contains a positive N N ( < 10^5 < 10^5 ) and an address of the head node, where N N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Key Next where Address is the address of the node in memory, Key is an integer in [ -10^5, 10^5 -10^5, 10^5 ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification For each test case, the output format is the same as that of the input, where N N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input 5 00001 11111 100 -1 00001 0 22222 33333 100000 11111 12345 -1 33333 22222 1000 12345 Sample Output 5 12345 12345 -1 00001 00001 0 11111 11111 100 22222 22222 1000 33333 33333 100000 -1","title":"1052-Linked List Sorting"},{"location":"PAT-Advanced-Level/1052-Linked%20List%20Sorting/#1052-linked-list-sorting","text":"","title":"1052 Linked List Sorting"},{"location":"PAT-Advanced-Level/1052-Linked%20List%20Sorting/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order. Input Specification Each input file contains one test case. For each case, the first line contains a positive N N ( < 10^5 < 10^5 ) and an address of the head node, where N N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Key Next where Address is the address of the node in memory, Key is an integer in [ -10^5, 10^5 -10^5, 10^5 ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node. Output Specification For each test case, the output format is the same as that of the input, where N N is the total number of nodes in the list and all the nodes must be sorted order. Sample Input 5 00001 11111 100 -1 00001 0 22222 33333 100000 11111 12345 -1 33333 22222 1000 12345 Sample Output 5 12345 12345 -1 00001 00001 0 11111 11111 100 22222 22222 1000 33333 33333 100000 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1053-Path%20of%20Equal%20Weight/","text":"1053 Path of Equal Weight Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a non-empty tree with root R R , and with weight W_i W_i assigned to each tree node T_i T_i . The weight of a path from R R to L L is defined to be the sum of the weights of all the nodes along the path from R R to any leaf node L L . Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let's consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification Each input file contains one test case. Each case starts with a line containing 0 < N \\le 100 0 < N \\le 100 , the number of nodes in a tree, M M ( < N < N ), the number of non-leaf nodes, and 0 < S < 2^{30} 0 < S < 2^{30} , the given weight number. The next line contains N N positive numbers where W_i W_i ( <1000 <1000 ) corresponds to the tree node T_i T_i . Then M M lines follow, each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID 's of its children. For the sake of simplicity, let us fix the root ID to be 00 . Output Specification For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. Note: sequence \\{A_1, A_2, \\cdots , A_n\\} \\{A_1, A_2, \\cdots , A_n\\} is said to be greater than sequence \\{B_1, B_2, \\cdots , B_m\\} \\{B_1, B_2, \\cdots , B_m\\} if there exists 1 \\le k < min\\{n, m\\} 1 \\le k < min\\{n, m\\} such that A_i = B_i A_i = B_i for i=1, \\cdots , k i=1, \\cdots , k , and A_{k+1} > B_{k+1} A_{k+1} > B_{k+1} . Sample Input 20 9 24 10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2 00 4 01 02 03 04 02 1 05 04 2 06 07 03 3 11 12 13 06 1 09 07 2 08 10 16 1 15 13 3 14 16 17 17 2 18 19 Sample Output 10 5 2 7 10 4 10 10 3 3 6 2 10 3 3 6 2 Special thanks to Zhang Yuan and Yang Han for their contribution to the judge's data.","title":"1053-Path of Equal Weight"},{"location":"PAT-Advanced-Level/1053-Path%20of%20Equal%20Weight/#1053-path-of-equal-weight","text":"","title":"1053 Path of Equal Weight"},{"location":"PAT-Advanced-Level/1053-Path%20of%20Equal%20Weight/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a non-empty tree with root R R , and with weight W_i W_i assigned to each tree node T_i T_i . The weight of a path from R R to L L is defined to be the sum of the weights of all the nodes along the path from R R to any leaf node L L . Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let's consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure. Input Specification Each input file contains one test case. Each case starts with a line containing 0 < N \\le 100 0 < N \\le 100 , the number of nodes in a tree, M M ( < N < N ), the number of non-leaf nodes, and 0 < S < 2^{30} 0 < S < 2^{30} , the given weight number. The next line contains N N positive numbers where W_i W_i ( <1000 <1000 ) corresponds to the tree node T_i T_i . Then M M lines follow, each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID 's of its children. For the sake of simplicity, let us fix the root ID to be 00 . Output Specification For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line. Note: sequence \\{A_1, A_2, \\cdots , A_n\\} \\{A_1, A_2, \\cdots , A_n\\} is said to be greater than sequence \\{B_1, B_2, \\cdots , B_m\\} \\{B_1, B_2, \\cdots , B_m\\} if there exists 1 \\le k < min\\{n, m\\} 1 \\le k < min\\{n, m\\} such that A_i = B_i A_i = B_i for i=1, \\cdots , k i=1, \\cdots , k , and A_{k+1} > B_{k+1} A_{k+1} > B_{k+1} . Sample Input 20 9 24 10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2 00 4 01 02 03 04 02 1 05 04 2 06 07 03 3 11 12 13 06 1 09 07 2 08 10 16 1 15 13 3 14 16 17 17 2 18 19 Sample Output 10 5 2 7 10 4 10 10 3 3 6 2 10 3 3 6 2","title":"Statement"},{"location":"PAT-Advanced-Level/1053-Path%20of%20Equal%20Weight/#special-thanks-to-zhang-yuan-and-yang-han-for-their-contribution-to-the-judges-data","text":"","title":"Special thanks to Zhang Yuan and Yang Han for their contribution to the judge's data."},{"location":"PAT-Advanced-Level/1054-The%20Dominant%20Color/","text":"1054 The Dominant Color Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Behind the scenes in the computer's memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M M by N N (for example, 800\\times 600 800\\times 600 ), you are supposed to point out the strictly dominant color. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: M M ( \\le 800 \\le 800 ) and N N ( \\le 600 \\le 600 ) which are the resolutions of the image. Then N N lines follow, each contains M M digital colors in the range [ 0, 2^{24} 0, 2^{24} ). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space. Output Specification For each test case, simply print the dominant color in a line. Sample Input 5 3 0 0 255 16777215 24 24 24 0 0 24 24 0 24 24 24 Sample Output 24","title":"1054-The Dominant Color"},{"location":"PAT-Advanced-Level/1054-The%20Dominant%20Color/#1054-the-dominant-color","text":"","title":"1054 The Dominant Color"},{"location":"PAT-Advanced-Level/1054-The%20Dominant%20Color/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Behind the scenes in the computer's memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M M by N N (for example, 800\\times 600 800\\times 600 ), you are supposed to point out the strictly dominant color. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: M M ( \\le 800 \\le 800 ) and N N ( \\le 600 \\le 600 ) which are the resolutions of the image. Then N N lines follow, each contains M M digital colors in the range [ 0, 2^{24} 0, 2^{24} ). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space. Output Specification For each test case, simply print the dominant color in a line. Sample Input 5 3 0 0 255 16777215 24 24 24 0 0 24 24 0 24 24 24 Sample Output 24","title":"Statement"},{"location":"PAT-Advanced-Level/1055-The%20World%27s%20Richest/","text":"1055 The World's Richest Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 128 MB Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world's wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N N people, you must find the M M richest people in a given range of their ages. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 10^5 \\le 10^5 ) - the total number of people, and K K ( \\le 10^3 \\le 10^3 ) - the number of queries. Then N N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [ -10^6, 10^6 -10^6, 10^6 ]) of a person. Finally there are K K lines of queries, each contains three positive integers: M M ( \\le 100 \\le 100 ) - the maximum number of outputs, and [ Amin , Amax ] which are the range of ages. All the numbers in a line are separated by a space. Output Specification For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M M richest people with their ages in the range [ Amin , Amax ]. Each person's information occupies a line, in the format Name Age Net_Worth The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None . Sample Input 12 4 Zoe_Bill 35 2333 Bob_Volk 24 5888 Anny_Cin 95 999999 Williams 30 -22 Cindy 76 76000 Alice 18 88888 Joe_Mike 32 3222 Michael 5 300000 Rosemary 40 5888 Dobby 24 5888 Billy 24 5888 Nobody 5 0 4 15 45 4 30 35 4 5 95 1 45 50 Sample Output Case #1: Alice 18 88888 Billy 24 5888 Bob_Volk 24 5888 Dobby 24 5888 Case #2: Joe_Mike 32 3222 Zoe_Bill 35 2333 Williams 30 -22 Case #3: Anny_Cin 95 999999 Michael 5 300000 Alice 18 88888 Cindy 76 76000 Case #4: None","title":"1055-The World's Richest"},{"location":"PAT-Advanced-Level/1055-The%20World%27s%20Richest/#1055-the-worlds-richest","text":"","title":"1055 The World's Richest"},{"location":"PAT-Advanced-Level/1055-The%20World%27s%20Richest/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 128 MB Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world's wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N N people, you must find the M M richest people in a given range of their ages. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 10^5 \\le 10^5 ) - the total number of people, and K K ( \\le 10^3 \\le 10^3 ) - the number of queries. Then N N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [ -10^6, 10^6 -10^6, 10^6 ]) of a person. Finally there are K K lines of queries, each contains three positive integers: M M ( \\le 100 \\le 100 ) - the maximum number of outputs, and [ Amin , Amax ] which are the range of ages. All the numbers in a line are separated by a space. Output Specification For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M M richest people with their ages in the range [ Amin , Amax ]. Each person's information occupies a line, in the format Name Age Net_Worth The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None . Sample Input 12 4 Zoe_Bill 35 2333 Bob_Volk 24 5888 Anny_Cin 95 999999 Williams 30 -22 Cindy 76 76000 Alice 18 88888 Joe_Mike 32 3222 Michael 5 300000 Rosemary 40 5888 Dobby 24 5888 Billy 24 5888 Nobody 5 0 4 15 45 4 30 35 4 5 95 1 45 50 Sample Output Case #1: Alice 18 88888 Billy 24 5888 Bob_Volk 24 5888 Dobby 24 5888 Case #2: Joe_Mike 32 3222 Zoe_Bill 35 2333 Williams 30 -22 Case #3: Anny_Cin 95 999999 Michael 5 300000 Alice 18 88888 Cindy 76 76000 Case #4: None","title":"Statement"},{"location":"PAT-Advanced-Level/1056-Mice%20and%20Rice/","text":"1056 Mice and Rice Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse. First the playing order is randomly decided for N_P N_P programmers. Then every N_G N_G programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every N_G N_G winners are then grouped in the next match until a final winner is determined. For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N_P N_P and N_G N_G ( \\le 1000 \\le 1000 ), the number of programmers and the maximum number of mice in a group, respectively. If there are less than N_G N_G mice at the end of the player's list, then all the mice left will be put into the last group. The second line contains N_P N_P distinct non-negative numbers W_i W_i ( i=0,\\cdots ,N_P -1 i=0,\\cdots ,N_P -1 ) where each W_i W_i is the weight of the i i -th mouse respectively. The third line gives the initial playing order which is a permutation of 0,\\cdots ,N_P -1 0,\\cdots ,N_P -1 (assume that the programmers are numbered from 0 to N_P -1 N_P -1 ). All the numbers in a line are separated by a space. Output Specification For each test case, print the final ranks in a line. The i i -th number is the rank of the i i -th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line. Sample Input 11 3 25 18 0 46 37 3 19 22 57 56 10 6 0 8 7 10 5 9 1 4 2 3 Sample Output 5 5 5 2 5 5 5 3 1 3 5","title":"1056-Mice and Rice"},{"location":"PAT-Advanced-Level/1056-Mice%20and%20Rice/#1056-mice-and-rice","text":"","title":"1056 Mice and Rice"},{"location":"PAT-Advanced-Level/1056-Mice%20and%20Rice/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse. First the playing order is randomly decided for N_P N_P programmers. Then every N_G N_G programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every N_G N_G winners are then grouped in the next match until a final winner is determined. For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N_P N_P and N_G N_G ( \\le 1000 \\le 1000 ), the number of programmers and the maximum number of mice in a group, respectively. If there are less than N_G N_G mice at the end of the player's list, then all the mice left will be put into the last group. The second line contains N_P N_P distinct non-negative numbers W_i W_i ( i=0,\\cdots ,N_P -1 i=0,\\cdots ,N_P -1 ) where each W_i W_i is the weight of the i i -th mouse respectively. The third line gives the initial playing order which is a permutation of 0,\\cdots ,N_P -1 0,\\cdots ,N_P -1 (assume that the programmers are numbered from 0 to N_P -1 N_P -1 ). All the numbers in a line are separated by a space. Output Specification For each test case, print the final ranks in a line. The i i -th number is the rank of the i i -th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line. Sample Input 11 3 25 18 0 46 37 3 19 22 57 56 10 6 0 8 7 10 5 9 1 4 2 3 Sample Output 5 5 5 2 5 5 5 3 1 3 5","title":"Statement"},{"location":"PAT-Advanced-Level/1057-Stack/","text":"1057 Stack Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian \u2013 return the median value of all the elements in the stack. With N N elements, the median value is defined to be the (N/2) (N/2) -th smallest element if N N is even, or ((N+1)/2) ((N+1)/2) -th if N N is odd. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N lines follow, each contains a command in one of the following 3 formats: Push key Pop PeekMedian where key is a positive integer no more than 10^5 10^5 . Output Specification For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead. Sample Input 17 Pop PeekMedian Push 3 PeekMedian Push 2 PeekMedian Push 1 PeekMedian Pop Pop Push 5 Push 4 PeekMedian Pop Pop Pop Pop Sample Output Invalid Invalid 3 2 2 1 2 4 4 5 3 Invalid","title":"1057-Stack"},{"location":"PAT-Advanced-Level/1057-Stack/#1057-stack","text":"","title":"1057 Stack"},{"location":"PAT-Advanced-Level/1057-Stack/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian \u2013 return the median value of all the elements in the stack. With N N elements, the median value is defined to be the (N/2) (N/2) -th smallest element if N N is even, or ((N+1)/2) ((N+1)/2) -th if N N is odd. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N lines follow, each contains a command in one of the following 3 formats: Push key Pop PeekMedian where key is a positive integer no more than 10^5 10^5 . Output Specification For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead. Sample Input 17 Pop PeekMedian Push 3 PeekMedian Push 2 PeekMedian Push 1 PeekMedian Pop Pop Push 5 Push 4 PeekMedian Pop Pop Pop Pop Sample Output Invalid Invalid 3 2 2 1 2 4 4 5 3 Invalid","title":"Statement"},{"location":"PAT-Advanced-Level/1058-A%2BB%20in%20Hogwarts/","text":"1058 A+B in Hogwarts Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB If you are a fan of Harry Potter, you would know the world of magic has its own currency system \u2013 as Hagrid explained it to Harry, \"Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it's easy enough.\" Your job is to write a program to compute A+B A+B where A A and B B are given in the standard form of Galleon.Sickle.Knut ( Galleon is an integer in [ 0, 10^7 0, 10^7 ], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)). Input Specification Each input file contains one test case which occupies a line with A A and B B in the standard form, separated by one space. Output Specification For each test case you should output the sum of A A and B B in one line, with the same format as the input. Sample Input 3.2.1 10.16.27 Sample Output 14.1.28","title":"1058-A+B in Hogwarts"},{"location":"PAT-Advanced-Level/1058-A%2BB%20in%20Hogwarts/#1058-ab-in-hogwarts","text":"","title":"1058 A+B in Hogwarts"},{"location":"PAT-Advanced-Level/1058-A%2BB%20in%20Hogwarts/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB If you are a fan of Harry Potter, you would know the world of magic has its own currency system \u2013 as Hagrid explained it to Harry, \"Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it's easy enough.\" Your job is to write a program to compute A+B A+B where A A and B B are given in the standard form of Galleon.Sickle.Knut ( Galleon is an integer in [ 0, 10^7 0, 10^7 ], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)). Input Specification Each input file contains one test case which occupies a line with A A and B B in the standard form, separated by one space. Output Specification For each test case you should output the sum of A A and B B in one line, with the same format as the input. Sample Input 3.2.1 10.16.27 Sample Output 14.1.28","title":"Statement"},{"location":"PAT-Advanced-Level/1059-Prime%20Factors/","text":"1059 Prime Factors Statement Metadata \u4f5c\u8005: HE, Qinming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given any positive integer N N , you are supposed to find all of its prime factors, and write them in the format N N = {p_1}^{k_1}\\times {p_2}^{k_2} \\times \\cdots \\times {p_m}^{k_m} {p_1}^{k_1}\\times {p_2}^{k_2} \\times \\cdots \\times {p_m}^{k_m} . Input Specification Each input file contains one test case which gives a positive integer N N in the range of long int . Output Specification Factor N N in the format N N = p_1 p_1 ^ k_1 k_1 * p_2 p_2 ^ k_2 k_2 * \u2026 * p_m p_m ^ k_m k_m , where p_i p_i 's are prime factors of N N in increasing order, and the exponent k_i k_i is the number of p_i p_i \u2013 hence when there is only one p_i p_i , k_i k_i is 1 and must NOT be printed out. Sample Input 97532468 Sample Output 97532468=2^2*11*17*101*1291","title":"1059-Prime Factors"},{"location":"PAT-Advanced-Level/1059-Prime%20Factors/#1059-prime-factors","text":"","title":"1059 Prime Factors"},{"location":"PAT-Advanced-Level/1059-Prime%20Factors/#statement","text":"Metadata \u4f5c\u8005: HE, Qinming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given any positive integer N N , you are supposed to find all of its prime factors, and write them in the format N N = {p_1}^{k_1}\\times {p_2}^{k_2} \\times \\cdots \\times {p_m}^{k_m} {p_1}^{k_1}\\times {p_2}^{k_2} \\times \\cdots \\times {p_m}^{k_m} . Input Specification Each input file contains one test case which gives a positive integer N N in the range of long int . Output Specification Factor N N in the format N N = p_1 p_1 ^ k_1 k_1 * p_2 p_2 ^ k_2 k_2 * \u2026 * p_m p_m ^ k_m k_m , where p_i p_i 's are prime factors of N N in increasing order, and the exponent k_i k_i is the number of p_i p_i \u2013 hence when there is only one p_i p_i , k_i k_i is 1 and must NOT be printed out. Sample Input 97532468 Sample Output 97532468=2^2*11*17*101*1291","title":"Statement"},{"location":"PAT-Advanced-Level/1060-Are%20They%20Equal/","text":"1060 Are They Equal Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123\\times 10^5 0.123\\times 10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification Each input file contains one test case which gives three numbers N N , A A and B B , where N N ( <100 <100 ) is the number of significant digits, and A A and B B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^{100} 10^{100} , and that its total digit number is less than 100. Output Specification For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k ( d[1] >0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1 3 12300 12358.9 Sample Output 1 YES 0.123*10^5 Sample Input 2 3 120 128 Sample Output 2 NO 0.120*10^3 0.128*10^3","title":"1060-Are They Equal"},{"location":"PAT-Advanced-Level/1060-Are%20They%20Equal/#1060-are-they-equal","text":"","title":"1060 Are They Equal"},{"location":"PAT-Advanced-Level/1060-Are%20They%20Equal/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123\\times 10^5 0.123\\times 10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification Each input file contains one test case which gives three numbers N N , A A and B B , where N N ( <100 <100 ) is the number of significant digits, and A A and B B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^{100} 10^{100} , and that its total digit number is less than 100. Output Specification For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k ( d[1] >0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input 1 3 12300 12358.9 Sample Output 1 YES 0.123*10^5 Sample Input 2 3 120 128 Sample Output 2 NO 0.120*10^3 0.128*10^3","title":"Statement"},{"location":"PAT-Advanced-Level/1061-Dating/","text":"1061 Dating Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Sherlock Holmes received a note with some strange strings: Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm . It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 \u2013 since the first common capital English letter (case sensitive) shared by the first two strings is the 4 th capital letter D , representing the 4 th day in a week; the second common character is the 5 th capital letter E , representing the 14 th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N , respectively); and the English letter shared by the last two strings is s at the 4 th position, representing the 4 th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification For each test case, print the decoded time in one line, in the format DAY HH:MM , where DAY is a 3-character abbreviation for the days in a week \u2013 that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case. Sample Input 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm Sample Output THU 14:04","title":"1061-Dating"},{"location":"PAT-Advanced-Level/1061-Dating/#1061-dating","text":"","title":"1061 Dating"},{"location":"PAT-Advanced-Level/1061-Dating/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Sherlock Holmes received a note with some strange strings: Let's date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm . It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 \u2013 since the first common capital English letter (case sensitive) shared by the first two strings is the 4 th capital letter D , representing the 4 th day in a week; the second common character is the 5 th capital letter E , representing the 14 th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N , respectively); and the English letter shared by the last two strings is s at the 4 th position, representing the 4 th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification For each test case, print the decoded time in one line, in the format DAY HH:MM , where DAY is a 3-character abbreviation for the days in a week \u2013 that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case. Sample Input 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm Sample Output THU 14:04","title":"Statement"},{"location":"PAT-Advanced-Level/1062-Talent%20and%20Virtue/","text":"1062 Talent and Virtue Statement Metadata \u4f5c\u8005: CHEN, Li \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people's talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a \"sage\uff08\u5723\u4eba\uff09\"; being less excellent but with one's virtue outweighs talent can be called a \"nobleman\uff08\u541b\u5b50\uff09\"; being good in neither is a \"fool man\uff08\u611a\u4eba\uff09\"; yet a fool man is better than a \"small man\uff08\u5c0f\u4eba\uff09\" who prefers talent than virtue. Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang's theory. Input Specification Each input file contains one test case. Each case first gives 3 positive integers in a line: N N ( \\le 10^5 \\le 10^5 ), the total number of people to be ranked; L L ( \\ge 60 \\ge 60 ), the lower bound of the qualified grades \u2013 that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H H ( <100 <100 ), the higher line of qualification \u2013 that is, those with both grades not below this line are considered as the \"sages\", and will be ranked in non-increasing order according to their total grades. Those with talent grades below H H but virtue grades not are considered as the \"noblemen\", and are also ranked in non-increasing order according to their total grades, but they are listed after the \"sages\". Those with both grades below H H , but with virtue not lower than talent are considered as the \"fool men\". They are ranked in the same way but after the \"noblemen\". The rest of people whose grades both pass the L L line are ranked after the \"fool men\". Then N N lines follow, each gives the information of a person in the format: ID_Number Virtue_Grade Talent_Grade where ID_Number is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space. Output Specification The first line of output must give M M ( \\le N \\le N ), the total number of people that are actually ranked. Then M M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID's. Sample Input 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 Sample Output 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90","title":"1062-Talent and Virtue"},{"location":"PAT-Advanced-Level/1062-Talent%20and%20Virtue/#1062-talent-and-virtue","text":"","title":"1062 Talent and Virtue"},{"location":"PAT-Advanced-Level/1062-Talent%20and%20Virtue/#statement","text":"Metadata \u4f5c\u8005: CHEN, Li \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people's talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a \"sage\uff08\u5723\u4eba\uff09\"; being less excellent but with one's virtue outweighs talent can be called a \"nobleman\uff08\u541b\u5b50\uff09\"; being good in neither is a \"fool man\uff08\u611a\u4eba\uff09\"; yet a fool man is better than a \"small man\uff08\u5c0f\u4eba\uff09\" who prefers talent than virtue. Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang's theory. Input Specification Each input file contains one test case. Each case first gives 3 positive integers in a line: N N ( \\le 10^5 \\le 10^5 ), the total number of people to be ranked; L L ( \\ge 60 \\ge 60 ), the lower bound of the qualified grades \u2013 that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H H ( <100 <100 ), the higher line of qualification \u2013 that is, those with both grades not below this line are considered as the \"sages\", and will be ranked in non-increasing order according to their total grades. Those with talent grades below H H but virtue grades not are considered as the \"noblemen\", and are also ranked in non-increasing order according to their total grades, but they are listed after the \"sages\". Those with both grades below H H , but with virtue not lower than talent are considered as the \"fool men\". They are ranked in the same way but after the \"noblemen\". The rest of people whose grades both pass the L L line are ranked after the \"fool men\". Then N N lines follow, each gives the information of a person in the format: ID_Number Virtue_Grade Talent_Grade where ID_Number is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space. Output Specification The first line of output must give M M ( \\le N \\le N ), the total number of people that are actually ranked. Then M M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID's. Sample Input 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 Sample Output 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90","title":"Statement"},{"location":"PAT-Advanced-Level/1063-Set%20Similarity/","text":"1063 Set Similarity Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB Given two sets of integers, the similarity of the sets is defined to be N_c/N_t\\times 100\\% N_c/N_t\\times 100\\% , where N_c N_c is the number of distinct common numbers shared by the two sets, and N_t N_t is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification Each input file contains one test case. Each case first gives a positive integer N N ( \\le 50 \\le 50 ) which is the total number of sets. Then N N lines follow, each gives a set with a positive M M ( \\le 10^4 \\le 10^4 ) and followed by M M integers in the range [ 0, 10^9 0, 10^9 ]. After the input of sets, a positive integer K K ( \\le 2000 \\le 2000 ) is given, followed by K K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N N ). All the numbers in a line are separated by a space. Output Specification For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. Sample Input 3 3 99 87 101 4 87 101 5 87 7 99 101 18 5 135 18 99 2 1 2 1 3 Sample Output 50.0% 33.3%","title":"1063-Set Similarity"},{"location":"PAT-Advanced-Level/1063-Set%20Similarity/#1063-set-similarity","text":"","title":"1063 Set Similarity"},{"location":"PAT-Advanced-Level/1063-Set%20Similarity/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 500 ms \u5185\u5b58\u9650\u5236: 64 MB Given two sets of integers, the similarity of the sets is defined to be N_c/N_t\\times 100\\% N_c/N_t\\times 100\\% , where N_c N_c is the number of distinct common numbers shared by the two sets, and N_t N_t is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification Each input file contains one test case. Each case first gives a positive integer N N ( \\le 50 \\le 50 ) which is the total number of sets. Then N N lines follow, each gives a set with a positive M M ( \\le 10^4 \\le 10^4 ) and followed by M M integers in the range [ 0, 10^9 0, 10^9 ]. After the input of sets, a positive integer K K ( \\le 2000 \\le 2000 ) is given, followed by K K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N N ). All the numbers in a line are separated by a space. Output Specification For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. Sample Input 3 3 99 87 101 4 87 101 5 87 7 99 101 18 5 135 18 99 2 1 2 1 3 Sample Output 50.0% 33.3%","title":"Statement"},{"location":"PAT-Advanced-Level/1064-Complete%20Binary%20Search%20Tree/","text":"1064 Complete Binary Search Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ). Then N N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 10 1 2 3 4 5 6 7 8 9 0 Sample Output 6 3 8 1 5 7 9 0 2 4","title":"1064-Complete Binary Search Tree"},{"location":"PAT-Advanced-Level/1064-Complete%20Binary%20Search%20Tree/#1064-complete-binary-search-tree","text":"","title":"1064 Complete Binary Search Tree"},{"location":"PAT-Advanced-Level/1064-Complete%20Binary%20Search%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ). Then N N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 10 1 2 3 4 5 6 7 8 9 0 Sample Output 6 3 8 1 5 7 9 0 2 4","title":"Statement"},{"location":"PAT-Advanced-Level/1065-A%2BB%20and%20C%20%2864bit%29/","text":"1065 A+B and C (64bit) Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given three integers A A , B B and C C in ( -2^{63}, 2^{63} -2^{63}, 2^{63} ), you are supposed to tell whether A+B > C A+B > C . Input Specification The first line of the input gives the positive number of test cases, T T ( \\le 10 \\le 10 ). Then T T test cases follow, each consists of a single line containing three integers A A , B B and C C , separated by single spaces. Output Specification For each test case, output in one line Case #X: true if A+B>C A+B>C , or Case #X: false otherwise, where X X is the case number (starting from 1). Sample Input 3 1 2 3 2 3 4 9223372036854775807 -9223372036854775808 0 Sample Output Case #1: false Case #2: true Case #3: false Thanks to Jiwen Lin for amending the test data. Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; int count = 1 ; while ( t -- ) { ld a , b , c ; scanf ( \"%Lf%Lf%Lf\" , & a , & b , & c ); printf ( \"Case #%d: \" , count ++ ); if ( a + b > c ) cout << \"true \\n \" ; else cout << \"false \\n \" ; } }","title":"1065-A+B and C (64bit)"},{"location":"PAT-Advanced-Level/1065-A%2BB%20and%20C%20%2864bit%29/#1065-ab-and-c-64bit","text":"","title":"1065 A+B and C (64bit)"},{"location":"PAT-Advanced-Level/1065-A%2BB%20and%20C%20%2864bit%29/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given three integers A A , B B and C C in ( -2^{63}, 2^{63} -2^{63}, 2^{63} ), you are supposed to tell whether A+B > C A+B > C . Input Specification The first line of the input gives the positive number of test cases, T T ( \\le 10 \\le 10 ). Then T T test cases follow, each consists of a single line containing three integers A A , B B and C C , separated by single spaces. Output Specification For each test case, output in one line Case #X: true if A+B>C A+B>C , or Case #X: false otherwise, where X X is the case number (starting from 1). Sample Input 3 1 2 3 2 3 4 9223372036854775807 -9223372036854775808 0 Sample Output Case #1: false Case #2: true Case #3: false Thanks to Jiwen Lin for amending the test data.","title":"Statement"},{"location":"PAT-Advanced-Level/1065-A%2BB%20and%20C%20%2864bit%29/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; int count = 1 ; while ( t -- ) { ld a , b , c ; scanf ( \"%Lf%Lf%Lf\" , & a , & b , & c ); printf ( \"Case #%d: \" , count ++ ); if ( a + b > c ) cout << \"true \\n \" ; else cout << \"false \\n \" ; } }","title":"Solution"},{"location":"PAT-Advanced-Level/1066-Root%20of%20AVL%20Tree/","text":"1066 Root of AVL Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 20 \\le 20 ) which is the total number of keys to be inserted. Then N N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, print the root of the resulting AVL tree in one line. Sample Input 1 5 88 70 61 96 120 Sample Output 1 70 Sample Input 2 7 88 70 61 96 120 90 65 Sample Output 2 88","title":"1066-Root of AVL Tree"},{"location":"PAT-Advanced-Level/1066-Root%20of%20AVL%20Tree/#1066-root-of-avl-tree","text":"","title":"1066 Root of AVL Tree"},{"location":"PAT-Advanced-Level/1066-Root%20of%20AVL%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 20 \\le 20 ) which is the total number of keys to be inserted. Then N N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, print the root of the resulting AVL tree in one line. Sample Input 1 5 88 70 61 96 120 Sample Output 1 70 Sample Input 2 7 88 70 61 96 120 90 65 Sample Output 2 88","title":"Statement"},{"location":"PAT-Advanced-Level/1067-Sort%20with%20Swap%280%2C%20i%29/","text":"1067 Sort with Swap(0, i) Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given any permutation of the numbers {0, 1, 2,\u2026, N-1 N-1 }, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) => {4, 1, 2, 0, 3} Swap(0, 3) => {4, 1, 2, 3, 0} Swap(0, 4) => {0, 1, 2, 3, 4} Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N N nonnegative integers. Input Specification Each input file contains one test case, which gives a positive N N ( \\le 10^5 \\le 10^5 ) followed by a permutation sequence of {0, 1, \u2026, N-1 N-1 }. All the numbers in a line are separated by a space. Output Specification For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input 10 3 5 7 2 6 4 9 0 8 1 Sample Output 9","title":"1067-Sort with Swap(0, i)"},{"location":"PAT-Advanced-Level/1067-Sort%20with%20Swap%280%2C%20i%29/#1067-sort-with-swap0-i","text":"","title":"1067 Sort with Swap(0, i)"},{"location":"PAT-Advanced-Level/1067-Sort%20with%20Swap%280%2C%20i%29/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given any permutation of the numbers {0, 1, 2,\u2026, N-1 N-1 }, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) => {4, 1, 2, 0, 3} Swap(0, 3) => {4, 1, 2, 3, 0} Swap(0, 4) => {0, 1, 2, 3, 4} Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N N nonnegative integers. Input Specification Each input file contains one test case, which gives a positive N N ( \\le 10^5 \\le 10^5 ) followed by a permutation sequence of {0, 1, \u2026, N-1 N-1 }. All the numbers in a line are separated by a space. Output Specification For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input 10 3 5 7 2 6 4 9 0 8 1 Sample Output 9","title":"Statement"},{"location":"PAT-Advanced-Level/1068-Find%20More%20Coins/","text":"1068 Find More Coins Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 10^4 10^4 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: N ( \\le 10^4 \\le 10^4 , the total number of coins) and M ( \\le 10^2 \\le 10^2 , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the face values V_1 \\le V_2 \\le \\cdots \\le V_k V_1 \\le V_2 \\le \\cdots \\le V_k such that $V_1 + V_2 + cdots + V_k = $ M . All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output \"No Solution\" instead. Note: sequence {A[1], A[2], \u2026} is said to be \"smaller\" than sequence {B[1], B[2], \u2026} if there exists k \\ge 1 k \\ge 1 such that A[ i i ]=B[ i i ] for all i < k i < k , and A[ k k ] < < B[ k k ]. Sample Input 1 8 9 5 9 8 7 2 3 4 1 Sample Output 1 1 3 5 Sample Input 2 4 8 7 2 4 3 Sample Output 2 No Solution","title":"1068-Find More Coins"},{"location":"PAT-Advanced-Level/1068-Find%20More%20Coins/#1068-find-more-coins","text":"","title":"1068 Find More Coins"},{"location":"PAT-Advanced-Level/1068-Find%20More%20Coins/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 10^4 10^4 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive numbers: N ( \\le 10^4 \\le 10^4 , the total number of coins) and M ( \\le 10^2 \\le 10^2 , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the face values V_1 \\le V_2 \\le \\cdots \\le V_k V_1 \\le V_2 \\le \\cdots \\le V_k such that $V_1 + V_2 + cdots + V_k = $ M . All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output \"No Solution\" instead. Note: sequence {A[1], A[2], \u2026} is said to be \"smaller\" than sequence {B[1], B[2], \u2026} if there exists k \\ge 1 k \\ge 1 such that A[ i i ]=B[ i i ] for all i < k i < k , and A[ k k ] < < B[ k k ]. Sample Input 1 8 9 5 9 8 7 2 3 4 1 Sample Output 1 1 3 5 Sample Input 2 4 8 7 2 4 3 Sample Output 2 No Solution","title":"Statement"},{"location":"PAT-Advanced-Level/1069-The%20Black%20Hole%20of%20Numbers/","text":"1069 The Black Hole of Numbers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 \u2013 the black hole of 4-digit numbers. This number is named Kaprekar Constant. For example, start from 6767 , we'll get: 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 ... ... Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole. Input Specification Each input file contains one test case which gives a positive integer N N in the range (0, 10^4) (0, 10^4) . Output Specification If all the 4 digits of N N are the same, print in one line the equation N - N = 0000 . Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input 1 6767 Sample Output 1 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 Sample Input 2 2222 Sample Output 2 2222 - 2222 = 0000","title":"1069-The Black Hole of Numbers"},{"location":"PAT-Advanced-Level/1069-The%20Black%20Hole%20of%20Numbers/#1069-the-black-hole-of-numbers","text":"","title":"1069 The Black Hole of Numbers"},{"location":"PAT-Advanced-Level/1069-The%20Black%20Hole%20of%20Numbers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 \u2013 the black hole of 4-digit numbers. This number is named Kaprekar Constant. For example, start from 6767 , we'll get: 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 ... ... Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole. Input Specification Each input file contains one test case which gives a positive integer N N in the range (0, 10^4) (0, 10^4) . Output Specification If all the 4 digits of N N are the same, print in one line the equation N - N = 0000 . Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input 1 6767 Sample Output 1 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 Sample Input 2 2222 Sample Output 2 2222 - 2222 = 0000","title":"Statement"},{"location":"PAT-Advanced-Level/1070-Mooncake/","text":"1070 Mooncake Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region's culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made. Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans). Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( \\le 1000 \\le 1000 ), the number of different kinds of mooncakes, and D D ( \\le 500 \\le 500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N N kinds of mooncakes. All the numbers in a line are separated by a space. Output Specification For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places. Sample Input 3 200 180 150 100 7.5 7.2 4.5 Sample Output 9.45","title":"1070-Mooncake"},{"location":"PAT-Advanced-Level/1070-Mooncake/#1070-mooncake","text":"","title":"1070 Mooncake"},{"location":"PAT-Advanced-Level/1070-Mooncake/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region's culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made. Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans). Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( \\le 1000 \\le 1000 ), the number of different kinds of mooncakes, and D D ( \\le 500 \\le 500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N N kinds of mooncakes. All the numbers in a line are separated by a space. Output Specification For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places. Sample Input 3 200 180 150 100 7.5 7.2 4.5 Sample Output 9.45","title":"Statement"},{"location":"PAT-Advanced-Level/1071-Speech%20Patterns/","text":"1071 Speech Patterns Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB People often have a preference among synonyms of the same word. For example, some may prefer \"the police\", while others may prefer \"the cops\". Analyzing such patterns can help to narrow down a speaker's identity, which is useful when validating, for example, whether it's still the same person behind an online avatar. Now given a paragraph of text sampled from someone's speech, can you find the person's most commonly used word? Input Specification Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return \\n . The input contains at least one alphanumerical character, i.e., one character from the set [ 0-9 A-Z a-z ]. Output Specification For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a \"word\" is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end. Note that words are case insensitive . Sample Input Can1: \"Can a can can a can? It can!\" Sample Output can 5","title":"1071-Speech Patterns"},{"location":"PAT-Advanced-Level/1071-Speech%20Patterns/#1071-speech-patterns","text":"","title":"1071 Speech Patterns"},{"location":"PAT-Advanced-Level/1071-Speech%20Patterns/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB People often have a preference among synonyms of the same word. For example, some may prefer \"the police\", while others may prefer \"the cops\". Analyzing such patterns can help to narrow down a speaker's identity, which is useful when validating, for example, whether it's still the same person behind an online avatar. Now given a paragraph of text sampled from someone's speech, can you find the person's most commonly used word? Input Specification Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return \\n . The input contains at least one alphanumerical character, i.e., one character from the set [ 0-9 A-Z a-z ]. Output Specification For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a \"word\" is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end. Note that words are case insensitive . Sample Input Can1: \"Can a can can a can? It can!\" Sample Output can 5","title":"Statement"},{"location":"PAT-Advanced-Level/1072-Gas%20Station/","text":"1072 Gas Station Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive integers: N N ( \\le 10^3 \\le 10^3 ), the total number of houses; M M ( \\le 10 \\le 10 ), the total number of the candidate locations for the gas stations; K K ( \\le 10^4 \\le 10^4 ), the number of roads connecting the houses and the gas stations; and D_S D_S , the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N N , and all the candidate locations are numbered from G 1 to G M M . Then K K lines follow, each describes a road in the format P1 P2 Dist where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output Specification For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution . Sample Input 1 4 3 11 5 1 2 2 1 4 2 1 G1 4 1 G2 3 2 3 2 2 G2 1 3 4 2 3 G3 2 4 G1 3 G2 G1 1 G3 G2 2 Sample Output 1 G1 2.0 3.3 Sample Input 2 2 1 2 10 1 G1 9 2 G1 20 Sample Output 2 No Solution","title":"1072-Gas Station"},{"location":"PAT-Advanced-Level/1072-Gas%20Station/#1072-gas-station","text":"","title":"1072 Gas Station"},{"location":"PAT-Advanced-Level/1072-Gas%20Station/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive integers: N N ( \\le 10^3 \\le 10^3 ), the total number of houses; M M ( \\le 10 \\le 10 ), the total number of the candidate locations for the gas stations; K K ( \\le 10^4 \\le 10^4 ), the number of roads connecting the houses and the gas stations; and D_S D_S , the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N N , and all the candidate locations are numbered from G 1 to G M M . Then K K lines follow, each describes a road in the format P1 P2 Dist where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road. Output Specification For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution . Sample Input 1 4 3 11 5 1 2 2 1 4 2 1 G1 4 1 G2 3 2 3 2 2 G2 1 3 4 2 3 G3 2 4 G1 3 G2 G1 1 G3 G2 2 Sample Output 1 G1 2.0 3.3 Sample Input 2 2 1 2 10 1 G1 9 2 G1 20 Sample Output 2 No Solution","title":"Statement"},{"location":"PAT-Advanced-Level/1073-Scientific%20Notation/","text":"1073 Scientific Notation Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9] . [0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent's signs are always provided even when they are positive. Now given a real number A A in scientific notation, you are supposed to print A A in the conventional notation while keeping all the significant figures. Input Specification Each input contains one test case. For each case, there is one line containing the real number A A in scientific notation. The number is no more than 9999 bytes in length and the exponent's absolute value is no more than 9999. Output Specification For each test case, print in one line the input number A A in the conventional notation, with all the significant figures kept, including trailing zeros. Sample Input 1 +1.23400E-03 Sample Output 1 0.00123400 Sample Input 2 -1.2E+10 Sample Output 2 -12000000000","title":"1073-Scientific Notation"},{"location":"PAT-Advanced-Level/1073-Scientific%20Notation/#1073-scientific-notation","text":"","title":"1073 Scientific Notation"},{"location":"PAT-Advanced-Level/1073-Scientific%20Notation/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9] . [0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent's signs are always provided even when they are positive. Now given a real number A A in scientific notation, you are supposed to print A A in the conventional notation while keeping all the significant figures. Input Specification Each input contains one test case. For each case, there is one line containing the real number A A in scientific notation. The number is no more than 9999 bytes in length and the exponent's absolute value is no more than 9999. Output Specification For each test case, print in one line the input number A A in the conventional notation, with all the significant figures kept, including trailing zeros. Sample Input 1 +1.23400E-03 Sample Output 1 0.00123400 Sample Input 2 -1.2E+10 Sample Output 2 -12000000000","title":"Statement"},{"location":"PAT-Advanced-Level/1074-Reversing%20Linked%20List/","text":"1074 Reversing Linked List Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a constant K K and a singly linked list L L , you are supposed to reverse the links of every K K elements on L L . For example, given L L being 1\u21922\u21923\u21924\u21925\u21926, if K = 3 K = 3 , then you must output 3\u21922\u21921\u21926\u21925\u21924; if K = 4 K = 4 , you must output 4\u21923\u21922\u21921\u21925\u21926. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K K ( \\le N \\le N ) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 Sample Output 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1","title":"1074-Reversing Linked List"},{"location":"PAT-Advanced-Level/1074-Reversing%20Linked%20List/#1074-reversing-linked-list","text":"","title":"1074 Reversing Linked List"},{"location":"PAT-Advanced-Level/1074-Reversing%20Linked%20List/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a constant K K and a singly linked list L L , you are supposed to reverse the links of every K K elements on L L . For example, given L L being 1\u21922\u21923\u21924\u21925\u21926, if K = 3 K = 3 , then you must output 3\u21922\u21921\u21926\u21925\u21924; if K = 4 K = 4 , you must output 4\u21923\u21922\u21921\u21925\u21926. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K K ( \\le N \\le N ) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 Sample Output 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1075-PAT%20Judge/","text":"1075 PAT Judge Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT. Input Specification Each input file contains one test case. For each case, the first line contains 3 positive integers, N N ( \\le 10^4 \\le 10^4 ), the total number of users, K K ( \\le 5 \\le 5 ), the total number of problems, and M M ( \\le 10^5 \\le 10^5 ), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to N N , and the problem id's are from 1 to K K . The next line contains K K positive integers p[i] ( i =1, \u2026, K K ), where p[i] corresponds to the full mark of the i-th problem. Then M M lines follow, each gives the information of a submission in the following format: user_id problem_id partial_score_obtained where partial_score_obtained is either -1 -1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id] ]. All the numbers in a line are separated by a space. Output Specification For each test case, you are supposed to output the ranklist in the following format: rank user_id total_score s[1] ... s[K] where rank is calculated according to the total_score , and all the users with the same total_score obtain the same rank ; and s[i] is the partial score obtained for the i -th problem. If a user has never submitted a solution for a problem, then \"-\" must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted. The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist. Sample Input 7 4 20 20 25 25 30 00002 2 12 00007 4 17 00005 1 19 00007 2 25 00005 1 20 00002 2 2 00005 1 15 00001 1 18 00004 3 25 00002 2 25 00005 3 22 00006 4 -1 00001 2 18 00002 1 20 00004 1 15 00002 4 18 00001 3 4 00001 4 2 00005 2 -1 00004 2 0 Sample Output 1 00002 63 20 25 - 18 2 00005 42 20 0 22 - 2 00007 42 - 25 - 17 2 00001 42 18 18 4 2 5 00004 40 15 0 25 -","title":"1075-PAT Judge"},{"location":"PAT-Advanced-Level/1075-PAT%20Judge/#1075-pat-judge","text":"","title":"1075 PAT Judge"},{"location":"PAT-Advanced-Level/1075-PAT%20Judge/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT. Input Specification Each input file contains one test case. For each case, the first line contains 3 positive integers, N N ( \\le 10^4 \\le 10^4 ), the total number of users, K K ( \\le 5 \\le 5 ), the total number of problems, and M M ( \\le 10^5 \\le 10^5 ), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to N N , and the problem id's are from 1 to K K . The next line contains K K positive integers p[i] ( i =1, \u2026, K K ), where p[i] corresponds to the full mark of the i-th problem. Then M M lines follow, each gives the information of a submission in the following format: user_id problem_id partial_score_obtained where partial_score_obtained is either -1 -1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id] ]. All the numbers in a line are separated by a space. Output Specification For each test case, you are supposed to output the ranklist in the following format: rank user_id total_score s[1] ... s[K] where rank is calculated according to the total_score , and all the users with the same total_score obtain the same rank ; and s[i] is the partial score obtained for the i -th problem. If a user has never submitted a solution for a problem, then \"-\" must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted. The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist. Sample Input 7 4 20 20 25 25 30 00002 2 12 00007 4 17 00005 1 19 00007 2 25 00005 1 20 00002 2 2 00005 1 15 00001 1 18 00004 3 25 00002 2 25 00005 3 22 00006 4 -1 00001 2 18 00002 1 20 00004 1 15 00002 4 18 00001 3 4 00001 4 2 00005 2 -1 00004 2 0 Sample Output 1 00002 63 20 25 - 18 2 00005 42 20 0 22 - 2 00007 42 - 25 - 17 2 00001 42 18 18 4 2 5 00004 40 15 0 25 -","title":"Statement"},{"location":"PAT-Advanced-Level/1076-Forwards%20on%20Weibo/","text":"1076 Forwards on Weibo Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L L levels of indirect followers are counted. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 1000 \\le 1000 ), the number of users; and L L ( \\le 6 \\le 6 ), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N N . Then N N lines follow, each in the format: M[i] user_list[i] where M[i] ( \\le 100 \\le 100 ) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i] . It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K K is given, followed by K K UserID 's for query. Output Specification For each UserID , you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L L levels of indirect followers are counted. Sample Input 7 3 3 2 3 4 0 2 5 6 2 3 1 2 3 4 1 4 1 5 2 2 6 Sample Output 4 5","title":"1076-Forwards on Weibo"},{"location":"PAT-Advanced-Level/1076-Forwards%20on%20Weibo/#1076-forwards-on-weibo","text":"","title":"1076 Forwards on Weibo"},{"location":"PAT-Advanced-Level/1076-Forwards%20on%20Weibo/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L L levels of indirect followers are counted. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers: N N ( \\le 1000 \\le 1000 ), the number of users; and L L ( \\le 6 \\le 6 ), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N N . Then N N lines follow, each in the format: M[i] user_list[i] where M[i] ( \\le 100 \\le 100 ) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i] . It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K K is given, followed by K K UserID 's for query. Output Specification For each UserID , you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L L levels of indirect followers are counted. Sample Input 7 3 3 2 3 4 0 2 5 6 2 3 1 2 3 4 1 4 1 5 2 2 6 Sample Output 4 5","title":"Statement"},{"location":"PAT-Advanced-Level/1077-Kuchiguse/","text":"1077 Kuchiguse Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called \"Kuchiguse\" and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle \"nyan~\" is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification Each input file contains one test case. For each case, the first line is an integer N N ( 2\\le N\\le 100 2\\le N\\le 100 ). Following are N N file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive. Output Specification For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N N lines. If there is no such suffix, write nai . Sample Input 1 3 Itai nyan~ Ninjin wa iyadanyan~ uhhh nyan~ Sample Output 1 nyan~ Sample Input 2 3 Itai! Ninjinnwaiyada T_T T_T Sample Output 2 nai","title":"1077-Kuchiguse"},{"location":"PAT-Advanced-Level/1077-Kuchiguse/#1077-kuchiguse","text":"","title":"1077 Kuchiguse"},{"location":"PAT-Advanced-Level/1077-Kuchiguse/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called \"Kuchiguse\" and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle \"nyan~\" is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification Each input file contains one test case. For each case, the first line is an integer N N ( 2\\le N\\le 100 2\\le N\\le 100 ). Following are N N file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive. Output Specification For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N N lines. If there is no such suffix, write nai . Sample Input 1 3 Itai nyan~ Ninjin wa iyadanyan~ uhhh nyan~ Sample Output 1 nyan~ Sample Input 2 3 Itai! Ninjinnwaiyada T_T T_T Sample Output 2 nai","title":"Statement"},{"location":"PAT-Advanced-Level/1078-Hashing/","text":"1078 Hashing Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key) = key \\% TSize H(key) = key \\% TSize where TSize TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification Each input file contains one test case. For each case, the first line contains two positive numbers: MSize MSize ( \\le 10^4 \\le 10^4 ) and N N ( \\le MSize \\le MSize ) which are the user-defined table size and the number of input numbers, respectively. Then N N distinct positive integers are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print \"-\" instead. Sample Input 4 4 10 6 4 15 Sample Output 0 1 4 -","title":"1078-Hashing"},{"location":"PAT-Advanced-Level/1078-Hashing/#1078-hashing","text":"","title":"1078 Hashing"},{"location":"PAT-Advanced-Level/1078-Hashing/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key) = key \\% TSize H(key) = key \\% TSize where TSize TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification Each input file contains one test case. For each case, the first line contains two positive numbers: MSize MSize ( \\le 10^4 \\le 10^4 ) and N N ( \\le MSize \\le MSize ) which are the user-defined table size and the number of input numbers, respectively. Then N N distinct positive integers are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print \"-\" instead. Sample Input 4 4 10 6 4 15 Sample Output 0 1 4 -","title":"Statement"},{"location":"PAT-Advanced-Level/1079-Total%20Sales%20of%20Supply%20Chain/","text":"1079 Total Sales of Supply Chain Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the total sales from all the retailers. Input Specification Each input file contains one test case. For each case, the first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to N-1 N-1 , and the root supplier's ID is 0); P P , the unit price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then N N lines follow, each describes a distributor or retailer in the following format: K_i K_i ID[1] ID[2] \u2026 ID[ K_i K_i ] where in the i i -th line, K_i K_i is the total number of distributors or retailers who receive products from supplier i i , and is then followed by the ID's of these distributors or retailers. K_j K_j being 0 means that the j j -th member is a retailer, then instead the total amount of the product will be given after K_j K_j . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 10^{10} 10^{10} . Sample Input 10 1.80 1.00 3 2 3 5 1 9 1 4 1 7 0 7 2 6 1 1 8 0 9 0 4 0 3 Sample Output 42.4","title":"1079-Total Sales of Supply Chain"},{"location":"PAT-Advanced-Level/1079-Total%20Sales%20of%20Supply%20Chain/#1079-total-sales-of-supply-chain","text":"","title":"1079 Total Sales of Supply Chain"},{"location":"PAT-Advanced-Level/1079-Total%20Sales%20of%20Supply%20Chain/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the total sales from all the retailers. Input Specification Each input file contains one test case. For each case, the first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to N-1 N-1 , and the root supplier's ID is 0); P P , the unit price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then N N lines follow, each describes a distributor or retailer in the following format: K_i K_i ID[1] ID[2] \u2026 ID[ K_i K_i ] where in the i i -th line, K_i K_i is the total number of distributors or retailers who receive products from supplier i i , and is then followed by the ID's of these distributors or retailers. K_j K_j being 0 means that the j j -th member is a retailer, then instead the total amount of the product will be given after K_j K_j . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 10^{10} 10^{10} . Sample Input 10 1.80 1.00 3 2 3 5 1 9 1 4 1 7 0 7 2 6 1 1 8 0 9 0 4 0 3 Sample Output 42.4","title":"Statement"},{"location":"PAT-Advanced-Level/1080-Graduate%20Admission/","text":"1080 Graduate Admission Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade G_E G_E , and the interview grade G_I G_I . The final grade of an applicant is (G_E + G_I) / 2 (G_E + G_I) / 2 . The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list. If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade G_E G_E . If still tied, their ranks must be the same. Each applicant may have K K choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected. If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded . Input Specification Each input file contains one test case. Each case starts with a line containing three positive integers: N N ( \\le 40,000 \\le 40,000 ), the total number of applicants; M M ( \\le 100 \\le 100 ), the total number of graduate schools; and K K ( \\le 5 \\le 5 ), the number of choices an applicant may have. In the next line, separated by a space, there are M M positive integers. The i i -th integer is the quota of the i i -th graduate school respectively. Then N N lines follow, each contains 2+K 2+K integers separated by a space. The first 2 integers are the applicant's G_E G_E and G_I G_I , respectively. The next K K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M-1 M-1 , and the applicants are numbered from 0 to N-1 N-1 . Output Specification For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input 11 6 3 2 1 2 2 2 3 100 100 0 1 2 60 60 2 3 5 100 90 0 3 4 90 100 1 2 0 90 90 5 1 3 80 90 1 0 2 80 80 0 1 2 80 80 0 1 2 80 70 1 3 2 70 80 1 2 3 100 100 0 2 4 Sample Output 0 10 3 5 6 7 2 8 1 4","title":"1080-Graduate Admission"},{"location":"PAT-Advanced-Level/1080-Graduate%20Admission/#1080-graduate-admission","text":"","title":"1080 Graduate Admission"},{"location":"PAT-Advanced-Level/1080-Graduate%20Admission/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade G_E G_E , and the interview grade G_I G_I . The final grade of an applicant is (G_E + G_I) / 2 (G_E + G_I) / 2 . The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list. If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade G_E G_E . If still tied, their ranks must be the same. Each applicant may have K K choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected. If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded . Input Specification Each input file contains one test case. Each case starts with a line containing three positive integers: N N ( \\le 40,000 \\le 40,000 ), the total number of applicants; M M ( \\le 100 \\le 100 ), the total number of graduate schools; and K K ( \\le 5 \\le 5 ), the number of choices an applicant may have. In the next line, separated by a space, there are M M positive integers. The i i -th integer is the quota of the i i -th graduate school respectively. Then N N lines follow, each contains 2+K 2+K integers separated by a space. The first 2 integers are the applicant's G_E G_E and G_I G_I , respectively. The next K K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M-1 M-1 , and the applicants are numbered from 0 to N-1 N-1 . Output Specification For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input 11 6 3 2 1 2 2 2 3 100 100 0 1 2 60 60 2 3 5 100 90 0 3 4 90 100 1 2 0 90 90 5 1 3 80 90 1 0 2 80 80 0 1 2 80 80 0 1 2 80 70 1 3 2 70 80 1 2 3 100 100 0 2 4 Sample Output 0 10 3 5 6 7 2 8 1 4","title":"Statement"},{"location":"PAT-Advanced-Level/1081-Rational%20Sum/","text":"1081 Rational Sum Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given N N rational numbers in the form numerator/denominator , you are supposed to calculate their sum. Input Specification Each input file contains one test case. Each case starts with a positive integer N N ( \\le 100 \\le 100 ), followed in the next line N N rational numbers a1/b1 a2/b2 ... where all the numerators and denominators are in the range of long int . If there is a negative number, then the sign must appear in front of the numerator. Output Specification For each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator < < denominator , and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample Input 1 5 2/5 4/15 1/30 -2/60 8/3 Sample Output 1 3 1/3 Sample Input 2 2 4/3 2/3 Sample Output 2 2 Sample Input 3 3 1/3 -1/6 1/8 Sample Output 3 7/24","title":"1081-Rational Sum"},{"location":"PAT-Advanced-Level/1081-Rational%20Sum/#1081-rational-sum","text":"","title":"1081 Rational Sum"},{"location":"PAT-Advanced-Level/1081-Rational%20Sum/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given N N rational numbers in the form numerator/denominator , you are supposed to calculate their sum. Input Specification Each input file contains one test case. Each case starts with a positive integer N N ( \\le 100 \\le 100 ), followed in the next line N N rational numbers a1/b1 a2/b2 ... where all the numerators and denominators are in the range of long int . If there is a negative number, then the sign must appear in front of the numerator. Output Specification For each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator < < denominator , and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample Input 1 5 2/5 4/15 1/30 -2/60 8/3 Sample Output 1 3 1/3 Sample Input 2 2 4/3 2/3 Sample Output 2 2 Sample Input 3 3 1/3 -1/6 1/8 Sample Output 3 7/24","title":"Statement"},{"location":"PAT-Advanced-Level/1082-Read%20Number%20in%20Chinese/","text":"1082 Read Number in Chinese Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu . Note: zero ( ling ) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai . Input Specification Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1 -123456789 Sample Output 1 Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2 100800 Sample Output 2 yi Shi Wan ling ba Bai","title":"1082-Read Number in Chinese"},{"location":"PAT-Advanced-Level/1082-Read%20Number%20in%20Chinese/#1082-read-number-in-chinese","text":"","title":"1082 Read Number in Chinese"},{"location":"PAT-Advanced-Level/1082-Read%20Number%20in%20Chinese/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu . Note: zero ( ling ) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai . Input Specification Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1 -123456789 Sample Output 1 Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2 100800 Sample Output 2 yi Shi Wan ling ba Bai","title":"Statement"},{"location":"PAT-Advanced-Level/1083-List%20Grades/","text":"1083 List Grades Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a list of N N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval. Input Specification Each input file contains one test case. Each case is given in the following format: N name[1] ID[1] grade[1] name[2] ID[2] grade[2] ... ... name[N] ID[N] grade[N] grade1 grade2 where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade's interval. It is guaranteed that all the grades are distinct . Output Specification For each test case you should output the student records of which the grades are in the given interval [ grade1 , grade2 ] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output NONE instead. Sample Input 1 4 Tom CS000001 59 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 60 100 Sample Output 1 Mike CS991301 Mary EE990830 Joe Math990112 Sample Input 2 2 Jean AA980920 60 Ann CS01 80 90 95 Sample Output 2 NONE","title":"1083-List Grades"},{"location":"PAT-Advanced-Level/1083-List%20Grades/#1083-list-grades","text":"","title":"1083 List Grades"},{"location":"PAT-Advanced-Level/1083-List%20Grades/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a list of N N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval. Input Specification Each input file contains one test case. Each case is given in the following format: N name[1] ID[1] grade[1] name[2] ID[2] grade[2] ... ... name[N] ID[N] grade[N] grade1 grade2 where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade's interval. It is guaranteed that all the grades are distinct . Output Specification For each test case you should output the student records of which the grades are in the given interval [ grade1 , grade2 ] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output NONE instead. Sample Input 1 4 Tom CS000001 59 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 60 100 Sample Output 1 Mike CS991301 Mary EE990830 Joe Math990112 Sample Input 2 2 Jean AA980920 60 Ann CS01 80 90 95 Sample Output 2 NONE","title":"Statement"},{"location":"PAT-Advanced-Level/1084-Broken%20Keyboard/","text":"1084 Broken Keyboard Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen. Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out. Input Specification Each input file contains one test case. For each case, the 1 st line contains the original string, and the 2 nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or _ (representing the space). It is guaranteed that both strings are non-empty. Output Specification For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key. Sample Input 7_This_is_a_test _hs_s_a_es Sample Output 7TI","title":"1084-Broken Keyboard"},{"location":"PAT-Advanced-Level/1084-Broken%20Keyboard/#1084-broken-keyboard","text":"","title":"1084 Broken Keyboard"},{"location":"PAT-Advanced-Level/1084-Broken%20Keyboard/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen. Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out. Input Specification Each input file contains one test case. For each case, the 1 st line contains the original string, and the 2 nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or _ (representing the space). It is guaranteed that both strings are non-empty. Output Specification For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key. Sample Input 7_This_is_a_test _hs_s_a_es Sample Output 7TI","title":"Statement"},{"location":"PAT-Advanced-Level/1085-Perfect%20Sequence/","text":"1085 Perfect Sequence Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of positive integers and another positive integer p p . The sequence is said to be a perfect sequence if M \\le m \\times p M \\le m \\times p where M M and m m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p p , you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers N N and p p , where N N ( \\le 10^5 \\le 10^5 ) is the number of integers in the sequence, and p p ( \\le 10^9 \\le 10^9 ) is the parameter. In the second line there are N N positive integers, each is no greater than 10^9 10^9 . Output Specification For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input 10 8 2 3 20 4 5 1 6 7 8 9 Sample Output 8","title":"1085-Perfect Sequence"},{"location":"PAT-Advanced-Level/1085-Perfect%20Sequence/#1085-perfect-sequence","text":"","title":"1085 Perfect Sequence"},{"location":"PAT-Advanced-Level/1085-Perfect%20Sequence/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of positive integers and another positive integer p p . The sequence is said to be a perfect sequence if M \\le m \\times p M \\le m \\times p where M M and m m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p p , you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers N N and p p , where N N ( \\le 10^5 \\le 10^5 ) is the number of integers in the sequence, and p p ( \\le 10^9 \\le 10^9 ) is the parameter. In the second line there are N N positive integers, each is no greater than 10^9 10^9 . Output Specification For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input 10 8 2 3 20 4 5 1 6 7 8 9 Sample Output 8","title":"Statement"},{"location":"PAT-Advanced-Level/1086-Tree%20Traversals%20Again/","text":"1086 Tree Traversals Again Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree. Figure 1 Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 30 \\le 30 ) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N N ). Then 2N 2N lines follow, each describes a stack operation in the format: \"Push X\" where X is the index of the node being pushed onto the stack; or \"Pop\" meaning to pop one node from the stack. Output Specification For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 6 Push 1 Push 2 Push 3 Pop Pop Push 4 Pop Pop Push 5 Push 6 Pop Pop Sample Output 3 4 2 6 5 1","title":"1086-Tree Traversals Again"},{"location":"PAT-Advanced-Level/1086-Tree%20Traversals%20Again/#1086-tree-traversals-again","text":"","title":"1086 Tree Traversals Again"},{"location":"PAT-Advanced-Level/1086-Tree%20Traversals%20Again/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree. Figure 1 Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le 30 \\le 30 ) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N N ). Then 2N 2N lines follow, each describes a stack operation in the format: \"Push X\" where X is the index of the node being pushed onto the stack; or \"Pop\" meaning to pop one node from the stack. Output Specification For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 6 Push 1 Push 2 Push 3 Pop Pop Push 4 Pop Pop Push 5 Push 6 Pop Pop Sample Output 3 4 2 6 5 1","title":"Statement"},{"location":"PAT-Advanced-Level/1087-All%20Roads%20Lead%20to%20Rome/","text":"1087 All Roads Lead to Rome Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2\\le N\\le 200 2\\le N\\le 200 ), the number of cities, and K K , the total number of routes between pairs of cities; followed by the name of the starting city. The next N-1 N-1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K K lines follow, each describes a route between two cities in the format City1 City2 Cost . Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome. Output Specification For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness \u2013 it is guaranteed by the judge that such a solution exists and is unique. Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1->City2->...->ROM . Sample Input 6 7 HZH ROM 100 PKN 40 GDN 55 PRS 95 BLN 80 ROM GDN 1 BLN ROM 1 HZH PKN 1 PRS ROM 2 BLN HZH 2 PKN GDN 1 HZH PRS 1 Sample Output 3 3 195 97 HZH->PRS->ROM Tutorial \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u65e0\u5411\u56fe\uff0c\u7ed9\u51fa\u8d77\u70b9\uff0c\u7ec8\u70b9\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u70b9(\u9664\u4e86\u8d77\u70b9)\u6709\u70b9\u6743\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u627e\u4e00\u6761\u6700\u77ed\u8def\u5f84\uff0c\u4f9d\u6b21\u6ee1\u8db3\u5982\u4e0b\u4e09\u4e2a\u6761\u4ef6\uff1a \u9996\u5148\u6ee1\u8db3\u8fb9\u6743\u548c\u6700\u5c0f\u3002 \u5176\u6b21\u6ee1\u8db3\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u6240\u6709\u70b9\u7684\u70b9\u6743\u548c\u6700\u5927\u3002 \u6700\u540e\u6ee1\u8db3\u7ecf\u8fc7\u7684\u70b9\u6570\u6700\u5c11\u3002 \u53e6\u5916\u8fd8\u8981\u6c42\u8fb9\u6743\u548c\u6700\u5c0f\u7684\u4e0d\u540c\u8def\u5f84\u6761\u6570\uff0c\u548c\u4e0a\u8ff0\u8def\u5f84\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u3002 \u6ce8\u610f\uff1a\u7b2c\u4e09\u4e2a\u6761\u4ef6\uff0c\u9898\u76ee\u672c\u8eab\u7ed9\u51fa\u7684\u5b9e\u9645\u4e0a\u70b9\u6743\u548c\u7684\u5e73\u5747\u503c\u6700\u5927\u3002 \u601d\u8def\uff1a \u8001 Dijkstra \u5957\u8def\u4e86\uff0c\u53ea\u4e0d\u8fc7\u8f6c\u79fb\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u7684\u53d8\u91cf\u591a\u4e86\u70b9\uff0c\u987a\u4fbf\u8bb0\u5f55\u4e0b\u65b9\u6848\u548c\u524d\u9a71\u7ed3\u70b9\u5373\u53ef\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1e3 + 10 , INF = 0x3f3f3f3f ; map < string , int > mp ; int n , m , w [ N ], pre [ N ]; string st , ed , fmp [ N ]; vector < vector < pII > > G ; int getID ( const string & s ) { static int cnt = 0 ; if ( mp . count ( s ) == 0 ) { mp [ s ] = ++ cnt ; fmp [ cnt ] = s ; } return mp [ s ]; } struct valde { int cost , w , num ; valde () {} valde ( int cost , int w , int num ) : cost ( cost ), w ( w ), num ( num ) {} bool operator < ( const valde & other ) const { if ( cost != other . cost ) return cost < other . cost ; if ( w != other . w ) return w > other . w ; if ( num != other . num ) return num < other . num ; return false ; } }; struct node { int to ; valde val ; node () {} node ( int to , valde val ) : to ( to ), val ( val ) {} bool operator < ( const node & other ) const { return ! ( val < other . val ); } }; valde dis [ N ]; bool vis [ N ]; int f [ N ]; void gao ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = valde ( INF , w [ i ], 1 ); vis [ i ] = 0 ; f [ i ] = 0 ; } dis [ st ] = valde ( 0 , w [ st ], 1 ); priority_queue < node > pq ; pq . push ( node ( st , dis [ st ])); pre [ st ] = -1 ; f [ st ] = 1 ; while ( ! pq . empty ()) { node u = pq . top (); pq . pop (); if ( vis [ u . to ]) continue ; // cout << u.to << \" \" << f[u.to] << endl; vis [ u . to ] = 1 ; for ( auto & it : G [ u . to ]) { int v = it . fi , cost = it . se ; valde tmp = u . val ; tmp . cost += cost ; tmp . w += w [ v ]; tmp . num ++ ; if ( tmp . cost == dis [ v ]. cost ) f [ v ] += f [ u . to ]; else if ( tmp . cost < dis [ v ]. cost ) f [ v ] = f [ u . to ]; if ( tmp < dis [ v ]) { dis [ v ] = tmp ; pre [ v ] = u . to ; pq . push ( node ( v , tmp )); } } } int ed = getID ( \"ROM\" ); // cout << ed << endl; // return; cout << f [ ed ] << \" \" << dis [ ed ]. cost << \" \" << dis [ ed ]. w << \" \" << dis [ ed ]. w / ( dis [ ed ]. num - 1 ) << \" \\n \" ; vector < int > res ; while ( ed != -1 ) { res . push_back ( ed ); ed = pre [ ed ]; } reverse ( res . begin (), res . end ()); for ( int i = 0 ; i < SZ ( res ); ++ i ) { cout << fmp [ res [ i ]]; if ( i != SZ ( res ) - 1 ) cout << \"->\" ; else cout << \" \\n \" ; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); ed = \"ROM\" ; cin >> n >> m >> st ; G . clear (); G . resize ( n + 1 ); for ( int i = 1 , _w ; i < n ; ++ i ) { string s ; cin >> s >> _w ; w [ getID ( s )] = _w ; } for ( int i = 1 , u , v , cost ; i <= m ; ++ i ) { string _u , _v ; cin >> _u >> _v >> cost ; u = getID ( _u ); v = getID ( _v ); G [ u ]. push_back ( pII ( v , cost )); G [ v ]. push_back ( pII ( u , cost )); } getID ( st ); // for (int i = 1; i <= n; ++i) cout << fmp[i] << endl; gao ( getID ( st )); return 0 ; }","title":"1087-All Roads Lead to Rome"},{"location":"PAT-Advanced-Level/1087-All%20Roads%20Lead%20to%20Rome/#1087-all-roads-lead-to-rome","text":"","title":"1087 All Roads Lead to Rome"},{"location":"PAT-Advanced-Level/1087-All%20Roads%20Lead%20to%20Rome/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2\\le N\\le 200 2\\le N\\le 200 ), the number of cities, and K K , the total number of routes between pairs of cities; followed by the name of the starting city. The next N-1 N-1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K K lines follow, each describes a route between two cities in the format City1 City2 Cost . Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome. Output Specification For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness \u2013 it is guaranteed by the judge that such a solution exists and is unique. Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1->City2->...->ROM . Sample Input 6 7 HZH ROM 100 PKN 40 GDN 55 PRS 95 BLN 80 ROM GDN 1 BLN ROM 1 HZH PKN 1 PRS ROM 2 BLN HZH 2 PKN GDN 1 HZH PRS 1 Sample Output 3 3 195 97 HZH->PRS->ROM","title":"Statement"},{"location":"PAT-Advanced-Level/1087-All%20Roads%20Lead%20to%20Rome/#tutorial","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u65e0\u5411\u56fe\uff0c\u7ed9\u51fa\u8d77\u70b9\uff0c\u7ec8\u70b9\u56fa\u5b9a\uff0c\u6bcf\u4e2a\u70b9(\u9664\u4e86\u8d77\u70b9)\u6709\u70b9\u6743\uff0c\u6bcf\u6761\u8fb9\u6709\u8fb9\u6743\uff0c\u627e\u4e00\u6761\u6700\u77ed\u8def\u5f84\uff0c\u4f9d\u6b21\u6ee1\u8db3\u5982\u4e0b\u4e09\u4e2a\u6761\u4ef6\uff1a \u9996\u5148\u6ee1\u8db3\u8fb9\u6743\u548c\u6700\u5c0f\u3002 \u5176\u6b21\u6ee1\u8db3\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u6240\u6709\u70b9\u7684\u70b9\u6743\u548c\u6700\u5927\u3002 \u6700\u540e\u6ee1\u8db3\u7ecf\u8fc7\u7684\u70b9\u6570\u6700\u5c11\u3002 \u53e6\u5916\u8fd8\u8981\u6c42\u8fb9\u6743\u548c\u6700\u5c0f\u7684\u4e0d\u540c\u8def\u5f84\u6761\u6570\uff0c\u548c\u4e0a\u8ff0\u8def\u5f84\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u3002 \u6ce8\u610f\uff1a\u7b2c\u4e09\u4e2a\u6761\u4ef6\uff0c\u9898\u76ee\u672c\u8eab\u7ed9\u51fa\u7684\u5b9e\u9645\u4e0a\u70b9\u6743\u548c\u7684\u5e73\u5747\u503c\u6700\u5927\u3002 \u601d\u8def\uff1a \u8001 Dijkstra \u5957\u8def\u4e86\uff0c\u53ea\u4e0d\u8fc7\u8f6c\u79fb\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u7684\u53d8\u91cf\u591a\u4e86\u70b9\uff0c\u987a\u4fbf\u8bb0\u5f55\u4e0b\u65b9\u6848\u548c\u524d\u9a71\u7ed3\u70b9\u5373\u53ef\u3002","title":"Tutorial"},{"location":"PAT-Advanced-Level/1087-All%20Roads%20Lead%20to%20Rome/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1e3 + 10 , INF = 0x3f3f3f3f ; map < string , int > mp ; int n , m , w [ N ], pre [ N ]; string st , ed , fmp [ N ]; vector < vector < pII > > G ; int getID ( const string & s ) { static int cnt = 0 ; if ( mp . count ( s ) == 0 ) { mp [ s ] = ++ cnt ; fmp [ cnt ] = s ; } return mp [ s ]; } struct valde { int cost , w , num ; valde () {} valde ( int cost , int w , int num ) : cost ( cost ), w ( w ), num ( num ) {} bool operator < ( const valde & other ) const { if ( cost != other . cost ) return cost < other . cost ; if ( w != other . w ) return w > other . w ; if ( num != other . num ) return num < other . num ; return false ; } }; struct node { int to ; valde val ; node () {} node ( int to , valde val ) : to ( to ), val ( val ) {} bool operator < ( const node & other ) const { return ! ( val < other . val ); } }; valde dis [ N ]; bool vis [ N ]; int f [ N ]; void gao ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = valde ( INF , w [ i ], 1 ); vis [ i ] = 0 ; f [ i ] = 0 ; } dis [ st ] = valde ( 0 , w [ st ], 1 ); priority_queue < node > pq ; pq . push ( node ( st , dis [ st ])); pre [ st ] = -1 ; f [ st ] = 1 ; while ( ! pq . empty ()) { node u = pq . top (); pq . pop (); if ( vis [ u . to ]) continue ; // cout << u.to << \" \" << f[u.to] << endl; vis [ u . to ] = 1 ; for ( auto & it : G [ u . to ]) { int v = it . fi , cost = it . se ; valde tmp = u . val ; tmp . cost += cost ; tmp . w += w [ v ]; tmp . num ++ ; if ( tmp . cost == dis [ v ]. cost ) f [ v ] += f [ u . to ]; else if ( tmp . cost < dis [ v ]. cost ) f [ v ] = f [ u . to ]; if ( tmp < dis [ v ]) { dis [ v ] = tmp ; pre [ v ] = u . to ; pq . push ( node ( v , tmp )); } } } int ed = getID ( \"ROM\" ); // cout << ed << endl; // return; cout << f [ ed ] << \" \" << dis [ ed ]. cost << \" \" << dis [ ed ]. w << \" \" << dis [ ed ]. w / ( dis [ ed ]. num - 1 ) << \" \\n \" ; vector < int > res ; while ( ed != -1 ) { res . push_back ( ed ); ed = pre [ ed ]; } reverse ( res . begin (), res . end ()); for ( int i = 0 ; i < SZ ( res ); ++ i ) { cout << fmp [ res [ i ]]; if ( i != SZ ( res ) - 1 ) cout << \"->\" ; else cout << \" \\n \" ; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); ed = \"ROM\" ; cin >> n >> m >> st ; G . clear (); G . resize ( n + 1 ); for ( int i = 1 , _w ; i < n ; ++ i ) { string s ; cin >> s >> _w ; w [ getID ( s )] = _w ; } for ( int i = 1 , u , v , cost ; i <= m ; ++ i ) { string _u , _v ; cin >> _u >> _v >> cost ; u = getID ( _u ); v = getID ( _v ); G [ u ]. push_back ( pII ( v , cost )); G [ v ]. push_back ( pII ( u , cost )); } getID ( st ); // for (int i = 1; i <= n; ++i) cout << fmp[i] << endl; gao ( getID ( st )); return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1088-Rational%20Arithmetic/","text":"1088 Rational Arithmetic Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient. Input Specification Each input file contains one test case, which gives in one line the two rational numbers in the format a1/b1 a2/b2 . The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers. Output Specification For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is number1 operator number2 = result . Notice that all the rational numbers must be in their simplest form k a/b , where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output Inf as the result. It is guaranteed that all the output integers are in the range of long int . Sample Input 1 2/3 -4/2 Sample Output 1 2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) Sample Input 2 5/3 0/6 Sample Output 2 1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf","title":"1088-Rational Arithmetic"},{"location":"PAT-Advanced-Level/1088-Rational%20Arithmetic/#1088-rational-arithmetic","text":"","title":"1088 Rational Arithmetic"},{"location":"PAT-Advanced-Level/1088-Rational%20Arithmetic/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient. Input Specification Each input file contains one test case, which gives in one line the two rational numbers in the format a1/b1 a2/b2 . The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers. Output Specification For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is number1 operator number2 = result . Notice that all the rational numbers must be in their simplest form k a/b , where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output Inf as the result. It is guaranteed that all the output integers are in the range of long int . Sample Input 1 2/3 -4/2 Sample Output 1 2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) Sample Input 2 5/3 0/6 Sample Output 2 1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf","title":"Statement"},{"location":"PAT-Advanced-Level/1089-Insert%20or%20Merge/","text":"1089 Insert or Merge Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then in the next line, N N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification For each test case, print in the first line either \"Insertion Sort\" or \"Merge Sort\" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 Sample Output 2 Merge Sort 1 2 3 8 4 5 7 9 0 6 \u9e23\u8c22\u7528\u6237 \u6728\u5b50 \u8865\u5145\u6570\u636e\uff01","title":"1089-Insert or Merge"},{"location":"PAT-Advanced-Level/1089-Insert%20or%20Merge/#1089-insert-or-merge","text":"","title":"1089 Insert or Merge"},{"location":"PAT-Advanced-Level/1089-Insert%20or%20Merge/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then in the next line, N N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification For each test case, print in the first line either \"Insertion Sort\" or \"Merge Sort\" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 Sample Output 2 Merge Sort 1 2 3 8 4 5 7 9 0 6 \u9e23\u8c22\u7528\u6237 \u6728\u5b50 \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1090-Highest%20Price%20in%20Supply%20Chain/","text":"1090 Highest Price in Supply Chain Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers. Input Specification Each input file contains one test case. For each case, The first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence they are numbered from 0 to N-1 N-1 ); P P , the price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then the next line contains N N numbers, each number S_i S_i is the index of the supplier for the i i -th member. S_{root} S_{root} for the root supplier is defined to be -1 -1 . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 10^{10} 10^{10} . Sample Input 9 1.80 1.00 1 5 4 4 -1 4 5 3 6 Sample Output 1.85 2","title":"1090-Highest Price in Supply Chain"},{"location":"PAT-Advanced-Level/1090-Highest%20Price%20in%20Supply%20Chain/#1090-highest-price-in-supply-chain","text":"","title":"1090 Highest Price in Supply Chain"},{"location":"PAT-Advanced-Level/1090-Highest%20Price%20in%20Supply%20Chain/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers. Input Specification Each input file contains one test case. For each case, The first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence they are numbered from 0 to N-1 N-1 ); P P , the price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then the next line contains N N numbers, each number S_i S_i is the index of the supplier for the i i -th member. S_{root} S_{root} for the root supplier is defined to be -1 -1 . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 10^{10} 10^{10} . Sample Input 9 1.80 1.00 1 5 4 4 -1 4 5 3 6 Sample Output 1.85 2","title":"Statement"},{"location":"PAT-Advanced-Level/1091-Acute%20Stroke/","text":"1091 Acute Stroke Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB One important factor to identify acute stroke (\u6025\u6027\u8111\u5352\u4e2d) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive integers: M M , N N , L L and T T , where M M and N N are the sizes of each slice (i.e. pixels of a slice are in an M \\times N M \\times N matrix, and the maximum resolution is 1286 by 128); L L ( \\le 60 \\le 60 ) is the number of slices of a brain; and T T is the integer threshold (i.e. if the volume of a connected core is less than T T , then that core must not be counted). Then L L slices are given. Each slice is represented by an M \\times N M \\times N matrix of 0's and 1's, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1's to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than T T are counted. Two pixels are connected and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one. Figure 1 Output Specification For each case, output in a line the total volume of the stroke core. Sample Input 3 4 5 2 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 Sample Output 26 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e6 ; int n , m , L , T , now , tot ; int G [ N ], vis [ N ]; int Move [][ 3 ] = { { 0 , 0 , 1 }, { 0 , 0 , -1 }, { 0 , 1 , 0 }, { 0 , -1 , 0 }, { 1 , 0 , 0 }, { -1 , 0 , 0 }, }; inline int id ( int x , int y , int z ) { ++ x , ++ y , ++ z ; return ( x - 1 ) * ( n * m ) + ( y - 1 ) * m + z ; } bool ok ( int x , int y , int z ) { if ( x < 0 || x >= L || y < 0 || y >= n || z < 0 || z >= m || vis [ id ( x , y , z )] || G [ id ( x , y , z )] == 0 ) return false ; return true ; } struct E { int x , y , z ; E () {} E ( int x , int y , int z ) : x ( x ), y ( y ), z ( z ) {} }; void bfs ( int x , int y , int z ) { queue < E > que ; que . emplace ( x , y , z ); while ( ! que . empty ()) { x = que . front (). x ; y = que . front (). y ; z = que . front (). z ; que . pop (); vis [ id ( x , y , z )] = 1 ; ++ now ; for ( int i = 0 ; i < 6 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; int nz = z + Move [ i ][ 2 ]; if ( ok ( nx , ny , nz )) { vis [ id ( nx , ny , nz )] = 1 ; que . emplace ( nx , ny , nz ); } } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m >> L >> T ; memset ( G , 0 , sizeof G ); memset ( vis , 0 , sizeof vis ); tot = 0 ; for ( int i = 0 ; i < L ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { cin >> G [ id ( i , j , k )]; } } } for ( int i = 0 ; i < L ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( G [ id ( i , j , k )] == 1 && vis [ id ( i , j , k )] == 0 ) { now = 0 ; bfs ( i , j , k ); if ( now >= T ) { tot += now ; } } } } } cout << tot << \" \\n \" ; return 0 ; }","title":"1091-Acute Stroke"},{"location":"PAT-Advanced-Level/1091-Acute%20Stroke/#1091-acute-stroke","text":"","title":"1091 Acute Stroke"},{"location":"PAT-Advanced-Level/1091-Acute%20Stroke/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB One important factor to identify acute stroke (\u6025\u6027\u8111\u5352\u4e2d) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core. Input Specification Each input file contains one test case. For each case, the first line contains 4 positive integers: M M , N N , L L and T T , where M M and N N are the sizes of each slice (i.e. pixels of a slice are in an M \\times N M \\times N matrix, and the maximum resolution is 1286 by 128); L L ( \\le 60 \\le 60 ) is the number of slices of a brain; and T T is the integer threshold (i.e. if the volume of a connected core is less than T T , then that core must not be counted). Then L L slices are given. Each slice is represented by an M \\times N M \\times N matrix of 0's and 1's, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1's to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than T T are counted. Two pixels are connected and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one. Figure 1 Output Specification For each case, output in a line the total volume of the stroke core. Sample Input 3 4 5 2 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 1 0 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 Sample Output 26","title":"Statement"},{"location":"PAT-Advanced-Level/1091-Acute%20Stroke/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e6 ; int n , m , L , T , now , tot ; int G [ N ], vis [ N ]; int Move [][ 3 ] = { { 0 , 0 , 1 }, { 0 , 0 , -1 }, { 0 , 1 , 0 }, { 0 , -1 , 0 }, { 1 , 0 , 0 }, { -1 , 0 , 0 }, }; inline int id ( int x , int y , int z ) { ++ x , ++ y , ++ z ; return ( x - 1 ) * ( n * m ) + ( y - 1 ) * m + z ; } bool ok ( int x , int y , int z ) { if ( x < 0 || x >= L || y < 0 || y >= n || z < 0 || z >= m || vis [ id ( x , y , z )] || G [ id ( x , y , z )] == 0 ) return false ; return true ; } struct E { int x , y , z ; E () {} E ( int x , int y , int z ) : x ( x ), y ( y ), z ( z ) {} }; void bfs ( int x , int y , int z ) { queue < E > que ; que . emplace ( x , y , z ); while ( ! que . empty ()) { x = que . front (). x ; y = que . front (). y ; z = que . front (). z ; que . pop (); vis [ id ( x , y , z )] = 1 ; ++ now ; for ( int i = 0 ; i < 6 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; int nz = z + Move [ i ][ 2 ]; if ( ok ( nx , ny , nz )) { vis [ id ( nx , ny , nz )] = 1 ; que . emplace ( nx , ny , nz ); } } } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m >> L >> T ; memset ( G , 0 , sizeof G ); memset ( vis , 0 , sizeof vis ); tot = 0 ; for ( int i = 0 ; i < L ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { cin >> G [ id ( i , j , k )]; } } } for ( int i = 0 ; i < L ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( G [ id ( i , j , k )] == 1 && vis [ id ( i , j , k )] == 0 ) { now = 0 ; bfs ( i , j , k ); if ( now >= T ) { tot += now ; } } } } } cout << tot << \" \\n \" ; return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1092-To%20Buy%20or%20Not%20to%20Buy/","text":"1092 To Buy or Not to Buy Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes , please tell her the number of extra beads she has to buy; or if the answer is No , please tell her the number of beads missing from the string. For the sake of simplicity, let's use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3 rd string in Figure 1 is the one that Eva would like to make. Then the 1 st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2 nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification For each test case, print your answer in one line. If the answer is Yes , then also output the number of extra beads Eva has to buy; or if the answer is No , then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1 ppRYYGrrYBR2258 YrR8RrY Sample Output 1 Yes 8 Sample Input 2 ppRYYGrrYB225 YrR8RrY Sample Output 2 No 2","title":"1092-To Buy or Not to Buy"},{"location":"PAT-Advanced-Level/1092-To%20Buy%20or%20Not%20to%20Buy/#1092-to-buy-or-not-to-buy","text":"","title":"1092 To Buy or Not to Buy"},{"location":"PAT-Advanced-Level/1092-To%20Buy%20or%20Not%20to%20Buy/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes , please tell her the number of extra beads she has to buy; or if the answer is No , please tell her the number of beads missing from the string. For the sake of simplicity, let's use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3 rd string in Figure 1 is the one that Eva would like to make. Then the 1 st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2 nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification For each test case, print your answer in one line. If the answer is Yes , then also output the number of extra beads Eva has to buy; or if the answer is No , then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1 ppRYYGrrYBR2258 YrR8RrY Sample Output 1 Yes 8 Sample Input 2 ppRYYGrrYB225 YrR8RrY Sample Output 2 No 2","title":"Statement"},{"location":"PAT-Advanced-Level/1093-Count%20PAT%27s/","text":"1093 Count PAT's Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB The string APPAPT contains two PAT 's as substrings. The first one is formed by the 2 nd , the 4 th , and the 6 th characters, and the second one is formed by the 3 rd , the 4 th , and the 6 th characters. Now given any string, you are supposed to tell the number of PAT 's contained in the string. Input Specification Each input file contains one test case. For each case, there is only one line giving a string of no more than 10^5 10^5 characters containing only P , A , or T . Output Specification For each test case, print in one line the number of PAT 's contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input APPAPT Sample Output 2 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 , mod = 1e9 + 7 ; char s [ N ]; int f [ 110 ]; int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { memset ( f , 0 , sizeof f ); for ( int i = 1 ; s [ i ]; ++ i ) { if ( s [ i ] == 'P' ) { ++ f [ 'P' ]; } else if ( s [ i ] == 'A' ) { f [ 'A' ] += f [ 'P' ]; } else { f [ 'T' ] += f [ 'A' ]; } f [ s [ i ]] %= mod ; } printf ( \"%d \\n \" , f [ 'T' ]); } return 0 ; }","title":"1093-Count PAT's"},{"location":"PAT-Advanced-Level/1093-Count%20PAT%27s/#1093-count-pats","text":"","title":"1093 Count PAT's"},{"location":"PAT-Advanced-Level/1093-Count%20PAT%27s/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB The string APPAPT contains two PAT 's as substrings. The first one is formed by the 2 nd , the 4 th , and the 6 th characters, and the second one is formed by the 3 rd , the 4 th , and the 6 th characters. Now given any string, you are supposed to tell the number of PAT 's contained in the string. Input Specification Each input file contains one test case. For each case, there is only one line giving a string of no more than 10^5 10^5 characters containing only P , A , or T . Output Specification For each test case, print in one line the number of PAT 's contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input APPAPT Sample Output 2","title":"Statement"},{"location":"PAT-Advanced-Level/1093-Count%20PAT%27s/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 , mod = 1e9 + 7 ; char s [ N ]; int f [ 110 ]; int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { memset ( f , 0 , sizeof f ); for ( int i = 1 ; s [ i ]; ++ i ) { if ( s [ i ] == 'P' ) { ++ f [ 'P' ]; } else if ( s [ i ] == 'A' ) { f [ 'A' ] += f [ 'P' ]; } else { f [ 'T' ] += f [ 'A' ]; } f [ s [ i ]] %= mod ; } printf ( \"%d \\n \" , f [ 'T' ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1094-The%20Largest%20Generation/","text":"1094 The Largest Generation Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population. Input Specification Each input file contains one test case. Each case starts with two positive integers N N ( <100 <100 ) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N N ), and M M ( <N <N ) which is the number of family members who have children. Then M M lines follow, each contains the information of a family member in the following format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a family member, K ( >0 >0 ) is the number of his/her children, followed by a sequence of two-digit ID 's of his/her children. For the sake of simplicity, let us fix the root ID to be 01 . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1. Sample Input 23 13 21 1 23 01 4 03 02 04 05 03 3 06 07 08 06 2 12 13 13 1 21 08 2 15 16 02 2 09 10 11 2 19 20 17 1 22 05 1 11 07 1 14 09 1 17 10 1 18 Sample Output 9 4","title":"1094-The Largest Generation"},{"location":"PAT-Advanced-Level/1094-The%20Largest%20Generation/#1094-the-largest-generation","text":"","title":"1094 The Largest Generation"},{"location":"PAT-Advanced-Level/1094-The%20Largest%20Generation/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population. Input Specification Each input file contains one test case. Each case starts with two positive integers N N ( <100 <100 ) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N N ), and M M ( <N <N ) which is the number of family members who have children. Then M M lines follow, each contains the information of a family member in the following format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a family member, K ( >0 >0 ) is the number of his/her children, followed by a sequence of two-digit ID 's of his/her children. For the sake of simplicity, let us fix the root ID to be 01 . All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1. Sample Input 23 13 21 1 23 01 4 03 02 04 05 03 3 06 07 08 06 2 12 13 13 1 21 08 2 15 16 02 2 09 10 11 2 19 20 17 1 22 05 1 11 07 1 14 09 1 17 10 1 18 Sample Output 9 4","title":"Statement"},{"location":"PAT-Advanced-Level/1095-Cars%20on%20Campus/","text":"1095 Cars on Campus Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period. Input Specification Each input file contains one test case. Each case starts with two positive integers N N ( \\le 10^4 \\le 10^4 ), the number of records, and K K ( \\le 8\\times 10^4 \\le 8\\times 10^4 ) the number of queries. Then N N lines follow, each gives a record in the format: plate_number hh:mm:ss status where plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59 ; and status is either in or out . Note that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an out record. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock. Then K K lines of queries follow, each gives a time point in the format hh:mm:ss . Note: the queries are given in ascending order of the times. Output Specification For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space. Sample Input 16 7 JH007BD 18:00:01 in ZD00001 11:30:08 out DB8888A 13:00:00 out ZA3Q625 23:59:50 out ZA133CH 10:23:00 in ZD00001 04:09:59 in JH007BD 05:09:59 in ZA3Q625 11:42:01 out JH007BD 05:10:33 in ZA3Q625 06:30:50 in JH007BD 12:23:42 out ZA3Q625 23:55:00 in JH007BD 12:24:23 out ZA133CH 17:11:22 out JH007BD 18:07:01 out DB8888A 06:30:50 in 05:10:00 06:30:50 11:00:00 12:23:42 14:00:00 18:00:00 23:59:00 Sample Output 1 4 5 2 1 0 1 JH007BD ZD00001 07:20:09","title":"1095-Cars on Campus"},{"location":"PAT-Advanced-Level/1095-Cars%20on%20Campus/#1095-cars-on-campus","text":"","title":"1095 Cars on Campus"},{"location":"PAT-Advanced-Level/1095-Cars%20on%20Campus/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period. Input Specification Each input file contains one test case. Each case starts with two positive integers N N ( \\le 10^4 \\le 10^4 ), the number of records, and K K ( \\le 8\\times 10^4 \\le 8\\times 10^4 ) the number of queries. Then N N lines follow, each gives a record in the format: plate_number hh:mm:ss status where plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59 ; and status is either in or out . Note that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an out record. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock. Then K K lines of queries follow, each gives a time point in the format hh:mm:ss . Note: the queries are given in ascending order of the times. Output Specification For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space. Sample Input 16 7 JH007BD 18:00:01 in ZD00001 11:30:08 out DB8888A 13:00:00 out ZA3Q625 23:59:50 out ZA133CH 10:23:00 in ZD00001 04:09:59 in JH007BD 05:09:59 in ZA3Q625 11:42:01 out JH007BD 05:10:33 in ZA3Q625 06:30:50 in JH007BD 12:23:42 out ZA3Q625 23:55:00 in JH007BD 12:24:23 out ZA133CH 17:11:22 out JH007BD 18:07:01 out DB8888A 06:30:50 in 05:10:00 06:30:50 11:00:00 12:23:42 14:00:00 18:00:00 23:59:00 Sample Output 1 4 5 2 1 0 1 JH007BD ZD00001 07:20:09","title":"Statement"},{"location":"PAT-Advanced-Level/1096-Consecutive%20Factors/","text":"1096 Consecutive Factors Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3 \\times \\times 5 \\times \\times 6 \\times \\times 7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification Each input file contains one test case, which gives the integer N (1 < < N <2^{31} <2^{31} ). Output Specification For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]*factor[2]*...*factor[k] , where the factors are listed in increasing order, and 1 is NOT included. Sample Input 630 Sample Output 3 5*6*7","title":"1096-Consecutive Factors"},{"location":"PAT-Advanced-Level/1096-Consecutive%20Factors/#1096-consecutive-factors","text":"","title":"1096 Consecutive Factors"},{"location":"PAT-Advanced-Level/1096-Consecutive%20Factors/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3 \\times \\times 5 \\times \\times 6 \\times \\times 7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors. Input Specification Each input file contains one test case, which gives the integer N (1 < < N <2^{31} <2^{31} ). Output Specification For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]*factor[2]*...*factor[k] , where the factors are listed in increasing order, and 1 is NOT included. Sample Input 630 Sample Output 3 5*6*7","title":"Statement"},{"location":"PAT-Advanced-Level/1097-Deduplication%20on%20a%20Linked%20List/","text":"1097 Deduplication on a Linked List Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list L L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K K , only the first node of which the value or absolute value of its key equals K K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L L being 21\u2192-15\u2192-15\u2192-7\u219215, you must output 21\u2192-15\u2192-7, and the removed list -15\u219215. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Key Next where Address is the position of the node, Key is an integer of which absolute value is no more than 10^4 10^4 , and Next is the position of the next node. Output Specification For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 5 99999 -7 87654 23854 -15 00000 87654 15 -1 00000 -15 99999 00100 21 23854 Sample Output 00100 21 23854 23854 -15 99999 99999 -7 -1 00000 -15 87654 87654 15 -1","title":"1097-Deduplication on a Linked List"},{"location":"PAT-Advanced-Level/1097-Deduplication%20on%20a%20Linked%20List/#1097-deduplication-on-a-linked-list","text":"","title":"1097 Deduplication on a Linked List"},{"location":"PAT-Advanced-Level/1097-Deduplication%20on%20a%20Linked%20List/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list L L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K K , only the first node of which the value or absolute value of its key equals K K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L L being 21\u2192-15\u2192-15\u2192-7\u219215, you must output 21\u2192-15\u2192-7, and the removed list -15\u219215. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Key Next where Address is the position of the node, Key is an integer of which absolute value is no more than 10^4 10^4 , and Next is the position of the next node. Output Specification For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 5 99999 -7 87654 23854 -15 00000 87654 15 -1 00000 -15 99999 00100 21 23854 Sample Output 00100 21 23854 23854 -15 99999 99999 -7 -1 00000 -15 87654 87654 15 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1098-Insertion%20or%20Heap%20Sort/","text":"1098 Insertion or Heap Sort Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then in the next line, N N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification For each test case, print in the first line either \"Insertion Sort\" or \"Heap Sort\" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2 10 3 1 2 8 7 5 9 4 6 0 6 4 5 1 0 3 2 7 8 9 Sample Output 2 Heap Sort 5 4 3 1 0 2 6 7 8 9","title":"1098-Insertion or Heap Sort"},{"location":"PAT-Advanced-Level/1098-Insertion%20or%20Heap%20Sort/#1098-insertion-or-heap-sort","text":"","title":"1098 Insertion or Heap Sort"},{"location":"PAT-Advanced-Level/1098-Insertion%20or%20Heap%20Sort/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then in the next line, N N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification For each test case, print in the first line either \"Insertion Sort\" or \"Heap Sort\" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 Sample Output 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 Sample Input 2 10 3 1 2 8 7 5 9 4 6 0 6 4 5 1 0 3 2 7 8 9 Sample Output 2 Heap Sort 5 4 3 1 0 2 6 7 8 9","title":"Statement"},{"location":"PAT-Advanced-Level/1099-Build%20A%20Binary%20Search%20Tree/","text":"1099 Build A Binary Search Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ) which is the total number of nodes in the tree. The next N N lines each contains the left and the right children of a node in the format left_index right_index , provided that the nodes are numbered from 0 to N-1 N-1 , and 0 is always the root. If one child is missing, then -1 -1 will represent the NULL child pointer. Finally N N distinct integer keys are given in the last line. Output Specification For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input 9 1 6 2 3 -1 -1 -1 4 5 -1 -1 -1 7 -1 -1 8 -1 -1 73 45 11 58 82 25 67 38 42 Sample Output 58 25 82 11 38 67 45 73 42","title":"1099-Build A Binary Search Tree"},{"location":"PAT-Advanced-Level/1099-Build%20A%20Binary%20Search%20Tree/#1099-build-a-binary-search-tree","text":"","title":"1099 Build A Binary Search Tree"},{"location":"PAT-Advanced-Level/1099-Build%20A%20Binary%20Search%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ) which is the total number of nodes in the tree. The next N N lines each contains the left and the right children of a node in the format left_index right_index , provided that the nodes are numbered from 0 to N-1 N-1 , and 0 is always the root. If one child is missing, then -1 -1 will represent the NULL child pointer. Finally N N distinct integer keys are given in the last line. Output Specification For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input 9 1 6 2 3 -1 -1 -1 4 5 -1 -1 -1 7 -1 -1 8 -1 -1 73 45 11 58 82 25 67 38 42 Sample Output 58 25 82 11 38 67 45 73 42","title":"Statement"},{"location":"PAT-Advanced-Level/1100-Mars%20Numbers/","text":"1100 Mars Numbers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB People on Mars count their numbers with base 13: Zero on Earth is called \"tret\" on Mars. The numbers 1 to 12 on Earth is called \"jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec\" on Mars, respectively. For the next higher digit, Mars people name the 12 numbers as \"tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou\", respectively. For examples, the number 29 on Earth is called \"hel mar\" on Mars; and \"elo nov\" on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( < 100 < 100 ). Then N N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification For each number, print in a line the corresponding number in the other language. Sample Input 4 29 5 elo nov tam Sample Output hel mar may 115 13","title":"1100-Mars Numbers"},{"location":"PAT-Advanced-Level/1100-Mars%20Numbers/#1100-mars-numbers","text":"","title":"1100 Mars Numbers"},{"location":"PAT-Advanced-Level/1100-Mars%20Numbers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB People on Mars count their numbers with base 13: Zero on Earth is called \"tret\" on Mars. The numbers 1 to 12 on Earth is called \"jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec\" on Mars, respectively. For the next higher digit, Mars people name the 12 numbers as \"tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou\", respectively. For examples, the number 29 on Earth is called \"hel mar\" on Mars; and \"elo nov\" on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( < 100 < 100 ). Then N N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification For each number, print in a line the corresponding number in the other language. Sample Input 4 29 5 elo nov tam Sample Output hel mar may 115 13","title":"Statement"},{"location":"PAT-Advanced-Level/1101-Quick%20Sort/","text":"1101 Quick Sort Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N = 5 N = 5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; and for the similar reason, 4 and 5 could also be the pivot. Hence in total there are 3 pivot candidates. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ). Then the next line contains N N distinct positive integers no larger than 10^9 10^9 . The numbers in a line are separated by spaces. Output Specification For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input 5 1 3 2 4 5 Sample Output 3 1 4 5 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ], f [ N ], g [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); f [ 0 ] = -1 , g [ n + 1 ] = 1e9 ; for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = max ( f [ i - 1 ], a [ i ]); } for ( int i = n ; i >= 1 ; -- i ) { g [ i ] = min ( g [ i + 1 ], a [ i ]); } int res = 0 ; vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) { if ( f [ i - 1 ] < a [ i ] && g [ i + 1 ] > a [ i ]) ++ res , vec . push_back ( a [ i ]); } printf ( \"%d \\n \" , res ); for ( int i = 0 ; i < res ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == res - 1 ]); if ( ! res ) cout << endl ; } return 0 ; }","title":"1101-Quick Sort"},{"location":"PAT-Advanced-Level/1101-Quick%20Sort/#1101-quick-sort","text":"","title":"1101 Quick Sort"},{"location":"PAT-Advanced-Level/1101-Quick%20Sort/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N = 5 N = 5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; and for the similar reason, 4 and 5 could also be the pivot. Hence in total there are 3 pivot candidates. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ). Then the next line contains N N distinct positive integers no larger than 10^9 10^9 . The numbers in a line are separated by spaces. Output Specification For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input 5 1 3 2 4 5 Sample Output 3 1 4 5","title":"Statement"},{"location":"PAT-Advanced-Level/1101-Quick%20Sort/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ], f [ N ], g [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); f [ 0 ] = -1 , g [ n + 1 ] = 1e9 ; for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = max ( f [ i - 1 ], a [ i ]); } for ( int i = n ; i >= 1 ; -- i ) { g [ i ] = min ( g [ i + 1 ], a [ i ]); } int res = 0 ; vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) { if ( f [ i - 1 ] < a [ i ] && g [ i + 1 ] > a [ i ]) ++ res , vec . push_back ( a [ i ]); } printf ( \"%d \\n \" , res ); for ( int i = 0 ; i < res ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == res - 1 ]); if ( ! res ) cout << endl ; } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1102-Invert%20a%20Binary%20Tree/","text":"1102 Invert a Binary Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The following is from Max Howell @twitter : Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off. Now it's your turn to prove that YOU CAN invert a binary tree! Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10 \\le 10 ) which is the total number of nodes in the tree \u2013 and hence the nodes are numbered from 0 to N-1 N-1 . Then N N lines follow, each corresponds to a node from 0 to N-1 N-1 , and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input 8 1 - - - 0 - 2 7 - - - - 5 - 4 6 Sample Output 3 7 2 6 4 0 5 1 6 5 7 4 3 2 0 1 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 110 ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = -1 ; } } e [ N ]; int n , vis [ N ]; vector < int > vec ; void bfs ( int S ) { queue < int > que ; que . push ( S ); while ( ! que . empty ()) { int u = que . front (); que . pop (); vec . push_back ( u ); if ( e [ u ]. son [ 1 ] != -1 ) { que . push ( e [ u ]. son [ 1 ]); } if ( e [ u ]. son [ 0 ] != -1 ) { que . push ( e [ u ]. son [ 0 ]); } } } void dfs ( int u ) { if ( u == -1 ) return ; dfs ( e [ u ]. son [ 1 ]); vec . push_back ( u ); dfs ( e [ u ]. son [ 0 ]); } void print ( vector < int > vec ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( e , -1 , sizeof e ); memset ( vis , 0 , sizeof vis ); for ( int i = 0 ; i < n ; ++ i ) { static char x [ 10 ], y [ 10 ]; scanf ( \"%s %s\" , x , y ); if ( x [ 0 ] != '-' ) { int c = x [ 0 ] - '0' ; e [ i ]. son [ 0 ] = c ; vis [ c ] = 1 ; } if ( y [ 0 ] != '-' ) { int c = y [ 0 ] - '0' ; e [ i ]. son [ 1 ] = c ; vis [ c ] = 1 ; } } int rt = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) rt = i ; } vec . clear (); bfs ( rt ); print ( vec ); vec . clear (); dfs ( rt ); print ( vec ); } return 0 ; }","title":"1102-Invert a Binary Tree"},{"location":"PAT-Advanced-Level/1102-Invert%20a%20Binary%20Tree/#1102-invert-a-binary-tree","text":"","title":"1102 Invert a Binary Tree"},{"location":"PAT-Advanced-Level/1102-Invert%20a%20Binary%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The following is from Max Howell @twitter : Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off. Now it's your turn to prove that YOU CAN invert a binary tree! Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10 \\le 10 ) which is the total number of nodes in the tree \u2013 and hence the nodes are numbered from 0 to N-1 N-1 . Then N N lines follow, each corresponds to a node from 0 to N-1 N-1 , and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input 8 1 - - - 0 - 2 7 - - - - 5 - 4 6 Sample Output 3 7 2 6 4 0 5 1 6 5 7 4 3 2 0 1","title":"Statement"},{"location":"PAT-Advanced-Level/1102-Invert%20a%20Binary%20Tree/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 110 ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = -1 ; } } e [ N ]; int n , vis [ N ]; vector < int > vec ; void bfs ( int S ) { queue < int > que ; que . push ( S ); while ( ! que . empty ()) { int u = que . front (); que . pop (); vec . push_back ( u ); if ( e [ u ]. son [ 1 ] != -1 ) { que . push ( e [ u ]. son [ 1 ]); } if ( e [ u ]. son [ 0 ] != -1 ) { que . push ( e [ u ]. son [ 0 ]); } } } void dfs ( int u ) { if ( u == -1 ) return ; dfs ( e [ u ]. son [ 1 ]); vec . push_back ( u ); dfs ( e [ u ]. son [ 0 ]); } void print ( vector < int > vec ) { for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( e , -1 , sizeof e ); memset ( vis , 0 , sizeof vis ); for ( int i = 0 ; i < n ; ++ i ) { static char x [ 10 ], y [ 10 ]; scanf ( \"%s %s\" , x , y ); if ( x [ 0 ] != '-' ) { int c = x [ 0 ] - '0' ; e [ i ]. son [ 0 ] = c ; vis [ c ] = 1 ; } if ( y [ 0 ] != '-' ) { int c = y [ 0 ] - '0' ; e [ i ]. son [ 1 ] = c ; vis [ c ] = 1 ; } } int rt = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) rt = i ; } vec . clear (); bfs ( rt ); print ( vec ); vec . clear (); dfs ( rt ); print ( vec ); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1103-Integer%20Factorization/","text":"1103 Integer Factorization Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB The K-P K-P factorization of a positive integer N N is to write N N as the sum of the P P -th power of K K positive integers. You are supposed to write a program to find the K-P K-P factorization of N N for any positive integers N N , K K and P P . Input Specification Each input file contains one test case which gives in a line the three positive integers N N ( \\le 400 \\le 400 ), K K ( \\le N \\le N ) and P P ( 1 < P\\le 7 1 < P\\le 7 ). The numbers in a line are separated by a space. Output Specification For each case, if the solution exists, output in the format: N = n[1]^P + ... n[K]^P where n[i] ( i = 1, \u2026, K ) is the i -th factor. All the factors must be printed in non-increasing order. Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 12^2 + 4^2 + 2^2 + 2^2 + 1^2 12^2 + 4^2 + 2^2 + 2^2 + 1^2 , or 11^2 + 6^2 + 2^2 + 2^2 + 2^2 11^2 + 6^2 + 2^2 + 2^2 + 2^2 , or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen \u2013 sequence { a_1, a_2, \\cdots , a_K a_1, a_2, \\cdots , a_K } is said to be larger than { b_1, b_2, \\cdots , b_K b_1, b_2, \\cdots , b_K } if there exists 1\\le L\\le K 1\\le L\\le K such that a_i=b_i a_i=b_i for i<L i<L and a_L>b_L a_L>b_L . If there is no solution, simple output Impossible . Sample Input 1 169 5 2 Sample Output 1 169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2 Sample Input 2 169 167 3 Sample Output 2 Impossible","title":"1103-Integer Factorization"},{"location":"PAT-Advanced-Level/1103-Integer%20Factorization/#1103-integer-factorization","text":"","title":"1103 Integer Factorization"},{"location":"PAT-Advanced-Level/1103-Integer%20Factorization/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB The K-P K-P factorization of a positive integer N N is to write N N as the sum of the P P -th power of K K positive integers. You are supposed to write a program to find the K-P K-P factorization of N N for any positive integers N N , K K and P P . Input Specification Each input file contains one test case which gives in a line the three positive integers N N ( \\le 400 \\le 400 ), K K ( \\le N \\le N ) and P P ( 1 < P\\le 7 1 < P\\le 7 ). The numbers in a line are separated by a space. Output Specification For each case, if the solution exists, output in the format: N = n[1]^P + ... n[K]^P where n[i] ( i = 1, \u2026, K ) is the i -th factor. All the factors must be printed in non-increasing order. Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 12^2 + 4^2 + 2^2 + 2^2 + 1^2 12^2 + 4^2 + 2^2 + 2^2 + 1^2 , or 11^2 + 6^2 + 2^2 + 2^2 + 2^2 11^2 + 6^2 + 2^2 + 2^2 + 2^2 , or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen \u2013 sequence { a_1, a_2, \\cdots , a_K a_1, a_2, \\cdots , a_K } is said to be larger than { b_1, b_2, \\cdots , b_K b_1, b_2, \\cdots , b_K } if there exists 1\\le L\\le K 1\\le L\\le K such that a_i=b_i a_i=b_i for i<L i<L and a_L>b_L a_L>b_L . If there is no solution, simple output Impossible . Sample Input 1 169 5 2 Sample Output 1 169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2 Sample Input 2 169 167 3 Sample Output 2 Impossible","title":"Statement"},{"location":"PAT-Advanced-Level/1104-Sum%20of%20Number%20Segments/","text":"1104 Sum of Number Segments Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N , the size of the sequence which is no more than 10^5 10^5 . The next line contains N N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input 4 0.1 0.2 0.3 0.4 Sample Output 5.00 Thanks to Ruihan Zheng for correcting the test data. Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; double num ; scanf ( \"%d\" , & n ); double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & num ); sum += num * ( i + 1 ) * ( n - i ); } printf ( \"%.2lf \\n \" , sum ); }","title":"1104-Sum of Number Segments"},{"location":"PAT-Advanced-Level/1104-Sum%20of%20Number%20Segments/#1104-sum-of-number-segments","text":"","title":"1104 Sum of Number Segments"},{"location":"PAT-Advanced-Level/1104-Sum%20of%20Number%20Segments/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N , the size of the sequence which is no more than 10^5 10^5 . The next line contains N N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input 4 0.1 0.2 0.3 0.4 Sample Output 5.00 Thanks to Ruihan Zheng for correcting the test data.","title":"Statement"},{"location":"PAT-Advanced-Level/1104-Sum%20of%20Number%20Segments/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; double num ; scanf ( \"%d\" , & n ); double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & num ); sum += num * ( i + 1 ) * ( n - i ); } printf ( \"%.2lf \\n \" , sum ); }","title":"Solution"},{"location":"PAT-Advanced-Level/1105-Spiral%20Matrix/","text":"1105 Spiral Matrix Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This time your job is to fill a sequence of N N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m m rows and n n columns, where m m and n n satisfy the following: m\\times n m\\times n must be equal to N N ; m\\ge n m\\ge n ; and m-n m-n is the minimum of all the possible values. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N . Then the next line contains N N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^4 10^4 . The numbers in a line are separated by spaces. Output Specification For each test case, output the resulting matrix in m m lines, each contains n n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input 12 37 76 20 98 76 42 53 95 60 81 58 93 Sample Output 98 95 93 42 37 81 53 20 76 58 60 76","title":"1105-Spiral Matrix"},{"location":"PAT-Advanced-Level/1105-Spiral%20Matrix/#1105-spiral-matrix","text":"","title":"1105 Spiral Matrix"},{"location":"PAT-Advanced-Level/1105-Spiral%20Matrix/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This time your job is to fill a sequence of N N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m m rows and n n columns, where m m and n n satisfy the following: m\\times n m\\times n must be equal to N N ; m\\ge n m\\ge n ; and m-n m-n is the minimum of all the possible values. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N . Then the next line contains N N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^4 10^4 . The numbers in a line are separated by spaces. Output Specification For each test case, output the resulting matrix in m m lines, each contains n n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input 12 37 76 20 98 76 42 53 95 60 81 58 93 Sample Output 98 95 93 42 37 81 53 20 76 58 60 76","title":"Statement"},{"location":"PAT-Advanced-Level/1106-Lowest%20Price%20in%20Supply%20Chain/","text":"1106 Lowest Price in Supply Chain Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers. Input Specification Each input file contains one test case. For each case, The first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to N-1 N-1 , and the root supplier's ID is 0); P P , the price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then N N lines follow, each describes a distributor or retailer in the following format: K_i K_i ID[1] ID[2] \u2026 ID[ K_i K_i ] where in the i i -th line, K_i K_i is the total number of distributors or retailers who receive products from supplier i i , and is then followed by the ID's of these distributors or retailers. K_j K_j being 0 means that the j j -th member is a retailer. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 10^{10} 10^{10} . Sample Input 10 1.80 1.00 3 2 3 5 1 9 1 4 1 7 0 2 6 1 1 8 0 0 0 Sample Output 1.8362 2","title":"1106-Lowest Price in Supply Chain"},{"location":"PAT-Advanced-Level/1106-Lowest%20Price%20in%20Supply%20Chain/#1106-lowest-price-in-supply-chain","text":"","title":"1106 Lowest Price in Supply Chain"},{"location":"PAT-Advanced-Level/1106-Lowest%20Price%20in%20Supply%20Chain/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB A supply chain is a network of retailers\uff08\u96f6\u552e\u5546\uff09, distributors\uff08\u7ecf\u9500\u5546\uff09, and suppliers\uff08\u4f9b\u5e94\u5546\uff09\u2013 everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P P and sell or distribute them in a price that is r r % higher than P P . Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers. Input Specification Each input file contains one test case. For each case, The first line contains three positive numbers: N N ( \\le 10^5 \\le 10^5 ), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to N-1 N-1 , and the root supplier's ID is 0); P P , the price given by the root supplier; and r r , the percentage rate of price increment for each distributor or retailer. Then N N lines follow, each describes a distributor or retailer in the following format: K_i K_i ID[1] ID[2] \u2026 ID[ K_i K_i ] where in the i i -th line, K_i K_i is the total number of distributors or retailers who receive products from supplier i i , and is then followed by the ID's of these distributors or retailers. K_j K_j being 0 means that the j j -th member is a retailer. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed 10^{10} 10^{10} . Sample Input 10 1.80 1.00 3 2 3 5 1 9 1 4 1 7 0 2 6 1 1 8 0 0 0 Sample Output 1.8362 2","title":"Statement"},{"location":"PAT-Advanced-Level/1107-Social%20Clusters/","text":"1107 Social Clusters Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters. Input Specification Each input file contains one test case. For each test case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ), the total number of people in a social network. Hence the people are numbered from 1 to N N . Then N N lines follow, each gives the hobby list of a person in the format: K_i K_i : h_i h_i [1] h_i h_i [2] \u2026 h_i h_i [ K_i K_i ] where K_i K_i ( >0 >0 ) is the number of hobbies, and h_i[j] h_i[j] is the index of the j j -th hobby, which is an integer in [1, 1000]. Output Specification For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 8 3: 2 7 10 1: 4 2: 5 3 1: 4 1: 3 1: 4 4: 6 8 1 5 1: 4 Sample Output 3 4 3 1 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , m , fa [ N ], sze [ N ]; int find ( int x ) { return fa [ x ] == x ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int u , int v ) { int fu = find ( u ), fv = find ( v ); if ( fu != fv ) { fa [ fu ] = fv ; sze [ fv ] += sze [ fu ]; } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { m = n ; for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = i ; sze [ i ] = 1 ; } for ( int i = n + 1 ; i <= m + 1000 ; ++ i ) { fa [ i ] = i ; sze [ i ] = 0 ; } for ( int i = 1 , sze ; i <= n ; ++ i ) { scanf ( \"%d: \" , & sze ); int pre = -1 ; for ( int j = 1 , x ; j <= sze ; ++ j ) { scanf ( \"%d\" , & x ); m = max ( m , n + x ); merge ( i , n + x ); if ( pre != -1 ) { merge ( n + pre , n + x ); pre = x ; } } } vector < int > res ; for ( int i = 1 ; i <= m ; ++ i ) { if ( fa [ i ] == i && sze [ i ]) { res . push_back ( sze [ i ]); } } sort ( res . begin (), res . end ()); reverse ( res . begin (), res . end ()); int sze = res . size (); printf ( \"%d \\n \" , sze ); for ( int i = 0 ; i < sze ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == sze - 1 ]); } return 0 ; }","title":"1107-Social Clusters"},{"location":"PAT-Advanced-Level/1107-Social%20Clusters/#1107-social-clusters","text":"","title":"1107 Social Clusters"},{"location":"PAT-Advanced-Level/1107-Social%20Clusters/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1200 ms \u5185\u5b58\u9650\u5236: 64 MB When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters. Input Specification Each input file contains one test case. For each test case, the first line contains a positive integer N N ( \\le 1000 \\le 1000 ), the total number of people in a social network. Hence the people are numbered from 1 to N N . Then N N lines follow, each gives the hobby list of a person in the format: K_i K_i : h_i h_i [1] h_i h_i [2] \u2026 h_i h_i [ K_i K_i ] where K_i K_i ( >0 >0 ) is the number of hobbies, and h_i[j] h_i[j] is the index of the j j -th hobby, which is an integer in [1, 1000]. Output Specification For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 8 3: 2 7 10 1: 4 2: 5 3 1: 4 1: 3 1: 4 4: 6 8 1 5 1: 4 Sample Output 3 4 3 1","title":"Statement"},{"location":"PAT-Advanced-Level/1107-Social%20Clusters/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , m , fa [ N ], sze [ N ]; int find ( int x ) { return fa [ x ] == x ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int u , int v ) { int fu = find ( u ), fv = find ( v ); if ( fu != fv ) { fa [ fu ] = fv ; sze [ fv ] += sze [ fu ]; } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { m = n ; for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = i ; sze [ i ] = 1 ; } for ( int i = n + 1 ; i <= m + 1000 ; ++ i ) { fa [ i ] = i ; sze [ i ] = 0 ; } for ( int i = 1 , sze ; i <= n ; ++ i ) { scanf ( \"%d: \" , & sze ); int pre = -1 ; for ( int j = 1 , x ; j <= sze ; ++ j ) { scanf ( \"%d\" , & x ); m = max ( m , n + x ); merge ( i , n + x ); if ( pre != -1 ) { merge ( n + pre , n + x ); pre = x ; } } } vector < int > res ; for ( int i = 1 ; i <= m ; ++ i ) { if ( fa [ i ] == i && sze [ i ]) { res . push_back ( sze [ i ]); } } sort ( res . begin (), res . end ()); reverse ( res . begin (), res . end ()); int sze = res . size (); printf ( \"%d \\n \" , sze ); for ( int i = 0 ; i < sze ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == sze - 1 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1108-Finding%20Average/","text":"1108 Finding Average Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The basic task is simple: given N N real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. A legal input is a real number in [ -1000, 1000 -1000, 1000 ] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then N N numbers are given in the next line, separated by one space. Output Specification For each illegal input number, print in a line ERROR: X is not a legal number where X is the input. Then finally print in a line the result: The average of K numbers is Y where K is the number of legal inputs and Y is their average, accurate to 2 decimal places. In case the average cannot be calculated, output Undefined instead of Y . In case K is only 1, output The average of 1 number is Y instead. Sample Input 1 7 5 -3.2 aaa 9999 2.3.4 7.123 2.35 Sample Output 1 ERROR: aaa is not a legal number ERROR: 9999 is not a legal number ERROR: 2.3.4 is not a legal number ERROR: 7.123 is not a legal number The average of 3 numbers is 1.38 Sample Input 2 2 aaa -9999 Sample Output 2 ERROR: aaa is not a legal number ERROR: -9999 is not a legal number The average of 0 numbers is Undefined","title":"1108-Finding Average"},{"location":"PAT-Advanced-Level/1108-Finding%20Average/#1108-finding-average","text":"","title":"1108 Finding Average"},{"location":"PAT-Advanced-Level/1108-Finding%20Average/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB The basic task is simple: given N N real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. A legal input is a real number in [ -1000, 1000 -1000, 1000 ] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 100 \\le 100 ). Then N N numbers are given in the next line, separated by one space. Output Specification For each illegal input number, print in a line ERROR: X is not a legal number where X is the input. Then finally print in a line the result: The average of K numbers is Y where K is the number of legal inputs and Y is their average, accurate to 2 decimal places. In case the average cannot be calculated, output Undefined instead of Y . In case K is only 1, output The average of 1 number is Y instead. Sample Input 1 7 5 -3.2 aaa 9999 2.3.4 7.123 2.35 Sample Output 1 ERROR: aaa is not a legal number ERROR: 9999 is not a legal number ERROR: 2.3.4 is not a legal number ERROR: 7.123 is not a legal number The average of 3 numbers is 1.38 Sample Input 2 2 aaa -9999 Sample Output 2 ERROR: aaa is not a legal number ERROR: -9999 is not a legal number The average of 0 numbers is Undefined","title":"Statement"},{"location":"PAT-Advanced-Level/1109-Group%20Photo/","text":"1109 Group Photo Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Formation is very important when taking a group photo. Given the rules of forming K K rows with N N people as the following: The number of people in each row must be N/K N/K (round down to the nearest integer), with all the extra people (if any) standing in the last row; All the people in the rear row must be no shorter than anyone standing in the front rows; In each row, the tallest one stands at the central position (which is defined to be the position (m/2+1) (m/2+1) , where m m is the total number of people in that row, and the division result must be rounded down to the nearest integer); In each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.); When there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names. Now given the information of a group of people, you are supposed to write a program to output their formation. Input Specification Each input file contains one test case. For each test case, the first line contains two positive integers N N ( \\le 10^4 \\le 10^4 ), the total number of people, and K K ( \\le 10 \\le 10 ), the total number of rows. Then N N lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]). Output Specification For each case, print the formation \u2013 that is, print the names of people in K K lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows. Sample Input 10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 Sample Output Bob Tom Joe Nick Ann Mike Eva Tim Amy John","title":"1109-Group Photo"},{"location":"PAT-Advanced-Level/1109-Group%20Photo/#1109-group-photo","text":"","title":"1109 Group Photo"},{"location":"PAT-Advanced-Level/1109-Group%20Photo/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Formation is very important when taking a group photo. Given the rules of forming K K rows with N N people as the following: The number of people in each row must be N/K N/K (round down to the nearest integer), with all the extra people (if any) standing in the last row; All the people in the rear row must be no shorter than anyone standing in the front rows; In each row, the tallest one stands at the central position (which is defined to be the position (m/2+1) (m/2+1) , where m m is the total number of people in that row, and the division result must be rounded down to the nearest integer); In each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.); When there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names. Now given the information of a group of people, you are supposed to write a program to output their formation. Input Specification Each input file contains one test case. For each test case, the first line contains two positive integers N N ( \\le 10^4 \\le 10^4 ), the total number of people, and K K ( \\le 10 \\le 10 ), the total number of rows. Then N N lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]). Output Specification For each case, print the formation \u2013 that is, print the names of people in K K lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows. Sample Input 10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 Sample Output Bob Tom Joe Nick Ann Mike Eva Tim Amy John","title":"Statement"},{"location":"PAT-Advanced-Level/1110-Complete%20Binary%20Tree/","text":"1110 Complete Binary Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a tree, you are supposed to tell if it is a complete binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 20 \\le 20 ) which is the total number of nodes in the tree \u2013 and hence the nodes are numbered from 0 to N-1 N-1 . Then N N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification For each case, print in one line YES and the index of the last node if the tree is a complete binary tree, or NO and the index of the root if not. There must be exactly one space separating the word and the number. Sample Input 1 9 7 8 - - - - - - 0 1 2 3 4 5 - - - - Sample Output 1 YES 8 Sample Input 2 8 - - 4 5 0 6 - - 2 3 - 7 - - - - Sample Output 2 NO 1 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = -1 ; } } e [ N ]; int n , Max , MaxId , vis [ N ]; void dfs ( int u , int id ) { MaxId = max ( MaxId , id ); if ( id == n ) Max = u ; int now = e [ u ]. son [ 0 ]; if ( now != -1 ) dfs ( now , id << 1 ); now = e [ u ]. son [ 1 ]; if ( now != -1 ) dfs ( now , id << 1 | 1 ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { assert ( n <= 20 ); memset ( e , -1 , sizeof e ); memset ( vis , 0 , sizeof vis ); for ( int i = 0 ; i < n ; ++ i ) { static char x [ 10 ], y [ 10 ]; scanf ( \"%s %s\" , x , y ); if ( x [ 0 ] != '-' ) { int c = 0 ; for ( int j = 0 ; x [ j ]; ++ j ) c = c * 10 + x [ j ] - '0' ; e [ i ]. son [ 0 ] = c ; vis [ c ] = 1 ; } if ( y [ 0 ] != '-' ) { int c = 0 ; for ( int j = 0 ; y [ j ]; ++ j ) c = c * 10 + y [ j ] - '0' ; e [ i ]. son [ 1 ] = c ; vis [ c ] = 1 ; } } int rt = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) { assert ( rt == -1 ); rt = i ; } } Max = -1 ; MaxId = 0 ; dfs ( rt , 1 ); if ( MaxId == n ) { cout << \"YES \" << Max ; } else { cout << \"NO \" << rt ; } cout << \" \\n \" ; } return 0 ; }","title":"1110-Complete Binary Tree"},{"location":"PAT-Advanced-Level/1110-Complete%20Binary%20Tree/#1110-complete-binary-tree","text":"","title":"1110 Complete Binary Tree"},{"location":"PAT-Advanced-Level/1110-Complete%20Binary%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a tree, you are supposed to tell if it is a complete binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 20 \\le 20 ) which is the total number of nodes in the tree \u2013 and hence the nodes are numbered from 0 to N-1 N-1 . Then N N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space. Output Specification For each case, print in one line YES and the index of the last node if the tree is a complete binary tree, or NO and the index of the root if not. There must be exactly one space separating the word and the number. Sample Input 1 9 7 8 - - - - - - 0 1 2 3 4 5 - - - - Sample Output 1 YES 8 Sample Input 2 8 - - 4 5 0 6 - - 2 3 - 7 - - - - Sample Output 2 NO 1","title":"Statement"},{"location":"PAT-Advanced-Level/1110-Complete%20Binary%20Tree/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = -1 ; } } e [ N ]; int n , Max , MaxId , vis [ N ]; void dfs ( int u , int id ) { MaxId = max ( MaxId , id ); if ( id == n ) Max = u ; int now = e [ u ]. son [ 0 ]; if ( now != -1 ) dfs ( now , id << 1 ); now = e [ u ]. son [ 1 ]; if ( now != -1 ) dfs ( now , id << 1 | 1 ); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { assert ( n <= 20 ); memset ( e , -1 , sizeof e ); memset ( vis , 0 , sizeof vis ); for ( int i = 0 ; i < n ; ++ i ) { static char x [ 10 ], y [ 10 ]; scanf ( \"%s %s\" , x , y ); if ( x [ 0 ] != '-' ) { int c = 0 ; for ( int j = 0 ; x [ j ]; ++ j ) c = c * 10 + x [ j ] - '0' ; e [ i ]. son [ 0 ] = c ; vis [ c ] = 1 ; } if ( y [ 0 ] != '-' ) { int c = 0 ; for ( int j = 0 ; y [ j ]; ++ j ) c = c * 10 + y [ j ] - '0' ; e [ i ]. son [ 1 ] = c ; vis [ c ] = 1 ; } } int rt = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) { assert ( rt == -1 ); rt = i ; } } Max = -1 ; MaxId = 0 ; dfs ( rt , 1 ); if ( MaxId == n ) { cout << \"YES \" << Max ; } else { cout << \"NO \" << rt ; } cout << \" \\n \" ; } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1111-Online%20Map/","text":"1111 Online Map Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 2 \\le N \\le 500 2 \\le N \\le 500 ), and M M , being the total number of streets intersections on a map, and the number of streets, respectively. Then M M lines follow, each describes a street in the format: V1 V2 one-way length time where V1 and V2 are the indices (from 0 to N-1 N-1 ) of the two ends of the street; one-way is 1 if the street is one-way from V1 to V2 , or 0 if not; length is the length of the street; and time is the time taken to pass the street. Finally a pair of source and destination is given. Output Specification For each case, first print the shortest path from the source to the destination with distance D in the format: Distance = D: source -> v1 -> ... -> destination Then in the next line print the fastest path with total time T : Time = T: source -> w1 -> ... -> destination In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique. In case the shortest and the fastest paths are identical, print them in one line in the format: Distance = D; Time = T: source -> u1 -> ... -> destination Sample Input 1 10 15 0 1 0 1 1 8 0 0 1 1 4 8 1 1 1 3 4 0 3 2 3 9 1 4 1 0 6 0 1 1 7 5 1 2 1 8 5 1 2 1 2 3 0 2 2 2 1 1 1 1 1 3 0 3 1 1 4 0 1 1 9 7 1 3 1 5 1 0 5 2 6 5 1 1 2 3 5 Sample Output 1 Distance = 6: 3 -> 4 -> 8 -> 5 Time = 3: 3 -> 1 -> 5 Sample Input 2 7 9 0 4 1 1 1 1 6 1 1 3 2 6 1 1 1 2 5 1 2 2 3 0 0 1 1 3 1 1 1 3 3 2 1 1 2 4 5 0 2 2 6 5 1 1 2 3 5 Sample Output 2 Distance = 3; Time = 4: 3 -> 2 -> 5","title":"1111-Online Map"},{"location":"PAT-Advanced-Level/1111-Online%20Map/#1111-online-map","text":"","title":"1111 Online Map"},{"location":"PAT-Advanced-Level/1111-Online%20Map/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 2 \\le N \\le 500 2 \\le N \\le 500 ), and M M , being the total number of streets intersections on a map, and the number of streets, respectively. Then M M lines follow, each describes a street in the format: V1 V2 one-way length time where V1 and V2 are the indices (from 0 to N-1 N-1 ) of the two ends of the street; one-way is 1 if the street is one-way from V1 to V2 , or 0 if not; length is the length of the street; and time is the time taken to pass the street. Finally a pair of source and destination is given. Output Specification For each case, first print the shortest path from the source to the destination with distance D in the format: Distance = D: source -> v1 -> ... -> destination Then in the next line print the fastest path with total time T : Time = T: source -> w1 -> ... -> destination In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique. In case the shortest and the fastest paths are identical, print them in one line in the format: Distance = D; Time = T: source -> u1 -> ... -> destination Sample Input 1 10 15 0 1 0 1 1 8 0 0 1 1 4 8 1 1 1 3 4 0 3 2 3 9 1 4 1 0 6 0 1 1 7 5 1 2 1 8 5 1 2 1 2 3 0 2 2 2 1 1 1 1 1 3 0 3 1 1 4 0 1 1 9 7 1 3 1 5 1 0 5 2 6 5 1 1 2 3 5 Sample Output 1 Distance = 6: 3 -> 4 -> 8 -> 5 Time = 3: 3 -> 1 -> 5 Sample Input 2 7 9 0 4 1 1 1 1 6 1 1 3 2 6 1 1 1 2 5 1 2 2 3 0 0 1 1 3 1 1 1 3 3 2 1 1 2 4 5 0 2 2 6 5 1 1 2 3 5 Sample Output 2 Distance = 3; Time = 4: 3 -> 2 -> 5","title":"Statement"},{"location":"PAT-Advanced-Level/1112-Stucked%20Keyboard/","text":"1112 Stucked Keyboard Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for k k times. Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string. Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed k k times whenever it is pressed. For example, when k = 3 k = 3 , from the string thiiis iiisss a teeeeeest we know that the keys i and e might be stucked, but s is not even though it appears repeatedly sometimes. The original string could be this isss a teest . Input Specification Each input file contains one test case. For each case, the 1 st line gives a positive integer k k ( 1 < k \\le 100 1 < k \\le 100 ) which is the output repeating times of a stucked key. The 2 nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and _ . It is guaranteed that the string is non-empty. Output Specification For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key. Sample Input 3 caseee1__thiiis_iiisss_a_teeeeeest Sample Output ei case1__this_isss_a_teest","title":"1112-Stucked Keyboard"},{"location":"PAT-Advanced-Level/1112-Stucked%20Keyboard/#1112-stucked-keyboard","text":"","title":"1112 Stucked Keyboard"},{"location":"PAT-Advanced-Level/1112-Stucked%20Keyboard/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for k k times. Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string. Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed k k times whenever it is pressed. For example, when k = 3 k = 3 , from the string thiiis iiisss a teeeeeest we know that the keys i and e might be stucked, but s is not even though it appears repeatedly sometimes. The original string could be this isss a teest . Input Specification Each input file contains one test case. For each case, the 1 st line gives a positive integer k k ( 1 < k \\le 100 1 < k \\le 100 ) which is the output repeating times of a stucked key. The 2 nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and _ . It is guaranteed that the string is non-empty. Output Specification For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key. Sample Input 3 caseee1__thiiis_iiisss_a_teeeeeest Sample Output ei case1__this_isss_a_teest","title":"Statement"},{"location":"PAT-Advanced-Level/1113-Integer%20Set%20Partition/","text":"1113 Integer Set Partition Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a set of N N ( > 1 > 1 ) positive integers, you are supposed to partition them into two disjoint sets A_1 A_1 and A_2 A_2 of n_1 n_1 and n_2 n_2 numbers, respectively. Let S_1 S_1 and S_2 S_2 denote the sums of all the numbers in A_1 A_1 and A_2 A_2 , respectively. You are supposed to make the partition so that |n_1 - n_2| |n_1 - n_2| is minimized first, and then |S_1 - S_2| |S_1 - S_2| is maximized. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 2 \\le N \\le 10^5 2 \\le N \\le 10^5 ), and then N N positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less than 2^{31} 2^{31} . Output Specification For each case, print in a line two numbers: |n_1 - n_2| |n_1 - n_2| and |S_1 - S_2| |S_1 - S_2| , separated by exactly one space. Sample Input 1 10 23 8 10 99 46 2333 46 1 666 555 Sample Output 1 0 3611 Sample Input 2 13 110 79 218 69 3721 100 29 135 2 6 13 5188 85 Sample Output 2 1 9359","title":"1113-Integer Set Partition"},{"location":"PAT-Advanced-Level/1113-Integer%20Set%20Partition/#1113-integer-set-partition","text":"","title":"1113 Integer Set Partition"},{"location":"PAT-Advanced-Level/1113-Integer%20Set%20Partition/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a set of N N ( > 1 > 1 ) positive integers, you are supposed to partition them into two disjoint sets A_1 A_1 and A_2 A_2 of n_1 n_1 and n_2 n_2 numbers, respectively. Let S_1 S_1 and S_2 S_2 denote the sums of all the numbers in A_1 A_1 and A_2 A_2 , respectively. You are supposed to make the partition so that |n_1 - n_2| |n_1 - n_2| is minimized first, and then |S_1 - S_2| |S_1 - S_2| is maximized. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 2 \\le N \\le 10^5 2 \\le N \\le 10^5 ), and then N N positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less than 2^{31} 2^{31} . Output Specification For each case, print in a line two numbers: |n_1 - n_2| |n_1 - n_2| and |S_1 - S_2| |S_1 - S_2| , separated by exactly one space. Sample Input 1 10 23 8 10 99 46 2333 46 1 666 555 Sample Output 1 0 3611 Sample Input 2 13 110 79 218 69 3721 100 29 135 2 6 13 5188 85 Sample Output 2 1 9359","title":"Statement"},{"location":"PAT-Advanced-Level/1114-Family%20Property/","text":"1114 Family Property Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to help us collect the data for family-owned property. Given each person's family members, and the estate\uff08\u623f\u4ea7\uff09info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 1000 \\le 1000 ). Then N N lines follow, each gives the infomation of a person who owns estate in the format: ID Father Mother k k Child_1 \\cdots Child_k Child_1 \\cdots Child_k M_{estate} M_{estate} Area where ID is a unique 4-digit identification number for each person; Father and Mother are the ID 's of this person's parents (if a parent has passed away, -1 will be given instead); k k ( 0\\le k\\le 5 0\\le k\\le 5 ) is the number of children of this person; Child_i Child_i 's are the ID 's of his/her children; M_{estate} M_{estate} is the total number of sets of the real estate under his/her name; and Area is the total area of his/her estate. Output Specification For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format: ID M AVG_{sets} AVG_{sets} AVG_{area} AVG_{area} where ID is the smallest ID in the family; M is the total number of family members; AVG_{sets} AVG_{sets} is the average number of sets of their real estate; and AVG_{area} AVG_{area} is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID's if there is a tie. Sample Input 10 6666 5551 5552 1 7777 1 100 1234 5678 9012 1 0002 2 300 8888 -1 -1 0 1 1000 2468 0001 0004 1 2222 1 500 7777 6666 -1 0 2 300 3721 -1 -1 1 2333 2 150 9012 -1 -1 3 1236 1235 1234 1 100 1235 5678 9012 0 1 50 2222 1236 2468 2 6661 6662 1 300 2333 -1 3721 3 6661 6662 6663 1 100 Sample Output 3 8888 1 1.000 1000.000 0001 15 0.600 100.000 5551 4 0.750 100.000","title":"1114-Family Property"},{"location":"PAT-Advanced-Level/1114-Family%20Property/#1114-family-property","text":"","title":"1114 Family Property"},{"location":"PAT-Advanced-Level/1114-Family%20Property/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This time, you are supposed to help us collect the data for family-owned property. Given each person's family members, and the estate\uff08\u623f\u4ea7\uff09info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 1000 \\le 1000 ). Then N N lines follow, each gives the infomation of a person who owns estate in the format: ID Father Mother k k Child_1 \\cdots Child_k Child_1 \\cdots Child_k M_{estate} M_{estate} Area where ID is a unique 4-digit identification number for each person; Father and Mother are the ID 's of this person's parents (if a parent has passed away, -1 will be given instead); k k ( 0\\le k\\le 5 0\\le k\\le 5 ) is the number of children of this person; Child_i Child_i 's are the ID 's of his/her children; M_{estate} M_{estate} is the total number of sets of the real estate under his/her name; and Area is the total area of his/her estate. Output Specification For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format: ID M AVG_{sets} AVG_{sets} AVG_{area} AVG_{area} where ID is the smallest ID in the family; M is the total number of family members; AVG_{sets} AVG_{sets} is the average number of sets of their real estate; and AVG_{area} AVG_{area} is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID's if there is a tie. Sample Input 10 6666 5551 5552 1 7777 1 100 1234 5678 9012 1 0002 2 300 8888 -1 -1 0 1 1000 2468 0001 0004 1 2222 1 500 7777 6666 -1 0 2 300 3721 -1 -1 1 2333 2 150 9012 -1 -1 3 1236 1235 1234 1 100 1235 5678 9012 0 1 50 2222 1236 2468 2 6661 6662 1 300 2333 -1 3721 3 6661 6662 6663 1 100 Sample Output 3 8888 1 1.000 1000.000 0001 15 0.600 100.000 5551 4 0.750 100.000","title":"Statement"},{"location":"PAT-Advanced-Level/1115-Counting%20Nodes%20in%20a%20BST/","text":"1115 Counting Nodes in a BST Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 1000 \\le 1000 ) which is the size of the input sequence. Then given in the next line are the N N integers in [-1000, 1000] [-1000, 1000] which are supposed to be inserted into an initially empty binary search tree. Output Specification For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format: n1 + n2 = n where n1 is the number of nodes in the lowest level, n2 is that of the level above, and n is the sum. Sample Input 9 25 30 42 16 20 20 35 -5 28 Sample Output 2 + 4 = 6 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ], Max , ans [ N ]; struct BST { struct node { int v , son [ 2 ]; node () { v = 0 , son [ 0 ] = son [ 1 ] = 0 ; } } t [ N ]; int rt , tot ; void init () { rt = 0 ; tot = 0 ; } int newnode () { ++ tot ; t [ tot ] = node (); return tot ; } void insert ( int & rt , int v , int dep ) { Max = max ( Max , dep ); if ( rt == 0 ) { rt = newnode (); ++ ans [ dep ]; t [ rt ]. v = v ; return ; } if ( v <= t [ rt ]. v ) insert ( t [ rt ]. son [ 0 ], v , dep + 1 ); else insert ( t [ rt ]. son [ 1 ], v , dep + 1 ); } } bst ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { Max = 0 ; memset ( ans , 0 , sizeof ans ); bst . init (); for ( int i = 1 , x ; i <= n ; ++ i ) { scanf ( \"%d\" , & x ); bst . insert ( bst . rt , x , 0 ); } assert ( Max >= 0 ); if ( Max == 0 ) { printf ( \"%d + %d = %d \\n \" , ans [ Max ], 0 , ans [ Max ]); } else { printf ( \"%d + %d = %d \\n \" , ans [ Max ], ans [ Max - 1 ], ans [ Max ] + ans [ Max - 1 ]); } } return 0 ; }","title":"1115-Counting Nodes in a BST"},{"location":"PAT-Advanced-Level/1115-Counting%20Nodes%20in%20a%20BST/#1115-counting-nodes-in-a-bst","text":"","title":"1115 Counting Nodes in a BST"},{"location":"PAT-Advanced-Level/1115-Counting%20Nodes%20in%20a%20BST/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than or equal to the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 1000 \\le 1000 ) which is the size of the input sequence. Then given in the next line are the N N integers in [-1000, 1000] [-1000, 1000] which are supposed to be inserted into an initially empty binary search tree. Output Specification For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format: n1 + n2 = n where n1 is the number of nodes in the lowest level, n2 is that of the level above, and n is the sum. Sample Input 9 25 30 42 16 20 20 35 -5 28 Sample Output 2 + 4 = 6","title":"Statement"},{"location":"PAT-Advanced-Level/1115-Counting%20Nodes%20in%20a%20BST/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ], Max , ans [ N ]; struct BST { struct node { int v , son [ 2 ]; node () { v = 0 , son [ 0 ] = son [ 1 ] = 0 ; } } t [ N ]; int rt , tot ; void init () { rt = 0 ; tot = 0 ; } int newnode () { ++ tot ; t [ tot ] = node (); return tot ; } void insert ( int & rt , int v , int dep ) { Max = max ( Max , dep ); if ( rt == 0 ) { rt = newnode (); ++ ans [ dep ]; t [ rt ]. v = v ; return ; } if ( v <= t [ rt ]. v ) insert ( t [ rt ]. son [ 0 ], v , dep + 1 ); else insert ( t [ rt ]. son [ 1 ], v , dep + 1 ); } } bst ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { Max = 0 ; memset ( ans , 0 , sizeof ans ); bst . init (); for ( int i = 1 , x ; i <= n ; ++ i ) { scanf ( \"%d\" , & x ); bst . insert ( bst . rt , x , 0 ); } assert ( Max >= 0 ); if ( Max == 0 ) { printf ( \"%d + %d = %d \\n \" , ans [ Max ], 0 , ans [ Max ]); } else { printf ( \"%d + %d = %d \\n \" , ans [ Max ], ans [ Max - 1 ], ans [ Max ] + ans [ Max - 1 ]); } } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1116-Come%20on%21%20Let%27s%20C/","text":"1116 Come on! Let's C Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \"Let's C\" is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following: 0\u3001 The Champion will receive a \"Mystery Award\" (such as a BIG collection of students' research papers\u2026). 1\u3001 Those who ranked as a prime number will receive the best award \u2013 the Minions (\u5c0f\u9ec4\u4eba)! 2\u3001 Everyone else will receive chocolates. Given the final ranklist and a sequence of contestant ID's, you are supposed to tell the corresponding awards. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^4 \\le 10^4 ), the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestant's ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query ID's. Output Specification For each query, print in a line ID: award where the award is Mystery Award , or Minion , or Chocolate . If the ID is not in the ranklist, print Are you kidding? instead. If the ID has been checked before, print ID: Checked . Sample Input 6 1111 6666 8888 1234 5555 0001 6 8888 0001 1111 2222 8888 2222 Sample Output 8888: Minion 0001: Chocolate 1111: Mystery Award 2222: Are you kidding? 8888: Checked 2222: Are you kidding? Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; bool isprime ( int x ) { int m = sqrt ( x ) + 1 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } int main () { int n , num ; map < int , int > m , flag ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); m [ num ] = i ; } cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); printf ( \"%04d: \" , num ); int vis = m [ num ]; if ( vis == 0 ) printf ( \"Are you kidding? \\n \" ); else if ( flag [ num ] == 1 ) printf ( \"Checked \\n \" ); else if ( vis == 1 ) printf ( \"Mystery Award \\n \" ); else if ( isprime ( vis )) printf ( \"Minion \\n \" ); else if ( m [ num ]) printf ( \"Chocolate \\n \" ); flag [ num ] = 1 ; } }","title":"1116-Come on! Let's C"},{"location":"PAT-Advanced-Level/1116-Come%20on%21%20Let%27s%20C/#1116-come-on-lets-c","text":"","title":"1116 Come on! Let's C"},{"location":"PAT-Advanced-Level/1116-Come%20on%21%20Let%27s%20C/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \"Let's C\" is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following: 0\u3001 The Champion will receive a \"Mystery Award\" (such as a BIG collection of students' research papers\u2026). 1\u3001 Those who ranked as a prime number will receive the best award \u2013 the Minions (\u5c0f\u9ec4\u4eba)! 2\u3001 Everyone else will receive chocolates. Given the final ranklist and a sequence of contestant ID's, you are supposed to tell the corresponding awards. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^4 \\le 10^4 ), the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestant's ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query ID's. Output Specification For each query, print in a line ID: award where the award is Mystery Award , or Minion , or Chocolate . If the ID is not in the ranklist, print Are you kidding? instead. If the ID has been checked before, print ID: Checked . Sample Input 6 1111 6666 8888 1234 5555 0001 6 8888 0001 1111 2222 8888 2222 Sample Output 8888: Minion 0001: Chocolate 1111: Mystery Award 2222: Are you kidding? 8888: Checked 2222: Are you kidding?","title":"Statement"},{"location":"PAT-Advanced-Level/1116-Come%20on%21%20Let%27s%20C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; bool isprime ( int x ) { int m = sqrt ( x ) + 1 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } int main () { int n , num ; map < int , int > m , flag ; cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); m [ num ] = i ; } cin >> n ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num ); printf ( \"%04d: \" , num ); int vis = m [ num ]; if ( vis == 0 ) printf ( \"Are you kidding? \\n \" ); else if ( flag [ num ] == 1 ) printf ( \"Checked \\n \" ); else if ( vis == 1 ) printf ( \"Mystery Award \\n \" ); else if ( isprime ( vis )) printf ( \"Minion \\n \" ); else if ( m [ num ]) printf ( \"Chocolate \\n \" ); flag [ num ] = 1 ; } }","title":"Solution"},{"location":"PAT-Advanced-Level/1117-Eddington%20Number/","text":"1117 Eddington Number Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB British astronomer Eddington liked to ride a bike. It is said that in order to show off his skill, he has even defined an \"Eddington number\", E E \u2013 that is, the maximum integer E E such that it is for E E days that one rides more than E E miles. Eddington's own E E was 87. Now given everyday's distances that one rides for N N days, you are supposed to find the corresponding E E ( \\le N \\le N ). Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ), the days of continuous riding. Then N N non-negative integers are given in the next line, being the riding distances of everyday. Output Specification For each case, print in a line the Eddington number for these N N days. Sample Input 10 6 7 6 9 3 10 8 2 7 8 Sample Output 6 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 1 , a + 1 + n , [ & ]( int x , int y ) { return x > y ; }); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] > i ) { res = i ; } } printf ( \"%d \\n \" , res ); } return 0 ; }","title":"1117-Eddington Number"},{"location":"PAT-Advanced-Level/1117-Eddington%20Number/#1117-eddington-number","text":"","title":"1117 Eddington Number"},{"location":"PAT-Advanced-Level/1117-Eddington%20Number/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB British astronomer Eddington liked to ride a bike. It is said that in order to show off his skill, he has even defined an \"Eddington number\", E E \u2013 that is, the maximum integer E E such that it is for E E days that one rides more than E E miles. Eddington's own E E was 87. Now given everyday's distances that one rides for N N days, you are supposed to find the corresponding E E ( \\le N \\le N ). Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ), the days of continuous riding. Then N N non-negative integers are given in the next line, being the riding distances of everyday. Output Specification For each case, print in a line the Eddington number for these N N days. Sample Input 10 6 7 6 9 3 10 8 2 7 8 Sample Output 6","title":"Statement"},{"location":"PAT-Advanced-Level/1117-Eddington%20Number/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 1 , a + 1 + n , [ & ]( int x , int y ) { return x > y ; }); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] > i ) { res = i ; } } printf ( \"%d \\n \" , res ); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1118-Birds%20in%20Forest/","text":"1118 Birds in Forest Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive number N N ( \\le 10^4 \\le 10^4 ) which is the number of pictures. Then N N lines follow, each describes a picture in the format: K K B_1 B_1 B_2 B_2 \u2026 B_K B_K where K K is the number of birds in this picture, and B_i B_i 's are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more than 10^4 10^4 . After the pictures there is a positive number Q Q ( \\le 10^4 \\le 10^4 ) which is the number of queries. Then Q Q lines follow, each contains the indices of two birds. Output Specification For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a line Yes if the two birds belong to the same tree, or No if not. Sample Input 4 3 10 1 2 2 3 4 4 1 5 7 8 3 9 6 4 2 10 5 3 7 Sample Output 2 10 Yes No","title":"1118-Birds in Forest"},{"location":"PAT-Advanced-Level/1118-Birds%20in%20Forest/#1118-birds-in-forest","text":"","title":"1118 Birds in Forest"},{"location":"PAT-Advanced-Level/1118-Birds%20in%20Forest/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive number N N ( \\le 10^4 \\le 10^4 ) which is the number of pictures. Then N N lines follow, each describes a picture in the format: K K B_1 B_1 B_2 B_2 \u2026 B_K B_K where K K is the number of birds in this picture, and B_i B_i 's are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more than 10^4 10^4 . After the pictures there is a positive number Q Q ( \\le 10^4 \\le 10^4 ) which is the number of queries. Then Q Q lines follow, each contains the indices of two birds. Output Specification For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a line Yes if the two birds belong to the same tree, or No if not. Sample Input 4 3 10 1 2 2 3 4 4 1 5 7 8 3 9 6 4 2 10 5 3 7 Sample Output 2 10 Yes No","title":"Statement"},{"location":"PAT-Advanced-Level/1119-Pre-%20and%20Post-order%20Traversals/","text":"1119 Pre- and Post-order Traversals Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique. Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, first printf in a line Yes if the tree is unique, or No if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 1 7 1 2 3 4 6 7 5 2 6 7 4 5 3 1 Sample Output 1 Yes 2 1 6 4 7 3 5 Sample Input 2 4 1 2 3 4 2 4 3 1 Sample Output 2 No 2 1 3 4 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } const int N = 1e5 + 10 , INF = 0x3f3f3f3f ; int n , Unique , a [ N ], b [ N ], id [ N ], c [ N ]; vector < int > vec ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = 0 ; } } e [ N ]; struct SEG { int t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = INF ; if ( l == r ) { t [ id ] = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = min ( t [ id << 1 ], t [ id << 1 | 1 ]); } int query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]; int mid = ( l + r ) >> 1 ; int res = INF ; if ( ql <= mid ) res = min ( res , query ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) res = min ( res , query ( id << 1 | 1 , mid + 1 , r , ql , qr )); return res ; } int query ( int l , int r ) { return query ( 1 , 1 , n , l , r ); } } seg ; int gao ( int al , int ar , int bl , int br ) { if ( al > ar || bl > br ) return 0 ; int rt = a [ al ]; if ( al == ar ) return rt ; if ( a [ al + 1 ] == b [ br - 1 ]) { Unique = 0 ; int Min = seg . query ( al + 1 , ar ); if ( Min < rt ) { e [ rt ]. son [ 0 ] = gao ( al + 1 , ar , bl , br - 1 ); } else { e [ rt ]. son [ 1 ] = gao ( al + 1 , ar , bl , br - 1 ); } } else { int pos = id [ b [ br - 1 ]]; int lsze = pos - 1 - al ; e [ rt ]. son [ 0 ] = gao ( al + 1 , pos - 1 , bl , bl + lsze - 1 ); e [ rt ]. son [ 1 ] = gao ( pos , ar , bl + lsze , br - 1 ); } return rt ; } void getprint ( int u ) { if ( ! u ) return ; getprint ( e [ u ]. son [ 0 ]); vec . push_back ( c [ u ]); getprint ( e [ u ]. son [ 1 ]); } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ] = E (); scanf ( \"%d\" , a + i ); c [ i ] = a [ i ]; } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , b + i ); } sort ( c + 1 , c + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( c + 1 , c + 1 + n , a [ i ]) - c ; b [ i ] = lower_bound ( c + 1 , c + 1 + n , b [ i ]) - c ; id [ a [ i ]] = i ; } seg . build ( 1 , 1 , n ); vec . clear (); Unique = 1 ; getprint ( gao ( 1 , n , 1 , n )); if ( Unique ) puts ( \"Yes\" ); else puts ( \"No\" ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); return 0 ; }","title":"1119-Pre- and Post-order Traversals"},{"location":"PAT-Advanced-Level/1119-Pre-%20and%20Post-order%20Traversals/#1119-pre--and-post-order-traversals","text":"","title":"1119 Pre- and Post-order Traversals"},{"location":"PAT-Advanced-Level/1119-Pre-%20and%20Post-order%20Traversals/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique. Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, first printf in a line Yes if the tree is unique, or No if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 1 7 1 2 3 4 6 7 5 2 6 7 4 5 3 1 Sample Output 1 Yes 2 1 6 4 7 3 5 Sample Input 2 4 1 2 3 4 2 4 3 1 Sample Output 2 No 2 1 3 4","title":"Statement"},{"location":"PAT-Advanced-Level/1119-Pre-%20and%20Post-order%20Traversals/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } const int N = 1e5 + 10 , INF = 0x3f3f3f3f ; int n , Unique , a [ N ], b [ N ], id [ N ], c [ N ]; vector < int > vec ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = 0 ; } } e [ N ]; struct SEG { int t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = INF ; if ( l == r ) { t [ id ] = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = min ( t [ id << 1 ], t [ id << 1 | 1 ]); } int query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]; int mid = ( l + r ) >> 1 ; int res = INF ; if ( ql <= mid ) res = min ( res , query ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) res = min ( res , query ( id << 1 | 1 , mid + 1 , r , ql , qr )); return res ; } int query ( int l , int r ) { return query ( 1 , 1 , n , l , r ); } } seg ; int gao ( int al , int ar , int bl , int br ) { if ( al > ar || bl > br ) return 0 ; int rt = a [ al ]; if ( al == ar ) return rt ; if ( a [ al + 1 ] == b [ br - 1 ]) { Unique = 0 ; int Min = seg . query ( al + 1 , ar ); if ( Min < rt ) { e [ rt ]. son [ 0 ] = gao ( al + 1 , ar , bl , br - 1 ); } else { e [ rt ]. son [ 1 ] = gao ( al + 1 , ar , bl , br - 1 ); } } else { int pos = id [ b [ br - 1 ]]; int lsze = pos - 1 - al ; e [ rt ]. son [ 0 ] = gao ( al + 1 , pos - 1 , bl , bl + lsze - 1 ); e [ rt ]. son [ 1 ] = gao ( pos , ar , bl + lsze , br - 1 ); } return rt ; } void getprint ( int u ) { if ( ! u ) return ; getprint ( e [ u ]. son [ 0 ]); vec . push_back ( c [ u ]); getprint ( e [ u ]. son [ 1 ]); } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { e [ i ] = E (); scanf ( \"%d\" , a + i ); c [ i ] = a [ i ]; } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , b + i ); } sort ( c + 1 , c + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( c + 1 , c + 1 + n , a [ i ]) - c ; b [ i ] = lower_bound ( c + 1 , c + 1 + n , b [ i ]) - c ; id [ a [ i ]] = i ; } seg . build ( 1 , 1 , n ); vec . clear (); Unique = 1 ; getprint ( gao ( 1 , n , 1 , n )); if ( Unique ) puts ( \"Yes\" ); else puts ( \"No\" ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1120-Friend%20Numbers/","text":"1120 Friend Numbers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Two integers are called \"friend numbers\" if they share the same sum of their digits, and the sum is their \"friend ID\". For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different friend ID's among them. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less than 10^4 10^4 . Output Specification For each case, print in the first line the number of different friend ID's among the given integers. Then in the second line, output the friend ID's in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line. Sample Input 8 123 899 51 998 27 33 36 12 Sample Output 4 3 6 9 26","title":"1120-Friend Numbers"},{"location":"PAT-Advanced-Level/1120-Friend%20Numbers/#1120-friend-numbers","text":"","title":"1120 Friend Numbers"},{"location":"PAT-Advanced-Level/1120-Friend%20Numbers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Two integers are called \"friend numbers\" if they share the same sum of their digits, and the sum is their \"friend ID\". For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different friend ID's among them. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less than 10^4 10^4 . Output Specification For each case, print in the first line the number of different friend ID's among the given integers. Then in the second line, output the friend ID's in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line. Sample Input 8 123 899 51 998 27 33 36 12 Sample Output 4 3 6 9 26","title":"Statement"},{"location":"PAT-Advanced-Level/1121-Damn%20Single/","text":"1121 Damn Single Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \"Damn Single (\u5355\u8eab\u72d7)\" is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID's which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M ( \\le \\le 10,000) followed by M ID's of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (\u91cd\u5a5a) or dangling with more than one companion. Output Specification First print in a line the total number of lonely guests. Then in the next line, print their ID's in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line. Sample Input 3 11111 22222 33333 44444 55555 66666 7 55555 44444 10000 88888 22222 11111 23333 Sample Output 5 10000 23333 44444 55555 88888","title":"1121-Damn Single"},{"location":"PAT-Advanced-Level/1121-Damn%20Single/#1121-damn-single","text":"","title":"1121 Damn Single"},{"location":"PAT-Advanced-Level/1121-Damn%20Single/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \"Damn Single (\u5355\u8eab\u72d7)\" is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID's which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M ( \\le \\le 10,000) followed by M ID's of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (\u91cd\u5a5a) or dangling with more than one companion. Output Specification First print in a line the total number of lonely guests. Then in the next line, print their ID's in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line. Sample Input 3 11111 22222 33333 44444 55555 66666 7 55555 44444 10000 88888 22222 11111 23333 Sample Output 5 10000 23333 44444 55555 88888","title":"Statement"},{"location":"PAT-Advanced-Level/1122-Hamiltonian%20Cycle/","text":"1122 Hamiltonian Cycle Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB The \"Hamilton cycle problem\" is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \"Hamiltonian cycle\". In this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2< N \\le 200 2< N \\le 200 ), the number of vertices, and M M , the number of edges in an undirected graph. Then M M lines follow, each describes an edge in the format Vertex1 Vertex2 , where the vertices are numbered from 1 to N N . The next line gives a positive integer K K which is the number of queries, followed by K K lines of queries, each in the format: n n V_1 V_1 V_2 V_2 \u2026 V_n V_n where n n is the number of vertices in the list, and V_i V_i 's are the vertices on a path. Output Specification For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not. Sample Input 6 10 6 2 3 4 1 5 2 5 3 1 4 1 1 6 6 3 1 2 4 5 6 7 5 1 4 3 6 2 5 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 3 4 5 2 6 7 6 1 2 5 4 3 1 Sample Output YES NO NO NO YES NO","title":"1122-Hamiltonian Cycle"},{"location":"PAT-Advanced-Level/1122-Hamiltonian%20Cycle/#1122-hamiltonian-cycle","text":"","title":"1122 Hamiltonian Cycle"},{"location":"PAT-Advanced-Level/1122-Hamiltonian%20Cycle/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB The \"Hamilton cycle problem\" is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a \"Hamiltonian cycle\". In this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2< N \\le 200 2< N \\le 200 ), the number of vertices, and M M , the number of edges in an undirected graph. Then M M lines follow, each describes an edge in the format Vertex1 Vertex2 , where the vertices are numbered from 1 to N N . The next line gives a positive integer K K which is the number of queries, followed by K K lines of queries, each in the format: n n V_1 V_1 V_2 V_2 \u2026 V_n V_n where n n is the number of vertices in the list, and V_i V_i 's are the vertices on a path. Output Specification For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not. Sample Input 6 10 6 2 3 4 1 5 2 5 3 1 4 1 1 6 6 3 1 2 4 5 6 7 5 1 4 3 6 2 5 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 3 4 5 2 6 7 6 1 2 5 4 3 1 Sample Output YES NO NO NO YES NO","title":"Statement"},{"location":"PAT-Advanced-Level/1123-Is%20It%20a%20Complete%20AVL%20Tree/","text":"1123 Is It a Complete AVL Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N ( \\le \\le 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not. Sample Input 1 5 88 70 61 63 65 Sample Output 1 70 63 88 61 65 YES Sample Input 2 8 88 70 61 96 120 90 65 68 Sample Output 2 88 65 96 61 70 90 120 68 NO","title":"1123-Is It a Complete AVL Tree"},{"location":"PAT-Advanced-Level/1123-Is%20It%20a%20Complete%20AVL%20Tree/#1123-is-it-a-complete-avl-tree","text":"","title":"1123 Is It a Complete AVL Tree"},{"location":"PAT-Advanced-Level/1123-Is%20It%20a%20Complete%20AVL%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N ( \\le \\le 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not. Sample Input 1 5 88 70 61 63 65 Sample Output 1 70 63 88 61 65 YES Sample Input 2 8 88 70 61 96 120 90 65 68 Sample Output 2 88 65 96 61 70 90 120 68 NO","title":"Statement"},{"location":"PAT-Advanced-Level/1124-Raffle%20for%20Weibo%20Followers/","text":"1124 Raffle for Weibo Followers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB John got a full mark on PAT. He was so happy that he decided to hold a raffle\uff08\u62bd\u5956\uff09 for his followers on Weibo \u2013 that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners. Input Specification Each input file contains one test case. For each case, the first line gives three positive integers M ( \\le \\le 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded John's post. Note: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one. Output Specification For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, print Keep going... instead. Sample Input 1 9 3 2 Imgonnawin! PickMe PickMeMeMeee LookHere Imgonnawin! TryAgainAgain TryAgainAgain Imgonnawin! TryAgainAgain Sample Output 1 PickMe Imgonnawin! TryAgainAgain Sample Input 2 2 3 5 Imgonnawin! PickMe Sample Output 2 Keep going...","title":"1124-Raffle for Weibo Followers"},{"location":"PAT-Advanced-Level/1124-Raffle%20for%20Weibo%20Followers/#1124-raffle-for-weibo-followers","text":"","title":"1124 Raffle for Weibo Followers"},{"location":"PAT-Advanced-Level/1124-Raffle%20for%20Weibo%20Followers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB John got a full mark on PAT. He was so happy that he decided to hold a raffle\uff08\u62bd\u5956\uff09 for his followers on Weibo \u2013 that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners. Input Specification Each input file contains one test case. For each case, the first line gives three positive integers M ( \\le \\le 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded John's post. Note: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one. Output Specification For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, print Keep going... instead. Sample Input 1 9 3 2 Imgonnawin! PickMe PickMeMeMeee LookHere Imgonnawin! TryAgainAgain TryAgainAgain Imgonnawin! TryAgainAgain Sample Output 1 PickMe Imgonnawin! TryAgainAgain Sample Input 2 2 3 5 Imgonnawin! PickMe Sample Output 2 Keep going...","title":"Statement"},{"location":"PAT-Advanced-Level/1125-Chain%20the%20Ropes/","text":"1125 Chain the Ropes Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain them into one piece, as shown by the figure. The resulting chain will be treated as another segment of rope and can be folded again. After each chaining, the lengths of the original two segments will be halved. Your job is to make the longest possible rope out of N N given segments. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 2 \\le N \\le 10^4 2 \\le N \\le 10^4 ). Then N N positive integer lengths of the segments are given in the next line, separated by spaces. All the integers are no more than 10^4 10^4 . Output Specification For each case, print in a line the length of the longest possible rope that can be made by the given segments. The result must be rounded to the nearest integer that is no greater than the maximum length. Sample Input 8 10 15 12 3 4 13 1 15 Sample Output 14","title":"1125-Chain the Ropes"},{"location":"PAT-Advanced-Level/1125-Chain%20the%20Ropes/#1125-chain-the-ropes","text":"","title":"1125 Chain the Ropes"},{"location":"PAT-Advanced-Level/1125-Chain%20the%20Ropes/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain them into one piece, as shown by the figure. The resulting chain will be treated as another segment of rope and can be folded again. After each chaining, the lengths of the original two segments will be halved. Your job is to make the longest possible rope out of N N given segments. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 2 \\le N \\le 10^4 2 \\le N \\le 10^4 ). Then N N positive integer lengths of the segments are given in the next line, separated by spaces. All the integers are no more than 10^4 10^4 . Output Specification For each case, print in a line the length of the longest possible rope that can be made by the given segments. The result must be rounded to the nearest integer that is no greater than the maximum length. Sample Input 8 10 15 12 3 4 13 1 15 Sample Output 14","title":"Statement"},{"location":"PAT-Advanced-Level/1126-Eulerian%20Path/","text":"1126 Eulerian Path Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian path which starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Konigsberg problem in 1736. It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called Eulerian . If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is called semi-Eulerian . (Cited from https://en.wikipedia.org/wiki/Eulerian_path ) Given an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by giving the two ends of the edge (the vertices are numbered from 1 to N). Output Specification For each test case, first print in a line the degrees of the vertices in ascending order of their indices. Then in the next line print your conclusion about the graph \u2013 either Eulerian , Semi-Eulerian , or Non-Eulerian . Note that all the numbers in the first line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line. Sample Input 1 7 12 5 7 1 2 1 3 2 3 2 4 3 4 5 2 7 6 6 3 4 5 6 4 5 6 Sample Output 1 2 4 4 4 4 4 2 Eulerian Sample Input 2 6 10 1 2 1 3 2 3 2 4 3 4 5 2 6 3 4 5 6 4 5 6 Sample Output 2 2 4 4 4 3 3 Semi-Eulerian Sample Input 3 5 8 1 2 2 5 5 4 4 1 1 3 3 2 3 4 5 3 Sample Output 3 3 3 4 3 3 Non-Eulerian","title":"1126-Eulerian Path"},{"location":"PAT-Advanced-Level/1126-Eulerian%20Path/#1126-eulerian-path","text":"","title":"1126 Eulerian Path"},{"location":"PAT-Advanced-Level/1126-Eulerian%20Path/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian path which starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Konigsberg problem in 1736. It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called Eulerian . If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is called semi-Eulerian . (Cited from https://en.wikipedia.org/wiki/Eulerian_path ) Given an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by giving the two ends of the edge (the vertices are numbered from 1 to N). Output Specification For each test case, first print in a line the degrees of the vertices in ascending order of their indices. Then in the next line print your conclusion about the graph \u2013 either Eulerian , Semi-Eulerian , or Non-Eulerian . Note that all the numbers in the first line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line. Sample Input 1 7 12 5 7 1 2 1 3 2 3 2 4 3 4 5 2 7 6 6 3 4 5 6 4 5 6 Sample Output 1 2 4 4 4 4 4 2 Eulerian Sample Input 2 6 10 1 2 1 3 2 3 2 4 3 4 5 2 6 3 4 5 6 4 5 6 Sample Output 2 2 4 4 4 3 3 Semi-Eulerian Sample Input 3 5 8 1 2 2 5 5 4 4 1 1 3 3 2 3 4 5 3 Sample Output 3 3 3 4 3 3 Non-Eulerian","title":"Statement"},{"location":"PAT-Advanced-Level/1127-ZigZagging%20on%20a%20Tree/","text":"1127 ZigZagging on a Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \"zigzagging order\" \u2013 that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 8 12 11 20 17 1 15 8 5 12 20 17 11 15 8 5 1 Sample Output 1 11 5 8 17 12 20 15 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; int n , rt , a [ N ], b [ N ], c [ N ], deep [ N ]; vector < vector < int >> vec ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = 0 ; } } e [ N ]; int gao ( int al , int ar , int bl , int br ) { if ( al > ar || bl > br ) return 0 ; int rt = a [ ar ], pos = -1 ; for ( int i = bl ; i <= br ; ++ i ) { if ( b [ i ] == rt ) { pos = i ; break ; } } if ( al >= ar ) return rt ; int lsze = pos - bl ; e [ rt ]. son [ 0 ] = gao ( al , al + lsze - 1 , bl , pos - 1 ); e [ rt ]. son [ 1 ] = gao ( al + lsze , ar - 1 , pos + 1 , br ); return rt ; } void bfs ( int S ) { queue < int > que ; que . push ( S ); deep [ S ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); vec [ deep [ u ]]. push_back ( c [ u ]); int v = e [ u ]. son [ 0 ]; if ( v ) { deep [ v ] = deep [ u ] + 1 ; que . push ( v ); } v = e [ u ]. son [ 1 ]; if ( v ) { deep [ v ] = deep [ u ] + 1 ; que . push ( v ); } } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( e , 0 , sizeof e ); memset ( deep , 0 , sizeof deep ); vec . clear (); vec . resize ( n + 35 ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ), c [ i ] = b [ i ]; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); sort ( c + 1 , c + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( c + 1 , c + 1 + n , a [ i ]) - c ; b [ i ] = lower_bound ( c + 1 , c + 1 + n , b [ i ]) - c ; } int rt = gao ( 1 , n , 1 , n ); bfs ( rt ); vector < int > res ; for ( int i = 1 ; i <= n + 30 ; ++ i ) { if ( vec [ i ]. empty ()) break ; if ( i & 1 ) { reverse ( vec [ i ]. begin (), vec [ i ]. end ()); } for ( auto & it : vec [ i ]) res . push_back ( it ); } assert ( res . size () == n ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"1127-ZigZagging on a Tree"},{"location":"PAT-Advanced-Level/1127-ZigZagging%20on%20a%20Tree/#1127-zigzagging-on-a-tree","text":"","title":"1127 ZigZagging on a Tree"},{"location":"PAT-Advanced-Level/1127-ZigZagging%20on%20a%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in \"zigzagging order\" \u2013 that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input 8 12 11 20 17 1 15 8 5 12 20 17 11 15 8 5 1 Sample Output 1 11 5 8 17 12 20 15","title":"Statement"},{"location":"PAT-Advanced-Level/1127-ZigZagging%20on%20a%20Tree/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; int n , rt , a [ N ], b [ N ], c [ N ], deep [ N ]; vector < vector < int >> vec ; struct E { int son [ 2 ]; E () { son [ 0 ] = son [ 1 ] = 0 ; } } e [ N ]; int gao ( int al , int ar , int bl , int br ) { if ( al > ar || bl > br ) return 0 ; int rt = a [ ar ], pos = -1 ; for ( int i = bl ; i <= br ; ++ i ) { if ( b [ i ] == rt ) { pos = i ; break ; } } if ( al >= ar ) return rt ; int lsze = pos - bl ; e [ rt ]. son [ 0 ] = gao ( al , al + lsze - 1 , bl , pos - 1 ); e [ rt ]. son [ 1 ] = gao ( al + lsze , ar - 1 , pos + 1 , br ); return rt ; } void bfs ( int S ) { queue < int > que ; que . push ( S ); deep [ S ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); vec [ deep [ u ]]. push_back ( c [ u ]); int v = e [ u ]. son [ 0 ]; if ( v ) { deep [ v ] = deep [ u ] + 1 ; que . push ( v ); } v = e [ u ]. son [ 1 ]; if ( v ) { deep [ v ] = deep [ u ] + 1 ; que . push ( v ); } } } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( e , 0 , sizeof e ); memset ( deep , 0 , sizeof deep ); vec . clear (); vec . resize ( n + 35 ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ), c [ i ] = b [ i ]; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); sort ( c + 1 , c + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( c + 1 , c + 1 + n , a [ i ]) - c ; b [ i ] = lower_bound ( c + 1 , c + 1 + n , b [ i ]) - c ; } int rt = gao ( 1 , n , 1 , n ); bfs ( rt ); vector < int > res ; for ( int i = 1 ; i <= n + 30 ; ++ i ) { if ( vec [ i ]. empty ()) break ; if ( i & 1 ) { reverse ( vec [ i ]. begin (), vec [ i ]. end ()); } for ( auto & it : vec [ i ]) res . push_back ( it ); } assert ( res . size () == n ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1128-N%20Queens%20Puzzle/","text":"1128 N Queens Puzzle Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB The \"eight queens puzzle\" is the problem of placing eight chess queens on an 8\\times 8 8\\times 8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N N queens problem of placing N N non-attacking queens on an N\\times N N\\times N chessboard. (From Wikipedia - \"Eight queens puzzle\".) Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (Q_1, Q_2, \\cdots , Q_N) (Q_1, Q_2, \\cdots , Q_N) , where Q_i Q_i is the row number of the queen in the i i -th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens' solution. Figure 1 Figure 2 Input Specification Each input file contains several test cases. The first line gives an integer K K ( 1<K\\le 200 1<K\\le 200 ). Then K K lines follow, each gives a configuration in the format \" N N Q_1 Q_1 Q_2 Q_2 \u2026 Q_N Q_N \", where 4\\le N\\le 1000 4\\le N\\le 1000 and it is guaranteed that 1\\le Q_i\\le N 1\\le Q_i\\le N for all i=1, \\cdots , N i=1, \\cdots , N . The numbers are separated by spaces. Output Specification For each configuration, if it is a solution to the N N queens problem, print YES in a line; or NO if not. Sample Input 4 8 4 6 8 2 7 1 3 5 9 4 6 7 2 8 1 9 5 3 6 1 5 2 6 4 3 5 1 3 5 2 4 Sample Output YES NO NO YES Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; while ( t -- ) { int n , num ; int flag = 1 ; cin >> n ; map < int , int > l , m , r ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); if ( m [ num ] || l [ num - i ] || r [ num + i ]) flag = 0 ; m [ num ] = 1 ; l [ num - i ] = 1 ; r [ num + i ] = 1 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"1128-N Queens Puzzle"},{"location":"PAT-Advanced-Level/1128-N%20Queens%20Puzzle/#1128-n-queens-puzzle","text":"","title":"1128 N Queens Puzzle"},{"location":"PAT-Advanced-Level/1128-N%20Queens%20Puzzle/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB The \"eight queens puzzle\" is the problem of placing eight chess queens on an 8\\times 8 8\\times 8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N N queens problem of placing N N non-attacking queens on an N\\times N N\\times N chessboard. (From Wikipedia - \"Eight queens puzzle\".) Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (Q_1, Q_2, \\cdots , Q_N) (Q_1, Q_2, \\cdots , Q_N) , where Q_i Q_i is the row number of the queen in the i i -th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens' solution. Figure 1 Figure 2 Input Specification Each input file contains several test cases. The first line gives an integer K K ( 1<K\\le 200 1<K\\le 200 ). Then K K lines follow, each gives a configuration in the format \" N N Q_1 Q_1 Q_2 Q_2 \u2026 Q_N Q_N \", where 4\\le N\\le 1000 4\\le N\\le 1000 and it is guaranteed that 1\\le Q_i\\le N 1\\le Q_i\\le N for all i=1, \\cdots , N i=1, \\cdots , N . The numbers are separated by spaces. Output Specification For each configuration, if it is a solution to the N N queens problem, print YES in a line; or NO if not. Sample Input 4 8 4 6 8 2 7 1 3 5 9 4 6 7 2 8 1 9 5 3 6 1 5 2 6 4 3 5 1 3 5 2 4 Sample Output YES NO NO YES","title":"Statement"},{"location":"PAT-Advanced-Level/1128-N%20Queens%20Puzzle/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int t ; cin >> t ; while ( t -- ) { int n , num ; int flag = 1 ; cin >> n ; map < int , int > l , m , r ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); if ( m [ num ] || l [ num - i ] || r [ num + i ]) flag = 0 ; m [ num ] = 1 ; l [ num - i ] = 1 ; r [ num + i ] = 1 ; } if ( flag ) printf ( \"YES \\n \" ); else printf ( \"NO \\n \" ); } }","title":"Solution"},{"location":"PAT-Advanced-Level/1129-Recommendation%20System/","text":"1129 Recommendation System Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user's preference by the number of times that an item has been accessed by this user. Input Specification Each input file contains one test case. For each test case, the first line contains two positive integers: N ( \\le \\le 50,000), the total number of queries, and K ( \\le \\le 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing \u2013 for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space. Output Specification For each case, process the queries one by one. Output the recommendations for each query in a line in the format: query: rec[1] rec[2] ... rec[K] where query is the item that the user is accessing, and rec[i] ( i =1, \u2026 K) is the i -th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order. Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query. Sample Input 12 3 3 5 7 5 5 3 2 1 8 3 8 12 Sample Output 5: 3 7: 3 5 5: 3 5 7 5: 5 3 7 3: 5 3 7 2: 5 3 7 1: 5 3 2 8: 5 3 1 3: 5 3 1 8: 3 5 1 12: 3 5 8","title":"1129-Recommendation System"},{"location":"PAT-Advanced-Level/1129-Recommendation%20System/#1129-recommendation-system","text":"","title":"1129 Recommendation System"},{"location":"PAT-Advanced-Level/1129-Recommendation%20System/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user's preference by the number of times that an item has been accessed by this user. Input Specification Each input file contains one test case. For each test case, the first line contains two positive integers: N ( \\le \\le 50,000), the total number of queries, and K ( \\le \\le 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing \u2013 for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space. Output Specification For each case, process the queries one by one. Output the recommendations for each query in a line in the format: query: rec[1] rec[2] ... rec[K] where query is the item that the user is accessing, and rec[i] ( i =1, \u2026 K) is the i -th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order. Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query. Sample Input 12 3 3 5 7 5 5 3 2 1 8 3 8 12 Sample Output 5: 3 7: 3 5 5: 3 5 7 5: 5 3 7 3: 5 3 7 2: 5 3 7 1: 5 3 2 8: 5 3 1 3: 5 3 1 8: 3 5 1 12: 3 5 8","title":"Statement"},{"location":"PAT-Advanced-Level/1130-Infix%20Expression/","text":"1130 Infix Expression Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i i -th line corresponds to the i i -th node) in the format: data left_child right_child where data is a string of no more than 10 characters, left_child and right_child are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by -1 -1 . The figures 1 and 2 correspond to the samples 1 and 2, respectively. Figure 1 Figure 2 Output Specification For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols. Sample Input 1 8 * 8 7 a -1 -1 * 4 1 + 2 5 b -1 -1 d -1 -1 - -1 6 c -1 -1 Sample Output 1 (a+b)*(c*(-d)) Sample Input 2 8 2.35 -1 -1 * 6 1 - -1 4 % 7 8 + 2 3 a -1 -1 str -1 -1 871 -1 -1 Sample Output 2 (a*2.35)+(-(str%871))","title":"1130-Infix Expression"},{"location":"PAT-Advanced-Level/1130-Infix%20Expression/#1130-infix-expression","text":"","title":"1130 Infix Expression"},{"location":"PAT-Advanced-Level/1130-Infix%20Expression/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i i -th line corresponds to the i i -th node) in the format: data left_child right_child where data is a string of no more than 10 characters, left_child and right_child are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by -1 -1 . The figures 1 and 2 correspond to the samples 1 and 2, respectively. Figure 1 Figure 2 Output Specification For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols. Sample Input 1 8 * 8 7 a -1 -1 * 4 1 + 2 5 b -1 -1 d -1 -1 - -1 6 c -1 -1 Sample Output 1 (a+b)*(c*(-d)) Sample Input 2 8 2.35 -1 -1 * 6 1 - -1 4 % 7 8 + 2 3 a -1 -1 str -1 -1 871 -1 -1 Sample Output 2 (a*2.35)+(-(str%871))","title":"Statement"},{"location":"PAT-Advanced-Level/1131-Subway%20Map/","text":"1131 Subway Map Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le \\le 100), the number of subway lines. Then N N lines follow, with the i i -th ( i=1, \\cdots , N i=1, \\cdots , N ) line describes the i i -th subway line in the format: M M S[1] S[2] \u2026 S[ M M ] where M M ( \\le \\le 100) is the number of stops, and S[ i i ]'s ( i=1, \\cdots , M i=1, \\cdots , M ) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order \u2013 that is, the train travels between S[ i i ] and S[ i+1 i+1 ] ( i=1, \\cdots , M-1 i=1, \\cdots , M-1 ) without any stop. Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called \"transfer stations\"), no station can be the conjunction of more than 5 lines. After the description of the subway, another positive integer K K ( \\le \\le 10) is given. Then K K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively. The following figure shows the sample map. Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers. Output Specification For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following: Take Line#X1 from S1 to S2. Take Line#X2 from S2 to S3. ...... where X i i 's are the line numbers and S i i 's are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed. If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique. Sample Input 4 7 1001 3212 1003 1204 1005 1306 7797 9 9988 2333 1204 2006 2005 2004 2003 2302 2001 13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011 4 6666 8432 4011 1306 3 3011 3013 6666 2001 2004 3001 Sample Output 2 Take Line#3 from 3011 to 3013. 10 Take Line#4 from 6666 to 1306. Take Line#3 from 1306 to 2302. Take Line#2 from 2302 to 2001. 6 Take Line#2 from 2004 to 1204. Take Line#1 from 1204 to 1306. Take Line#3 from 1306 to 3001.","title":"1131-Subway Map"},{"location":"PAT-Advanced-Level/1131-Subway%20Map/#1131-subway-map","text":"","title":"1131 Subway Map"},{"location":"PAT-Advanced-Level/1131-Subway%20Map/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N N ( \\le \\le 100), the number of subway lines. Then N N lines follow, with the i i -th ( i=1, \\cdots , N i=1, \\cdots , N ) line describes the i i -th subway line in the format: M M S[1] S[2] \u2026 S[ M M ] where M M ( \\le \\le 100) is the number of stops, and S[ i i ]'s ( i=1, \\cdots , M i=1, \\cdots , M ) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order \u2013 that is, the train travels between S[ i i ] and S[ i+1 i+1 ] ( i=1, \\cdots , M-1 i=1, \\cdots , M-1 ) without any stop. Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called \"transfer stations\"), no station can be the conjunction of more than 5 lines. After the description of the subway, another positive integer K K ( \\le \\le 10) is given. Then K K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively. The following figure shows the sample map. Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers. Output Specification For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following: Take Line#X1 from S1 to S2. Take Line#X2 from S2 to S3. ...... where X i i 's are the line numbers and S i i 's are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed. If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique. Sample Input 4 7 1001 3212 1003 1204 1005 1306 7797 9 9988 2333 1204 2006 2005 2004 2003 2302 2001 13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011 4 6666 8432 4011 1306 3 3011 3013 6666 2001 2004 3001 Sample Output 2 Take Line#3 from 3011 to 3013. 10 Take Line#4 from 6666 to 1306. Take Line#3 from 1306 to 2302. Take Line#2 from 2302 to 2001. 6 Take Line#2 from 2004 to 1204. Take Line#1 from 1204 to 1306. Take Line#3 from 1306 to 3001.","title":"Statement"},{"location":"PAT-Advanced-Level/1132-Cut%20Integer/","text":"1132 Cut Integer Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 \\times \\times 334) = 3. Given an integer Z, you are supposed to test if it is such an integer. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20). Then N lines follow, each gives an integer Z (10 \\le \\le Z <2^{31} <2^{31} ). It is guaranteed that the number of digits of Z is an even number. Output Specification For each case, print a single line Yes if it is such a number, or No if not. Sample Input 3 167334 2333 12345678 Sample Output Yes No No Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; ll x ; string s ; int main () { int _T ; cin >> _T ; while ( _T -- ) { cin >> s ; ll x = 0 , A = 0 , B = 0 ; for ( int i = 0 , len = s . size (); i < len ; ++ i ) { int c = s [ i ] - '0' ; x = x * 10 + c ; if ( i < len / 2 ) { A = A * 10 + c ; } else { B = B * 10 + c ; } } if ( A == 0 || B == 0 ) puts ( \"No\" ); else { if ( x % A == 0 && ( x / A ) % B == 0 ) { puts ( \"Yes\" ); } else { puts ( \"No\" ); } } } return 0 ; }","title":"1132-Cut Integer"},{"location":"PAT-Advanced-Level/1132-Cut%20Integer/#1132-cut-integer","text":"","title":"1132 Cut Integer"},{"location":"PAT-Advanced-Level/1132-Cut%20Integer/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 \\times \\times 334) = 3. Given an integer Z, you are supposed to test if it is such an integer. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20). Then N lines follow, each gives an integer Z (10 \\le \\le Z <2^{31} <2^{31} ). It is guaranteed that the number of digits of Z is an even number. Output Specification For each case, print a single line Yes if it is such a number, or No if not. Sample Input 3 167334 2333 12345678 Sample Output Yes No No","title":"Statement"},{"location":"PAT-Advanced-Level/1132-Cut%20Integer/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; ll x ; string s ; int main () { int _T ; cin >> _T ; while ( _T -- ) { cin >> s ; ll x = 0 , A = 0 , B = 0 ; for ( int i = 0 , len = s . size (); i < len ; ++ i ) { int c = s [ i ] - '0' ; x = x * 10 + c ; if ( i < len / 2 ) { A = A * 10 + c ; } else { B = B * 10 + c ; } } if ( A == 0 || B == 0 ) puts ( \"No\" ); else { if ( x % A == 0 && ( x / A ) % B == 0 ) { puts ( \"Yes\" ); } else { puts ( \"No\" ); } } } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1133-Splitting%20A%20Linked%20List/","text":"1133 Splitting A Linked List Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18\u21927\u2192-4\u21920\u21925\u2192-6\u219210\u219211\u2192-2 and K being 10, you must output -4\u2192-6\u2192-2\u21927\u21920\u21925\u219210\u219218\u219211. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K ( \\le 10^3 \\le 10^3 ). The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer in [-10^5, 10^5] [-10^5, 10^5] , and Next is the position of the next node. It is guaranteed that the list is not empty. Output Specification For each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 9 10 23333 10 27777 00000 0 99999 00100 18 12309 68237 -6 23333 33218 -4 00000 48652 -2 -1 99999 5 68237 27777 11 48652 12309 7 33218 Sample Output 33218 -4 68237 68237 -6 48652 48652 -2 12309 12309 7 00000 00000 0 99999 99999 5 23333 23333 10 00100 00100 18 27777 27777 11 -1","title":"1133-Splitting A Linked List"},{"location":"PAT-Advanced-Level/1133-Splitting%20A%20Linked%20List/#1133-splitting-a-linked-list","text":"","title":"1133 Splitting A Linked List"},{"location":"PAT-Advanced-Level/1133-Splitting%20A%20Linked%20List/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18\u21927\u2192-4\u21920\u21925\u2192-6\u219210\u219211\u2192-2 and K being 10, you must output -4\u2192-6\u2192-2\u21927\u21920\u21925\u219210\u219218\u219211. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K ( \\le 10^3 \\le 10^3 ). The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer in [-10^5, 10^5] [-10^5, 10^5] , and Next is the position of the next node. It is guaranteed that the list is not empty. Output Specification For each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 9 10 23333 10 27777 00000 0 99999 00100 18 12309 68237 -6 23333 33218 -4 00000 48652 -2 -1 99999 5 68237 27777 11 48652 12309 7 33218 Sample Output 33218 -4 68237 68237 -6 48652 48652 -2 12309 12309 7 00000 00000 0 99999 99999 5 23333 23333 10 00100 00100 18 27777 27777 11 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1134-Vertex%20Cover/","text":"1134 Vertex Cover Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of vertices and the edges, respectively. Then M M lines follow, each describes an edge by giving the indices (from 0 to N-1 N-1 ) of the two ends of the edge. After the graph, a positive integer K K ( \\le \\le 100) is given, which is the number of queries. Then K K lines of queries follow, each in the format: N_v N_v v[1] v[1] v[2] \\cdots v[N_v] v[2] \\cdots v[N_v] where N_v N_v is the number of vertices in the set, and v[i] v[i] 's are the indices of the vertices. Output Specification For each query, print in a line Yes if the set is a vertex cover, or No if not. Sample Input 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 0 2 4 5 4 0 3 8 4 6 6 1 7 5 4 9 3 1 8 4 2 2 8 7 9 8 7 6 5 4 2 Sample Output No Yes Yes No No","title":"1134-Vertex Cover"},{"location":"PAT-Advanced-Level/1134-Vertex%20Cover/#1134-vertex-cover","text":"","title":"1134 Vertex Cover"},{"location":"PAT-Advanced-Level/1134-Vertex%20Cover/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 600 ms \u5185\u5b58\u9650\u5236: 64 MB A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of vertices and the edges, respectively. Then M M lines follow, each describes an edge by giving the indices (from 0 to N-1 N-1 ) of the two ends of the edge. After the graph, a positive integer K K ( \\le \\le 100) is given, which is the number of queries. Then K K lines of queries follow, each in the format: N_v N_v v[1] v[1] v[2] \\cdots v[N_v] v[2] \\cdots v[N_v] where N_v N_v is the number of vertices in the set, and v[i] v[i] 's are the indices of the vertices. Output Specification For each query, print in a line Yes if the set is a vertex cover, or No if not. Sample Input 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 0 2 4 5 4 0 3 8 4 6 6 1 7 5 4 9 3 1 8 4 2 2 8 7 9 8 7 6 5 4 2 Sample Output No Yes Yes No No","title":"Statement"},{"location":"PAT-Advanced-Level/1135-Is%20It%20A%20Red-Black%20Tree/","text":"1135 Is It A Red-Black Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) Every leaf (NULL) is black. (4) If a node is red, then both its children are black. (5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not. Figure 1 Figure 2 Figure 3 For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification Each input file contains several test cases. The first line gives a positive integer K ( \\le \\le 30) which is the total number of cases. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification For each test case, print in a line \"Yes\" if the given tree is a red-black tree, or \"No\" if not. Sample Input 3 9 7 -2 1 5 -4 -11 8 14 -15 9 11 -2 1 -7 5 -4 8 14 -15 8 10 -7 5 -6 8 15 -11 17 Sample Output Yes No No","title":"1135-Is It A Red-Black Tree"},{"location":"PAT-Advanced-Level/1135-Is%20It%20A%20Red-Black%20Tree/#1135-is-it-a-red-black-tree","text":"","title":"1135 Is It A Red-Black Tree"},{"location":"PAT-Advanced-Level/1135-Is%20It%20A%20Red-Black%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) Every leaf (NULL) is black. (4) If a node is red, then both its children are black. (5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not. Figure 1 Figure 2 Figure 3 For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification Each input file contains several test cases. The first line gives a positive integer K ( \\le \\le 30) which is the total number of cases. For each case, the first line gives a positive integer N ( \\le \\le 30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification For each test case, print in a line \"Yes\" if the given tree is a red-black tree, or \"No\" if not. Sample Input 3 9 7 -2 1 5 -4 -11 8 14 -15 9 11 -2 1 -7 5 -4 8 14 -15 8 10 -7 5 -6 8 15 -11 17 Sample Output Yes No No","title":"Statement"},{"location":"PAT-Advanced-Level/1136-A%20Delayed%20Palindrome/","text":"1136 A Delayed Palindrome Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Consider a positive integer N N written in standard notation with k+1 k+1 digits a_i a_i as a_k \\cdots a_1 a_0 a_k \\cdots a_1 a_0 with 0 \\le a_i < 10 0 \\le a_i < 10 for all i i and a_k > 0 a_k > 0 . Then N N is palindromic if and only if a_i = a_{k-i} a_i = a_{k-i} for all i i . Zero is written 0 and is also palindromic by definition. Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is called a delayed palindrome . (Quoted from https://en.wikipedia.org/wiki/Palindromic_number ) Given any positive integer, you are supposed to find its paired palindromic number. Input Specification Each input file contains one test case which gives a positive integer no more than 1000 digits. Output Specification For each test case, print line by line the process of finding the palindromic number. The format of each line is the following: A + B = C where A is the original number, B is the reversed A , and C is their sum. A starts being the input number, and this process ends until C becomes a palindromic number \u2013 in this case we print in the last line C is a palindromic number. ; or if a palindromic number cannot be found in 10 iterations, print Not found in 10 iterations. instead. Sample Input 1 97152 Sample Output 1 97152 + 25179 = 122331 122331 + 133221 = 255552 255552 is a palindromic number. Sample Input 2 196 Sample Output 2 196 + 691 = 887 887 + 788 = 1675 1675 + 5761 = 7436 7436 + 6347 = 13783 13783 + 38731 = 52514 52514 + 41525 = 94039 94039 + 93049 = 187088 187088 + 880781 = 1067869 1067869 + 9687601 = 10755470 10755470 + 07455701 = 18211171 Not found in 10 iterations.","title":"1136-A Delayed Palindrome"},{"location":"PAT-Advanced-Level/1136-A%20Delayed%20Palindrome/#1136-a-delayed-palindrome","text":"","title":"1136 A Delayed Palindrome"},{"location":"PAT-Advanced-Level/1136-A%20Delayed%20Palindrome/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Consider a positive integer N N written in standard notation with k+1 k+1 digits a_i a_i as a_k \\cdots a_1 a_0 a_k \\cdots a_1 a_0 with 0 \\le a_i < 10 0 \\le a_i < 10 for all i i and a_k > 0 a_k > 0 . Then N N is palindromic if and only if a_i = a_{k-i} a_i = a_{k-i} for all i i . Zero is written 0 and is also palindromic by definition. Non-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is called a delayed palindrome . (Quoted from https://en.wikipedia.org/wiki/Palindromic_number ) Given any positive integer, you are supposed to find its paired palindromic number. Input Specification Each input file contains one test case which gives a positive integer no more than 1000 digits. Output Specification For each test case, print line by line the process of finding the palindromic number. The format of each line is the following: A + B = C where A is the original number, B is the reversed A , and C is their sum. A starts being the input number, and this process ends until C becomes a palindromic number \u2013 in this case we print in the last line C is a palindromic number. ; or if a palindromic number cannot be found in 10 iterations, print Not found in 10 iterations. instead. Sample Input 1 97152 Sample Output 1 97152 + 25179 = 122331 122331 + 133221 = 255552 255552 is a palindromic number. Sample Input 2 196 Sample Output 2 196 + 691 = 887 887 + 788 = 1675 1675 + 5761 = 7436 7436 + 6347 = 13783 13783 + 38731 = 52514 52514 + 41525 = 94039 94039 + 93049 = 187088 187088 + 880781 = 1067869 1067869 + 9687601 = 10755470 10755470 + 07455701 = 18211171 Not found in 10 iterations.","title":"Statement"},{"location":"PAT-Advanced-Level/1137-Final%20Grading/","text":"1137 Final Grading Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For a student taking the online course \"Data Structures\" on China University MOOC ( http://www.icourse163.org/ ), to be qualified for a certificate, he/she must first obtain no less than 200 points from the online programming assignments, and then receive a final grade no less than 60 out of 100. The final grade is calculated by G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) if G_{mid-term} > G_{final} G_{mid-term} > G_{final} , or G_{final} G_{final} will be taken as the final grade G G . Here G_{mid-term} G_{mid-term} and G_{final} G_{final} are the student's scores of the mid-term and the final exams, respectively. The problem is that different exams have different grading sheets. Your job is to write a program to merge all the grading sheets into one. Input Specification Each input file contains one test case. For each case, the first line gives three positive integers: P , the number of students having done the online programming assignments; M, the number of students on the mid-term list; and N, the number of students on the final exam list. All the numbers are no more than 10,000. Then three blocks follow. The first block contains P online programming scores G_p G_p 's; the second one contains M mid-term scores G_{mid-term} G_{mid-term} 's; and the last one contains N final exam scores G_{final} G_{final} 's. Each score occupies a line with the format: StudentID Score , where StudentID is a string of no more than 20 English letters and digits, and Score is a nonnegative integer (the maximum score of the online programming is 900, and that of the mid-term and final exams is 100). Output Specification For each case, print the list of students who are qualified for certificates. Each student occupies a line with the format: StudentID G_p G_p G_{mid-term} G_{mid-term} G_{final} G_{final} G G If some score does not exist, output \" -1 -1 \" instead. The output must be sorted in descending order of their final grades ( G G must be rounded up to an integer). If there is a tie, output in ascending order of their StudentID 's. It is guaranteed that the StudentID 's are all distinct, and there is at least one qullified student. Sample Input 6 6 7 01234 880 a1903 199 ydjh2 200 wehu8 300 dx86w 220 missing 400 ydhfu77 99 wehu8 55 ydjh2 98 dx86w 88 a1903 86 01234 39 ydhfu77 88 a1903 66 01234 58 wehu8 84 ydjh2 82 missing 99 dx86w 81 Sample Output missing 400 -1 99 99 ydjh2 200 98 82 88 dx86w 220 88 81 84 wehu8 300 55 84 84","title":"1137-Final Grading"},{"location":"PAT-Advanced-Level/1137-Final%20Grading/#1137-final-grading","text":"","title":"1137 Final Grading"},{"location":"PAT-Advanced-Level/1137-Final%20Grading/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB For a student taking the online course \"Data Structures\" on China University MOOC ( http://www.icourse163.org/ ), to be qualified for a certificate, he/she must first obtain no less than 200 points from the online programming assignments, and then receive a final grade no less than 60 out of 100. The final grade is calculated by G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) if G_{mid-term} > G_{final} G_{mid-term} > G_{final} , or G_{final} G_{final} will be taken as the final grade G G . Here G_{mid-term} G_{mid-term} and G_{final} G_{final} are the student's scores of the mid-term and the final exams, respectively. The problem is that different exams have different grading sheets. Your job is to write a program to merge all the grading sheets into one. Input Specification Each input file contains one test case. For each case, the first line gives three positive integers: P , the number of students having done the online programming assignments; M, the number of students on the mid-term list; and N, the number of students on the final exam list. All the numbers are no more than 10,000. Then three blocks follow. The first block contains P online programming scores G_p G_p 's; the second one contains M mid-term scores G_{mid-term} G_{mid-term} 's; and the last one contains N final exam scores G_{final} G_{final} 's. Each score occupies a line with the format: StudentID Score , where StudentID is a string of no more than 20 English letters and digits, and Score is a nonnegative integer (the maximum score of the online programming is 900, and that of the mid-term and final exams is 100). Output Specification For each case, print the list of students who are qualified for certificates. Each student occupies a line with the format: StudentID G_p G_p G_{mid-term} G_{mid-term} G_{final} G_{final} G G If some score does not exist, output \" -1 -1 \" instead. The output must be sorted in descending order of their final grades ( G G must be rounded up to an integer). If there is a tie, output in ascending order of their StudentID 's. It is guaranteed that the StudentID 's are all distinct, and there is at least one qullified student. Sample Input 6 6 7 01234 880 a1903 199 ydjh2 200 wehu8 300 dx86w 220 missing 400 ydhfu77 99 wehu8 55 ydjh2 98 dx86w 88 a1903 86 01234 39 ydhfu77 88 a1903 66 01234 58 wehu8 84 ydjh2 82 missing 99 dx86w 81 Sample Output missing 400 -1 99 99 ydjh2 200 98 82 88 dx86w 220 88 81 84 wehu8 300 55 84 84","title":"Statement"},{"location":"PAT-Advanced-Level/1138-Postorder%20Traversal/","text":"1138 Postorder Traversal Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 650 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the preorder and inorder traversal sequences, you are supposed to output the first number of the postorder traversal sequence of the corresponding binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 50,000), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the first number of the postorder traversal sequence of the corresponding binary tree. Sample Input 7 1 2 3 4 5 6 7 2 3 1 5 4 7 6 Sample Output 3","title":"1138-Postorder Traversal"},{"location":"PAT-Advanced-Level/1138-Postorder%20Traversal/#1138-postorder-traversal","text":"","title":"1138 Postorder Traversal"},{"location":"PAT-Advanced-Level/1138-Postorder%20Traversal/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 650 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the preorder and inorder traversal sequences, you are supposed to output the first number of the postorder traversal sequence of the corresponding binary tree. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 50,000), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification For each test case, print in one line the first number of the postorder traversal sequence of the corresponding binary tree. Sample Input 7 1 2 3 4 5 6 7 2 3 1 5 4 7 6 Sample Output 3","title":"Statement"},{"location":"PAT-Advanced-Level/1139-First%20Contact/","text":"1139 First Contact Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B \u2013 quite a long shot, isn't it? Girls would do analogously. Here given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N (1 < < N \\le \\le 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls. After the relations, a positive integer K ( \\le \\le 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one. Output Specification For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends. If the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender. The friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones. Sample Input 10 18 -2001 1001 -2002 -2001 1004 1001 -2004 -2001 -2003 1005 1005 -2001 1001 -2003 1002 1001 1002 -2004 -2004 1001 1003 -2002 -2003 1003 1004 -2002 -2001 -2003 1001 1003 1003 -2001 1002 -2001 -2002 -2003 5 1001 -2001 -2003 1001 1005 -2001 -2002 -2004 1111 -2003 Sample Output 4 1002 2004 1003 2002 1003 2003 1004 2002 4 2001 1002 2001 1003 2002 1003 2002 1004 0 1 2003 2001 0","title":"1139-First Contact"},{"location":"PAT-Advanced-Level/1139-First%20Contact/#1139-first-contact","text":"","title":"1139 First Contact"},{"location":"PAT-Advanced-Level/1139-First%20Contact/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B \u2013 quite a long shot, isn't it? Girls would do analogously. Here given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N (1 < < N \\le \\le 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls. After the relations, a positive integer K ( \\le \\le 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one. Output Specification For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends. If the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender. The friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones. Sample Input 10 18 -2001 1001 -2002 -2001 1004 1001 -2004 -2001 -2003 1005 1005 -2001 1001 -2003 1002 1001 1002 -2004 -2004 1001 1003 -2002 -2003 1003 1004 -2002 -2001 -2003 1001 1003 1003 -2001 1002 -2001 -2002 -2003 5 1001 -2001 -2003 1001 1005 -2001 -2002 -2004 1111 -2003 Sample Output 4 1002 2004 1003 2002 1003 2003 1004 2002 4 2001 1002 2001 1003 2002 1003 2002 1004 0 1 2003 2001 0","title":"Statement"},{"location":"PAT-Advanced-Level/1140-Look-and-say%20Sequence/","text":"1140 Look-and-say Sequence Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Look-and-say sequence is a sequence of integers as the following: D, D1, D111, D113, D11231, D112213111, ... where D is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2 nd number means that there is one D in the 1 st number, and hence it is D1 ; the 2 nd number consists of one D (corresponding to D1 ) and one 1 (corresponding to 11), therefore the 3 rd number is D111 ; or since the 4 th number is D113 , it consists of one D , two 1's, and one 3, so the next number must be D11231 . This definition works for D = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit D . Input Specification Each input file contains one test case, which gives D (in [0, 9]) and a positive integer N ( \\le \\le 40), separated by a space. Output Specification Print in a line the Nth number in a look-and-say sequence of D . Sample Input 1 8 Sample Output 1123123111","title":"1140-Look-and-say Sequence"},{"location":"PAT-Advanced-Level/1140-Look-and-say%20Sequence/#1140-look-and-say-sequence","text":"","title":"1140 Look-and-say Sequence"},{"location":"PAT-Advanced-Level/1140-Look-and-say%20Sequence/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Look-and-say sequence is a sequence of integers as the following: D, D1, D111, D113, D11231, D112213111, ... where D is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2 nd number means that there is one D in the 1 st number, and hence it is D1 ; the 2 nd number consists of one D (corresponding to D1 ) and one 1 (corresponding to 11), therefore the 3 rd number is D111 ; or since the 4 th number is D113 , it consists of one D , two 1's, and one 3, so the next number must be D11231 . This definition works for D = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit D . Input Specification Each input file contains one test case, which gives D (in [0, 9]) and a positive integer N ( \\le \\le 40), separated by a space. Output Specification Print in a line the Nth number in a look-and-say sequence of D . Sample Input 1 8 Sample Output 1123123111","title":"Statement"},{"location":"PAT-Advanced-Level/1141-PAT%20Ranking%20of%20Institutions/","text":"1141 PAT Ranking of Institutions Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB After each PAT, the PAT Center will announce the ranking of institutions based on their students' performances. Now you are asked to generate the ranklist. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^5 \\le 10^5 ), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format: ID Score School where ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level and T the top level; Score is an integer in [0, 100]; and School is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee. Output Specification For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format: Rank School TWS Ns where Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5 , where ScoreX is the total score of the testees belong to this institution on level X ; and Ns is the total number of testees who belong to this institution. The institutions are ranked according to their TWS . If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns . If there is still a tie, they shall be printed in alphabetical order of their codes. Sample Input 10 A57908 85 Au B57908 54 LanX A37487 60 au T28374 67 CMU T32486 24 hypu A66734 92 cmu B76378 71 AU A47780 45 lanx A72809 100 pku A03274 45 hypu Sample Output 5 1 cmu 192 2 1 au 192 3 3 pku 100 1 4 hypu 81 2 4 lanx 81 2","title":"1141-PAT Ranking of Institutions"},{"location":"PAT-Advanced-Level/1141-PAT%20Ranking%20of%20Institutions/#1141-pat-ranking-of-institutions","text":"","title":"1141 PAT Ranking of Institutions"},{"location":"PAT-Advanced-Level/1141-PAT%20Ranking%20of%20Institutions/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB After each PAT, the PAT Center will announce the ranking of institutions based on their students' performances. Now you are asked to generate the ranklist. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^5 \\le 10^5 ), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format: ID Score School where ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level and T the top level; Score is an integer in [0, 100]; and School is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee. Output Specification For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format: Rank School TWS Ns where Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5 , where ScoreX is the total score of the testees belong to this institution on level X ; and Ns is the total number of testees who belong to this institution. The institutions are ranked according to their TWS . If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns . If there is still a tie, they shall be printed in alphabetical order of their codes. Sample Input 10 A57908 85 Au B57908 54 LanX A37487 60 au T28374 67 CMU T32486 24 hypu A66734 92 cmu B76378 71 AU A47780 45 lanx A72809 100 pku A03274 45 hypu Sample Output 5 1 cmu 192 2 1 au 192 3 3 pku 100 1 4 hypu 81 2 4 lanx 81 2","title":"Statement"},{"location":"PAT-Advanced-Level/1142-Maximal%20Clique/","text":"1142 Maximal Clique Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. A maximal clique is a clique that cannot be extended by including one more adjacent vertex. (Quoted from https://en.wikipedia.org/wiki/Clique_(graph_theory )) Now it is your job to judge if a given subset of vertices can form a maximal clique. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers Nv ( \\le \\le 200), the number of vertices in the graph, and Ne, the number of undirected edges. Then Ne lines follow, each gives a pair of vertices of an edge. The vertices are numbered from 1 to Nv. After the graph, there is another positive integer M ( \\le \\le 100). Then M lines of query follow, each first gives a positive number K ( \\le \\le Nv), then followed by a sequence of K distinct vertices. All the numbers in a line are separated by a space. Output Specification For each of the M queries, print in a line Yes if the given subset of vertices can form a maximal clique; or if it is a clique but not a maximal clique , print Not Maximal ; or if it is not a clique at all, print Not a Clique . Sample Input 8 10 5 6 7 8 6 4 3 6 4 5 2 3 8 2 2 7 5 3 3 4 6 4 5 4 3 6 3 2 8 7 2 2 3 1 1 3 4 3 6 3 3 2 1 Sample Output Yes Yes Yes Yes Not Maximal Not a Clique","title":"1142-Maximal Clique"},{"location":"PAT-Advanced-Level/1142-Maximal%20Clique/#1142-maximal-clique","text":"","title":"1142 Maximal Clique"},{"location":"PAT-Advanced-Level/1142-Maximal%20Clique/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. A maximal clique is a clique that cannot be extended by including one more adjacent vertex. (Quoted from https://en.wikipedia.org/wiki/Clique_(graph_theory )) Now it is your job to judge if a given subset of vertices can form a maximal clique. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers Nv ( \\le \\le 200), the number of vertices in the graph, and Ne, the number of undirected edges. Then Ne lines follow, each gives a pair of vertices of an edge. The vertices are numbered from 1 to Nv. After the graph, there is another positive integer M ( \\le \\le 100). Then M lines of query follow, each first gives a positive number K ( \\le \\le Nv), then followed by a sequence of K distinct vertices. All the numbers in a line are separated by a space. Output Specification For each of the M queries, print in a line Yes if the given subset of vertices can form a maximal clique; or if it is a clique but not a maximal clique , print Not Maximal ; or if it is not a clique at all, print Not a Clique . Sample Input 8 10 5 6 7 8 6 4 3 6 4 5 2 3 8 2 2 7 5 3 3 4 6 4 5 4 3 6 3 2 8 7 2 2 3 1 1 3 4 3 6 3 3 2 1 Sample Output Yes Yes Yes Yes Not Maximal Not a Clique","title":"Statement"},{"location":"PAT-Advanced-Level/1143-Lowest%20Common%20Ancestor/","text":"1143 Lowest Common Ancestor Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. A binary search tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. Given any two nodes in a BST, you are supposed to find their LCA. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 1,000), the number of pairs of nodes to be tested; and N ( \\le \\le 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int . Output Specification For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found. . Sample Input 6 8 6 3 1 2 5 4 8 7 2 5 8 7 1 9 12 -3 0 8 99 99 Sample Output LCA of 2 and 5 is 3. 8 is an ancestor of 7. ERROR: 9 is not found. ERROR: 12 and -3 are not found. ERROR: 0 is not found. ERROR: 99 and 99 are not found.","title":"1143-Lowest Common Ancestor"},{"location":"PAT-Advanced-Level/1143-Lowest%20Common%20Ancestor/#1143-lowest-common-ancestor","text":"","title":"1143 Lowest Common Ancestor"},{"location":"PAT-Advanced-Level/1143-Lowest%20Common%20Ancestor/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. A binary search tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than or equal to the node's key. Both the left and right subtrees must also be binary search trees. Given any two nodes in a BST, you are supposed to find their LCA. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 1,000), the number of pairs of nodes to be tested; and N ( \\le \\le 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int . Output Specification For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found. . Sample Input 6 8 6 3 1 2 5 4 8 7 2 5 8 7 1 9 12 -3 0 8 99 99 Sample Output LCA of 2 and 5 is 3. 8 is an ancestor of 7. ERROR: 9 is not found. ERROR: 12 and -3 are not found. ERROR: 0 is not found. ERROR: 99 and 99 are not found.","title":"Statement"},{"location":"PAT-Advanced-Level/1144-The%20Missing%20Number/","text":"1144 The Missing Number Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^5 \\le 10^5 ). Then N integers are given in the next line, separated by spaces. All the numbers are in the range of int . Output Specification Print in a line the smallest positive integer that is missing from the input list. Sample Input 10 5 -25 9 6 1 3 4 2 5 17 Sample Output 7 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , b [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( b , 0 , sizeof b ); for ( int i = 1 , x ; i <= n ; ++ i ) { scanf ( \"%d\" , & x ); if ( x >= 1 && x <= 100005 ) { b [ x ] = 1 ; } } for ( int i = 1 ; i <= 100006 ; ++ i ) { if ( b [ i ] == 0 ) { printf ( \"%d \\n \" , i ); break ; } } } return 0 ; }","title":"1144-The Missing Number"},{"location":"PAT-Advanced-Level/1144-The%20Missing%20Number/#1144-the-missing-number","text":"","title":"1144 The Missing Number"},{"location":"PAT-Advanced-Level/1144-The%20Missing%20Number/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le 10^5 \\le 10^5 ). Then N integers are given in the next line, separated by spaces. All the numbers are in the range of int . Output Specification Print in a line the smallest positive integer that is missing from the input list. Sample Input 10 5 -25 9 6 1 3 4 2 5 17 Sample Output 7","title":"Statement"},{"location":"PAT-Advanced-Level/1144-The%20Missing%20Number/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , b [ N ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( b , 0 , sizeof b ); for ( int i = 1 , x ; i <= n ; ++ i ) { scanf ( \"%d\" , & x ); if ( x >= 1 && x <= 100005 ) { b [ x ] = 1 ; } } for ( int i = 1 ; i <= 100006 ; ++ i ) { if ( b [ i ] == 0 ) { printf ( \"%d \\n \" , i ); break ; } } } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1145-Hashing%20-%20Average%20Search%20Time/","text":"1145 Hashing - Average Search Time Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be H(key) = key \\% TSize H(key) = key \\% TSize where TSize TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than 10^4 10^4 . Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than 10^5 10^5 . Output Specification For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place. Sample Input 4 5 4 10 6 4 15 11 11 4 15 2 Sample Output 15 cannot be inserted. 2.8","title":"1145-Hashing - Average Search Time"},{"location":"PAT-Advanced-Level/1145-Hashing%20-%20Average%20Search%20Time/#1145-hashing---average-search-time","text":"","title":"1145 Hashing - Average Search Time"},{"location":"PAT-Advanced-Level/1145-Hashing%20-%20Average%20Search%20Time/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be H(key) = key \\% TSize H(key) = key \\% TSize where TSize TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than 10^4 10^4 . Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than 10^5 10^5 . Output Specification For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place. Sample Input 4 5 4 10 6 4 15 11 11 4 15 2 Sample Output 15 cannot be inserted. 2.8","title":"Statement"},{"location":"PAT-Advanced-Level/1146-Topological%20Order/","text":"1146 Topological Order Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N ( \\le \\le 1,000), the number of vertices in the graph, and M ( \\le \\le 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K ( \\le \\le 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification Print in a line all the indices of queries which correspond to \"NOT a topological order\". The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input 6 8 1 2 1 3 5 2 5 4 2 3 2 6 3 4 6 4 6 5 2 3 6 4 1 1 5 2 3 6 4 5 1 2 6 3 4 5 1 2 3 6 4 5 2 1 6 3 4 1 2 3 4 5 6 Sample Output 0 4 5 \u9e23\u8c22\u7528\u6237\u67f3\u6c40\u6d32\u8865\u5145\u6570\u636e\uff01","title":"1146-Topological Order"},{"location":"PAT-Advanced-Level/1146-Topological%20Order/#1146-topological-order","text":"","title":"1146 Topological Order"},{"location":"PAT-Advanced-Level/1146-Topological%20Order/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N ( \\le \\le 1,000), the number of vertices in the graph, and M ( \\le \\le 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K ( \\le \\le 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space. Output Specification Print in a line all the indices of queries which correspond to \"NOT a topological order\". The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer. Sample Input 6 8 1 2 1 3 5 2 5 4 2 3 2 6 3 4 6 4 6 5 2 3 6 4 1 1 5 2 3 6 4 5 1 2 6 3 4 5 1 2 3 6 4 5 2 1 6 3 4 1 2 3 4 5 6 Sample Output 0 4 5 \u9e23\u8c22\u7528\u6237\u67f3\u6c40\u6d32\u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Advanced-Level/1147-Heaps/","text":"1147 Heaps Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure )) Your job is to tell if a given complete binary tree is a heap. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 100), the number of trees to be tested; and N (1 < < N \\le \\le 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of int ), which gives the level order traversal sequence of a complete binary tree. Output Specification For each given tree, print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Then in the next line print the tree's postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. Sample Input 3 8 98 72 86 60 65 12 23 50 8 38 25 58 52 82 70 60 10 28 15 12 34 9 8 56 Sample Output Max Heap 50 60 65 72 12 23 86 98 Min Heap 60 58 52 38 82 70 25 8 Not Heap 56 12 34 28 9 8 15 10 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ]; vector < int > vec ; void dfs ( int u ) { if ( u > n ) return ; dfs ( u << 1 ); dfs ( u << 1 | 1 ); vec . push_back ( a [ u ]); } int main () { int _T ; cin >> _T >> n ; while ( _T -- ) { int l = 0 , g = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( i > 1 ) { if ( a [ i ] > a [ i >> 1 ]) ++ l ; else ++ g ; } } if ( l && g ) puts ( \"Not Heap\" ); else if ( l ) puts ( \"Min Heap\" ); else puts ( \"Max Heap\" ); vec . clear (); dfs ( 1 ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"1147-Heaps"},{"location":"PAT-Advanced-Level/1147-Heaps/#1147-heaps","text":"","title":"1147 Heaps"},{"location":"PAT-Advanced-Level/1147-Heaps/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure )) Your job is to tell if a given complete binary tree is a heap. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 100), the number of trees to be tested; and N (1 < < N \\le \\le 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of int ), which gives the level order traversal sequence of a complete binary tree. Output Specification For each given tree, print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Then in the next line print the tree's postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. Sample Input 3 8 98 72 86 60 65 12 23 50 8 38 25 58 52 82 70 60 10 28 15 12 34 9 8 56 Sample Output Max Heap 50 60 65 72 12 23 86 98 Min Heap 60 58 52 38 82 70 25 8 Not Heap 56 12 34 28 9 8 15 10","title":"Statement"},{"location":"PAT-Advanced-Level/1147-Heaps/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ]; vector < int > vec ; void dfs ( int u ) { if ( u > n ) return ; dfs ( u << 1 ); dfs ( u << 1 | 1 ); vec . push_back ( a [ u ]); } int main () { int _T ; cin >> _T >> n ; while ( _T -- ) { int l = 0 , g = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( i > 1 ) { if ( a [ i ] > a [ i >> 1 ]) ++ l ; else ++ g ; } } if ( l && g ) puts ( \"Not Heap\" ); else if ( l ) puts ( \"Min Heap\" ); else puts ( \"Max Heap\" ); vec . clear (); dfs ( 1 ); for ( int i = 0 ; i < n ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == n - 1 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1148-Werewolf%20-%20Simple%20Version/","text":"1148 Werewolf - Simple Version Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Werewolf\uff08\u72fc\u4eba\u6740\uff09 is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: \"Player #2 is a werewolf.\"; player #2 said: \"Player #3 is a human.\"; player #3 said: \"Player #4 is a werewolf.\"; player #4 said: \"Player #5 is a human.\"; and player #5 said: \"Player #4 is a human.\". Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 5 \\le N \\le 100 5 \\le N \\le 100 ). Then N N lines follow and the i i -th line gives the statement of the i i -th player ( 1 \\le i \\le N 1 \\le i \\le N ), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence \u2013 that is, for two sequences A = { a[1], ..., a[M] } A = { a[1], ..., a[M] } and B = { b[1], ..., b[M] } B = { b[1], ..., b[M] } , if there exists 0 \\le k < M 0 \\le k < M such that a[i]=b[i] a[i]=b[i] ( i \\le k i \\le k ) and a[k+1]<b[k+1] a[k+1]<b[k+1] , then A A is said to be smaller than B B . In case there is no solution, simply print No Solution . Sample Input 1 5 -2 +3 -4 +5 +4 Sample Output 1 1 4 Sample Input 2 6 +6 +3 +1 -5 -2 +4 Sample Output 2 (the solution is not unique) 1 5 Sample Input 3 5 -2 -3 -4 -5 -1 Sample Output 3 No Solution","title":"1148-Werewolf - Simple Version"},{"location":"PAT-Advanced-Level/1148-Werewolf%20-%20Simple%20Version/#1148-werewolf---simple-version","text":"","title":"1148 Werewolf - Simple Version"},{"location":"PAT-Advanced-Level/1148-Werewolf%20-%20Simple%20Version/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Werewolf\uff08\u72fc\u4eba\u6740\uff09 is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: \"Player #2 is a werewolf.\"; player #2 said: \"Player #3 is a human.\"; player #3 said: \"Player #4 is a werewolf.\"; player #4 said: \"Player #5 is a human.\"; and player #5 said: \"Player #4 is a human.\". Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 5 \\le N \\le 100 5 \\le N \\le 100 ). Then N N lines follow and the i i -th line gives the statement of the i i -th player ( 1 \\le i \\le N 1 \\le i \\le N ), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence \u2013 that is, for two sequences A = { a[1], ..., a[M] } A = { a[1], ..., a[M] } and B = { b[1], ..., b[M] } B = { b[1], ..., b[M] } , if there exists 0 \\le k < M 0 \\le k < M such that a[i]=b[i] a[i]=b[i] ( i \\le k i \\le k ) and a[k+1]<b[k+1] a[k+1]<b[k+1] , then A A is said to be smaller than B B . In case there is no solution, simply print No Solution . Sample Input 1 5 -2 +3 -4 +5 +4 Sample Output 1 1 4 Sample Input 2 6 +6 +3 +1 -5 -2 +4 Sample Output 2 (the solution is not unique) 1 5 Sample Input 3 5 -2 -3 -4 -5 -1 Sample Output 3 No Solution","title":"Statement"},{"location":"PAT-Advanced-Level/1149-Dangerous%20Goods%20Packaging/","text":"1149 Dangerous Goods Packaging Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent \uff08\u6c27\u5316\u5242\uff09 must not be packed with flammable liquid \uff08\u6613\u71c3\u6db2\u4f53\uff09, or it can cause explosion. Now you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: N N ( \\le 10^4 \\le 10^4 ), the number of pairs of incompatible goods, and M M ( \\le 100 \\le 100 ), the number of lists of goods to be shipped. Then two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format: K G[1] G[2] ... G[K] where K ( \\le 1,000 \\le 1,000 ) is the number of goods and G[i] 's are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces. Output Specification For each shipping list, print in a line Yes if there are no incompatible goods in the list, or No if not. Sample Input 6 3 20001 20002 20003 20004 20005 20006 20003 20001 20005 20004 20004 20006 4 00001 20004 00002 20003 5 98823 20002 20003 20006 10010 3 12345 67890 23333 Sample Output No Yes Yes","title":"1149-Dangerous Goods Packaging"},{"location":"PAT-Advanced-Level/1149-Dangerous%20Goods%20Packaging/#1149-dangerous-goods-packaging","text":"","title":"1149 Dangerous Goods Packaging"},{"location":"PAT-Advanced-Level/1149-Dangerous%20Goods%20Packaging/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent \uff08\u6c27\u5316\u5242\uff09 must not be packed with flammable liquid \uff08\u6613\u71c3\u6db2\u4f53\uff09, or it can cause explosion. Now you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: N N ( \\le 10^4 \\le 10^4 ), the number of pairs of incompatible goods, and M M ( \\le 100 \\le 100 ), the number of lists of goods to be shipped. Then two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format: K G[1] G[2] ... G[K] where K ( \\le 1,000 \\le 1,000 ) is the number of goods and G[i] 's are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces. Output Specification For each shipping list, print in a line Yes if there are no incompatible goods in the list, or No if not. Sample Input 6 3 20001 20002 20003 20004 20005 20006 20003 20001 20005 20004 20004 20006 4 00001 20004 00002 20003 5 98823 20002 20003 20006 10010 3 12345 67890 23333 Sample Output No Yes Yes","title":"Statement"},{"location":"PAT-Advanced-Level/1150-Travelling%20Salesman%20Problem/","text":"1150 Travelling Salesman Problem Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB The \"travelling salesman problem\" asks the following question: \"Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?\" It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science. (Quoted from \" https://en.wikipedia.org/wiki/Travelling_salesman_problem \".) In this problem, you are supposed to find, from a given list of cycles, the one that is the closest to the solution of a travelling salesman problem. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2< N \\le 200 2< N \\le 200 ), the number of cities, and M M , the number of edges in an undirected graph. Then M M lines follow, each describes an edge in the format City1 City2 Dist , where the cities are numbered from 1 to N N and the distance Dist is positive and is no more than 100. The next line gives a positive integer K K which is the number of paths, followed by K K lines of paths, each in the format: n n C_1 C_1 C_2 C_2 \u2026 C_n C_n where n n is the number of cities in the list, and C_i C_i 's are the cities on a path. Output Specification For each path, print in a line Path X: TotalDist (Description) where X is the index (starting from 1) of that path, TotalDist its total distance (if this distance does not exist, output NA instead), and Description is one of the following: TS simple cycle if it is a simple cycle that visits every city; TS cycle if it is a cycle that visits every city, but not a simple cycle; Not a TS cycle if it is NOT a cycle that visits every city. Finally print in a line Shortest Dist(X) = TotalDist where X is the index of the cycle that is the closest to the solution of a travelling salesman problem, and TotalDist is its total distance. It is guaranteed that such a solution is unique. Sample Input 6 10 6 2 1 3 4 1 1 5 1 2 5 1 3 1 8 4 1 6 1 6 1 6 3 1 1 2 1 4 5 1 7 7 5 1 4 3 6 2 5 7 6 1 3 4 5 2 6 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 2 5 4 3 1 7 6 3 2 5 4 1 6 Sample Output Path 1: 11 (TS simple cycle) Path 2: 13 (TS simple cycle) Path 3: 10 (Not a TS cycle) Path 4: 8 (TS cycle) Path 5: 3 (Not a TS cycle) Path 6: 13 (Not a TS cycle) Path 7: NA (Not a TS cycle) Shortest Dist(4) = 8","title":"1150-Travelling Salesman Problem"},{"location":"PAT-Advanced-Level/1150-Travelling%20Salesman%20Problem/#1150-travelling-salesman-problem","text":"","title":"1150 Travelling Salesman Problem"},{"location":"PAT-Advanced-Level/1150-Travelling%20Salesman%20Problem/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB The \"travelling salesman problem\" asks the following question: \"Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?\" It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science. (Quoted from \" https://en.wikipedia.org/wiki/Travelling_salesman_problem \".) In this problem, you are supposed to find, from a given list of cycles, the one that is the closest to the solution of a travelling salesman problem. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2< N \\le 200 2< N \\le 200 ), the number of cities, and M M , the number of edges in an undirected graph. Then M M lines follow, each describes an edge in the format City1 City2 Dist , where the cities are numbered from 1 to N N and the distance Dist is positive and is no more than 100. The next line gives a positive integer K K which is the number of paths, followed by K K lines of paths, each in the format: n n C_1 C_1 C_2 C_2 \u2026 C_n C_n where n n is the number of cities in the list, and C_i C_i 's are the cities on a path. Output Specification For each path, print in a line Path X: TotalDist (Description) where X is the index (starting from 1) of that path, TotalDist its total distance (if this distance does not exist, output NA instead), and Description is one of the following: TS simple cycle if it is a simple cycle that visits every city; TS cycle if it is a cycle that visits every city, but not a simple cycle; Not a TS cycle if it is NOT a cycle that visits every city. Finally print in a line Shortest Dist(X) = TotalDist where X is the index of the cycle that is the closest to the solution of a travelling salesman problem, and TotalDist is its total distance. It is guaranteed that such a solution is unique. Sample Input 6 10 6 2 1 3 4 1 1 5 1 2 5 1 3 1 8 4 1 6 1 6 1 6 3 1 1 2 1 4 5 1 7 7 5 1 4 3 6 2 5 7 6 1 3 4 5 2 6 6 5 1 4 3 6 2 9 6 2 1 6 3 4 5 2 6 4 1 2 5 1 7 6 1 2 5 4 3 1 7 6 3 2 5 4 1 6 Sample Output Path 1: 11 (TS simple cycle) Path 2: 13 (TS simple cycle) Path 3: 10 (Not a TS cycle) Path 4: 8 (TS cycle) Path 5: 3 (Not a TS cycle) Path 6: 13 (Not a TS cycle) Path 7: NA (Not a TS cycle) Shortest Dist(4) = 8","title":"Statement"},{"location":"PAT-Advanced-Level/1151-LCA%20in%20a%20Binary%20Tree/","text":"1151 LCA in a Binary Tree Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. Given any two nodes in a binary tree, you are supposed to find their LCA. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 1,000), the number of pairs of nodes to be tested; and N ( \\le \\le 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int . Output Specification For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found. . Sample Input 6 8 7 2 3 4 6 5 1 8 5 3 7 2 6 4 8 1 2 6 8 1 7 9 12 -3 0 8 99 99 Sample Output LCA of 2 and 6 is 3. 8 is an ancestor of 1. ERROR: 9 is not found. ERROR: 12 and -3 are not found. ERROR: 0 is not found. ERROR: 99 and 99 are not found.","title":"1151-LCA in a Binary Tree"},{"location":"PAT-Advanced-Level/1151-LCA%20in%20a%20Binary%20Tree/#1151-lca-in-a-binary-tree","text":"","title":"1151 LCA in a Binary Tree"},{"location":"PAT-Advanced-Level/1151-LCA%20in%20a%20Binary%20Tree/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. Given any two nodes in a binary tree, you are supposed to find their LCA. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: M ( \\le \\le 1,000), the number of pairs of nodes to be tested; and N ( \\le \\le 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int . Output Specification For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found. . Sample Input 6 8 7 2 3 4 6 5 1 8 5 3 7 2 6 4 8 1 2 6 8 1 7 9 12 -3 0 8 99 99 Sample Output LCA of 2 and 6 is 3. 8 is an ancestor of 1. ERROR: 9 is not found. ERROR: 12 and -3 are not found. ERROR: 0 is not found. ERROR: 99 and 99 are not found.","title":"Statement"},{"location":"PAT-Advanced-Level/1152-Google%20Recruitment/","text":"1152 Google Recruitment Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e e . The person who could find this prime number could go to the next step in Google's hiring process by visiting this website. The natural constant e e is a well known transcendental number\uff08\u8d85\u8d8a\u6570\uff09. The first several digits are: e e = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642 7427466391 932003059921\u2026 where the 10 digits in bold are the answer to Google's question. Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number. Input Specification Each input file contains one test case. Each case first gives in a line two positive integers: L ( \\le \\le 1,000) and K ( < < 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line. Output Specification For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number. Sample Input 1 20 5 23654987725541023819 Sample Output 1 49877 Sample Input 2 10 3 2468024680 Sample Output 2 404","title":"1152-Google Recruitment"},{"location":"PAT-Advanced-Level/1152-Google%20Recruitment/#1152-google-recruitment","text":"","title":"1152 Google Recruitment"},{"location":"PAT-Advanced-Level/1152-Google%20Recruitment/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e e . The person who could find this prime number could go to the next step in Google's hiring process by visiting this website. The natural constant e e is a well known transcendental number\uff08\u8d85\u8d8a\u6570\uff09. The first several digits are: e e = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642 7427466391 932003059921\u2026 where the 10 digits in bold are the answer to Google's question. Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number. Input Specification Each input file contains one test case. Each case first gives in a line two positive integers: L ( \\le \\le 1,000) and K ( < < 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line. Output Specification For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number. Sample Input 1 20 5 23654987725541023819 Sample Output 1 49877 Sample Input 2 10 3 2468024680 Sample Output 2 404","title":"Statement"},{"location":"PAT-Advanced-Level/1153-Decode%20Registration%20Card%20of%20PAT/","text":"1153 Decode Registration Card of PAT Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A registration card number of PAT consists of 4 parts: the 1 st letter represents the test level, namely, T for the top level, A for advance and B for basic; the 2 nd - 4 th digits are the test site number, ranged from 101 to 999; the 5 th - 10 th digits give the test date, in the form of yymmdd ; finally the 11 th - 13 th digits are the testee's number, ranged from 000 to 999. Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( \\le 10^4 \\le 10^4 ) and M M ( \\le 100 \\le 100 ), the numbers of cards and the queries, respectively. Then N N lines follow, each gives a card number and the owner's score (integer in [0, 100] [0, 100] ), separated by a space. After the info of testees, there are M M lines, each gives a query in the format Type Term , where Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level; Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number; Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card. Output Specification For each query, first print in a line Case #: input , where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested: for a type 1 query, the output format is the same as in input, that is, CardNumber Score . If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed); for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score; for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site . The output must be in non-increasing order of Nt 's, or in increasing order of site numbers if there is a tie of Nt . If the result of a query is empty, simply print NA . Sample Input 8 4 B123180908127 99 B102180908003 86 A112180318002 98 T107150310127 62 A107180908108 100 T123180908010 78 B112160918035 88 A107180908021 98 1 A 2 107 3 180908 2 999 Sample Output Case 1: 1 A A107180908108 100 A107180908021 98 A112180318002 98 Case 2: 2 107 3 260 Case 3: 3 180908 107 2 123 2 102 1 Case 4: 2 999 NA","title":"1153-Decode Registration Card of PAT"},{"location":"PAT-Advanced-Level/1153-Decode%20Registration%20Card%20of%20PAT/#1153-decode-registration-card-of-pat","text":"","title":"1153 Decode Registration Card of PAT"},{"location":"PAT-Advanced-Level/1153-Decode%20Registration%20Card%20of%20PAT/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB A registration card number of PAT consists of 4 parts: the 1 st letter represents the test level, namely, T for the top level, A for advance and B for basic; the 2 nd - 4 th digits are the test site number, ranged from 101 to 999; the 5 th - 10 th digits give the test date, in the form of yymmdd ; finally the 11 th - 13 th digits are the testee's number, ranged from 000 to 999. Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( \\le 10^4 \\le 10^4 ) and M M ( \\le 100 \\le 100 ), the numbers of cards and the queries, respectively. Then N N lines follow, each gives a card number and the owner's score (integer in [0, 100] [0, 100] ), separated by a space. After the info of testees, there are M M lines, each gives a query in the format Type Term , where Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level; Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number; Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card. Output Specification For each query, first print in a line Case #: input , where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested: for a type 1 query, the output format is the same as in input, that is, CardNumber Score . If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed); for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score; for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site . The output must be in non-increasing order of Nt 's, or in increasing order of site numbers if there is a tie of Nt . If the result of a query is empty, simply print NA . Sample Input 8 4 B123180908127 99 B102180908003 86 A112180318002 98 T107150310127 62 A107180908108 100 T123180908010 78 B112160918035 88 A107180908021 98 1 A 2 107 3 180908 2 999 Sample Output Case 1: 1 A A107180908108 100 A107180908021 98 A112180318002 98 Case 2: 2 107 3 260 Case 3: 3 180908 107 2 123 2 102 1 Case 4: 2 999 NA","title":"Statement"},{"location":"PAT-Advanced-Level/1154-Vertex%20Coloring/","text":"1154 Vertex Coloring Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 900 ms \u5185\u5b58\u9650\u5236: 64 MB A proper vertex coloring is a labeling of the graph's vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k k colors is called a (proper) k k -coloring . Now you are supposed to tell if a given coloring is a proper k k -coloring. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of vertices and edges, respectively. Then M M lines follow, each describes an edge by giving the indices (from 0 to N-1 N-1 ) of the two ends of the edge. After the graph, a positive integer K K ( \\le \\le 100) is given, which is the number of colorings you are supposed to check. Then K K lines follow, each contains N N colors which are represented by non-negative integers in the range of int . The i i -th color is the color of the i i -th vertex. Output Specification For each coloring, print in a line k-coloring if it is a proper k -coloring for some positive k , or No if not. Sample Input 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 0 2 4 4 0 1 0 1 4 1 0 1 3 0 0 1 0 1 4 1 0 1 0 0 8 1 0 1 4 1 0 5 3 0 1 2 3 4 5 6 7 8 8 9 Sample Output 4-coloring No 6-coloring No","title":"1154-Vertex Coloring"},{"location":"PAT-Advanced-Level/1154-Vertex%20Coloring/#1154-vertex-coloring","text":"","title":"1154 Vertex Coloring"},{"location":"PAT-Advanced-Level/1154-Vertex%20Coloring/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 900 ms \u5185\u5b58\u9650\u5236: 64 MB A proper vertex coloring is a labeling of the graph's vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k k colors is called a (proper) k k -coloring . Now you are supposed to tell if a given coloring is a proper k k -coloring. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of vertices and edges, respectively. Then M M lines follow, each describes an edge by giving the indices (from 0 to N-1 N-1 ) of the two ends of the edge. After the graph, a positive integer K K ( \\le \\le 100) is given, which is the number of colorings you are supposed to check. Then K K lines follow, each contains N N colors which are represented by non-negative integers in the range of int . The i i -th color is the color of the i i -th vertex. Output Specification For each coloring, print in a line k-coloring if it is a proper k -coloring for some positive k , or No if not. Sample Input 10 11 8 7 6 8 4 5 8 4 8 1 1 2 1 4 9 8 9 1 1 0 2 4 4 0 1 0 1 4 1 0 1 3 0 0 1 0 1 4 1 0 1 0 0 8 1 0 1 4 1 0 5 3 0 1 2 3 4 5 6 7 8 8 9 Sample Output 4-coloring No 6-coloring No","title":"Statement"},{"location":"PAT-Advanced-Level/1155-Heap%20Paths/","text":"1155 Heap Paths Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure )) One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order. Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 1 < N \\le 1,000 1 < N \\le 1,000 ), the number of keys in the tree. Then the next line contains N N distinct integer keys (all in the range of int ), which gives the level order traversal sequence of a complete binary tree. Output Specification For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree. Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Sample Input 1 8 98 72 86 60 65 12 23 50 Sample Output 1 98 86 23 98 86 12 98 72 65 98 72 60 50 Max Heap Sample Input 2 8 8 38 25 58 52 82 70 60 Sample Output 2 8 25 70 8 25 82 8 38 52 8 38 58 60 Min Heap Sample Input 3 8 10 28 15 12 34 9 8 56 Sample Output 3 10 15 8 10 15 9 10 28 34 10 28 12 56 Not Heap Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ], rt ; vector < vector < int >> G ; vector < int > vec ; void print ( vector < int > & vec ) { for ( int i = 0 , sze = vec . size (); i < sze ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == sze - 1 ]); } void dfs ( int u ) { if ( u > n ) { return ; } vec . push_back ( a [ u ]); if ( u * 2 > n ) { print ( vec ); } dfs ( u << 1 | 1 ); dfs ( u << 1 ); vec . pop_back (); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { G . clear (); G . resize ( n + 1 ); int l = 0 , g = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( i > 1 ) { if ( a [ i ] > a [ i / 2 ]) ++ l ; else ++ g ; } } vec . clear (); dfs ( 1 ); if ( l && g ) puts ( \"Not Heap\" ); else if ( l ) puts ( \"Min Heap\" ); else puts ( \"Max Heap\" ); } return 0 ; }","title":"1155-Heap Paths"},{"location":"PAT-Advanced-Level/1155-Heap%20Paths/#1155-heap-paths","text":"","title":"1155 Heap Paths"},{"location":"PAT-Advanced-Level/1155-Heap%20Paths/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure )) One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order. Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( 1 < N \\le 1,000 1 < N \\le 1,000 ), the number of keys in the tree. Then the next line contains N N distinct integer keys (all in the range of int ), which gives the level order traversal sequence of a complete binary tree. Output Specification For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree. Finally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Sample Input 1 8 98 72 86 60 65 12 23 50 Sample Output 1 98 86 23 98 86 12 98 72 65 98 72 60 50 Max Heap Sample Input 2 8 8 38 25 58 52 82 70 60 Sample Output 2 8 25 70 8 25 82 8 38 52 8 38 58 60 Min Heap Sample Input 3 8 10 28 15 12 34 9 8 56 Sample Output 3 10 15 8 10 15 9 10 28 34 10 28 12 56 Not Heap","title":"Statement"},{"location":"PAT-Advanced-Level/1155-Heap%20Paths/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ], rt ; vector < vector < int >> G ; vector < int > vec ; void print ( vector < int > & vec ) { for ( int i = 0 , sze = vec . size (); i < sze ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == sze - 1 ]); } void dfs ( int u ) { if ( u > n ) { return ; } vec . push_back ( a [ u ]); if ( u * 2 > n ) { print ( vec ); } dfs ( u << 1 | 1 ); dfs ( u << 1 ); vec . pop_back (); } int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { G . clear (); G . resize ( n + 1 ); int l = 0 , g = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( i > 1 ) { if ( a [ i ] > a [ i / 2 ]) ++ l ; else ++ g ; } } vec . clear (); dfs ( 1 ); if ( l && g ) puts ( \"Not Heap\" ); else if ( l ) puts ( \"Min Heap\" ); else puts ( \"Max Heap\" ); } return 0 ; }","title":"Solution"},{"location":"PAT-Advanced-Level/1156-Sexy%20Primes/","text":"1156 Sexy Primes Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Sexy primes are pairs of primes of the form ( p p , p+6 p+6 ), so-named since \"sex\" is the Latin word for \"six\". (Quoted from http://mathworld.wolfram.com/SexyPrimes.html ) Now given an integer, you are supposed to tell if it is a sexy prime. Input Specification Each input file contains one test case. Each case gives a positive integer N N ( \\le 10^8 \\le 10^8 ). Output Specification For each case, print in a line Yes if N N is a sexy prime, then print in the next line the other sexy prime paired with N N (if the answer is not unique, output the smaller number). Or if N N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N N . Sample Input 1 47 Sample Output 1 Yes 41 Sample Input 2 21 Sample Output 2 No 23","title":"1156-Sexy Primes"},{"location":"PAT-Advanced-Level/1156-Sexy%20Primes/#1156-sexy-primes","text":"","title":"1156 Sexy Primes"},{"location":"PAT-Advanced-Level/1156-Sexy%20Primes/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Sexy primes are pairs of primes of the form ( p p , p+6 p+6 ), so-named since \"sex\" is the Latin word for \"six\". (Quoted from http://mathworld.wolfram.com/SexyPrimes.html ) Now given an integer, you are supposed to tell if it is a sexy prime. Input Specification Each input file contains one test case. Each case gives a positive integer N N ( \\le 10^8 \\le 10^8 ). Output Specification For each case, print in a line Yes if N N is a sexy prime, then print in the next line the other sexy prime paired with N N (if the answer is not unique, output the smaller number). Or if N N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N N . Sample Input 1 47 Sample Output 1 Yes 41 Sample Input 2 21 Sample Output 2 No 23","title":"Statement"},{"location":"PAT-Advanced-Level/1157-Anniversary/","text":"1157 Anniversary Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association \uff08\u6821\u53cb\u4f1a\uff09 has gathered the ID's of all her alumni. Now your job is to write a program to count the number of alumni among all the people who come to the celebration. Input Specification Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X . It is guaranteed that all the ID's are distinct. The next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer M M ( \\le 10^5 \\le 10^5 ). Then M M lines follow, each contains an ID number of a guest. It is guaranteed that all the ID's are distinct. Output Specification First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus \u2013 notice that the 7 th - 14 th digits of the ID gives one's birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique. Sample Input 5 372928196906118710 610481197806202213 440684198612150417 13072819571002001X 150702193604190912 6 530125197901260019 150702193604190912 220221196701020034 610481197806202213 440684198612150417 370205198709275042 Sample Output 3 150702193604190912","title":"1157-Anniversary"},{"location":"PAT-Advanced-Level/1157-Anniversary/#1157-anniversary","text":"","title":"1157 Anniversary"},{"location":"PAT-Advanced-Level/1157-Anniversary/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association \uff08\u6821\u53cb\u4f1a\uff09 has gathered the ID's of all her alumni. Now your job is to write a program to count the number of alumni among all the people who come to the celebration. Input Specification Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X . It is guaranteed that all the ID's are distinct. The next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer M M ( \\le 10^5 \\le 10^5 ). Then M M lines follow, each contains an ID number of a guest. It is guaranteed that all the ID's are distinct. Output Specification First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus \u2013 notice that the 7 th - 14 th digits of the ID gives one's birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique. Sample Input 5 372928196906118710 610481197806202213 440684198612150417 13072819571002001X 150702193604190912 6 530125197901260019 150702193604190912 220221196701020034 610481197806202213 440684198612150417 370205198709275042 Sample Output 3 150702193604190912","title":"Statement"},{"location":"PAT-Advanced-Level/1158-Telefraud%20Detection/","text":"1158 Telefraud Detection Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Telefraud\uff08\u7535\u4fe1\u8bc8\u9a97\uff09 remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records. A person must be detected as a suspect if he/she makes more than K K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A A makes a short phone call to B B means that the total duration of the calls from A A to B B is no more than 5 minutes. Input Specification Each input file contains one test case. For each case, the first line gives 3 positive integers K K ( \\le 500 \\le 500 , the threshold\uff08\u9608\u503c\uff09 of the amount of short phone calls), N N ( \\le 10^3 \\le 10^3 , the number of different phone numbers), and M M ( \\le 10^5 \\le 10^5 , the number of phone call records). Then M M lines of one day's records are given, each in the format: caller receiver duration where caller and receiver are numbered from 1 to N N , and duration is no more than 1440 minutes in a day. Output Specification Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line. If no one is detected, output None instead. Sample Input 1 5 15 31 1 4 2 1 5 2 1 5 4 1 7 5 1 8 3 1 9 1 1 6 5 1 15 2 1 15 5 3 2 2 3 5 15 3 13 1 3 12 1 3 14 1 3 10 2 3 11 5 5 2 1 5 3 10 5 1 1 5 7 2 5 6 1 5 13 4 5 15 1 11 10 5 12 14 1 6 1 1 6 9 2 6 10 5 6 11 2 6 12 1 6 13 1 Sample Output 1 3 5 6 Note: In sample 1, although 1 had 9 records, but there were 7 distinct receivers, among which 5 and 15 both had conversations lasted more than 5 minutes in total. Hence 1 had made 5 short phone calls and didn't exceed the threshold 5, and therefore is not a suspect. Sample Input 2 5 7 8 1 2 1 1 3 1 1 4 1 1 5 1 1 6 1 1 7 1 2 1 1 3 1 1 Sample Output 2 None","title":"1158-Telefraud Detection"},{"location":"PAT-Advanced-Level/1158-Telefraud%20Detection/#1158-telefraud-detection","text":"","title":"1158 Telefraud Detection"},{"location":"PAT-Advanced-Level/1158-Telefraud%20Detection/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Telefraud\uff08\u7535\u4fe1\u8bc8\u9a97\uff09 remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records. A person must be detected as a suspect if he/she makes more than K K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A A makes a short phone call to B B means that the total duration of the calls from A A to B B is no more than 5 minutes. Input Specification Each input file contains one test case. For each case, the first line gives 3 positive integers K K ( \\le 500 \\le 500 , the threshold\uff08\u9608\u503c\uff09 of the amount of short phone calls), N N ( \\le 10^3 \\le 10^3 , the number of different phone numbers), and M M ( \\le 10^5 \\le 10^5 , the number of phone call records). Then M M lines of one day's records are given, each in the format: caller receiver duration where caller and receiver are numbered from 1 to N N , and duration is no more than 1440 minutes in a day. Output Specification Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line. If no one is detected, output None instead. Sample Input 1 5 15 31 1 4 2 1 5 2 1 5 4 1 7 5 1 8 3 1 9 1 1 6 5 1 15 2 1 15 5 3 2 2 3 5 15 3 13 1 3 12 1 3 14 1 3 10 2 3 11 5 5 2 1 5 3 10 5 1 1 5 7 2 5 6 1 5 13 4 5 15 1 11 10 5 12 14 1 6 1 1 6 9 2 6 10 5 6 11 2 6 12 1 6 13 1 Sample Output 1 3 5 6 Note: In sample 1, although 1 had 9 records, but there were 7 distinct receivers, among which 5 and 15 both had conversations lasted more than 5 minutes in total. Hence 1 had made 5 short phone calls and didn't exceed the threshold 5, and therefore is not a suspect. Sample Input 2 5 7 8 1 2 1 1 3 1 1 4 1 1 5 1 1 6 1 1 7 1 2 1 1 3 1 1 Sample Output 2 None","title":"Statement"},{"location":"PAT-Advanced-Level/1159-Structure%20of%20a%20Binary%20Tree/","text":"1159 Structure of a Binary Tree Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined. Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following: A is the root A and B are siblings A is the parent of B A is the left child of B A is the right child of B A and B are on the same level It is a full tree Note: Two nodes are on the same level , means that they have the same depth. A full binary tree is a tree in which every node other than the leaves has two children. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 30 \\le 30 ), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 10^3 10^3 and are separated by a space. Then another positive integer M M ( \\le 30 \\le 30 ) is given, followed by M M lines of statements. It is guaranteed that both A and B in the statements are in the tree. Output Specification For each statement, print in a line Yes if it is correct, or No if not. Sample Input 9 16 7 11 32 28 2 23 8 15 16 23 7 32 11 2 28 15 8 7 15 is the root 8 and 2 are siblings 32 is the parent of 11 23 is the left child of 16 28 is the right child of 2 7 and 11 are on the same level It is a full tree Sample Output Yes No Yes No Yes Yes Yes","title":"1159-Structure of a Binary Tree"},{"location":"PAT-Advanced-Level/1159-Structure%20of%20a%20Binary%20Tree/#1159-structure-of-a-binary-tree","text":"","title":"1159 Structure of a Binary Tree"},{"location":"PAT-Advanced-Level/1159-Structure%20of%20a%20Binary%20Tree/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined. Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following: A is the root A and B are siblings A is the parent of B A is the left child of B A is the right child of B A and B are on the same level It is a full tree Note: Two nodes are on the same level , means that they have the same depth. A full binary tree is a tree in which every node other than the leaves has two children. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 30 \\le 30 ), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 10^3 10^3 and are separated by a space. Then another positive integer M M ( \\le 30 \\le 30 ) is given, followed by M M lines of statements. It is guaranteed that both A and B in the statements are in the tree. Output Specification For each statement, print in a line Yes if it is correct, or No if not. Sample Input 9 16 7 11 32 28 2 23 8 15 16 23 7 32 11 2 28 15 8 7 15 is the root 8 and 2 are siblings 32 is the parent of 11 23 is the left child of 16 28 is the right child of 2 7 and 11 are on the same level It is a full tree Sample Output Yes No Yes No Yes Yes Yes","title":"Statement"},{"location":"PAT-Advanced-Level/1160-Forever/","text":"1160 Forever Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB \"Forever number\" is a positive integer A A with K K digits, satisfying the following constrains: the sum of all the digits of A A is m m ; the sum of all the digits of A+1 A+1 is n n ; and the greatest common divisor of m m and n n is a prime number which is greater than 2. Now you are supposed to find these forever numbers. Input Specification Each input file contains one test case. For each test case, the first line contains a positive integer N N ( \\le 5 \\le 5 ). Then N N lines follow, each gives a pair of K K ( 3<K<10 3<K<10 ) and m m ( 1<m<90 1<m<90 ), of which the meanings are given in the problem description. Output Specification For each pair of K K and m m , first print in a line Case X , where X is the case index (starts from 1). Then print n n and A A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n n . If still not unique, output in the ascending order of A A . If there is no solution, output No Solution . Sample Input 2 6 45 7 80 Sample Output Case 1 10 189999 10 279999 10 369999 10 459999 10 549999 10 639999 10 729999 10 819999 10 909999 Case 2 No Solution","title":"1160-Forever"},{"location":"PAT-Advanced-Level/1160-Forever/#1160-forever","text":"","title":"1160 Forever"},{"location":"PAT-Advanced-Level/1160-Forever/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB \"Forever number\" is a positive integer A A with K K digits, satisfying the following constrains: the sum of all the digits of A A is m m ; the sum of all the digits of A+1 A+1 is n n ; and the greatest common divisor of m m and n n is a prime number which is greater than 2. Now you are supposed to find these forever numbers. Input Specification Each input file contains one test case. For each test case, the first line contains a positive integer N N ( \\le 5 \\le 5 ). Then N N lines follow, each gives a pair of K K ( 3<K<10 3<K<10 ) and m m ( 1<m<90 1<m<90 ), of which the meanings are given in the problem description. Output Specification For each pair of K K and m m , first print in a line Case X , where X is the case index (starts from 1). Then print n n and A A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n n . If still not unique, output in the ascending order of A A . If there is no solution, output No Solution . Sample Input 2 6 45 7 80 Sample Output Case 1 10 189999 10 279999 10 369999 10 459999 10 549999 10 639999 10 729999 10 819999 10 909999 Case 2 No Solution","title":"Statement"},{"location":"PAT-Advanced-Level/1161-Merging%20Linked%20Lists/","text":"1161 Merging Linked Lists Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given two singly linked lists L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n and L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m . If n\\ge 2m n\\ge 2m , you are supposed to reverse and merge the shorter one into the longer one to obtain a list like $a_1 to a_2 to b_{m} to a_3 to a_4 to b_{m-1}cdots $. For example, given one list being 6\u21927 and the other one 1\u21922\u21923\u21924\u21925, you must output 1\u21922\u21927\u21923\u21924\u21926\u21925. Input Specification Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L_1 L_1 and L_2 L_2 , plus a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is a positive integer no more than 10^5 10^5 , and Next is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one. Output Specification For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 01000 7 02233 2 34891 00100 6 00001 34891 3 10086 01000 1 02233 00033 5 -1 10086 4 00033 00001 7 -1 Sample Output 01000 1 02233 02233 2 00001 00001 7 34891 34891 3 10086 10086 4 00100 00100 6 00033 00033 5 -1","title":"1161-Merging Linked Lists"},{"location":"PAT-Advanced-Level/1161-Merging%20Linked%20Lists/#1161-merging-linked-lists","text":"","title":"1161 Merging Linked Lists"},{"location":"PAT-Advanced-Level/1161-Merging%20Linked%20Lists/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given two singly linked lists L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n and L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m . If n\\ge 2m n\\ge 2m , you are supposed to reverse and merge the shorter one into the longer one to obtain a list like $a_1 to a_2 to b_{m} to a_3 to a_4 to b_{m-1}cdots $. For example, given one list being 6\u21927 and the other one 1\u21922\u21923\u21924\u21925, you must output 1\u21922\u21927\u21923\u21924\u21926\u21925. Input Specification Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L_1 L_1 and L_2 L_2 , plus a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is a positive integer no more than 10^5 10^5 , and Next is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one. Output Specification For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 01000 7 02233 2 34891 00100 6 00001 34891 3 10086 01000 1 02233 00033 5 -1 10086 4 00033 00001 7 -1 Sample Output 01000 1 02233 02233 2 00001 00001 7 34891 34891 3 10086 10086 4 00100 00100 6 00033 00033 5 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1162-Postfix%20Expression/","text":"1162 Postfix Expression Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i i -th line corresponds to the i i -th node) in the format: data left_child right_child where data is a string of no more than 10 characters, left_child and right_child are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by -1 -1 . The figures 1 and 2 correspond to the samples 1 and 2, respectively. Figure 1 Figure 2 Output Specification For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols. Sample Input 1 8 * 8 7 a -1 -1 * 4 1 + 2 5 b -1 -1 d -1 -1 - -1 6 c -1 -1 Sample Output 1 (((a)(b)+)((c)(-(d))*)*) Sample Input 2 8 2.35 -1 -1 * 6 1 - -1 4 % 7 8 + 2 3 a -1 -1 str -1 -1 871 -1 -1 Sample Output 2 (((a)(2.35)*)(-((str)(871)%))+)","title":"1162-Postfix Expression"},{"location":"PAT-Advanced-Level/1162-Postfix%20Expression/#1162-postfix-expression","text":"","title":"1162 Postfix Expression"},{"location":"PAT-Advanced-Level/1162-Postfix%20Expression/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N ( \\le \\le 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i i -th line corresponds to the i i -th node) in the format: data left_child right_child where data is a string of no more than 10 characters, left_child and right_child are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by -1 -1 . The figures 1 and 2 correspond to the samples 1 and 2, respectively. Figure 1 Figure 2 Output Specification For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols. Sample Input 1 8 * 8 7 a -1 -1 * 4 1 + 2 5 b -1 -1 d -1 -1 - -1 6 c -1 -1 Sample Output 1 (((a)(b)+)((c)(-(d))*)*) Sample Input 2 8 2.35 -1 -1 * 6 1 - -1 4 % 7 8 + 2 3 a -1 -1 str -1 -1 871 -1 -1 Sample Output 2 (((a)(2.35)*)(-((str)(871)%))+)","title":"Statement"},{"location":"PAT-Advanced-Level/1163-Dijkstra%20Sequence/","text":"1163 Dijkstra Sequence Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it Dijkstra sequence , is generated by Dijkstra's algorithm. On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers N_v N_v ( \\le 10^3 \\le 10^3 ) and N_e N_e ( \\le 10^5 \\le 10^5 ), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to N_v N_v . Then N_e N_e lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight ( \\le 100 \\le 100 ) of the edge. It is guaranteed that the given graph is connected. Finally the number of queries, K K , is given as a positive integer no larger than 100 100 , followed by K K lines of sequences, each contains a permutationof the N_v N_v vertices. It is assumed that the first vertex is the source for each sequence. All the inputs in a line are separated by a space. Output Specification For each of the K K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not. Sample Input 5 7 1 2 2 1 5 1 2 3 1 2 4 1 2 5 2 3 5 1 3 4 1 4 5 1 3 4 2 5 3 1 2 4 2 3 4 5 1 3 2 1 5 4 Sample Output Yes Yes Yes No","title":"1163-Dijkstra Sequence"},{"location":"PAT-Advanced-Level/1163-Dijkstra%20Sequence/#1163-dijkstra-sequence","text":"","title":"1163 Dijkstra Sequence"},{"location":"PAT-Advanced-Level/1163-Dijkstra%20Sequence/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it Dijkstra sequence , is generated by Dijkstra's algorithm. On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers N_v N_v ( \\le 10^3 \\le 10^3 ) and N_e N_e ( \\le 10^5 \\le 10^5 ), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to N_v N_v . Then N_e N_e lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight ( \\le 100 \\le 100 ) of the edge. It is guaranteed that the given graph is connected. Finally the number of queries, K K , is given as a positive integer no larger than 100 100 , followed by K K lines of sequences, each contains a permutationof the N_v N_v vertices. It is assumed that the first vertex is the source for each sequence. All the inputs in a line are separated by a space. Output Specification For each of the K K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not. Sample Input 5 7 1 2 2 1 5 1 2 3 1 2 4 1 2 5 2 3 5 1 3 4 1 4 5 1 3 4 2 5 3 1 2 4 2 3 4 5 1 3 2 1 5 4 Sample Output Yes Yes Yes No","title":"Statement"},{"location":"PAT-Advanced-Level/1164-Good%20in%20C/","text":"1164 Good in C Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB When your interviewer asks you to write \"Hello World\" using C, can you do as the following figure shows? Input Specification Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7\\times 5 7\\times 5 matrix of C 's and . 's. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters. It is guaranteed that there is at least one word given. Output Specification For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word. Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output. Sample Input ..C.. .C.C. C...C CCCCC C...C C...C C...C CCCC. C...C C...C CCCC. C...C C...C CCCC. .CCC. C...C C.... C.... C.... C...C .CCC. CCCC. C...C C...C C...C C...C C...C CCCC. CCCCC C.... C.... CCCC. C.... C.... CCCCC CCCCC C.... C.... CCCC. C.... C.... C.... CCCC. C...C C.... C.CCC C...C C...C CCCC. C...C C...C C...C CCCCC C...C C...C C...C CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. CCCCC CCCCC ....C ....C ....C ....C C...C .CCC. C...C C..C. C.C.. CC... C.C.. C..C. C...C C.... C.... C.... C.... C.... C.... CCCCC C...C C...C CC.CC C.C.C C...C C...C C...C C...C C...C CC..C C.C.C C..CC C...C C...C .CCC. C...C C...C C...C C...C C...C .CCC. CCCC. C...C C...C CCCC. C.... C.... C.... .CCC. C...C C...C C...C C.C.C C..CC .CCC. CCCC. C...C CCCC. CC... C.C.. C..C. C...C .CCC. C...C C.... .CCC. ....C C...C .CCC. CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. ..C.. C...C C...C C...C C...C C...C C...C .CCC. C...C C...C C...C C...C C...C .C.C. ..C.. C...C C...C C...C C.C.C CC.CC C...C C...C C...C C...C .C.C. ..C.. .C.C. C...C C...C C...C C...C .C.C. ..C.. ..C.. ..C.. ..C.. CCCCC ....C ...C. ..C.. .C... C.... CCCCC HELLO~WORLD! Sample Output C...C CCCCC C.... C.... .CCC. C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C CCCCC CCCC. C.... C.... C...C C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C C...C CCCCC CCCCC CCCCC .CCC. C...C .CCC. CCCC. C.... CCCC. C...C C...C C...C C.... C...C C...C C...C CCCC. C.... C...C C.C.C C...C CC... C.... C...C CC.CC C...C C.C.. C.... C...C C...C C...C C..C. C.... C...C C...C .CCC. C...C CCCCC CCCC.","title":"1164-Good in C"},{"location":"PAT-Advanced-Level/1164-Good%20in%20C/#1164-good-in-c","text":"","title":"1164 Good in C"},{"location":"PAT-Advanced-Level/1164-Good%20in%20C/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB When your interviewer asks you to write \"Hello World\" using C, can you do as the following figure shows? Input Specification Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7\\times 5 7\\times 5 matrix of C 's and . 's. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters. It is guaranteed that there is at least one word given. Output Specification For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word. Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output. Sample Input ..C.. .C.C. C...C CCCCC C...C C...C C...C CCCC. C...C C...C CCCC. C...C C...C CCCC. .CCC. C...C C.... C.... C.... C...C .CCC. CCCC. C...C C...C C...C C...C C...C CCCC. CCCCC C.... C.... CCCC. C.... C.... CCCCC CCCCC C.... C.... CCCC. C.... C.... C.... CCCC. C...C C.... C.CCC C...C C...C CCCC. C...C C...C C...C CCCCC C...C C...C C...C CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. CCCCC CCCCC ....C ....C ....C ....C C...C .CCC. C...C C..C. C.C.. CC... C.C.. C..C. C...C C.... C.... C.... C.... C.... C.... CCCCC C...C C...C CC.CC C.C.C C...C C...C C...C C...C C...C CC..C C.C.C C..CC C...C C...C .CCC. C...C C...C C...C C...C C...C .CCC. CCCC. C...C C...C CCCC. C.... C.... C.... .CCC. C...C C...C C...C C.C.C C..CC .CCC. CCCC. C...C CCCC. CC... C.C.. C..C. C...C .CCC. C...C C.... .CCC. ....C C...C .CCC. CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. ..C.. C...C C...C C...C C...C C...C C...C .CCC. C...C C...C C...C C...C C...C .C.C. ..C.. C...C C...C C...C C.C.C CC.CC C...C C...C C...C C...C .C.C. ..C.. .C.C. C...C C...C C...C C...C .C.C. ..C.. ..C.. ..C.. ..C.. CCCCC ....C ...C. ..C.. .C... C.... CCCCC HELLO~WORLD! Sample Output C...C CCCCC C.... C.... .CCC. C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C CCCCC CCCC. C.... C.... C...C C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C C...C CCCCC CCCCC CCCCC .CCC. C...C .CCC. CCCC. C.... CCCC. C...C C...C C...C C.... C...C C...C C...C CCCC. C.... C...C C.C.C C...C CC... C.... C...C CC.CC C...C C.C.. C.... C...C C...C C...C C..C. C.... C...C C...C .CCC. C...C CCCCC CCCC.","title":"Statement"},{"location":"PAT-Advanced-Level/1165-Block%20Reversing/","text":"1165 Block Reversing Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list L L . Let us consider every K K nodes as a block (if there are less than K K nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in L L . For example, given L L as 1\u21922\u21923\u21924\u21925\u21926\u21927\u21928 and K K as 3, your output must be 7\u21928\u21924\u21925\u21926\u21921\u21922\u21923. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K K ( \\le N \\le N ) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 8 3 71120 7 88666 00000 4 99999 00100 1 12309 68237 6 71120 33218 3 00000 99999 5 68237 88666 8 -1 12309 2 33218 Sample Output 71120 7 88666 88666 8 00000 00000 4 99999 99999 5 68237 68237 6 00100 00100 1 12309 12309 2 33218 33218 3 -1","title":"1165-Block Reversing"},{"location":"PAT-Advanced-Level/1165-Block%20Reversing/#1165-block-reversing","text":"","title":"1165 Block Reversing"},{"location":"PAT-Advanced-Level/1165-Block%20Reversing/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a singly linked list L L . Let us consider every K K nodes as a block (if there are less than K K nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in L L . For example, given L L as 1\u21922\u21923\u21924\u21925\u21926\u21927\u21928 and K K as 3, your output must be 7\u21928\u21924\u21925\u21926\u21921\u21922\u21923. Input Specification Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N N ( \\le 10^5 \\le 10^5 ) which is the total number of nodes, and a positive K K ( \\le N \\le N ) which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1 -1 . Then N N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input 00100 8 3 71120 7 88666 00000 4 99999 00100 1 12309 68237 6 71120 33218 3 00000 99999 5 68237 88666 8 -1 12309 2 33218 Sample Output 71120 7 88666 88666 8 00000 00000 4 99999 99999 5 68237 68237 6 00100 00100 1 12309 12309 2 33218 33218 3 -1","title":"Statement"},{"location":"PAT-Advanced-Level/1166-Summit/","text":"1166 Summit Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A summit (\u5cf0\u4f1a) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone. Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N ( \\le \\le 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N. Then there is another positive integer K ( \\le \\le 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L ( \\le \\le N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space. Output Specification For each of the K areas, print in a line your advice in the following format: if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print Area X is OK. . if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print Area X may invite more people, such as H. where H is the smallest index of the head who may be invited. if in this area the arrangement is not an ideal one, then print Area X needs help. so the host can provide some special service to help the heads get to know each other. Here X is the index of an area, starting from 1 to K . Sample Input 8 10 5 6 7 8 6 4 3 6 4 5 2 3 8 2 2 7 5 3 3 4 6 4 5 4 3 6 3 2 8 7 2 2 3 1 1 2 4 6 3 3 2 1 Sample Output Area 1 is OK. Area 2 is OK. Area 3 is OK. Area 4 is OK. Area 5 may invite more people, such as 3. Area 6 needs help.","title":"1166-Summit"},{"location":"PAT-Advanced-Level/1166-Summit/#1166-summit","text":"","title":"1166 Summit"},{"location":"PAT-Advanced-Level/1166-Summit/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A summit (\u5cf0\u4f1a) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone. Now given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N ( \\le \\le 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N. Then there is another positive integer K ( \\le \\le 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L ( \\le \\le N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space. Output Specification For each of the K areas, print in a line your advice in the following format: if in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print Area X is OK. . if in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print Area X may invite more people, such as H. where H is the smallest index of the head who may be invited. if in this area the arrangement is not an ideal one, then print Area X needs help. so the host can provide some special service to help the heads get to know each other. Here X is the index of an area, starting from 1 to K . Sample Input 8 10 5 6 7 8 6 4 3 6 4 5 2 3 8 2 2 7 5 3 3 4 6 4 5 4 3 6 3 2 8 7 2 2 3 1 1 2 4 6 3 3 2 1 Sample Output Area 1 is OK. Area 2 is OK. Area 3 is OK. Area 4 is OK. Area 5 may invite more people, such as 3. Area 6 needs help.","title":"Statement"},{"location":"PAT-Advanced-Level/1167-Cartesian%20Tree/","text":"1167 Cartesian Tree Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Cartesian tree is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure. Your job is to output the level-order traversal sequence of the min-heap Cartesian tree. Input Specification Each input file contains one test case. Each case starts from giving a positive integer N N ( \\le 30 \\le 30 ), and then N N distinct numbers in the next line, separated by a space. All the numbers are in the range of int . Output Specification For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. Sample Input 10 8 15 3 4 1 5 12 10 18 6 Sample Output 1 3 5 8 4 6 15 10 12 18","title":"1167-Cartesian Tree"},{"location":"PAT-Advanced-Level/1167-Cartesian%20Tree/#1167-cartesian-tree","text":"","title":"1167 Cartesian Tree"},{"location":"PAT-Advanced-Level/1167-Cartesian%20Tree/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB A Cartesian tree is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure. Your job is to output the level-order traversal sequence of the min-heap Cartesian tree. Input Specification Each input file contains one test case. Each case starts from giving a positive integer N N ( \\le 30 \\le 30 ), and then N N distinct numbers in the next line, separated by a space. All the numbers are in the range of int . Output Specification For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. Sample Input 10 8 15 3 4 1 5 12 10 18 6 Sample Output 1 3 5 8 4 6 15 10 12 18","title":"Statement"},{"location":"PAT-Basic-Level/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84%283n%2B1%29%E7%8C%9C%E6%83%B3/","text":"1001 \u5bb3\u6b7b\u4eba\u4e0d\u507f\u547d\u7684(3n+1)\u731c\u60f3 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5361\u62c9\u5179(Callatz)\u731c\u60f3\uff1a \u5bf9\u4efb\u4f55\u4e00\u4e2a\u6b63\u6574\u6570 n n \uff0c\u5982\u679c\u5b83\u662f\u5076\u6570\uff0c\u90a3\u4e48\u628a\u5b83\u780d\u6389\u4e00\u534a\uff1b\u5982\u679c\u5b83\u662f\u5947\u6570\uff0c\u90a3\u4e48\u628a (3n+1) (3n+1) \u780d\u6389\u4e00\u534a\u3002\u8fd9\u6837\u4e00\u76f4\u53cd\u590d\u780d\u4e0b\u53bb\uff0c\u6700\u540e\u4e00\u5b9a\u5728\u67d0\u4e00\u6b65\u5f97\u5230 n=1 n=1 \u3002\u5361\u62c9\u5179\u5728 1950 \u5e74\u7684\u4e16\u754c\u6570\u5b66\u5bb6\u5927\u4f1a\u4e0a\u516c\u5e03\u4e86\u8fd9\u4e2a\u731c\u60f3\uff0c\u4f20\u8bf4\u5f53\u65f6\u8036\u9c81\u5927\u5b66\u5e08\u751f\u9f50\u52a8\u5458\uff0c\u62fc\u547d\u60f3\u8bc1\u660e\u8fd9\u4e2a\u8c8c\u4f3c\u5f88\u50bb\u5f88\u5929\u771f\u7684\u547d\u9898\uff0c\u7ed3\u679c\u95f9\u5f97\u5b66\u751f\u4eec\u65e0\u5fc3\u5b66\u4e1a\uff0c\u4e00\u5fc3\u53ea\u8bc1 (3n+1) (3n+1) \uff0c\u4ee5\u81f3\u4e8e\u6709\u4eba\u8bf4\u8fd9\u662f\u4e00\u4e2a\u9634\u8c0b\uff0c\u5361\u62c9\u5179\u662f\u5728\u84c4\u610f\u5ef6\u7f13\u7f8e\u56fd\u6570\u5b66\u754c\u6559\u5b66\u4e0e\u79d1\u7814\u7684\u8fdb\u5c55\u2026\u2026 \u6211\u4eec\u4eca\u5929\u7684\u9898\u76ee\u4e0d\u662f\u8bc1\u660e\u5361\u62c9\u5179\u731c\u60f3\uff0c\u800c\u662f\u5bf9\u7ed9\u5b9a\u7684\u4efb\u4e00\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 n n \uff0c\u7b80\u5355\u5730\u6570\u4e00\u4e0b\uff0c\u9700\u8981\u591a\u5c11\u6b65\uff08\u780d\u51e0\u4e0b\uff09\u624d\u80fd\u5f97\u5230 n=1 n=1 \uff1f \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u7ed9\u51fa\u6b63\u6574\u6570 n n \u7684\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4ece n n \u8ba1\u7b97\u5230 1 \u9700\u8981\u7684\u6b65\u6570\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 5 Solution C #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); int total = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) { n /= 2 ; } else { n = ( 3 * n + 1 ) / 2 ; } total ++ ; } printf ( \"%d \\n \" , total ); }","title":"1001-\u5bb3\u6b7b\u4eba\u4e0d\u507f\u547d\u7684(3n+1)\u731c\u60f3"},{"location":"PAT-Basic-Level/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84%283n%2B1%29%E7%8C%9C%E6%83%B3/#1001-\u5bb3\u6b7b\u4eba\u4e0d\u507f\u547d\u76843n1\u731c\u60f3","text":"","title":"1001 \u5bb3\u6b7b\u4eba\u4e0d\u507f\u547d\u7684(3n+1)\u731c\u60f3"},{"location":"PAT-Basic-Level/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84%283n%2B1%29%E7%8C%9C%E6%83%B3/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5361\u62c9\u5179(Callatz)\u731c\u60f3\uff1a \u5bf9\u4efb\u4f55\u4e00\u4e2a\u6b63\u6574\u6570 n n \uff0c\u5982\u679c\u5b83\u662f\u5076\u6570\uff0c\u90a3\u4e48\u628a\u5b83\u780d\u6389\u4e00\u534a\uff1b\u5982\u679c\u5b83\u662f\u5947\u6570\uff0c\u90a3\u4e48\u628a (3n+1) (3n+1) \u780d\u6389\u4e00\u534a\u3002\u8fd9\u6837\u4e00\u76f4\u53cd\u590d\u780d\u4e0b\u53bb\uff0c\u6700\u540e\u4e00\u5b9a\u5728\u67d0\u4e00\u6b65\u5f97\u5230 n=1 n=1 \u3002\u5361\u62c9\u5179\u5728 1950 \u5e74\u7684\u4e16\u754c\u6570\u5b66\u5bb6\u5927\u4f1a\u4e0a\u516c\u5e03\u4e86\u8fd9\u4e2a\u731c\u60f3\uff0c\u4f20\u8bf4\u5f53\u65f6\u8036\u9c81\u5927\u5b66\u5e08\u751f\u9f50\u52a8\u5458\uff0c\u62fc\u547d\u60f3\u8bc1\u660e\u8fd9\u4e2a\u8c8c\u4f3c\u5f88\u50bb\u5f88\u5929\u771f\u7684\u547d\u9898\uff0c\u7ed3\u679c\u95f9\u5f97\u5b66\u751f\u4eec\u65e0\u5fc3\u5b66\u4e1a\uff0c\u4e00\u5fc3\u53ea\u8bc1 (3n+1) (3n+1) \uff0c\u4ee5\u81f3\u4e8e\u6709\u4eba\u8bf4\u8fd9\u662f\u4e00\u4e2a\u9634\u8c0b\uff0c\u5361\u62c9\u5179\u662f\u5728\u84c4\u610f\u5ef6\u7f13\u7f8e\u56fd\u6570\u5b66\u754c\u6559\u5b66\u4e0e\u79d1\u7814\u7684\u8fdb\u5c55\u2026\u2026 \u6211\u4eec\u4eca\u5929\u7684\u9898\u76ee\u4e0d\u662f\u8bc1\u660e\u5361\u62c9\u5179\u731c\u60f3\uff0c\u800c\u662f\u5bf9\u7ed9\u5b9a\u7684\u4efb\u4e00\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 n n \uff0c\u7b80\u5355\u5730\u6570\u4e00\u4e0b\uff0c\u9700\u8981\u591a\u5c11\u6b65\uff08\u780d\u51e0\u4e0b\uff09\u624d\u80fd\u5f97\u5230 n=1 n=1 \uff1f \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u7ed9\u51fa\u6b63\u6574\u6570 n n \u7684\u503c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4ece n n \u8ba1\u7b97\u5230 1 \u9700\u8981\u7684\u6b65\u6570\u3002 \u8f93\u5165\u6837\u4f8b 3 \u8f93\u51fa\u6837\u4f8b 5","title":"Statement"},{"location":"PAT-Basic-Level/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84%283n%2B1%29%E7%8C%9C%E6%83%B3/#solution","text":"C #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); int total = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) { n /= 2 ; } else { n = ( 3 * n + 1 ) / 2 ; } total ++ ; } printf ( \"%d \\n \" , total ); }","title":"Solution"},{"location":"PAT-Basic-Level/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/","text":"1002 \u5199\u51fa\u8fd9\u4e2a\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bfb\u5165\u4e00\u4e2a\u6b63\u6574\u6570 n n \uff0c\u8ba1\u7b97\u5176\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\uff0c\u7528\u6c49\u8bed\u62fc\u97f3\u5199\u51fa\u548c\u7684\u6bcf\u4e00\u4f4d\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u7ed9\u51fa\u81ea\u7136\u6570 n n \u7684\u503c\u3002\u8fd9\u91cc\u4fdd\u8bc1 n n \u5c0f\u4e8e 10^{100} 10^{100} \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u5185\u8f93\u51fa n n \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u7684\u6bcf\u4e00\u4f4d\uff0c\u62fc\u97f3\u6570\u5b57\u95f4\u6709 1 \u7a7a\u683c\uff0c\u4f46\u4e00\u884c\u4e2d\u6700\u540e\u4e00\u4e2a\u62fc\u97f3\u6570\u5b57\u540e\u6ca1\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 1234567890987654321123456789 \u8f93\u51fa\u6837\u4f8b yi san wu Solution C #include <stdio.h> #include <string.h> int main () { char n [ 1001 ]; gets ( n ); int i , j ; int total = 0 ; for ( i = 0 ; i < strlen ( n ); i ++ ) { total += n [ i ] - '0' ; } int flag ; int ave ; int count = 0 ; for ( i = 10 ;; i *= 10 ) { if ( total < i ) { flag = i / 10 ; break ; } count ++ ; } for ( i = 0 , j = flag ; i <= count ; i ++ , j /= 10 ) { ave = ( total / j ) % 10 ; if ( i ) { if ( ave == 0 ) printf ( \" ling\" ); else if ( ave == 1 ) printf ( \" yi\" ); else if ( ave == 2 ) printf ( \" er\" ); else if ( ave == 3 ) printf ( \" san\" ); else if ( ave == 4 ) printf ( \" si\" ); else if ( ave == 5 ) printf ( \" wu\" ); else if ( ave == 6 ) printf ( \" liu\" ); else if ( ave == 7 ) printf ( \" qi\" ); else if ( ave == 8 ) printf ( \" ba\" ); else if ( ave == 9 ) printf ( \" jiu\" ); } else { if ( ave == 0 ) printf ( \" ling\" ); else if ( ave == 1 ) printf ( \"yi\" ); else if ( ave == 2 ) printf ( \"er\" ); else if ( ave == 3 ) printf ( \"san\" ); else if ( ave == 4 ) printf ( \"si\" ); else if ( ave == 5 ) printf ( \"wu\" ); else if ( ave == 6 ) printf ( \"liu\" ); else if ( ave == 7 ) printf ( \"qi\" ); else if ( ave == 8 ) printf ( \"ba\" ); else if ( ave == 9 ) printf ( \"jiu\" ); } } printf ( \" \\n \" ); }","title":"1002-\u5199\u51fa\u8fd9\u4e2a\u6570"},{"location":"PAT-Basic-Level/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/#1002-\u5199\u51fa\u8fd9\u4e2a\u6570","text":"","title":"1002 \u5199\u51fa\u8fd9\u4e2a\u6570"},{"location":"PAT-Basic-Level/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bfb\u5165\u4e00\u4e2a\u6b63\u6574\u6570 n n \uff0c\u8ba1\u7b97\u5176\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\uff0c\u7528\u6c49\u8bed\u62fc\u97f3\u5199\u51fa\u548c\u7684\u6bcf\u4e00\u4f4d\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u7ed9\u51fa\u81ea\u7136\u6570 n n \u7684\u503c\u3002\u8fd9\u91cc\u4fdd\u8bc1 n n \u5c0f\u4e8e 10^{100} 10^{100} \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u5185\u8f93\u51fa n n \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u7684\u6bcf\u4e00\u4f4d\uff0c\u62fc\u97f3\u6570\u5b57\u95f4\u6709 1 \u7a7a\u683c\uff0c\u4f46\u4e00\u884c\u4e2d\u6700\u540e\u4e00\u4e2a\u62fc\u97f3\u6570\u5b57\u540e\u6ca1\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 1234567890987654321123456789 \u8f93\u51fa\u6837\u4f8b yi san wu","title":"Statement"},{"location":"PAT-Basic-Level/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/#solution","text":"C #include <stdio.h> #include <string.h> int main () { char n [ 1001 ]; gets ( n ); int i , j ; int total = 0 ; for ( i = 0 ; i < strlen ( n ); i ++ ) { total += n [ i ] - '0' ; } int flag ; int ave ; int count = 0 ; for ( i = 10 ;; i *= 10 ) { if ( total < i ) { flag = i / 10 ; break ; } count ++ ; } for ( i = 0 , j = flag ; i <= count ; i ++ , j /= 10 ) { ave = ( total / j ) % 10 ; if ( i ) { if ( ave == 0 ) printf ( \" ling\" ); else if ( ave == 1 ) printf ( \" yi\" ); else if ( ave == 2 ) printf ( \" er\" ); else if ( ave == 3 ) printf ( \" san\" ); else if ( ave == 4 ) printf ( \" si\" ); else if ( ave == 5 ) printf ( \" wu\" ); else if ( ave == 6 ) printf ( \" liu\" ); else if ( ave == 7 ) printf ( \" qi\" ); else if ( ave == 8 ) printf ( \" ba\" ); else if ( ave == 9 ) printf ( \" jiu\" ); } else { if ( ave == 0 ) printf ( \" ling\" ); else if ( ave == 1 ) printf ( \"yi\" ); else if ( ave == 2 ) printf ( \"er\" ); else if ( ave == 3 ) printf ( \"san\" ); else if ( ave == 4 ) printf ( \"si\" ); else if ( ave == 5 ) printf ( \"wu\" ); else if ( ave == 6 ) printf ( \"liu\" ); else if ( ave == 7 ) printf ( \"qi\" ); else if ( ave == 8 ) printf ( \"ba\" ); else if ( ave == 9 ) printf ( \"jiu\" ); } } printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/","text":"1003 \u6211\u8981\u901a\u8fc7\uff01 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c \u7b54\u6848\u6b63\u786e \u201d\u662f\u81ea\u52a8\u5224\u9898\u7cfb\u7edf\u7ed9\u51fa\u7684\u6700\u4ee4\u4eba\u6b22\u559c\u7684\u56de\u590d\u3002\u672c\u9898\u5c5e\u4e8e PAT \u7684\u201c \u7b54\u6848\u6b63\u786e \u201d\u5927\u6d3e\u9001 \u2014\u2014 \u53ea\u8981\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\uff0c\u7cfb\u7edf\u5c31\u8f93\u51fa\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5426\u5219\u8f93\u51fa\u201c \u7b54\u6848\u9519\u8bef \u201d\u3002 \u5f97\u5230\u201c \u7b54\u6848\u6b63\u786e \u201d\u7684\u6761\u4ef6\u662f\uff1a \u5b57\u7b26\u4e32\u4e2d\u5fc5\u987b\u4ec5\u6709 P \u3001 A \u3001 T \u8fd9\u4e09\u79cd\u5b57\u7b26\uff0c\u4e0d\u53ef\u4ee5\u5305\u542b\u5176\u5b83\u5b57\u7b26\uff1b \u4efb\u610f\u5f62\u5982 xPATx \u7684\u5b57\u7b26\u4e32\u90fd\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5176\u4e2d x \u6216\u8005\u662f\u7a7a\u5b57\u7b26\u4e32\uff0c\u6216\u8005\u662f\u4ec5\u7531\u5b57\u6bcd A \u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff1b \u5982\u679c aPbTc \u662f\u6b63\u786e\u7684\uff0c\u90a3\u4e48 aPbATca \u4e5f\u662f\u6b63\u786e\u7684\uff0c\u5176\u4e2d a \u3001 b \u3001 c \u5747\u6216\u8005\u662f\u7a7a\u5b57\u7b26\u4e32\uff0c\u6216\u8005\u662f\u4ec5\u7531\u5b57\u6bcd A \u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u73b0\u5728\u5c31\u8bf7\u4f60\u4e3a PAT \u5199\u4e00\u4e2a\u81ea\u52a8\u88c1\u5224\u7a0b\u5e8f\uff0c\u5224\u5b9a\u54ea\u4e9b\u5b57\u7b26\u4e32\u662f\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u7b2c 1 \u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 n n ( \u226410 \u226410 )\uff0c\u662f\u9700\u8981\u68c0\u6d4b\u7684\u5b57\u7b26\u4e32\u4e2a\u6570\u3002\u63a5\u4e0b\u6765\u6bcf\u4e2a\u5b57\u7b26\u4e32\u5360\u4e00\u884c\uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 100\uff0c\u4e14\u4e0d\u5305\u542b\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u68c0\u6d4b\u7ed3\u679c\u5360\u4e00\u884c\uff0c\u5982\u679c\u8be5\u5b57\u7b26\u4e32\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5219\u8f93\u51fa YES \uff0c\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 10 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA APT APATTAA \u8f93\u51fa\u6837\u4f8b YES YES YES YES NO NO NO NO NO NO \u9e23\u8c22\u6c5f\u897f\u8d22\u7ecf\u5927\u5b66\u8f6f\u4ef6\u5b66\u9662\u6731\u653f\u540c\u5b66\u3001\u7528\u6237 woluo_z \u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01 Solution C++ #include <string.h> #include <iostream> using namespace std ; int main () { int t , l , i , flag , a , b , c , d ; char n [ 101 ]; cin >> t ; while ( t -- ) { a = b = c = d = 0 ; flag = 1 ; scanf ( \"%s\" , n ); l = strlen ( n ); for ( i = 0 ; i < l ; i ++ ) { if ( n [ i ] != 'P' && n [ i ] != 'A' && n [ i ] != 'T' ) { flag = 0 ; } // cout<<flag<<endl; if ( n [ i ] == 'P' ) { a = i ; c ++ ; } else if ( n [ i ] == 'T' ) { b = i ; d ++ ; } } if ( c > 1 || d > 1 ) { flag = 0 ; } if (( b - a - 1 ) == 1 ) { if ( a != ( l - b - 1 )) { flag = 0 ; } } else if (( b - a - 1 ) == 2 ) { if ( 2 * a != ( l - b - 1 )) { flag = 0 ; } } else { flag = 0 ; } if ( flag ) { cout << \"YES\" << endl ; } else { cout << \"NO\" << endl ; } } }","title":"1003-\u6211\u8981\u901a\u8fc7\uff01"},{"location":"PAT-Basic-Level/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/#1003-\u6211\u8981\u901a\u8fc7","text":"","title":"1003 \u6211\u8981\u901a\u8fc7\uff01"},{"location":"PAT-Basic-Level/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c \u7b54\u6848\u6b63\u786e \u201d\u662f\u81ea\u52a8\u5224\u9898\u7cfb\u7edf\u7ed9\u51fa\u7684\u6700\u4ee4\u4eba\u6b22\u559c\u7684\u56de\u590d\u3002\u672c\u9898\u5c5e\u4e8e PAT \u7684\u201c \u7b54\u6848\u6b63\u786e \u201d\u5927\u6d3e\u9001 \u2014\u2014 \u53ea\u8981\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\uff0c\u7cfb\u7edf\u5c31\u8f93\u51fa\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5426\u5219\u8f93\u51fa\u201c \u7b54\u6848\u9519\u8bef \u201d\u3002 \u5f97\u5230\u201c \u7b54\u6848\u6b63\u786e \u201d\u7684\u6761\u4ef6\u662f\uff1a \u5b57\u7b26\u4e32\u4e2d\u5fc5\u987b\u4ec5\u6709 P \u3001 A \u3001 T \u8fd9\u4e09\u79cd\u5b57\u7b26\uff0c\u4e0d\u53ef\u4ee5\u5305\u542b\u5176\u5b83\u5b57\u7b26\uff1b \u4efb\u610f\u5f62\u5982 xPATx \u7684\u5b57\u7b26\u4e32\u90fd\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5176\u4e2d x \u6216\u8005\u662f\u7a7a\u5b57\u7b26\u4e32\uff0c\u6216\u8005\u662f\u4ec5\u7531\u5b57\u6bcd A \u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff1b \u5982\u679c aPbTc \u662f\u6b63\u786e\u7684\uff0c\u90a3\u4e48 aPbATca \u4e5f\u662f\u6b63\u786e\u7684\uff0c\u5176\u4e2d a \u3001 b \u3001 c \u5747\u6216\u8005\u662f\u7a7a\u5b57\u7b26\u4e32\uff0c\u6216\u8005\u662f\u4ec5\u7531\u5b57\u6bcd A \u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u3002 \u73b0\u5728\u5c31\u8bf7\u4f60\u4e3a PAT \u5199\u4e00\u4e2a\u81ea\u52a8\u88c1\u5224\u7a0b\u5e8f\uff0c\u5224\u5b9a\u54ea\u4e9b\u5b57\u7b26\u4e32\u662f\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\u7684\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u7b2c 1 \u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 n n ( \u226410 \u226410 )\uff0c\u662f\u9700\u8981\u68c0\u6d4b\u7684\u5b57\u7b26\u4e32\u4e2a\u6570\u3002\u63a5\u4e0b\u6765\u6bcf\u4e2a\u5b57\u7b26\u4e32\u5360\u4e00\u884c\uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 100\uff0c\u4e14\u4e0d\u5305\u542b\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u68c0\u6d4b\u7ed3\u679c\u5360\u4e00\u884c\uff0c\u5982\u679c\u8be5\u5b57\u7b26\u4e32\u53ef\u4ee5\u83b7\u5f97\u201c \u7b54\u6848\u6b63\u786e \u201d\uff0c\u5219\u8f93\u51fa YES \uff0c\u5426\u5219\u8f93\u51fa NO \u3002 \u8f93\u5165\u6837\u4f8b 10 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA APT APATTAA \u8f93\u51fa\u6837\u4f8b YES YES YES YES NO NO NO NO NO NO \u9e23\u8c22\u6c5f\u897f\u8d22\u7ecf\u5927\u5b66\u8f6f\u4ef6\u5b66\u9662\u6731\u653f\u540c\u5b66\u3001\u7528\u6237 woluo_z \u8865\u5145\u6d4b\u8bd5\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/#solution","text":"C++ #include <string.h> #include <iostream> using namespace std ; int main () { int t , l , i , flag , a , b , c , d ; char n [ 101 ]; cin >> t ; while ( t -- ) { a = b = c = d = 0 ; flag = 1 ; scanf ( \"%s\" , n ); l = strlen ( n ); for ( i = 0 ; i < l ; i ++ ) { if ( n [ i ] != 'P' && n [ i ] != 'A' && n [ i ] != 'T' ) { flag = 0 ; } // cout<<flag<<endl; if ( n [ i ] == 'P' ) { a = i ; c ++ ; } else if ( n [ i ] == 'T' ) { b = i ; d ++ ; } } if ( c > 1 || d > 1 ) { flag = 0 ; } if (( b - a - 1 ) == 1 ) { if ( a != ( l - b - 1 )) { flag = 0 ; } } else if (( b - a - 1 ) == 2 ) { if ( 2 * a != ( l - b - 1 )) { flag = 0 ; } } else { flag = 0 ; } if ( flag ) { cout << \"YES\" << endl ; } else { cout << \"NO\" << endl ; } } }","title":"Solution"},{"location":"PAT-Basic-Level/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/","text":"1004 \u6210\u7ee9\u6392\u540d Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bfb\u5165 n n \uff08 >0 >0 \uff09\u540d\u5b66\u751f\u7684\u59d3\u540d\u3001\u5b66\u53f7\u3001\u6210\u7ee9\uff0c\u5206\u522b\u8f93\u51fa\u6210\u7ee9\u6700\u9ad8\u548c\u6210\u7ee9\u6700\u4f4e\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u683c\u5f0f\u4e3a \u7b2c 1 \u884c\uff1a\u6b63\u6574\u6570 n \u7b2c 2 \u884c\uff1a\u7b2c 1 \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 \u7b2c 3 \u884c\uff1a\u7b2c 2 \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 ... ... ... \u7b2c n+1 \u884c\uff1a\u7b2c n \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 \u5176\u4e2d \u59d3\u540d \u548c \u5b66\u53f7 \u5747\u4e3a\u4e0d\u8d85\u8fc7 10 \u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u6210\u7ee9\u4e3a 0 \u5230 100 \u4e4b\u95f4\u7684\u4e00\u4e2a\u6574\u6570\uff0c\u8fd9\u91cc\u4fdd\u8bc1\u5728\u4e00\u7ec4\u6d4b\u8bd5\u7528\u4f8b\u4e2d\u6ca1\u6709\u4e24\u4e2a\u5b66\u751f\u7684\u6210\u7ee9\u662f\u76f8\u540c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8f93\u51fa 2 \u884c\uff0c\u7b2c 1 \u884c\u662f\u6210\u7ee9\u6700\u9ad8\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\uff0c\u7b2c 2 \u884c\u662f\u6210\u7ee9\u6700\u4f4e\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\uff0c\u5b57\u7b26\u4e32\u95f4\u6709 1 \u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 \u8f93\u51fa\u6837\u4f8b Mike CS991301 Joe Math990112 Solution C #include <limits.h> #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); char c1 [ n ][ 11 ], c2 [ n ][ 11 ]; int num [ n ]; int i ; int max = INT_MIN , min = INT_MAX ; int flag1 , flag2 ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%s %s %d\" , & c1 [ i ], & c2 [ i ], & num [ i ]); if ( num [ i ] > max ) { max = num [ i ]; flag1 = i ; } if ( num [ i ] < min ) { min = num [ i ]; flag2 = i ; } } printf ( \"%s %s \\n \" , c1 [ flag1 ], c2 [ flag1 ]); printf ( \"%s %s \\n \" , c1 [ flag2 ], c2 [ flag2 ]); }","title":"1004-\u6210\u7ee9\u6392\u540d"},{"location":"PAT-Basic-Level/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/#1004-\u6210\u7ee9\u6392\u540d","text":"","title":"1004 \u6210\u7ee9\u6392\u540d"},{"location":"PAT-Basic-Level/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bfb\u5165 n n \uff08 >0 >0 \uff09\u540d\u5b66\u751f\u7684\u59d3\u540d\u3001\u5b66\u53f7\u3001\u6210\u7ee9\uff0c\u5206\u522b\u8f93\u51fa\u6210\u7ee9\u6700\u9ad8\u548c\u6210\u7ee9\u6700\u4f4e\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u683c\u5f0f\u4e3a \u7b2c 1 \u884c\uff1a\u6b63\u6574\u6570 n \u7b2c 2 \u884c\uff1a\u7b2c 1 \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 \u7b2c 3 \u884c\uff1a\u7b2c 2 \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 ... ... ... \u7b2c n+1 \u884c\uff1a\u7b2c n \u4e2a\u5b66\u751f\u7684\u59d3\u540d \u5b66\u53f7 \u6210\u7ee9 \u5176\u4e2d \u59d3\u540d \u548c \u5b66\u53f7 \u5747\u4e3a\u4e0d\u8d85\u8fc7 10 \u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u6210\u7ee9\u4e3a 0 \u5230 100 \u4e4b\u95f4\u7684\u4e00\u4e2a\u6574\u6570\uff0c\u8fd9\u91cc\u4fdd\u8bc1\u5728\u4e00\u7ec4\u6d4b\u8bd5\u7528\u4f8b\u4e2d\u6ca1\u6709\u4e24\u4e2a\u5b66\u751f\u7684\u6210\u7ee9\u662f\u76f8\u540c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8f93\u51fa 2 \u884c\uff0c\u7b2c 1 \u884c\u662f\u6210\u7ee9\u6700\u9ad8\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\uff0c\u7b2c 2 \u884c\u662f\u6210\u7ee9\u6700\u4f4e\u5b66\u751f\u7684\u59d3\u540d\u548c\u5b66\u53f7\uff0c\u5b57\u7b26\u4e32\u95f4\u6709 1 \u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 \u8f93\u51fa\u6837\u4f8b Mike CS991301 Joe Math990112","title":"Statement"},{"location":"PAT-Basic-Level/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/#solution","text":"C #include <limits.h> #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); char c1 [ n ][ 11 ], c2 [ n ][ 11 ]; int num [ n ]; int i ; int max = INT_MIN , min = INT_MAX ; int flag1 , flag2 ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%s %s %d\" , & c1 [ i ], & c2 [ i ], & num [ i ]); if ( num [ i ] > max ) { max = num [ i ]; flag1 = i ; } if ( num [ i ] < min ) { min = num [ i ]; flag2 = i ; } } printf ( \"%s %s \\n \" , c1 [ flag1 ], c2 [ flag1 ]); printf ( \"%s %s \\n \" , c1 [ flag2 ], c2 [ flag2 ]); }","title":"Solution"},{"location":"PAT-Basic-Level/1005-%E7%BB%A7%E7%BB%AD%283n%2B1%29%E7%8C%9C%E6%83%B3/","text":"1005 \u7ee7\u7eed(3n+1)\u731c\u60f3 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5361\u62c9\u5179(Callatz)\u731c\u60f3\u5df2\u7ecf\u57281001\u4e2d\u7ed9\u51fa\u4e86\u63cf\u8ff0\u3002\u5728\u8fd9\u4e2a\u9898\u76ee\u91cc\uff0c\u60c5\u51b5\u7a0d\u5fae\u6709\u4e9b\u590d\u6742\u3002 \u5f53\u6211\u4eec\u9a8c\u8bc1\u5361\u62c9\u5179\u731c\u60f3\u7684\u65f6\u5019\uff0c\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u8ba1\u7b97\uff0c\u53ef\u4ee5\u8bb0\u5f55\u4e0b\u9012\u63a8\u8fc7\u7a0b\u4e2d\u9047\u5230\u7684\u6bcf\u4e00\u4e2a\u6570\u3002\u4f8b\u5982\u5bf9 n=3 n=3 \u8fdb\u884c\u9a8c\u8bc1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u8ba1\u7b97 3\u30015\u30018\u30014\u30012\u30011\uff0c\u5219\u5f53\u6211\u4eec\u5bf9 n=5 n=5 \u30018\u30014\u30012 \u8fdb\u884c\u9a8c\u8bc1\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u5224\u5b9a\u5361\u62c9\u5179\u731c\u60f3\u7684\u771f\u4f2a\uff0c\u800c\u4e0d\u9700\u8981\u91cd\u590d\u8ba1\u7b97\uff0c\u56e0\u4e3a\u8fd9 4 \u4e2a\u6570\u5df2\u7ecf\u5728\u9a8c\u8bc13\u7684\u65f6\u5019\u9047\u5230\u8fc7\u4e86\uff0c\u6211\u4eec\u79f0 5\u30018\u30014\u30012 \u662f\u88ab 3\u201c\u8986\u76d6\u201d\u7684\u6570\u3002\u6211\u4eec\u79f0\u4e00\u4e2a\u6570\u5217\u4e2d\u7684\u67d0\u4e2a\u6570 n n \u4e3a\u201c\u5173\u952e\u6570\u201d\uff0c\u5982\u679c n n \u4e0d\u80fd\u88ab\u6570\u5217\u4e2d\u7684\u5176\u4ed6\u6570\u5b57\u6240\u8986\u76d6\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u7cfb\u5217\u5f85\u9a8c\u8bc1\u7684\u6570\u5b57\uff0c\u6211\u4eec\u53ea\u9700\u8981\u9a8c\u8bc1\u5176\u4e2d\u7684\u51e0\u4e2a\u5173\u952e\u6570\uff0c\u5c31\u53ef\u4ee5\u4e0d\u5fc5\u518d\u91cd\u590d\u9a8c\u8bc1\u4f59\u4e0b\u7684\u6570\u5b57\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u627e\u51fa\u8fd9\u4e9b\u5173\u952e\u6570\u5b57\uff0c\u5e76\u6309\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u8f93\u51fa\u5b83\u4eec\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7b2c 1 \u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K ( <100 <100 )\uff0c\u7b2c 2 \u884c\u7ed9\u51fa K K \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u5f85\u9a8c\u8bc1\u7684\u6b63\u6574\u6570 n n ( 1<n\\le 100 1<n\\le 100 )\u7684\u503c\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u9694\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u6309\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u8f93\u51fa\u5173\u952e\u6570\u5b57\u3002\u6570\u5b57\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u9694\u5f00\uff0c\u4f46\u4e00\u884c\u4e2d\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u540e\u6ca1\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 3 5 6 7 8 11 \u8f93\u51fa\u6837\u4f8b 7 6 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 105 int a [ MAXN ] = { 0 }, b [ MAXN ], c [ MAXN ]; void f ( int x ) { for (; x != 1 ;) { if ( x % 2 ) { x = 3 * x + 1 ; x /= 2 ; if ( x <= 100 ) a [ x ] = 0 ; } else { x /= 2 ; if ( x <= 100 ) a [ x ] = 0 ; } } } int comp ( int x , int y ) { return x > y ; } int main () { int n , i , j , num ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); a [ b [ i ]] = 1 ; } for ( i = 0 ; i < n ; i ++ ) f ( b [ i ]); for ( i = 0 , j = 0 ; i < MAXN ; i ++ ) { if ( a [ i ]) c [ j ++ ] = i ; } sort ( c , c + j , comp ); printf ( \"%d\" , c [ 0 ]); for ( i = 1 ; i < j ; i ++ ) printf ( \" %d\" , c [ i ]); cout << \" \\n \" ; }","title":"1005-\u7ee7\u7eed(3n+1)\u731c\u60f3"},{"location":"PAT-Basic-Level/1005-%E7%BB%A7%E7%BB%AD%283n%2B1%29%E7%8C%9C%E6%83%B3/#1005-\u7ee7\u7eed3n1\u731c\u60f3","text":"","title":"1005 \u7ee7\u7eed(3n+1)\u731c\u60f3"},{"location":"PAT-Basic-Level/1005-%E7%BB%A7%E7%BB%AD%283n%2B1%29%E7%8C%9C%E6%83%B3/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5361\u62c9\u5179(Callatz)\u731c\u60f3\u5df2\u7ecf\u57281001\u4e2d\u7ed9\u51fa\u4e86\u63cf\u8ff0\u3002\u5728\u8fd9\u4e2a\u9898\u76ee\u91cc\uff0c\u60c5\u51b5\u7a0d\u5fae\u6709\u4e9b\u590d\u6742\u3002 \u5f53\u6211\u4eec\u9a8c\u8bc1\u5361\u62c9\u5179\u731c\u60f3\u7684\u65f6\u5019\uff0c\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u8ba1\u7b97\uff0c\u53ef\u4ee5\u8bb0\u5f55\u4e0b\u9012\u63a8\u8fc7\u7a0b\u4e2d\u9047\u5230\u7684\u6bcf\u4e00\u4e2a\u6570\u3002\u4f8b\u5982\u5bf9 n=3 n=3 \u8fdb\u884c\u9a8c\u8bc1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u8ba1\u7b97 3\u30015\u30018\u30014\u30012\u30011\uff0c\u5219\u5f53\u6211\u4eec\u5bf9 n=5 n=5 \u30018\u30014\u30012 \u8fdb\u884c\u9a8c\u8bc1\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u5224\u5b9a\u5361\u62c9\u5179\u731c\u60f3\u7684\u771f\u4f2a\uff0c\u800c\u4e0d\u9700\u8981\u91cd\u590d\u8ba1\u7b97\uff0c\u56e0\u4e3a\u8fd9 4 \u4e2a\u6570\u5df2\u7ecf\u5728\u9a8c\u8bc13\u7684\u65f6\u5019\u9047\u5230\u8fc7\u4e86\uff0c\u6211\u4eec\u79f0 5\u30018\u30014\u30012 \u662f\u88ab 3\u201c\u8986\u76d6\u201d\u7684\u6570\u3002\u6211\u4eec\u79f0\u4e00\u4e2a\u6570\u5217\u4e2d\u7684\u67d0\u4e2a\u6570 n n \u4e3a\u201c\u5173\u952e\u6570\u201d\uff0c\u5982\u679c n n \u4e0d\u80fd\u88ab\u6570\u5217\u4e2d\u7684\u5176\u4ed6\u6570\u5b57\u6240\u8986\u76d6\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u7cfb\u5217\u5f85\u9a8c\u8bc1\u7684\u6570\u5b57\uff0c\u6211\u4eec\u53ea\u9700\u8981\u9a8c\u8bc1\u5176\u4e2d\u7684\u51e0\u4e2a\u5173\u952e\u6570\uff0c\u5c31\u53ef\u4ee5\u4e0d\u5fc5\u518d\u91cd\u590d\u9a8c\u8bc1\u4f59\u4e0b\u7684\u6570\u5b57\u3002\u4f60\u7684\u4efb\u52a1\u5c31\u662f\u627e\u51fa\u8fd9\u4e9b\u5173\u952e\u6570\u5b57\uff0c\u5e76\u6309\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u8f93\u51fa\u5b83\u4eec\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7b2c 1 \u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K ( <100 <100 )\uff0c\u7b2c 2 \u884c\u7ed9\u51fa K K \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u5f85\u9a8c\u8bc1\u7684\u6b63\u6574\u6570 n n ( 1<n\\le 100 1<n\\le 100 )\u7684\u503c\uff0c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u9694\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u6309\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u8f93\u51fa\u5173\u952e\u6570\u5b57\u3002\u6570\u5b57\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u9694\u5f00\uff0c\u4f46\u4e00\u884c\u4e2d\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u540e\u6ca1\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 3 5 6 7 8 11 \u8f93\u51fa\u6837\u4f8b 7 6","title":"Statement"},{"location":"PAT-Basic-Level/1005-%E7%BB%A7%E7%BB%AD%283n%2B1%29%E7%8C%9C%E6%83%B3/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 105 int a [ MAXN ] = { 0 }, b [ MAXN ], c [ MAXN ]; void f ( int x ) { for (; x != 1 ;) { if ( x % 2 ) { x = 3 * x + 1 ; x /= 2 ; if ( x <= 100 ) a [ x ] = 0 ; } else { x /= 2 ; if ( x <= 100 ) a [ x ] = 0 ; } } } int comp ( int x , int y ) { return x > y ; } int main () { int n , i , j , num ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & b [ i ]); a [ b [ i ]] = 1 ; } for ( i = 0 ; i < n ; i ++ ) f ( b [ i ]); for ( i = 0 , j = 0 ; i < MAXN ; i ++ ) { if ( a [ i ]) c [ j ++ ] = i ; } sort ( c , c + j , comp ); printf ( \"%d\" , c [ 0 ]); for ( i = 1 ; i < j ; i ++ ) printf ( \" %d\" , c [ i ]); cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/","text":"1006 \u6362\u4e2a\u683c\u5f0f\u8f93\u51fa\u6574\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8ba9\u6211\u4eec\u7528\u5b57\u6bcd B \u6765\u8868\u793a\u201c\u767e\u201d\u3001\u5b57\u6bcd S \u8868\u793a\u201c\u5341\u201d\uff0c\u7528 12...n \u6765\u8868\u793a\u4e0d\u4e3a\u96f6\u7684\u4e2a\u4f4d\u6570\u5b57 n \uff08 <10 <10 \uff09\uff0c\u6362\u4e2a\u683c\u5f0f\u6765\u8f93\u51fa\u4efb\u4e00\u4e2a\u4e0d\u8d85\u8fc7 3 \u4f4d\u7684\u6b63\u6574\u6570\u3002\u4f8b\u5982 234 \u5e94\u8be5\u88ab\u8f93\u51fa\u4e3a BBSSS1234 \uff0c\u56e0\u4e3a\u5b83\u6709 2 \u4e2a\u201c\u767e\u201d\u30013 \u4e2a\u201c\u5341\u201d\u3001\u4ee5\u53ca\u4e2a\u4f4d\u7684 4\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7ed9\u51fa\u6b63\u6574\u6570 n n \uff08 <1000 <1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u7528\u89c4\u5b9a\u7684\u683c\u5f0f\u8f93\u51fa n n \u3002 \u8f93\u5165\u6837\u4f8b 1 234 \u8f93\u51fa\u6837\u4f8b 1 BBSSS1234 \u8f93\u5165\u6837\u4f8b 2 23 \u8f93\u51fa\u6837\u4f8b 2 SS123 Solution C #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); int i ; int flag1 , flag2 , flag3 ; flag1 = ( n / 100 ) % 10 ; flag2 = ( n / 10 ) % 10 ; flag3 = n % 10 ; while ( flag1 -- ) { printf ( \"B\" ); } while ( flag2 -- ) { printf ( \"S\" ); } for ( i = 1 ; i <= flag3 ; i ++ ) { printf ( \"%d\" , i ); } printf ( \" \\n \" ); }","title":"1006-\u6362\u4e2a\u683c\u5f0f\u8f93\u51fa\u6574\u6570"},{"location":"PAT-Basic-Level/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/#1006-\u6362\u4e2a\u683c\u5f0f\u8f93\u51fa\u6574\u6570","text":"","title":"1006 \u6362\u4e2a\u683c\u5f0f\u8f93\u51fa\u6574\u6570"},{"location":"PAT-Basic-Level/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8ba9\u6211\u4eec\u7528\u5b57\u6bcd B \u6765\u8868\u793a\u201c\u767e\u201d\u3001\u5b57\u6bcd S \u8868\u793a\u201c\u5341\u201d\uff0c\u7528 12...n \u6765\u8868\u793a\u4e0d\u4e3a\u96f6\u7684\u4e2a\u4f4d\u6570\u5b57 n \uff08 <10 <10 \uff09\uff0c\u6362\u4e2a\u683c\u5f0f\u6765\u8f93\u51fa\u4efb\u4e00\u4e2a\u4e0d\u8d85\u8fc7 3 \u4f4d\u7684\u6b63\u6574\u6570\u3002\u4f8b\u5982 234 \u5e94\u8be5\u88ab\u8f93\u51fa\u4e3a BBSSS1234 \uff0c\u56e0\u4e3a\u5b83\u6709 2 \u4e2a\u201c\u767e\u201d\u30013 \u4e2a\u201c\u5341\u201d\u3001\u4ee5\u53ca\u4e2a\u4f4d\u7684 4\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7ed9\u51fa\u6b63\u6574\u6570 n n \uff08 <1000 <1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u7528\u89c4\u5b9a\u7684\u683c\u5f0f\u8f93\u51fa n n \u3002 \u8f93\u5165\u6837\u4f8b 1 234 \u8f93\u51fa\u6837\u4f8b 1 BBSSS1234 \u8f93\u5165\u6837\u4f8b 2 23 \u8f93\u51fa\u6837\u4f8b 2 SS123","title":"Statement"},{"location":"PAT-Basic-Level/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/#solution","text":"C #include <stdio.h> int main () { int n ; scanf ( \"%d\" , & n ); int i ; int flag1 , flag2 , flag3 ; flag1 = ( n / 100 ) % 10 ; flag2 = ( n / 10 ) % 10 ; flag3 = n % 10 ; while ( flag1 -- ) { printf ( \"B\" ); } while ( flag2 -- ) { printf ( \"S\" ); } for ( i = 1 ; i <= flag3 ; i ++ ) { printf ( \"%d\" , i ); } printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/","text":"1007 \u7d20\u6570\u5bf9\u731c\u60f3 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8ba9\u6211\u4eec\u5b9a\u4e49 d_n d_n \u4e3a\uff1a d_n = p_{n+1}-p_n d_n = p_{n+1}-p_n \uff0c\u5176\u4e2d p_i p_i \u662f\u7b2c i i \u4e2a\u7d20\u6570\u3002\u663e\u7136\u6709 d_1 = 1 d_1 = 1 \uff0c\u4e14\u5bf9\u4e8e n>1 n>1 \u6709 d_n d_n \u662f\u5076\u6570\u3002\u201c\u7d20\u6570\u5bf9\u731c\u60f3\u201d\u8ba4\u4e3a\u201c\u5b58\u5728\u65e0\u7a77\u591a\u5bf9\u76f8\u90bb\u4e14\u5dee\u4e3a2\u7684\u7d20\u6570\u201d\u3002 \u73b0\u7ed9\u5b9a\u4efb\u610f\u6b63\u6574\u6570 N ( <10^5 <10^5 )\uff0c\u8bf7\u8ba1\u7b97\u4e0d\u8d85\u8fc7 N \u7684\u6ee1\u8db3\u731c\u60f3\u7684\u7d20\u6570\u5bf9\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e0d\u8d85\u8fc7 N \u7684\u6ee1\u8db3\u731c\u60f3\u7684\u7d20\u6570\u5bf9\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b 20 \u8f93\u51fa\u6837\u4f8b 4 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int isPrime [ MAXN ]; void getprime ( int x ) { int i , j , k , n ; isPrime [ 1 ] = 0 ; for ( i = 2 ; i <= x ; i ++ ) { k = sqrt ( i ); for ( j = 2 ; j <= k ; j ++ ) { if ( 0 == i % j ) break ; } if ( j > k ) isPrime [ i ] = 1 ; else isPrime [ i ] = 0 ; } } int main () { int n , i , total = 0 ; cin >> n ; getprime ( n ); if ( n >= 5 ) for ( i = 5 ; i <= n ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] && ! isPrime [ i - 1 ]) total ++ ; } cout << total << endl ; }","title":"1007-\u7d20\u6570\u5bf9\u731c\u60f3"},{"location":"PAT-Basic-Level/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/#1007-\u7d20\u6570\u5bf9\u731c\u60f3","text":"","title":"1007 \u7d20\u6570\u5bf9\u731c\u60f3"},{"location":"PAT-Basic-Level/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8ba9\u6211\u4eec\u5b9a\u4e49 d_n d_n \u4e3a\uff1a d_n = p_{n+1}-p_n d_n = p_{n+1}-p_n \uff0c\u5176\u4e2d p_i p_i \u662f\u7b2c i i \u4e2a\u7d20\u6570\u3002\u663e\u7136\u6709 d_1 = 1 d_1 = 1 \uff0c\u4e14\u5bf9\u4e8e n>1 n>1 \u6709 d_n d_n \u662f\u5076\u6570\u3002\u201c\u7d20\u6570\u5bf9\u731c\u60f3\u201d\u8ba4\u4e3a\u201c\u5b58\u5728\u65e0\u7a77\u591a\u5bf9\u76f8\u90bb\u4e14\u5dee\u4e3a2\u7684\u7d20\u6570\u201d\u3002 \u73b0\u7ed9\u5b9a\u4efb\u610f\u6b63\u6574\u6570 N ( <10^5 <10^5 )\uff0c\u8bf7\u8ba1\u7b97\u4e0d\u8d85\u8fc7 N \u7684\u6ee1\u8db3\u731c\u60f3\u7684\u7d20\u6570\u5bf9\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e0d\u8d85\u8fc7 N \u7684\u6ee1\u8db3\u731c\u60f3\u7684\u7d20\u6570\u5bf9\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b 20 \u8f93\u51fa\u6837\u4f8b 4","title":"Statement"},{"location":"PAT-Basic-Level/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int isPrime [ MAXN ]; void getprime ( int x ) { int i , j , k , n ; isPrime [ 1 ] = 0 ; for ( i = 2 ; i <= x ; i ++ ) { k = sqrt ( i ); for ( j = 2 ; j <= k ; j ++ ) { if ( 0 == i % j ) break ; } if ( j > k ) isPrime [ i ] = 1 ; else isPrime [ i ] = 0 ; } } int main () { int n , i , total = 0 ; cin >> n ; getprime ( n ); if ( n >= 5 ) for ( i = 5 ; i <= n ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] && ! isPrime [ i - 1 ]) total ++ ; } cout << total << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/","text":"1008 \u6570\u7ec4\u5143\u7d20\u5faa\u73af\u53f3\u79fb\u95ee\u9898 Statement Metadata \u4f5c\u8005: DS\u8bfe\u7a0b\u7ec4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6570\u7ec4 A A \u4e2d\u5b58\u6709 N N \uff08 >0 >0 \uff09\u4e2a\u6574\u6570\uff0c\u5728\u4e0d\u5141\u8bb8\u4f7f\u7528\u53e6\u5916\u6570\u7ec4\u7684\u524d\u63d0\u4e0b\uff0c\u5c06\u6bcf\u4e2a\u6574\u6570\u5faa\u73af\u5411\u53f3\u79fb M M \uff08 \\ge 0 \\ge 0 \uff09\u4e2a\u4f4d\u7f6e\uff0c\u5373\u5c06 A A \u4e2d\u7684\u6570\u636e\u7531\uff08 A_0 A_1 \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-1} \uff09\u53d8\u6362\u4e3a\uff08 A_{N-M} \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-M-1} A_{N-M} \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-M-1} \uff09\uff08\u6700\u540e M M \u4e2a\u6570\u5faa\u73af\u79fb\u81f3\u6700\u524d\u9762\u7684 M M \u4e2a\u4f4d\u7f6e\uff09\u3002\u5982\u679c\u9700\u8981\u8003\u8651\u7a0b\u5e8f\u79fb\u52a8\u6570\u636e\u7684\u6b21\u6570\u5c3d\u91cf\u5c11\uff0c\u8981\u5982\u4f55\u8bbe\u8ba1\u79fb\u52a8\u7684\u65b9\u6cd5\uff1f \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7b2c1\u884c\u8f93\u5165 N N \uff08 1\\le N \\le 100 1\\le N \\le 100 \uff09\u548c M M \uff08 \\ge 0 \\ge 0 \uff09\uff1b\u7b2c2\u884c\u8f93\u5165 N N \u4e2a\u6574\u6570\uff0c\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5faa\u73af\u53f3\u79fb M M \u4f4d\u4ee5\u540e\u7684\u6574\u6570\u5e8f\u5217\uff0c\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\uff0c\u5e8f\u5217\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 2 1 2 3 4 5 6 \u8f93\u51fa\u6837\u4f8b 5 6 1 2 3 4 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int a [ MAXN ]; int main () { int n , m , i ; cin >> n >> m ; m %= n ; for ( i = m ; i < n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( i = 0 ; i < m ; i ++ ) scanf ( \"%d\" , & a [ i ]); printf ( \"%d\" , a [ 0 ]); for ( i = 1 ; i < n ; i ++ ) printf ( \" %d\" , a [ i ]); printf ( \" \\n \" ); }","title":"1008-\u6570\u7ec4\u5143\u7d20\u5faa\u73af\u53f3\u79fb\u95ee\u9898"},{"location":"PAT-Basic-Level/1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/#1008-\u6570\u7ec4\u5143\u7d20\u5faa\u73af\u53f3\u79fb\u95ee\u9898","text":"","title":"1008 \u6570\u7ec4\u5143\u7d20\u5faa\u73af\u53f3\u79fb\u95ee\u9898"},{"location":"PAT-Basic-Level/1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: DS\u8bfe\u7a0b\u7ec4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u6570\u7ec4 A A \u4e2d\u5b58\u6709 N N \uff08 >0 >0 \uff09\u4e2a\u6574\u6570\uff0c\u5728\u4e0d\u5141\u8bb8\u4f7f\u7528\u53e6\u5916\u6570\u7ec4\u7684\u524d\u63d0\u4e0b\uff0c\u5c06\u6bcf\u4e2a\u6574\u6570\u5faa\u73af\u5411\u53f3\u79fb M M \uff08 \\ge 0 \\ge 0 \uff09\u4e2a\u4f4d\u7f6e\uff0c\u5373\u5c06 A A \u4e2d\u7684\u6570\u636e\u7531\uff08 A_0 A_1 \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-1} \uff09\u53d8\u6362\u4e3a\uff08 A_{N-M} \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-M-1} A_{N-M} \\cdots A_{N-1} A_0 A_1 \\cdots A_{N-M-1} \uff09\uff08\u6700\u540e M M \u4e2a\u6570\u5faa\u73af\u79fb\u81f3\u6700\u524d\u9762\u7684 M M \u4e2a\u4f4d\u7f6e\uff09\u3002\u5982\u679c\u9700\u8981\u8003\u8651\u7a0b\u5e8f\u79fb\u52a8\u6570\u636e\u7684\u6b21\u6570\u5c3d\u91cf\u5c11\uff0c\u8981\u5982\u4f55\u8bbe\u8ba1\u79fb\u52a8\u7684\u65b9\u6cd5\uff1f \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u7b2c1\u884c\u8f93\u5165 N N \uff08 1\\le N \\le 100 1\\le N \\le 100 \uff09\u548c M M \uff08 \\ge 0 \\ge 0 \uff09\uff1b\u7b2c2\u884c\u8f93\u5165 N N \u4e2a\u6574\u6570\uff0c\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5faa\u73af\u53f3\u79fb M M \u4f4d\u4ee5\u540e\u7684\u6574\u6570\u5e8f\u5217\uff0c\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\uff0c\u5e8f\u5217\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 6 2 1 2 3 4 5 6 \u8f93\u51fa\u6837\u4f8b 5 6 1 2 3 4","title":"Statement"},{"location":"PAT-Basic-Level/1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int a [ MAXN ]; int main () { int n , m , i ; cin >> n >> m ; m %= n ; for ( i = m ; i < n ; i ++ ) scanf ( \"%d\" , & a [ i ]); for ( i = 0 ; i < m ; i ++ ) scanf ( \"%d\" , & a [ i ]); printf ( \"%d\" , a [ 0 ]); for ( i = 1 ; i < n ; i ++ ) printf ( \" %d\" , a [ i ]); printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/","text":"1009 \u8bf4\u53cd\u8bdd Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u53e5\u82f1\u8bed\uff0c\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5c06\u53e5\u4e2d\u6240\u6709\u5355\u8bcd\u7684\u987a\u5e8f\u98a0\u5012\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u6d4b\u8bd5\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u5185\u7ed9\u51fa\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7 80 \u7684\u5b57\u7b26\u4e32\u3002\u5b57\u7b26\u4e32\u7531\u82e5\u5e72\u5355\u8bcd\u548c\u82e5\u5e72\u7a7a\u683c\u7ec4\u6210\uff0c\u5176\u4e2d\u5355\u8bcd\u662f\u7531\u82f1\u6587\u5b57\u6bcd\uff08\u5927\u5c0f\u5199\u6709\u533a\u5206\uff09\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5355\u8bcd\u4e4b\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u5f00\uff0c\u8f93\u5165\u4fdd\u8bc1\u53e5\u5b50\u672b\u5c3e\u6ca1\u6709\u591a\u4f59\u7684\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u8f93\u51fa\u5012\u5e8f\u540e\u7684\u53e5\u5b50\u3002 \u8f93\u5165\u6837\u4f8b Hello World Here I Come \u8f93\u51fa\u6837\u4f8b Come I Here World Hello \u9e23\u8c22\u7528\u6237 \u65e0\u5f71 \u4fee\u6b63\u6570\u636e\uff01 Solution C #include <stdio.h> int main () { char c [ 100 ][ 100 ]; int i , j ; for ( i = 0 ;; i ++ ) { scanf ( \"%s\" , & c [ i ]); if ( getchar () == '\\n' ) break ; } printf ( \"%s\" , c [ i ]); for ( j = i - 1 ; j >= 0 ; j -- ) { printf ( \" %s\" , c [ j ]); } printf ( \" \\n \" ); }","title":"1009-\u8bf4\u53cd\u8bdd"},{"location":"PAT-Basic-Level/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/#1009-\u8bf4\u53cd\u8bdd","text":"","title":"1009 \u8bf4\u53cd\u8bdd"},{"location":"PAT-Basic-Level/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u53e5\u82f1\u8bed\uff0c\u8981\u6c42\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5c06\u53e5\u4e2d\u6240\u6709\u5355\u8bcd\u7684\u987a\u5e8f\u98a0\u5012\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u6d4b\u8bd5\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u5185\u7ed9\u51fa\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc7 80 \u7684\u5b57\u7b26\u4e32\u3002\u5b57\u7b26\u4e32\u7531\u82e5\u5e72\u5355\u8bcd\u548c\u82e5\u5e72\u7a7a\u683c\u7ec4\u6210\uff0c\u5176\u4e2d\u5355\u8bcd\u662f\u7531\u82f1\u6587\u5b57\u6bcd\uff08\u5927\u5c0f\u5199\u6709\u533a\u5206\uff09\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5355\u8bcd\u4e4b\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u5f00\uff0c\u8f93\u5165\u4fdd\u8bc1\u53e5\u5b50\u672b\u5c3e\u6ca1\u6709\u591a\u4f59\u7684\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u8f93\u51fa\u5360\u4e00\u884c\uff0c\u8f93\u51fa\u5012\u5e8f\u540e\u7684\u53e5\u5b50\u3002 \u8f93\u5165\u6837\u4f8b Hello World Here I Come \u8f93\u51fa\u6837\u4f8b Come I Here World Hello \u9e23\u8c22\u7528\u6237 \u65e0\u5f71 \u4fee\u6b63\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/#solution","text":"C #include <stdio.h> int main () { char c [ 100 ][ 100 ]; int i , j ; for ( i = 0 ;; i ++ ) { scanf ( \"%s\" , & c [ i ]); if ( getchar () == '\\n' ) break ; } printf ( \"%s\" , c [ i ]); for ( j = i - 1 ; j >= 0 ; j -- ) { printf ( \" %s\" , c [ j ]); } printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/","text":"1010 \u4e00\u5143\u591a\u9879\u5f0f\u6c42\u5bfc Statement Metadata \u4f5c\u8005: DS\u8bfe\u7a0b\u7ec4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bbe\u8ba1\u51fd\u6570\u6c42\u4e00\u5143\u591a\u9879\u5f0f\u7684\u5bfc\u6570\u3002\uff08\u6ce8\uff1a x^n x^n \uff08 n n \u4e3a\u6574\u6570\uff09\u7684\u4e00\u9636\u5bfc\u6570\u4e3a n x^{n-1} n x^{n-1} \u3002\uff09 \u8f93\u5165\u683c\u5f0f \u4ee5\u6307\u6570\u9012\u964d\u65b9\u5f0f\u8f93\u5165\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7cfb\u6570\u548c\u6307\u6570\uff08\u7edd\u5bf9\u503c\u5747\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u6574\u6570\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4ee5\u4e0e\u8f93\u5165\u76f8\u540c\u7684\u683c\u5f0f\u8f93\u51fa\u5bfc\u6570\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7684\u7cfb\u6570\u548c\u6307\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\u201c\u96f6\u591a\u9879\u5f0f\u201d\u7684\u6307\u6570\u548c\u7cfb\u6570\u90fd\u662f 0\uff0c\u4f46\u662f\u8868\u793a\u4e3a 0 0 \u3002 \u8f93\u5165\u6837\u4f8b 3 4 -5 2 6 1 -2 0 \u8f93\u51fa\u6837\u4f8b 12 3 -10 1 6 0 Solution C #include <stdio.h> #include <string.h> int main () { int n , e , flag = 0 ; while ( scanf ( \"%d%d\" , & n , & e ) != EOF ) { if ( n * e ) { if ( flag ) printf ( \" \" ); else flag = 1 ; printf ( \"%d %d\" , n * e , e - 1 ); } } if ( ! flag ) printf ( \"0 0\" ); return 0 ; }","title":"1010-\u4e00\u5143\u591a\u9879\u5f0f\u6c42\u5bfc"},{"location":"PAT-Basic-Level/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/#1010-\u4e00\u5143\u591a\u9879\u5f0f\u6c42\u5bfc","text":"","title":"1010 \u4e00\u5143\u591a\u9879\u5f0f\u6c42\u5bfc"},{"location":"PAT-Basic-Level/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/#statement","text":"Metadata \u4f5c\u8005: DS\u8bfe\u7a0b\u7ec4 \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bbe\u8ba1\u51fd\u6570\u6c42\u4e00\u5143\u591a\u9879\u5f0f\u7684\u5bfc\u6570\u3002\uff08\u6ce8\uff1a x^n x^n \uff08 n n \u4e3a\u6574\u6570\uff09\u7684\u4e00\u9636\u5bfc\u6570\u4e3a n x^{n-1} n x^{n-1} \u3002\uff09 \u8f93\u5165\u683c\u5f0f \u4ee5\u6307\u6570\u9012\u964d\u65b9\u5f0f\u8f93\u5165\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7cfb\u6570\u548c\u6307\u6570\uff08\u7edd\u5bf9\u503c\u5747\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u6574\u6570\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u4ee5\u4e0e\u8f93\u5165\u76f8\u540c\u7684\u683c\u5f0f\u8f93\u51fa\u5bfc\u6570\u591a\u9879\u5f0f\u975e\u96f6\u9879\u7684\u7cfb\u6570\u548c\u6307\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u7ed3\u5c3e\u4e0d\u80fd\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\u201c\u96f6\u591a\u9879\u5f0f\u201d\u7684\u6307\u6570\u548c\u7cfb\u6570\u90fd\u662f 0\uff0c\u4f46\u662f\u8868\u793a\u4e3a 0 0 \u3002 \u8f93\u5165\u6837\u4f8b 3 4 -5 2 6 1 -2 0 \u8f93\u51fa\u6837\u4f8b 12 3 -10 1 6 0","title":"Statement"},{"location":"PAT-Basic-Level/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/#solution","text":"C #include <stdio.h> #include <string.h> int main () { int n , e , flag = 0 ; while ( scanf ( \"%d%d\" , & n , & e ) != EOF ) { if ( n * e ) { if ( flag ) printf ( \" \" ); else flag = 1 ; printf ( \"%d %d\" , n * e , e - 1 ); } } if ( ! flag ) printf ( \"0 0\" ); return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1011-A%2BB%20%E5%92%8C%20C/","text":"1011 A+B \u548c C Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u533a\u95f4 [ -2^{31}, 2^{31} -2^{31}, 2^{31} ] \u5185\u7684 3 \u4e2a\u6574\u6570 A A \u3001 B B \u548c C C \uff0c\u8bf7\u5224\u65ad A+B A+B \u662f\u5426\u5927\u4e8e C C \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 T T ( \\le 10 \\le 10 )\uff0c\u662f\u6d4b\u8bd5\u7528\u4f8b\u7684\u4e2a\u6570\u3002\u968f\u540e\u7ed9\u51fa T T \u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u7ec4\u5360\u4e00\u884c\uff0c\u987a\u5e8f\u7ed9\u51fa A A \u3001 B B \u548c C C \u3002\u6574\u6570\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case #X: true \u5982\u679c A+B>C A+B>C \uff0c\u5426\u5219\u8f93\u51fa Case #X: false \uff0c\u5176\u4e2d X \u662f\u6d4b\u8bd5\u7528\u4f8b\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002 \u8f93\u5165\u6837\u4f8b 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 \u8f93\u51fa\u6837\u4f8b Case #1: false Case #2: true Case #3: true Case #4: false Solution C #include <stdio.h> int main () { int t ; scanf ( \"%d\" , & t ); int i = 1 ; while ( t -- ) { long long a , b , c ; int flag = 0 ; scanf ( \"%lld %lld %lld\" , & a , & b , & c ); if ( a + b > c ) flag = 1 ; if ( flag ) printf ( \"Case #%d: true \\n \" , i ); else printf ( \"Case #%d: false \\n \" , i ); i ++ ; } }","title":"1011-A+B \u548c C"},{"location":"PAT-Basic-Level/1011-A%2BB%20%E5%92%8C%20C/#1011-ab-\u548c-c","text":"","title":"1011 A+B \u548c C"},{"location":"PAT-Basic-Level/1011-A%2BB%20%E5%92%8C%20C/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u533a\u95f4 [ -2^{31}, 2^{31} -2^{31}, 2^{31} ] \u5185\u7684 3 \u4e2a\u6574\u6570 A A \u3001 B B \u548c C C \uff0c\u8bf7\u5224\u65ad A+B A+B \u662f\u5426\u5927\u4e8e C C \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 T T ( \\le 10 \\le 10 )\uff0c\u662f\u6d4b\u8bd5\u7528\u4f8b\u7684\u4e2a\u6570\u3002\u968f\u540e\u7ed9\u51fa T T \u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6bcf\u7ec4\u5360\u4e00\u884c\uff0c\u987a\u5e8f\u7ed9\u51fa A A \u3001 B B \u548c C C \u3002\u6574\u6570\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case #X: true \u5982\u679c A+B>C A+B>C \uff0c\u5426\u5219\u8f93\u51fa Case #X: false \uff0c\u5176\u4e2d X \u662f\u6d4b\u8bd5\u7528\u4f8b\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\u3002 \u8f93\u5165\u6837\u4f8b 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 \u8f93\u51fa\u6837\u4f8b Case #1: false Case #2: true Case #3: true Case #4: false","title":"Statement"},{"location":"PAT-Basic-Level/1011-A%2BB%20%E5%92%8C%20C/#solution","text":"C #include <stdio.h> int main () { int t ; scanf ( \"%d\" , & t ); int i = 1 ; while ( t -- ) { long long a , b , c ; int flag = 0 ; scanf ( \"%lld %lld %lld\" , & a , & b , & c ); if ( a + b > c ) flag = 1 ; if ( flag ) printf ( \"Case #%d: true \\n \" , i ); else printf ( \"Case #%d: false \\n \" , i ); i ++ ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/","text":"1012 \u6570\u5b57\u5206\u7c7b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u7cfb\u5217\u6b63\u6574\u6570\uff0c\u8bf7\u6309\u8981\u6c42\u5bf9\u6570\u5b57\u8fdb\u884c\u5206\u7c7b\uff0c\u5e76\u8f93\u51fa\u4ee5\u4e0b 5 \u4e2a\u6570\u5b57\uff1a A_1 A_1 = \u80fd\u88ab 5 \u6574\u9664\u7684\u6570\u5b57\u4e2d\u6240\u6709\u5076\u6570\u7684\u548c\uff1b A_2 A_2 = \u5c06\u88ab 5 \u9664\u540e\u4f59 1 \u7684\u6570\u5b57\u6309\u7ed9\u51fa\u987a\u5e8f\u8fdb\u884c\u4ea4\u9519\u6c42\u548c\uff0c\u5373\u8ba1\u7b97 n_1-n_2+n_3-n_4\\cdots n_1-n_2+n_3-n_4\\cdots \uff1b A_3 A_3 = \u88ab 5 \u9664\u540e\u4f59 2 \u7684\u6570\u5b57\u7684\u4e2a\u6570\uff1b A_4 A_4 = \u88ab 5 \u9664\u540e\u4f59 3 \u7684\u6570\u5b57\u7684\u5e73\u5747\u6570\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 1 \u4f4d\uff1b A_5 A_5 = \u88ab 5 \u9664\u540e\u4f59 4 \u7684\u6570\u5b57\u4e2d\u6700\u5927\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \uff0c\u968f\u540e\u7ed9\u51fa N N \u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u5f85\u5206\u7c7b\u7684\u6b63\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7ed9\u5b9a\u7684 N N \u4e2a\u6b63\u6574\u6570\uff0c\u6309\u9898\u76ee\u8981\u6c42\u8ba1\u7b97 A_1 A_1 ~ A_5 A_5 \u5e76\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u82e5\u5206\u7c7b\u4e4b\u540e\u67d0\u4e00\u7c7b\u4e0d\u5b58\u5728\u6570\u5b57\uff0c\u5219\u5728\u76f8\u5e94\u4f4d\u7f6e\u8f93\u51fa N \u3002 \u8f93\u5165\u6837\u4f8b 1 13 1 2 3 4 5 6 7 8 9 10 20 16 18 \u8f93\u51fa\u6837\u4f8b 1 30 11 2 9.7 9 \u8f93\u5165\u6837\u4f8b 2 8 1 2 4 5 6 7 9 16 \u8f93\u51fa\u6837\u4f8b 2 N 11 2 N 9 Solution C #include <limits.h> #include <stdio.h> int main () { int total1 = 0 , total2 = 0 ; double total4 = 0 ; int count1 = 0 , count2 = 0 , count3 = 0 , count4 = 0 , count5 = 0 ; int n ; int max = INT_MIN ; scanf ( \"%d\" , & n ); int num [ n ]; int i ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); if ( num [ i ] % 10 == 0 ) { count1 ++ ; total1 += num [ i ]; } else if ( num [ i ] % 5 == 1 ) { count2 ++ ; if ( count2 % 2 ) total2 += num [ i ]; else total2 -= num [ i ]; } else if ( num [ i ] % 5 == 2 ) count3 ++ ; else if ( num [ i ] % 5 == 3 ) { count4 ++ ; total4 += num [ i ]; } else if ( num [ i ] % 5 == 4 ) { count5 ++ ; if ( num [ i ] > max ) max = num [ i ]; } } if ( count1 ) printf ( \"%d\" , total1 ); else printf ( \"N\" ); if ( count2 ) printf ( \" %d\" , total2 ); else printf ( \" N\" ); if ( count3 ) printf ( \" %d\" , count3 ); else printf ( \" N\" ); if ( count4 ) printf ( \" %.1f\" , total4 / count4 ); else printf ( \" N\" ); if ( count5 ) printf ( \" %d\" , max ); else printf ( \" N\" ); printf ( \" \\n \" ); }","title":"1012-\u6570\u5b57\u5206\u7c7b"},{"location":"PAT-Basic-Level/1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/#1012-\u6570\u5b57\u5206\u7c7b","text":"","title":"1012 \u6570\u5b57\u5206\u7c7b"},{"location":"PAT-Basic-Level/1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u7cfb\u5217\u6b63\u6574\u6570\uff0c\u8bf7\u6309\u8981\u6c42\u5bf9\u6570\u5b57\u8fdb\u884c\u5206\u7c7b\uff0c\u5e76\u8f93\u51fa\u4ee5\u4e0b 5 \u4e2a\u6570\u5b57\uff1a A_1 A_1 = \u80fd\u88ab 5 \u6574\u9664\u7684\u6570\u5b57\u4e2d\u6240\u6709\u5076\u6570\u7684\u548c\uff1b A_2 A_2 = \u5c06\u88ab 5 \u9664\u540e\u4f59 1 \u7684\u6570\u5b57\u6309\u7ed9\u51fa\u987a\u5e8f\u8fdb\u884c\u4ea4\u9519\u6c42\u548c\uff0c\u5373\u8ba1\u7b97 n_1-n_2+n_3-n_4\\cdots n_1-n_2+n_3-n_4\\cdots \uff1b A_3 A_3 = \u88ab 5 \u9664\u540e\u4f59 2 \u7684\u6570\u5b57\u7684\u4e2a\u6570\uff1b A_4 A_4 = \u88ab 5 \u9664\u540e\u4f59 3 \u7684\u6570\u5b57\u7684\u5e73\u5747\u6570\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 1 \u4f4d\uff1b A_5 A_5 = \u88ab 5 \u9664\u540e\u4f59 4 \u7684\u6570\u5b57\u4e2d\u6700\u5927\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \uff0c\u968f\u540e\u7ed9\u51fa N N \u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u5f85\u5206\u7c7b\u7684\u6b63\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7ed9\u5b9a\u7684 N N \u4e2a\u6b63\u6574\u6570\uff0c\u6309\u9898\u76ee\u8981\u6c42\u8ba1\u7b97 A_1 A_1 ~ A_5 A_5 \u5e76\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u82e5\u5206\u7c7b\u4e4b\u540e\u67d0\u4e00\u7c7b\u4e0d\u5b58\u5728\u6570\u5b57\uff0c\u5219\u5728\u76f8\u5e94\u4f4d\u7f6e\u8f93\u51fa N \u3002 \u8f93\u5165\u6837\u4f8b 1 13 1 2 3 4 5 6 7 8 9 10 20 16 18 \u8f93\u51fa\u6837\u4f8b 1 30 11 2 9.7 9 \u8f93\u5165\u6837\u4f8b 2 8 1 2 4 5 6 7 9 16 \u8f93\u51fa\u6837\u4f8b 2 N 11 2 N 9","title":"Statement"},{"location":"PAT-Basic-Level/1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/#solution","text":"C #include <limits.h> #include <stdio.h> int main () { int total1 = 0 , total2 = 0 ; double total4 = 0 ; int count1 = 0 , count2 = 0 , count3 = 0 , count4 = 0 , count5 = 0 ; int n ; int max = INT_MIN ; scanf ( \"%d\" , & n ); int num [ n ]; int i ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); if ( num [ i ] % 10 == 0 ) { count1 ++ ; total1 += num [ i ]; } else if ( num [ i ] % 5 == 1 ) { count2 ++ ; if ( count2 % 2 ) total2 += num [ i ]; else total2 -= num [ i ]; } else if ( num [ i ] % 5 == 2 ) count3 ++ ; else if ( num [ i ] % 5 == 3 ) { count4 ++ ; total4 += num [ i ]; } else if ( num [ i ] % 5 == 4 ) { count5 ++ ; if ( num [ i ] > max ) max = num [ i ]; } } if ( count1 ) printf ( \"%d\" , total1 ); else printf ( \"N\" ); if ( count2 ) printf ( \" %d\" , total2 ); else printf ( \" N\" ); if ( count3 ) printf ( \" %d\" , count3 ); else printf ( \" N\" ); if ( count4 ) printf ( \" %.1f\" , total4 / count4 ); else printf ( \" N\" ); if ( count5 ) printf ( \" %d\" , max ); else printf ( \" N\" ); printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1013-%E6%95%B0%E7%B4%A0%E6%95%B0/","text":"1013 \u6570\u7d20\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee4 P_i P_i \u8868\u793a\u7b2c i i \u4e2a\u7d20\u6570\u3002\u73b0\u4efb\u7ed9\u4e24\u4e2a\u6b63\u6574\u6570 M \\le N \\le 10^4 M \\le N \\le 10^4 \uff0c\u8bf7\u8f93\u51fa P_M P_M \u5230 P_N P_N \u7684\u6240\u6709\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u548c N N \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4ece P_M P_M \u5230 P_N P_N \u7684\u6240\u6709\u7d20\u6570\uff0c\u6bcf 10 \u4e2a\u6570\u5b57\u5360 1 \u884c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 27 \u8f93\u51fa\u6837\u4f8b 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 Solution C++ #include <cmath> #include <iostream> #include <map> #include <string> using namespace std ; #define MAXN 100000 int isprime ( int x ) { int flag ; int n , i ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 || x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { i = ( int ) sqrt (( double ) x ); for ( n = 3 ; n <= i ; n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { int m , n , i ; map < int , int > q ; int j = 1 ; cin >> m >> n ; for ( i = 1 ; i <= 110000 ; i ++ ) { if ( isprime ( i )) { q [ j ++ ] = i ; } } j = 1 ; for ( i = m ; i < n ; i ++ ) { if ( j % 10 ) { cout << q [ i ] << \" \" ; } else { cout << q [ i ] << endl ; } j ++ ; } cout << q [ i ] << endl ; }","title":"1013-\u6570\u7d20\u6570"},{"location":"PAT-Basic-Level/1013-%E6%95%B0%E7%B4%A0%E6%95%B0/#1013-\u6570\u7d20\u6570","text":"","title":"1013 \u6570\u7d20\u6570"},{"location":"PAT-Basic-Level/1013-%E6%95%B0%E7%B4%A0%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee4 P_i P_i \u8868\u793a\u7b2c i i \u4e2a\u7d20\u6570\u3002\u73b0\u4efb\u7ed9\u4e24\u4e2a\u6b63\u6574\u6570 M \\le N \\le 10^4 M \\le N \\le 10^4 \uff0c\u8bf7\u8f93\u51fa P_M P_M \u5230 P_N P_N \u7684\u6240\u6709\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u548c N N \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u4ece P_M P_M \u5230 P_N P_N \u7684\u6240\u6709\u7d20\u6570\uff0c\u6bcf 10 \u4e2a\u6570\u5b57\u5360 1 \u884c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 27 \u8f93\u51fa\u6837\u4f8b 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103","title":"Statement"},{"location":"PAT-Basic-Level/1013-%E6%95%B0%E7%B4%A0%E6%95%B0/#solution","text":"C++ #include <cmath> #include <iostream> #include <map> #include <string> using namespace std ; #define MAXN 100000 int isprime ( int x ) { int flag ; int n , i ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 || x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { i = ( int ) sqrt (( double ) x ); for ( n = 3 ; n <= i ; n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { int m , n , i ; map < int , int > q ; int j = 1 ; cin >> m >> n ; for ( i = 1 ; i <= 110000 ; i ++ ) { if ( isprime ( i )) { q [ j ++ ] = i ; } } j = 1 ; for ( i = m ; i < n ; i ++ ) { if ( j % 10 ) { cout << q [ i ] << \" \" ; } else { cout << q [ i ] << endl ; } j ++ ; } cout << q [ i ] << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/","text":"1014 \u798f\u5c14\u6469\u65af\u7684\u7ea6\u4f1a Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u4fa6\u63a2\u798f\u5c14\u6469\u65af\u63a5\u5230\u4e00\u5f20\u5947\u602a\u7684\u5b57\u6761\uff1a \u6211\u4eec\u7ea6\u4f1a\u5427\uff01 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm \u5927\u4fa6\u63a2\u5f88\u5feb\u5c31\u660e\u767d\u4e86\uff0c\u5b57\u6761\u4e0a\u5947\u602a\u7684\u4e71\u7801\u5b9e\u9645\u4e0a\u5c31\u662f\u7ea6\u4f1a\u7684\u65f6\u95f4 \u661f\u671f\u56db 14:04 \uff0c\u56e0\u4e3a\u524d\u9762\u4e24\u5b57\u7b26\u4e32\u4e2d\u7b2c 1 \u5bf9\u76f8\u540c\u7684\u5927\u5199\u82f1\u6587\u5b57\u6bcd\uff08\u5927\u5c0f\u5199\u6709\u533a\u5206\uff09\u662f\u7b2c 4 \u4e2a\u5b57\u6bcd D \uff0c\u4ee3\u8868\u661f\u671f\u56db\uff1b\u7b2c 2 \u5bf9\u76f8\u540c\u7684\u5b57\u7b26\u662f E \uff0c\u90a3\u662f\u7b2c 5 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff0c\u4ee3\u8868\u4e00\u5929\u91cc\u7684\u7b2c 14 \u4e2a\u949f\u5934\uff08\u4e8e\u662f\u4e00\u5929\u7684 0 \u70b9\u5230 23 \u70b9\u7531\u6570\u5b57 0 \u5230 9\u3001\u4ee5\u53ca\u5927\u5199\u5b57\u6bcd A \u5230 N \u8868\u793a\uff09\uff1b\u540e\u9762\u4e24\u5b57\u7b26\u4e32\u7b2c 1 \u5bf9\u76f8\u540c\u7684\u82f1\u6587\u5b57\u6bcd s \u51fa\u73b0\u5728\u7b2c 4 \u4e2a\u4f4d\u7f6e\uff08\u4ece 0 \u5f00\u59cb\u8ba1\u6570\uff09\u4e0a\uff0c\u4ee3\u8868\u7b2c 4 \u5206\u949f\u3002\u73b0\u7ed9\u5b9a\u4e24\u5bf9\u5b57\u7b26\u4e32\uff0c\u8bf7\u5e2e\u52a9\u798f\u5c14\u6469\u65af\u89e3\u7801\u5f97\u5230\u7ea6\u4f1a\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 4 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa 4 \u4e2a\u975e\u7a7a\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u3001\u4e14\u957f\u5ea6\u4e0d\u8d85\u8fc7 60 \u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ea6\u4f1a\u7684\u65f6\u95f4\uff0c\u683c\u5f0f\u4e3a DAY HH:MM \uff0c\u5176\u4e2d DAY \u662f\u67d0\u661f\u671f\u7684 3 \u5b57\u7b26\u7f29\u5199\uff0c\u5373 MON \u8868\u793a\u661f\u671f\u4e00\uff0c TUE \u8868\u793a\u661f\u671f\u4e8c\uff0c WED \u8868\u793a\u661f\u671f\u4e09\uff0c THU \u8868\u793a\u661f\u671f\u56db\uff0c FRI \u8868\u793a\u661f\u671f\u4e94\uff0c SAT \u8868\u793a\u661f\u671f\u516d\uff0c SUN \u8868\u793a\u661f\u671f\u65e5\u3002\u9898\u76ee\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u6d4b\u8bd5\u5b58\u5728\u552f\u4e00\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm \u8f93\u51fa\u6837\u4f8b THU 14:04 Solution C++ #include <iostream> #include <string> using namespace std ; int main () { string s1 , s2 ; cin >> s1 >> s2 ; int week = 0 , hour = 0 , minute = 0 ; int len1 = s1 . size (), len2 = s2 . size (); int len = min ( len1 , len2 ), flag1 = 1 , flag2 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] >= 65 && s1 [ i ] <= 71 && s1 [ i ] == s2 [ i ]) { week = s1 [ i ] - 'A' + 1 ; break ; // cout<<week<<endl; } } for ( int i = 0 ; i < len ; i ++ ) { if ( flag1 ) { if ( s1 [ i ] == s2 [ i ]) { flag1 = 0 ; flag2 = 1 ; i ++ ; } } if ( flag2 ) { if ( s1 [ i ] == s2 [ i ]) { if ( s1 [ i ] >= '0' && s1 [ i ] <= '9' ) { hour = s1 [ i ] - '0' ; break ; } else if ( s1 [ i ] >= 'A' && s1 [ i ] <= 'N' ) { hour = s1 [ i ] - 55 ; //-55 break ; } } } } cin >> s1 >> s2 ; len1 = s1 . size (), len2 = s2 . size (); len = min ( len1 , len2 ); for ( int i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] == s2 [ i ]) { if (( s1 [ i ] >= 'a' && s1 [ i ] <= 'z' ) || ( s1 [ i ] >= 65 && s1 [ i ] <= 90 )) { minute = i ; break ; } } } switch ( week ) { case 1 : printf ( \"MON \" ); break ; case 2 : printf ( \"TUE \" ); break ; case 3 : printf ( \"WED \" ); break ; case 4 : printf ( \"THU \" ); break ; case 5 : printf ( \"FRI \" ); break ; case 6 : printf ( \"SAT \" ); break ; case 7 : printf ( \"SUN \" ); break ; } printf ( \"%02d:%02d \\n \" , hour , minute ); }","title":"1014-\u798f\u5c14\u6469\u65af\u7684\u7ea6\u4f1a"},{"location":"PAT-Basic-Level/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/#1014-\u798f\u5c14\u6469\u65af\u7684\u7ea6\u4f1a","text":"","title":"1014 \u798f\u5c14\u6469\u65af\u7684\u7ea6\u4f1a"},{"location":"PAT-Basic-Level/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u4fa6\u63a2\u798f\u5c14\u6469\u65af\u63a5\u5230\u4e00\u5f20\u5947\u602a\u7684\u5b57\u6761\uff1a \u6211\u4eec\u7ea6\u4f1a\u5427\uff01 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm \u5927\u4fa6\u63a2\u5f88\u5feb\u5c31\u660e\u767d\u4e86\uff0c\u5b57\u6761\u4e0a\u5947\u602a\u7684\u4e71\u7801\u5b9e\u9645\u4e0a\u5c31\u662f\u7ea6\u4f1a\u7684\u65f6\u95f4 \u661f\u671f\u56db 14:04 \uff0c\u56e0\u4e3a\u524d\u9762\u4e24\u5b57\u7b26\u4e32\u4e2d\u7b2c 1 \u5bf9\u76f8\u540c\u7684\u5927\u5199\u82f1\u6587\u5b57\u6bcd\uff08\u5927\u5c0f\u5199\u6709\u533a\u5206\uff09\u662f\u7b2c 4 \u4e2a\u5b57\u6bcd D \uff0c\u4ee3\u8868\u661f\u671f\u56db\uff1b\u7b2c 2 \u5bf9\u76f8\u540c\u7684\u5b57\u7b26\u662f E \uff0c\u90a3\u662f\u7b2c 5 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff0c\u4ee3\u8868\u4e00\u5929\u91cc\u7684\u7b2c 14 \u4e2a\u949f\u5934\uff08\u4e8e\u662f\u4e00\u5929\u7684 0 \u70b9\u5230 23 \u70b9\u7531\u6570\u5b57 0 \u5230 9\u3001\u4ee5\u53ca\u5927\u5199\u5b57\u6bcd A \u5230 N \u8868\u793a\uff09\uff1b\u540e\u9762\u4e24\u5b57\u7b26\u4e32\u7b2c 1 \u5bf9\u76f8\u540c\u7684\u82f1\u6587\u5b57\u6bcd s \u51fa\u73b0\u5728\u7b2c 4 \u4e2a\u4f4d\u7f6e\uff08\u4ece 0 \u5f00\u59cb\u8ba1\u6570\uff09\u4e0a\uff0c\u4ee3\u8868\u7b2c 4 \u5206\u949f\u3002\u73b0\u7ed9\u5b9a\u4e24\u5bf9\u5b57\u7b26\u4e32\uff0c\u8bf7\u5e2e\u52a9\u798f\u5c14\u6469\u65af\u89e3\u7801\u5f97\u5230\u7ea6\u4f1a\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 4 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa 4 \u4e2a\u975e\u7a7a\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u3001\u4e14\u957f\u5ea6\u4e0d\u8d85\u8fc7 60 \u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ea6\u4f1a\u7684\u65f6\u95f4\uff0c\u683c\u5f0f\u4e3a DAY HH:MM \uff0c\u5176\u4e2d DAY \u662f\u67d0\u661f\u671f\u7684 3 \u5b57\u7b26\u7f29\u5199\uff0c\u5373 MON \u8868\u793a\u661f\u671f\u4e00\uff0c TUE \u8868\u793a\u661f\u671f\u4e8c\uff0c WED \u8868\u793a\u661f\u671f\u4e09\uff0c THU \u8868\u793a\u661f\u671f\u56db\uff0c FRI \u8868\u793a\u661f\u671f\u4e94\uff0c SAT \u8868\u793a\u661f\u671f\u516d\uff0c SUN \u8868\u793a\u661f\u671f\u65e5\u3002\u9898\u76ee\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u6d4b\u8bd5\u5b58\u5728\u552f\u4e00\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm \u8f93\u51fa\u6837\u4f8b THU 14:04","title":"Statement"},{"location":"PAT-Basic-Level/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/#solution","text":"C++ #include <iostream> #include <string> using namespace std ; int main () { string s1 , s2 ; cin >> s1 >> s2 ; int week = 0 , hour = 0 , minute = 0 ; int len1 = s1 . size (), len2 = s2 . size (); int len = min ( len1 , len2 ), flag1 = 1 , flag2 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] >= 65 && s1 [ i ] <= 71 && s1 [ i ] == s2 [ i ]) { week = s1 [ i ] - 'A' + 1 ; break ; // cout<<week<<endl; } } for ( int i = 0 ; i < len ; i ++ ) { if ( flag1 ) { if ( s1 [ i ] == s2 [ i ]) { flag1 = 0 ; flag2 = 1 ; i ++ ; } } if ( flag2 ) { if ( s1 [ i ] == s2 [ i ]) { if ( s1 [ i ] >= '0' && s1 [ i ] <= '9' ) { hour = s1 [ i ] - '0' ; break ; } else if ( s1 [ i ] >= 'A' && s1 [ i ] <= 'N' ) { hour = s1 [ i ] - 55 ; //-55 break ; } } } } cin >> s1 >> s2 ; len1 = s1 . size (), len2 = s2 . size (); len = min ( len1 , len2 ); for ( int i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] == s2 [ i ]) { if (( s1 [ i ] >= 'a' && s1 [ i ] <= 'z' ) || ( s1 [ i ] >= 65 && s1 [ i ] <= 90 )) { minute = i ; break ; } } } switch ( week ) { case 1 : printf ( \"MON \" ); break ; case 2 : printf ( \"TUE \" ); break ; case 3 : printf ( \"WED \" ); break ; case 4 : printf ( \"THU \" ); break ; case 5 : printf ( \"FRI \" ); break ; case 6 : printf ( \"SAT \" ); break ; case 7 : printf ( \"SUN \" ); break ; } printf ( \"%02d:%02d \\n \" , hour , minute ); }","title":"Solution"},{"location":"PAT-Basic-Level/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/","text":"1015 \u5fb7\u624d\u8bba Statement Metadata \u4f5c\u8005: CHEN, Li \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b8b\u4ee3\u53f2\u5b66\u5bb6\u53f8\u9a6c\u5149\u5728\u300a\u8d44\u6cbb\u901a\u9274\u300b\u4e2d\u6709\u4e00\u6bb5\u8457\u540d\u7684\u201c\u5fb7\u624d\u8bba\u201d\uff1a\u201c\u662f\u6545\u624d\u5fb7\u5168\u5c3d\u8c13\u4e4b\u5723\u4eba\uff0c\u624d\u5fb7\u517c\u4ea1\u8c13\u4e4b\u611a\u4eba\uff0c\u5fb7\u80dc\u624d\u8c13\u4e4b\u541b\u5b50\uff0c\u624d\u80dc\u5fb7\u8c13\u4e4b\u5c0f\u4eba\u3002\u51e1\u53d6\u4eba\u4e4b\u672f\uff0c\u82df\u4e0d\u5f97\u5723\u4eba\uff0c\u541b\u5b50\u800c\u4e0e\u4e4b\uff0c\u4e0e\u5176\u5f97\u5c0f\u4eba\uff0c\u4e0d\u82e5\u5f97\u611a\u4eba\u3002\u201d \u73b0\u7ed9\u51fa\u4e00\u6279\u8003\u751f\u7684\u5fb7\u624d\u5206\u6570\uff0c\u8bf7\u6839\u636e\u53f8\u9a6c\u5149\u7684\u7406\u8bba\u7ed9\u51fa\u5f55\u53d6\u6392\u540d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u4e3a\uff1a N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u8003\u751f\u603b\u6570\uff1b L L \uff08 \\ge 60 \\ge 60 \uff09\uff0c\u4e3a\u5f55\u53d6\u6700\u4f4e\u5206\u6570\u7ebf\uff0c\u5373\u5fb7\u5206\u548c\u624d\u5206\u5747\u4e0d\u4f4e\u4e8e L L \u7684\u8003\u751f\u624d\u6709\u8d44\u683c\u88ab\u8003\u8651\u5f55\u53d6\uff1b H H \uff08 < 100 < 100 \uff09\uff0c\u4e3a\u4f18\u5148\u5f55\u53d6\u7ebf\u2014\u2014\u5fb7\u5206\u548c\u624d\u5206\u5747\u4e0d\u4f4e\u4e8e\u6b64\u7ebf\u7684\u88ab\u5b9a\u4e49\u4e3a\u201c\u624d\u5fb7\u5168\u5c3d\u201d\uff0c\u6b64\u7c7b\u8003\u751f\u6309\u5fb7\u624d\u603b\u5206\u4ece\u9ad8\u5230\u4f4e\u6392\u5e8f\uff1b\u624d\u5206\u4e0d\u5230\u4f46\u5fb7\u5206\u5230\u7ebf\u7684\u4e00\u7c7b\u8003\u751f\u5c5e\u4e8e\u201c\u5fb7\u80dc\u624d\u201d\uff0c\u4e5f\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e00\u7c7b\u8003\u751f\u4e4b\u540e\uff1b\u5fb7\u624d\u5206\u5747\u4f4e\u4e8e H H \uff0c\u4f46\u662f\u5fb7\u5206\u4e0d\u4f4e\u4e8e\u624d\u5206\u7684\u8003\u751f\u5c5e\u4e8e\u201c\u624d\u5fb7\u517c\u4ea1\u201d\u4f46\u5c1a\u6709\u201c\u5fb7\u80dc\u624d\u201d\u8005\uff0c\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e8c\u7c7b\u8003\u751f\u4e4b\u540e\uff1b\u5176\u4ed6\u8fbe\u5230\u6700\u4f4e\u7ebf L L \u7684\u8003\u751f\u4e5f\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e09\u7c7b\u8003\u751f\u4e4b\u540e\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u8003\u751f\u7684\u4fe1\u606f\uff0c\u5305\u62ec\uff1a \u51c6\u8003\u8bc1\u53f7 \u5fb7\u5206 \u624d\u5206 \uff0c\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u4e3a 8 \u4f4d\u6574\u6570\uff0c\u5fb7\u624d\u5206\u4e3a\u533a\u95f4 [0, 100] \u5185\u7684\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7b2c\u4e00\u884c\u9996\u5148\u7ed9\u51fa\u8fbe\u5230\u6700\u4f4e\u5206\u6570\u7ebf\u7684\u8003\u751f\u4eba\u6570 M M \uff0c\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u6309\u7167\u8f93\u5165\u683c\u5f0f\u8f93\u51fa\u4e00\u4f4d\u8003\u751f\u7684\u4fe1\u606f\uff0c\u8003\u751f\u6309\u8f93\u5165\u4e2d\u8bf4\u660e\u7684\u89c4\u5219\u4ece\u9ad8\u5230\u4f4e\u6392\u5e8f\u3002\u5f53\u67d0\u7c7b\u8003\u751f\u4e2d\u6709\u591a\u4eba\u603b\u5206\u76f8\u540c\u65f6\uff0c\u6309\u5176\u5fb7\u5206\u964d\u5e8f\u6392\u5217\uff1b\u82e5\u5fb7\u5206\u4e5f\u5e76\u5217\uff0c\u5219\u6309\u51c6\u8003\u8bc1\u53f7\u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 \u8f93\u51fa\u6837\u4f8b 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 struct pp { int num ; int a , b , total , level ; } q [ MAXN ]; int comp ( pp x , pp y ) { if ( x . level < y . level ) return 1 ; else if ( x . level == y . level ) { if ( x . total > y . total ) return 1 ; else if ( x . total == y . total ) { if ( x . a > y . a ) return 1 ; else if ( x . a == y . a ) { if ( x . num < y . num ) return 1 ; } } } return 0 ; } int main () { int n , L , H , a , b , i , j , total , num ; cin >> n >> L >> H ; for ( i = 0 , j = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & num , & a , & b ); // cout<<a<<\" \"<<b<<endl; if ( a >= L && b >= L ) { q [ j ]. num = num , q [ j ]. a = a , q [ j ]. b = b , q [ j ]. total = q [ j ]. a + q [ j ]. b ; if ( a >= H && b >= H ) q [ j ]. level = 1 ; else if ( a >= H && b < H ) q [ j ]. level = 2 ; else if ( a >= b && a < H && b < H ) q [ j ]. level = 3 ; else q [ j ]. level = 4 ; // cout<<q[j].level<<endl; j ++ ; } } total = j ; sort ( q , q + total , comp ); printf ( \"%d \\n \" , total ); for ( i = 0 ; i < total ; i ++ ) { printf ( \"%d %d %d \\n \" , q [ i ]. num , q [ i ]. a , q [ i ]. b ); // cout<<q[i].level<<\" \"<<q[i].total<<endl; } }","title":"1015-\u5fb7\u624d\u8bba"},{"location":"PAT-Basic-Level/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/#1015-\u5fb7\u624d\u8bba","text":"","title":"1015 \u5fb7\u624d\u8bba"},{"location":"PAT-Basic-Level/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/#statement","text":"Metadata \u4f5c\u8005: CHEN, Li \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b8b\u4ee3\u53f2\u5b66\u5bb6\u53f8\u9a6c\u5149\u5728\u300a\u8d44\u6cbb\u901a\u9274\u300b\u4e2d\u6709\u4e00\u6bb5\u8457\u540d\u7684\u201c\u5fb7\u624d\u8bba\u201d\uff1a\u201c\u662f\u6545\u624d\u5fb7\u5168\u5c3d\u8c13\u4e4b\u5723\u4eba\uff0c\u624d\u5fb7\u517c\u4ea1\u8c13\u4e4b\u611a\u4eba\uff0c\u5fb7\u80dc\u624d\u8c13\u4e4b\u541b\u5b50\uff0c\u624d\u80dc\u5fb7\u8c13\u4e4b\u5c0f\u4eba\u3002\u51e1\u53d6\u4eba\u4e4b\u672f\uff0c\u82df\u4e0d\u5f97\u5723\u4eba\uff0c\u541b\u5b50\u800c\u4e0e\u4e4b\uff0c\u4e0e\u5176\u5f97\u5c0f\u4eba\uff0c\u4e0d\u82e5\u5f97\u611a\u4eba\u3002\u201d \u73b0\u7ed9\u51fa\u4e00\u6279\u8003\u751f\u7684\u5fb7\u624d\u5206\u6570\uff0c\u8bf7\u6839\u636e\u53f8\u9a6c\u5149\u7684\u7406\u8bba\u7ed9\u51fa\u5f55\u53d6\u6392\u540d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u4e3a\uff1a N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u8003\u751f\u603b\u6570\uff1b L L \uff08 \\ge 60 \\ge 60 \uff09\uff0c\u4e3a\u5f55\u53d6\u6700\u4f4e\u5206\u6570\u7ebf\uff0c\u5373\u5fb7\u5206\u548c\u624d\u5206\u5747\u4e0d\u4f4e\u4e8e L L \u7684\u8003\u751f\u624d\u6709\u8d44\u683c\u88ab\u8003\u8651\u5f55\u53d6\uff1b H H \uff08 < 100 < 100 \uff09\uff0c\u4e3a\u4f18\u5148\u5f55\u53d6\u7ebf\u2014\u2014\u5fb7\u5206\u548c\u624d\u5206\u5747\u4e0d\u4f4e\u4e8e\u6b64\u7ebf\u7684\u88ab\u5b9a\u4e49\u4e3a\u201c\u624d\u5fb7\u5168\u5c3d\u201d\uff0c\u6b64\u7c7b\u8003\u751f\u6309\u5fb7\u624d\u603b\u5206\u4ece\u9ad8\u5230\u4f4e\u6392\u5e8f\uff1b\u624d\u5206\u4e0d\u5230\u4f46\u5fb7\u5206\u5230\u7ebf\u7684\u4e00\u7c7b\u8003\u751f\u5c5e\u4e8e\u201c\u5fb7\u80dc\u624d\u201d\uff0c\u4e5f\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e00\u7c7b\u8003\u751f\u4e4b\u540e\uff1b\u5fb7\u624d\u5206\u5747\u4f4e\u4e8e H H \uff0c\u4f46\u662f\u5fb7\u5206\u4e0d\u4f4e\u4e8e\u624d\u5206\u7684\u8003\u751f\u5c5e\u4e8e\u201c\u624d\u5fb7\u517c\u4ea1\u201d\u4f46\u5c1a\u6709\u201c\u5fb7\u80dc\u624d\u201d\u8005\uff0c\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e8c\u7c7b\u8003\u751f\u4e4b\u540e\uff1b\u5176\u4ed6\u8fbe\u5230\u6700\u4f4e\u7ebf L L \u7684\u8003\u751f\u4e5f\u6309\u603b\u5206\u6392\u5e8f\uff0c\u4f46\u6392\u5728\u7b2c\u4e09\u7c7b\u8003\u751f\u4e4b\u540e\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u8003\u751f\u7684\u4fe1\u606f\uff0c\u5305\u62ec\uff1a \u51c6\u8003\u8bc1\u53f7 \u5fb7\u5206 \u624d\u5206 \uff0c\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u4e3a 8 \u4f4d\u6574\u6570\uff0c\u5fb7\u624d\u5206\u4e3a\u533a\u95f4 [0, 100] \u5185\u7684\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7b2c\u4e00\u884c\u9996\u5148\u7ed9\u51fa\u8fbe\u5230\u6700\u4f4e\u5206\u6570\u7ebf\u7684\u8003\u751f\u4eba\u6570 M M \uff0c\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u6309\u7167\u8f93\u5165\u683c\u5f0f\u8f93\u51fa\u4e00\u4f4d\u8003\u751f\u7684\u4fe1\u606f\uff0c\u8003\u751f\u6309\u8f93\u5165\u4e2d\u8bf4\u660e\u7684\u89c4\u5219\u4ece\u9ad8\u5230\u4f4e\u6392\u5e8f\u3002\u5f53\u67d0\u7c7b\u8003\u751f\u4e2d\u6709\u591a\u4eba\u603b\u5206\u76f8\u540c\u65f6\uff0c\u6309\u5176\u5fb7\u5206\u964d\u5e8f\u6392\u5217\uff1b\u82e5\u5fb7\u5206\u4e5f\u5e76\u5217\uff0c\u5219\u6309\u51c6\u8003\u8bc1\u53f7\u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 \u8f93\u51fa\u6837\u4f8b 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90","title":"Statement"},{"location":"PAT-Basic-Level/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 struct pp { int num ; int a , b , total , level ; } q [ MAXN ]; int comp ( pp x , pp y ) { if ( x . level < y . level ) return 1 ; else if ( x . level == y . level ) { if ( x . total > y . total ) return 1 ; else if ( x . total == y . total ) { if ( x . a > y . a ) return 1 ; else if ( x . a == y . a ) { if ( x . num < y . num ) return 1 ; } } } return 0 ; } int main () { int n , L , H , a , b , i , j , total , num ; cin >> n >> L >> H ; for ( i = 0 , j = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & num , & a , & b ); // cout<<a<<\" \"<<b<<endl; if ( a >= L && b >= L ) { q [ j ]. num = num , q [ j ]. a = a , q [ j ]. b = b , q [ j ]. total = q [ j ]. a + q [ j ]. b ; if ( a >= H && b >= H ) q [ j ]. level = 1 ; else if ( a >= H && b < H ) q [ j ]. level = 2 ; else if ( a >= b && a < H && b < H ) q [ j ]. level = 3 ; else q [ j ]. level = 4 ; // cout<<q[j].level<<endl; j ++ ; } } total = j ; sort ( q , q + total , comp ); printf ( \"%d \\n \" , total ); for ( i = 0 ; i < total ; i ++ ) { printf ( \"%d %d %d \\n \" , q [ i ]. num , q [ i ]. a , q [ i ]. b ); // cout<<q[i].level<<\" \"<<q[i].total<<endl; } }","title":"Solution"},{"location":"PAT-Basic-Level/1016-%E9%83%A8%E5%88%86A%2BB/","text":"1016 \u90e8\u5206A+B Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6b63\u6574\u6570 A A \u7684\u201c D_A D_A \uff08\u4e3a 1 \u4f4d\u6574\u6570\uff09\u90e8\u5206\u201d\u5b9a\u4e49\u4e3a\u7531 A A \u4e2d\u6240\u6709 D_A D_A \u7ec4\u6210\u7684\u65b0\u6574\u6570 P_A P_A \u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a A = 3862767 A = 3862767 \uff0c D_A = 6 D_A = 6 \uff0c\u5219 A A \u7684\u201c6 \u90e8\u5206\u201d P_A P_A \u662f 66\uff0c\u56e0\u4e3a A A \u4e2d\u6709 2 \u4e2a 6\u3002 \u73b0\u7ed9\u5b9a A A \u3001 D_A D_A \u3001 B B \u3001 D_B D_B \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8ba1\u7b97 P_A + P_B P_A + P_B \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A A \u3001 D_A D_A \u3001 B B \u3001 D_B D_B \uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u5176\u4e2d 0 < A, B < 10^{9} 0 < A, B < 10^{9} \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa P_A + P_B P_A + P_B \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 1 3862767 6 13530293 3 \u8f93\u51fa\u6837\u4f8b 1 399 \u8f93\u5165\u6837\u4f8b 2 3862767 1 13530293 8 \u8f93\u51fa\u6837\u4f8b 2 0 \u9e23\u8c22\u7528\u6237 George Hu \u4fee\u6b63\u6570\u636e\u8303\u56f4\uff01 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , tot1 = 0 , tot2 = 0 , i , j , len ; string s1 , s2 ; cin >> s1 >> a >> s2 >> b ; // cout<<s1<<endl<<a<<endl<<s2<<endl<<b<<endl; len = s1 . size (); for ( i = 0 , j = 1 ; i < len ; i ++ ) { if ( s1 [ i ] - '0' == a ) { tot1 += a * j , j *= 10 ; // cout<<tot1<<endl; } } // cout<<tot1<<endl; len = s2 . size (); for ( i = 0 , j = 1 ; i < len ; i ++ ) { if ( s2 [ i ] - '0' == b ) { tot2 += b * j , j *= 10 ; } } // cout<<tot2<<endl; cout << tot1 + tot2 << endl ; }","title":"1016-\u90e8\u5206A+B"},{"location":"PAT-Basic-Level/1016-%E9%83%A8%E5%88%86A%2BB/#1016-\u90e8\u5206ab","text":"","title":"1016 \u90e8\u5206A+B"},{"location":"PAT-Basic-Level/1016-%E9%83%A8%E5%88%86A%2BB/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6b63\u6574\u6570 A A \u7684\u201c D_A D_A \uff08\u4e3a 1 \u4f4d\u6574\u6570\uff09\u90e8\u5206\u201d\u5b9a\u4e49\u4e3a\u7531 A A \u4e2d\u6240\u6709 D_A D_A \u7ec4\u6210\u7684\u65b0\u6574\u6570 P_A P_A \u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a A = 3862767 A = 3862767 \uff0c D_A = 6 D_A = 6 \uff0c\u5219 A A \u7684\u201c6 \u90e8\u5206\u201d P_A P_A \u662f 66\uff0c\u56e0\u4e3a A A \u4e2d\u6709 2 \u4e2a 6\u3002 \u73b0\u7ed9\u5b9a A A \u3001 D_A D_A \u3001 B B \u3001 D_B D_B \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8ba1\u7b97 P_A + P_B P_A + P_B \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A A \u3001 D_A D_A \u3001 B B \u3001 D_B D_B \uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u5176\u4e2d 0 < A, B < 10^{9} 0 < A, B < 10^{9} \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa P_A + P_B P_A + P_B \u7684\u503c\u3002 \u8f93\u5165\u6837\u4f8b 1 3862767 6 13530293 3 \u8f93\u51fa\u6837\u4f8b 1 399 \u8f93\u5165\u6837\u4f8b 2 3862767 1 13530293 8 \u8f93\u51fa\u6837\u4f8b 2 0 \u9e23\u8c22\u7528\u6237 George Hu \u4fee\u6b63\u6570\u636e\u8303\u56f4\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1016-%E9%83%A8%E5%88%86A%2BB/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , tot1 = 0 , tot2 = 0 , i , j , len ; string s1 , s2 ; cin >> s1 >> a >> s2 >> b ; // cout<<s1<<endl<<a<<endl<<s2<<endl<<b<<endl; len = s1 . size (); for ( i = 0 , j = 1 ; i < len ; i ++ ) { if ( s1 [ i ] - '0' == a ) { tot1 += a * j , j *= 10 ; // cout<<tot1<<endl; } } // cout<<tot1<<endl; len = s2 . size (); for ( i = 0 , j = 1 ; i < len ; i ++ ) { if ( s2 [ i ] - '0' == b ) { tot2 += b * j , j *= 10 ; } } // cout<<tot2<<endl; cout << tot1 + tot2 << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1017-A%E9%99%A4%E4%BB%A5B/","text":"1017 A\u9664\u4ee5B Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u8ba1\u7b97 A/B A/B \uff0c\u5176\u4e2d A A \u662f\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570\uff0c B B \u662f 1 \u4f4d\u6b63\u6574\u6570\u3002\u4f60\u9700\u8981\u8f93\u51fa\u5546\u6570 Q Q \u548c\u4f59\u6570 R R \uff0c\u4f7f\u5f97 A = B \\times Q + R A = B \\times Q + R \u6210\u7acb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A A \u548c B B \uff0c\u4e2d\u95f4\u4ee5 1 \u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u8f93\u51fa Q Q \u548c R R \uff0c\u4e2d\u95f4\u4ee5 1 \u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 123456789050987654321 7 \u8f93\u51fa\u6837\u4f8b 17636684150141093474 3 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int n [ MAXN ]; int main () { string s ; int a , num ; cin >> s >> a ; int len = s . size (), i , j = 0 ; if ( len > 1 ) { num = s [ 0 ] - '0' ; if ( num / a ) n [ j ++ ] = num / a ; num %= a ; num *= 10 ; for ( i = 1 ; i < len ; i ++ ) { num += s [ i ] - '0' ; n [ j ++ ] = num / a ; num %= a ; num *= 10 ; } for ( i = 0 ; i < j ; i ++ ) printf ( \"%d\" , n [ i ]); printf ( \" %d \\n \" , num / 10 ); } else { printf ( \"%d %d \\n \" , ( s [ 0 ] - '0' ) / a , ( s [ 0 ] - '0' ) % a ); } }","title":"1017-A\u9664\u4ee5B"},{"location":"PAT-Basic-Level/1017-A%E9%99%A4%E4%BB%A5B/#1017-a\u9664\u4ee5b","text":"","title":"1017 A\u9664\u4ee5B"},{"location":"PAT-Basic-Level/1017-A%E9%99%A4%E4%BB%A5B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u8ba1\u7b97 A/B A/B \uff0c\u5176\u4e2d A A \u662f\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570\uff0c B B \u662f 1 \u4f4d\u6b63\u6574\u6570\u3002\u4f60\u9700\u8981\u8f93\u51fa\u5546\u6570 Q Q \u548c\u4f59\u6570 R R \uff0c\u4f7f\u5f97 A = B \\times Q + R A = B \\times Q + R \u6210\u7acb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A A \u548c B B \uff0c\u4e2d\u95f4\u4ee5 1 \u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u8f93\u51fa Q Q \u548c R R \uff0c\u4e2d\u95f4\u4ee5 1 \u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 123456789050987654321 7 \u8f93\u51fa\u6837\u4f8b 17636684150141093474 3","title":"Statement"},{"location":"PAT-Basic-Level/1017-A%E9%99%A4%E4%BB%A5B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int n [ MAXN ]; int main () { string s ; int a , num ; cin >> s >> a ; int len = s . size (), i , j = 0 ; if ( len > 1 ) { num = s [ 0 ] - '0' ; if ( num / a ) n [ j ++ ] = num / a ; num %= a ; num *= 10 ; for ( i = 1 ; i < len ; i ++ ) { num += s [ i ] - '0' ; n [ j ++ ] = num / a ; num %= a ; num *= 10 ; } for ( i = 0 ; i < j ; i ++ ) printf ( \"%d\" , n [ i ]); printf ( \" %d \\n \" , num / 10 ); } else { printf ( \"%d %d \\n \" , ( s [ 0 ] - '0' ) / a , ( s [ 0 ] - '0' ) % a ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/","text":"1018 \u9524\u5b50\u526a\u5200\u5e03 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5e94\u8be5\u90fd\u4f1a\u73a9\u201c\u9524\u5b50\u526a\u5200\u5e03\u201d\u7684\u6e38\u620f\uff1a\u4e24\u4eba\u540c\u65f6\u7ed9\u51fa\u624b\u52bf\uff0c\u80dc\u8d1f\u89c4\u5219\u5982\u56fe\u6240\u793a\uff1a \u73b0\u7ed9\u51fa\u4e24\u4eba\u7684\u4ea4\u950b\u8bb0\u5f55\uff0c\u8bf7\u7edf\u8ba1\u53cc\u65b9\u7684\u80dc\u3001\u5e73\u3001\u8d1f\u6b21\u6570\uff0c\u5e76\u4e14\u7ed9\u51fa\u53cc\u65b9\u5206\u522b\u51fa\u4ec0\u4e48\u624b\u52bf\u7684\u80dc\u7b97\u6700\u5927\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u53cc\u65b9\u4ea4\u950b\u7684\u6b21\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6b21\u4ea4\u950b\u7684\u4fe1\u606f\uff0c\u5373\u7532\u3001\u4e59\u53cc\u65b9\u540c\u65f6\u7ed9\u51fa\u7684\u7684\u624b\u52bf\u3002 C \u4ee3\u8868\u201c\u9524\u5b50\u201d\u3001 J \u4ee3\u8868\u201c\u526a\u5200\u201d\u3001 B \u4ee3\u8868\u201c\u5e03\u201d\uff0c\u7b2c 1 \u4e2a\u5b57\u6bcd\u4ee3\u8868\u7532\u65b9\uff0c\u7b2c 2 \u4e2a\u4ee3\u8868\u4e59\u65b9\uff0c\u4e2d\u95f4\u6709 1 \u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7b2c 1\u30012 \u884c\u5206\u522b\u7ed9\u51fa\u7532\u3001\u4e59\u7684\u80dc\u3001\u5e73\u3001\u8d1f\u6b21\u6570\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u7b2c 3 \u884c\u7ed9\u51fa\u4e24\u4e2a\u5b57\u6bcd\uff0c\u5206\u522b\u4ee3\u8868\u7532\u3001\u4e59\u83b7\u80dc\u6b21\u6570\u6700\u591a\u7684\u624b\u52bf\uff0c\u4e2d\u95f4\u6709 1 \u4e2a\u7a7a\u683c\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6309\u5b57\u6bcd\u5e8f\u6700\u5c0f\u7684\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 10 C J J B C B B B B C C C C B J B B C J J \u8f93\u51fa\u6837\u4f8b 5 3 2 2 3 5 B B Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , j , win = 0 , def = 0 , ave = 0 , max [ 2 ][ 3 ] = { 0 }, flag1 , flag2 , max1 = -1 , max2 = -1 ; char a , b ; string s = \"BCJ\" ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \" %c %c\" , & a , & b ); if (( a == 'C' && b == 'J' ) || ( a == 'J' && b == 'B' ) || ( a == 'B' && b == 'C' )) { win ++ ; for ( j = 0 ; j < 3 ; j ++ ) if ( a == s [ j ]) max [ 0 ][ j ] ++ ; } else if ( a == b ) ave ++ ; else { def ++ ; for ( j = 0 ; j < 3 ; j ++ ) if ( b == s [ j ]) max [ 1 ][ j ] ++ ; } } printf ( \"%d %d %d \\n \" , win , ave , def ); printf ( \"%d %d %d \\n \" , def , ave , win ); for ( i = 0 ; i < 3 ; i ++ ) { if ( max [ 0 ][ i ] > max1 ) { max1 = max [ 0 ][ i ]; flag1 = i ; } if ( max [ 1 ][ i ] > max2 ) { max2 = max [ 1 ][ i ]; flag2 = i ; } } cout << s [ flag1 ] << \" \" << s [ flag2 ] << endl ; }","title":"1018-\u9524\u5b50\u526a\u5200\u5e03"},{"location":"PAT-Basic-Level/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/#1018-\u9524\u5b50\u526a\u5200\u5e03","text":"","title":"1018 \u9524\u5b50\u526a\u5200\u5e03"},{"location":"PAT-Basic-Level/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5927\u5bb6\u5e94\u8be5\u90fd\u4f1a\u73a9\u201c\u9524\u5b50\u526a\u5200\u5e03\u201d\u7684\u6e38\u620f\uff1a\u4e24\u4eba\u540c\u65f6\u7ed9\u51fa\u624b\u52bf\uff0c\u80dc\u8d1f\u89c4\u5219\u5982\u56fe\u6240\u793a\uff1a \u73b0\u7ed9\u51fa\u4e24\u4eba\u7684\u4ea4\u950b\u8bb0\u5f55\uff0c\u8bf7\u7edf\u8ba1\u53cc\u65b9\u7684\u80dc\u3001\u5e73\u3001\u8d1f\u6b21\u6570\uff0c\u5e76\u4e14\u7ed9\u51fa\u53cc\u65b9\u5206\u522b\u51fa\u4ec0\u4e48\u624b\u52bf\u7684\u80dc\u7b97\u6700\u5927\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u53cc\u65b9\u4ea4\u950b\u7684\u6b21\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u6b21\u4ea4\u950b\u7684\u4fe1\u606f\uff0c\u5373\u7532\u3001\u4e59\u53cc\u65b9\u540c\u65f6\u7ed9\u51fa\u7684\u7684\u624b\u52bf\u3002 C \u4ee3\u8868\u201c\u9524\u5b50\u201d\u3001 J \u4ee3\u8868\u201c\u526a\u5200\u201d\u3001 B \u4ee3\u8868\u201c\u5e03\u201d\uff0c\u7b2c 1 \u4e2a\u5b57\u6bcd\u4ee3\u8868\u7532\u65b9\uff0c\u7b2c 2 \u4e2a\u4ee3\u8868\u4e59\u65b9\uff0c\u4e2d\u95f4\u6709 1 \u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7b2c 1\u30012 \u884c\u5206\u522b\u7ed9\u51fa\u7532\u3001\u4e59\u7684\u80dc\u3001\u5e73\u3001\u8d1f\u6b21\u6570\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u7b2c 3 \u884c\u7ed9\u51fa\u4e24\u4e2a\u5b57\u6bcd\uff0c\u5206\u522b\u4ee3\u8868\u7532\u3001\u4e59\u83b7\u80dc\u6b21\u6570\u6700\u591a\u7684\u624b\u52bf\uff0c\u4e2d\u95f4\u6709 1 \u4e2a\u7a7a\u683c\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6309\u5b57\u6bcd\u5e8f\u6700\u5c0f\u7684\u89e3\u3002 \u8f93\u5165\u6837\u4f8b 10 C J J B C B B B B C C C C B J B B C J J \u8f93\u51fa\u6837\u4f8b 5 3 2 2 3 5 B B","title":"Statement"},{"location":"PAT-Basic-Level/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , i , j , win = 0 , def = 0 , ave = 0 , max [ 2 ][ 3 ] = { 0 }, flag1 , flag2 , max1 = -1 , max2 = -1 ; char a , b ; string s = \"BCJ\" ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \" %c %c\" , & a , & b ); if (( a == 'C' && b == 'J' ) || ( a == 'J' && b == 'B' ) || ( a == 'B' && b == 'C' )) { win ++ ; for ( j = 0 ; j < 3 ; j ++ ) if ( a == s [ j ]) max [ 0 ][ j ] ++ ; } else if ( a == b ) ave ++ ; else { def ++ ; for ( j = 0 ; j < 3 ; j ++ ) if ( b == s [ j ]) max [ 1 ][ j ] ++ ; } } printf ( \"%d %d %d \\n \" , win , ave , def ); printf ( \"%d %d %d \\n \" , def , ave , win ); for ( i = 0 ; i < 3 ; i ++ ) { if ( max [ 0 ][ i ] > max1 ) { max1 = max [ 0 ][ i ]; flag1 = i ; } if ( max [ 1 ][ i ] > max2 ) { max2 = max [ 1 ][ i ]; flag2 = i ; } } cout << s [ flag1 ] << \" \" << s [ flag2 ] << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/","text":"1019 \u6570\u5b57\u9ed1\u6d1e Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4efb\u4e00\u4e2a\u5404\u4f4d\u6570\u5b57\u4e0d\u5b8c\u5168\u76f8\u540c\u7684 4 \u4f4d\u6b63\u6574\u6570\uff0c\u5982\u679c\u6211\u4eec\u5148\u628a 4 \u4e2a\u6570\u5b57\u6309\u975e\u9012\u589e\u6392\u5e8f\uff0c\u518d\u6309\u975e\u9012\u51cf\u6392\u5e8f\uff0c\u7136\u540e\u7528\u7b2c 1 \u4e2a\u6570\u5b57\u51cf\u7b2c 2 \u4e2a\u6570\u5b57\uff0c\u5c06\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u6570\u5b57\u3002\u4e00\u76f4\u91cd\u590d\u8fd9\u6837\u505a\uff0c\u6211\u4eec\u5f88\u5feb\u4f1a\u505c\u5728\u6709\u201c\u6570\u5b57\u9ed1\u6d1e\u201d\u4e4b\u79f0\u7684 6174 \uff0c\u8fd9\u4e2a\u795e\u5947\u7684\u6570\u5b57\u4e5f\u53eb Kaprekar \u5e38\u6570\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u4ece 6767 \u5f00\u59cb\uff0c\u5c06\u5f97\u5230 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 ... ... \u73b0\u7ed9\u5b9a\u4efb\u610f 4 \u4f4d\u6b63\u6574\u6570\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u6f14\u793a\u5230\u8fbe\u9ed1\u6d1e\u7684\u8fc7\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u4e00\u4e2a (0, 10^4) (0, 10^4) \u533a\u95f4\u5185\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c N N \u7684 4 \u4f4d\u6570\u5b57\u5168\u76f8\u7b49\uff0c\u5219\u5728\u4e00\u884c\u5185\u8f93\u51fa N - N = 0000 \uff1b\u5426\u5219\u5c06\u8ba1\u7b97\u7684\u6bcf\u4e00\u6b65\u5728\u4e00\u884c\u5185\u8f93\u51fa\uff0c\u76f4\u5230 6174 \u4f5c\u4e3a\u5dee\u51fa\u73b0\uff0c\u8f93\u51fa\u683c\u5f0f\u89c1\u6837\u4f8b\u3002\u6ce8\u610f\u6bcf\u4e2a\u6570\u5b57\u6309 4 \u4f4d\u6570\u683c\u5f0f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 6767 \u8f93\u51fa\u6837\u4f8b 1 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 \u8f93\u5165\u6837\u4f8b 2 2222 \u8f93\u51fa\u6837\u4f8b 2 2222 - 2222 = 0000 Solution C++ #include <iostream> #include <map> #include <string> using namespace std ; string division ( string s1 , string s2 ) { int i , m , num = 0 ; string s , c ; for ( i = 3 ; i >= 0 ; i -- ) { num += s1 [ i ] - s2 [ i ]; if ( num >= 0 ) { s += num + '0' ; num = 0 ; } else if ( num < 0 ) { num += 10 ; s += num + '0' ; num = -1 ; } } for ( i = 3 ; i >= 0 ; i -- ) { c += s [ i ]; } return c ; } string front ( string s ) { int i = 0 , j = 0 ; char temp ; int len = s . size (); for ( i = 0 ; i < 4 - len ; i ++ ) { s . insert ( 0 , \"0\" ); } for ( i = 1 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 - i ; j ++ ) { if ( s [ j ] < s [ j + 1 ]) { temp = s [ j ]; s [ j ] = s [ j + 1 ]; s [ j + 1 ] = temp ; } } } return s ; } string back ( string s ) { int i = 0 , j = 0 ; char temp ; int len = s . size (); for ( i = 0 ; i < 4 - len ; i ++ ) { s . insert ( 0 , \"0\" ); } for ( i = 1 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 - i ; j ++ ) { if ( s [ j ] > s [ j + 1 ]) { temp = s [ j ]; s [ j ] = s [ j + 1 ]; s [ j + 1 ] = temp ; } } } return s ; } int main () { string s ; int i , j , k ; cin >> s ; if ( s [ 0 ] == s [ 1 ] && s [ 2 ] == s [ 3 ] && s [ 1 ] == s [ 2 ]) { cout << s << \" - \" << s << \" = \" << \"0000 \\n \" ; // } else { cout << front ( s ) << \" - \" << back ( s ) << \" = \" ; s = division ( front ( s ), back ( s )); cout << s << endl ; while ( s != \"6174\" ) { cout << front ( s ) << \" - \" << back ( s ) << \" = \" ; s = division ( front ( s ), back ( s )); cout << s << endl ; } } }","title":"1019-\u6570\u5b57\u9ed1\u6d1e"},{"location":"PAT-Basic-Level/1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/#1019-\u6570\u5b57\u9ed1\u6d1e","text":"","title":"1019 \u6570\u5b57\u9ed1\u6d1e"},{"location":"PAT-Basic-Level/1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4efb\u4e00\u4e2a\u5404\u4f4d\u6570\u5b57\u4e0d\u5b8c\u5168\u76f8\u540c\u7684 4 \u4f4d\u6b63\u6574\u6570\uff0c\u5982\u679c\u6211\u4eec\u5148\u628a 4 \u4e2a\u6570\u5b57\u6309\u975e\u9012\u589e\u6392\u5e8f\uff0c\u518d\u6309\u975e\u9012\u51cf\u6392\u5e8f\uff0c\u7136\u540e\u7528\u7b2c 1 \u4e2a\u6570\u5b57\u51cf\u7b2c 2 \u4e2a\u6570\u5b57\uff0c\u5c06\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u6570\u5b57\u3002\u4e00\u76f4\u91cd\u590d\u8fd9\u6837\u505a\uff0c\u6211\u4eec\u5f88\u5feb\u4f1a\u505c\u5728\u6709\u201c\u6570\u5b57\u9ed1\u6d1e\u201d\u4e4b\u79f0\u7684 6174 \uff0c\u8fd9\u4e2a\u795e\u5947\u7684\u6570\u5b57\u4e5f\u53eb Kaprekar \u5e38\u6570\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u4ece 6767 \u5f00\u59cb\uff0c\u5c06\u5f97\u5230 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 7641 - 1467 = 6174 ... ... \u73b0\u7ed9\u5b9a\u4efb\u610f 4 \u4f4d\u6b63\u6574\u6570\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u6f14\u793a\u5230\u8fbe\u9ed1\u6d1e\u7684\u8fc7\u7a0b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u4e00\u4e2a (0, 10^4) (0, 10^4) \u533a\u95f4\u5185\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c N N \u7684 4 \u4f4d\u6570\u5b57\u5168\u76f8\u7b49\uff0c\u5219\u5728\u4e00\u884c\u5185\u8f93\u51fa N - N = 0000 \uff1b\u5426\u5219\u5c06\u8ba1\u7b97\u7684\u6bcf\u4e00\u6b65\u5728\u4e00\u884c\u5185\u8f93\u51fa\uff0c\u76f4\u5230 6174 \u4f5c\u4e3a\u5dee\u51fa\u73b0\uff0c\u8f93\u51fa\u683c\u5f0f\u89c1\u6837\u4f8b\u3002\u6ce8\u610f\u6bcf\u4e2a\u6570\u5b57\u6309 4 \u4f4d\u6570\u683c\u5f0f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 1 6767 \u8f93\u51fa\u6837\u4f8b 1 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 \u8f93\u5165\u6837\u4f8b 2 2222 \u8f93\u51fa\u6837\u4f8b 2 2222 - 2222 = 0000","title":"Statement"},{"location":"PAT-Basic-Level/1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/#solution","text":"C++ #include <iostream> #include <map> #include <string> using namespace std ; string division ( string s1 , string s2 ) { int i , m , num = 0 ; string s , c ; for ( i = 3 ; i >= 0 ; i -- ) { num += s1 [ i ] - s2 [ i ]; if ( num >= 0 ) { s += num + '0' ; num = 0 ; } else if ( num < 0 ) { num += 10 ; s += num + '0' ; num = -1 ; } } for ( i = 3 ; i >= 0 ; i -- ) { c += s [ i ]; } return c ; } string front ( string s ) { int i = 0 , j = 0 ; char temp ; int len = s . size (); for ( i = 0 ; i < 4 - len ; i ++ ) { s . insert ( 0 , \"0\" ); } for ( i = 1 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 - i ; j ++ ) { if ( s [ j ] < s [ j + 1 ]) { temp = s [ j ]; s [ j ] = s [ j + 1 ]; s [ j + 1 ] = temp ; } } } return s ; } string back ( string s ) { int i = 0 , j = 0 ; char temp ; int len = s . size (); for ( i = 0 ; i < 4 - len ; i ++ ) { s . insert ( 0 , \"0\" ); } for ( i = 1 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 - i ; j ++ ) { if ( s [ j ] > s [ j + 1 ]) { temp = s [ j ]; s [ j ] = s [ j + 1 ]; s [ j + 1 ] = temp ; } } } return s ; } int main () { string s ; int i , j , k ; cin >> s ; if ( s [ 0 ] == s [ 1 ] && s [ 2 ] == s [ 3 ] && s [ 1 ] == s [ 2 ]) { cout << s << \" - \" << s << \" = \" << \"0000 \\n \" ; // } else { cout << front ( s ) << \" - \" << back ( s ) << \" = \" ; s = division ( front ( s ), back ( s )); cout << s << endl ; while ( s != \"6174\" ) { cout << front ( s ) << \" - \" << back ( s ) << \" = \" ; s = division ( front ( s ), back ( s )); cout << s << endl ; } } }","title":"Solution"},{"location":"PAT-Basic-Level/1020-%E6%9C%88%E9%A5%BC/","text":"1020 \u6708\u997c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e2d\u56fd\u4eba\u5728\u4e2d\u79cb\u4f73\u8282\u65f6\u5403\u7684\u4e00\u79cd\u4f20\u7edf\u98df\u54c1\uff0c\u4e0d\u540c\u5730\u533a\u6709\u8bb8\u591a\u4e0d\u540c\u98ce\u5473\u7684\u6708\u997c\u3002\u73b0\u7ed9\u5b9a\u6240\u6709\u79cd\u7c7b\u6708\u997c\u7684\u5e93\u5b58\u91cf\u3001\u603b\u552e\u4ef7\u3001\u4ee5\u53ca\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\uff0c\u8bf7\u4f60\u8ba1\u7b97\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u662f\u591a\u5c11\u3002 \u6ce8\u610f\uff1a\u9500\u552e\u65f6\u5141\u8bb8\u53d6\u51fa\u4e00\u90e8\u5206\u5e93\u5b58\u3002\u6837\u4f8b\u7ed9\u51fa\u7684\u60c5\u5f62\u662f\u8fd9\u6837\u7684\uff1a\u5047\u5982\u6211\u4eec\u6709 3 \u79cd\u6708\u997c\uff0c\u5176\u5e93\u5b58\u91cf\u5206\u522b\u4e3a 18\u300115\u300110 \u4e07\u5428\uff0c\u603b\u552e\u4ef7\u5206\u522b\u4e3a 75\u300172\u300145 \u4ebf\u5143\u3002\u5982\u679c\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\u53ea\u6709 20 \u4e07\u5428\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u5927\u6536\u76ca\u7b56\u7565\u5e94\u8be5\u662f\u5356\u51fa\u5168\u90e8 15 \u4e07\u5428\u7b2c 2 \u79cd\u6708\u997c\u3001\u4ee5\u53ca 5 \u4e07\u5428\u7b2c 3 \u79cd\u6708\u997c\uff0c\u83b7\u5f97 72 + 45/2 = 94.5\uff08\u4ebf\u5143\uff09\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \u8868\u793a\u6708\u997c\u7684\u79cd\u7c7b\u6570\u3001\u4ee5\u53ca\u4e0d\u8d85\u8fc7 500\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\u7684\u6b63\u6574\u6570 D D \u8868\u793a\u5e02\u573a\u6700\u5927\u9700\u6c42\u91cf\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u5e93\u5b58\u91cf\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u603b\u552e\u4ef7\uff08\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u6536\u76ca\uff0c\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\u5e76\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 3 20 18 15 10 75 72 45 \u8f93\u51fa\u6837\u4f8b 94.50 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int a [ MAXN ], b [ MAXN ]; struct pp { double a , b , ave ; } q [ MAXN ]; int comp ( pp x , pp y ) { return x . ave > y . ave ; } int main () { int n , d , i ; cin >> n >> d ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & q [ i ]. a ); for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & q [ i ]. b ); q [ i ]. ave = q [ i ]. b / q [ i ]. a ; } sort ( q , q + n , comp ); // for(i=0;i<n;i++) printf(\"%lf %lf %lf\\n\",q[i].a,q[i].b,q[i].ave); double total = 0 ; i = 0 ; while ( d && i < 1000 ) { if ( d > q [ i ]. a ) { d -= ( int ) q [ i ]. a ; total += q [ i ]. b ; // cout<<total<<endl; } else { total += q [ i ]. ave * d ; d = 0 ; // cout<<total<<endl; } i ++ ; } printf ( \"%.2lf \\n \" , total ); }","title":"1020-\u6708\u997c"},{"location":"PAT-Basic-Level/1020-%E6%9C%88%E9%A5%BC/#1020-\u6708\u997c","text":"","title":"1020 \u6708\u997c"},{"location":"PAT-Basic-Level/1020-%E6%9C%88%E9%A5%BC/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e2d\u56fd\u4eba\u5728\u4e2d\u79cb\u4f73\u8282\u65f6\u5403\u7684\u4e00\u79cd\u4f20\u7edf\u98df\u54c1\uff0c\u4e0d\u540c\u5730\u533a\u6709\u8bb8\u591a\u4e0d\u540c\u98ce\u5473\u7684\u6708\u997c\u3002\u73b0\u7ed9\u5b9a\u6240\u6709\u79cd\u7c7b\u6708\u997c\u7684\u5e93\u5b58\u91cf\u3001\u603b\u552e\u4ef7\u3001\u4ee5\u53ca\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\uff0c\u8bf7\u4f60\u8ba1\u7b97\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u662f\u591a\u5c11\u3002 \u6ce8\u610f\uff1a\u9500\u552e\u65f6\u5141\u8bb8\u53d6\u51fa\u4e00\u90e8\u5206\u5e93\u5b58\u3002\u6837\u4f8b\u7ed9\u51fa\u7684\u60c5\u5f62\u662f\u8fd9\u6837\u7684\uff1a\u5047\u5982\u6211\u4eec\u6709 3 \u79cd\u6708\u997c\uff0c\u5176\u5e93\u5b58\u91cf\u5206\u522b\u4e3a 18\u300115\u300110 \u4e07\u5428\uff0c\u603b\u552e\u4ef7\u5206\u522b\u4e3a 75\u300172\u300145 \u4ebf\u5143\u3002\u5982\u679c\u5e02\u573a\u7684\u6700\u5927\u9700\u6c42\u91cf\u53ea\u6709 20 \u4e07\u5428\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u5927\u6536\u76ca\u7b56\u7565\u5e94\u8be5\u662f\u5356\u51fa\u5168\u90e8 15 \u4e07\u5428\u7b2c 2 \u79cd\u6708\u997c\u3001\u4ee5\u53ca 5 \u4e07\u5428\u7b2c 3 \u79cd\u6708\u997c\uff0c\u83b7\u5f97 72 + 45/2 = 94.5\uff08\u4ebf\u5143\uff09\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5148\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 N N \u8868\u793a\u6708\u997c\u7684\u79cd\u7c7b\u6570\u3001\u4ee5\u53ca\u4e0d\u8d85\u8fc7 500\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\u7684\u6b63\u6574\u6570 D D \u8868\u793a\u5e02\u573a\u6700\u5927\u9700\u6c42\u91cf\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u5e93\u5b58\u91cf\uff08\u4ee5\u4e07\u5428\u4e3a\u5355\u4f4d\uff09\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6570\u8868\u793a\u6bcf\u79cd\u6708\u997c\u7684\u603b\u552e\u4ef7\uff08\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7ec4\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u6536\u76ca\uff0c\u4ee5\u4ebf\u5143\u4e3a\u5355\u4f4d\u5e76\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 3 20 18 15 10 75 72 45 \u8f93\u51fa\u6837\u4f8b 94.50","title":"Statement"},{"location":"PAT-Basic-Level/1020-%E6%9C%88%E9%A5%BC/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int a [ MAXN ], b [ MAXN ]; struct pp { double a , b , ave ; } q [ MAXN ]; int comp ( pp x , pp y ) { return x . ave > y . ave ; } int main () { int n , d , i ; cin >> n >> d ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & q [ i ]. a ); for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%lf\" , & q [ i ]. b ); q [ i ]. ave = q [ i ]. b / q [ i ]. a ; } sort ( q , q + n , comp ); // for(i=0;i<n;i++) printf(\"%lf %lf %lf\\n\",q[i].a,q[i].b,q[i].ave); double total = 0 ; i = 0 ; while ( d && i < 1000 ) { if ( d > q [ i ]. a ) { d -= ( int ) q [ i ]. a ; total += q [ i ]. b ; // cout<<total<<endl; } else { total += q [ i ]. ave * d ; d = 0 ; // cout<<total<<endl; } i ++ ; } printf ( \"%.2lf \\n \" , total ); }","title":"Solution"},{"location":"PAT-Basic-Level/1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/","text":"1021 \u4e2a\u4f4d\u6570\u7edf\u8ba1 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k k \u4f4d\u6574\u6570 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 ( 0\\le d_i \\le 9 0\\le d_i \\le 9 , i=0,\\cdots ,k-1 i=0,\\cdots ,k-1 , d_{k-1}>0 d_{k-1}>0 )\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u7edf\u8ba1\u6bcf\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a N = 100311 N = 100311 \uff0c\u5219\u6709 2 \u4e2a 0\uff0c3 \u4e2a 1\uff0c\u548c 1 \u4e2a 3\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9 N N \u4e2d\u6bcf\u4e00\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u4ee5 D:M \u7684\u683c\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u4f4d\u6570\u5b57 D \u53ca\u5176\u5728 N N \u4e2d\u51fa\u73b0\u7684\u6b21\u6570 M \u3002\u8981\u6c42\u6309 D \u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 100311 \u8f93\u51fa\u6837\u4f8b 0:2 1:3 3:1 Solution C++ #include <bits/stdc++.h> using namespace std ; int n [ 10 ]; int main () { memset ( n , 0 , sizeof ( n )); string s ; cin >> s ; int i , len ; len = s . size (); for ( i = 0 ; i < len ; i ++ ) { n [ s [ i ] - 48 ] ++ ; } for ( i = 0 ; i < 10 ; i ++ ) { if ( n [ i ] != 0 ) { cout << i << \":\" << n [ i ] << endl ; } } }","title":"1021-\u4e2a\u4f4d\u6570\u7edf\u8ba1"},{"location":"PAT-Basic-Level/1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#1021-\u4e2a\u4f4d\u6570\u7edf\u8ba1","text":"","title":"1021 \u4e2a\u4f4d\u6570\u7edf\u8ba1"},{"location":"PAT-Basic-Level/1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k k \u4f4d\u6574\u6570 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 N = d_{k-1}10^{k-1} + \\cdots + d_1 10^1 + d_0 ( 0\\le d_i \\le 9 0\\le d_i \\le 9 , i=0,\\cdots ,k-1 i=0,\\cdots ,k-1 , d_{k-1}>0 d_{k-1}>0 )\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u7edf\u8ba1\u6bcf\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a N = 100311 N = 100311 \uff0c\u5219\u6709 2 \u4e2a 0\uff0c3 \u4e2a 1\uff0c\u548c 1 \u4e2a 3\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4e0d\u8d85\u8fc7 1000 \u4f4d\u7684\u6b63\u6574\u6570 N N \u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9 N N \u4e2d\u6bcf\u4e00\u79cd\u4e0d\u540c\u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u4ee5 D:M \u7684\u683c\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u4f4d\u6570\u5b57 D \u53ca\u5176\u5728 N N \u4e2d\u51fa\u73b0\u7684\u6b21\u6570 M \u3002\u8981\u6c42\u6309 D \u7684\u5347\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 100311 \u8f93\u51fa\u6837\u4f8b 0:2 1:3 3:1","title":"Statement"},{"location":"PAT-Basic-Level/1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int n [ 10 ]; int main () { memset ( n , 0 , sizeof ( n )); string s ; cin >> s ; int i , len ; len = s . size (); for ( i = 0 ; i < len ; i ++ ) { n [ s [ i ] - 48 ] ++ ; } for ( i = 0 ; i < 10 ; i ++ ) { if ( n [ i ] != 0 ) { cout << i << \":\" << n [ i ] << endl ; } } }","title":"Solution"},{"location":"PAT-Basic-Level/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB/","text":"1022 D\u8fdb\u5236\u7684A+B Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8f93\u5165\u4e24\u4e2a\u975e\u8d1f 10 \u8fdb\u5236\u6574\u6570 A A \u548c B B ( \\le 2^{30} -1 \\le 2^{30} -1 )\uff0c\u8f93\u51fa A+B A+B \u7684 D D ( 1 < D \\le 10 1 < D \\le 10 )\u8fdb\u5236\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa 3 \u4e2a\u6574\u6570 A A \u3001 B B \u548c D D \u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa A+B A+B \u7684 D D \u8fdb\u5236\u6570\u3002 \u8f93\u5165\u6837\u4f8b 123 456 8 \u8f93\u51fa\u6837\u4f8b 1103 \u9e23\u8c22\u7528\u6237\u8c22\u6d69\u7136\u8865\u5145\u6570\u636e\uff01 Solution C++ #include <iostream> using namespace std ; int main () { int a , b , d ; cin >> a >> b >> d ; int sum [ 100000 ], i , j = 0 ; long long c = a + b ; for ( i = 0 ; c ; i ++ ) { sum [ i ] = c % d ; c /= d ; j ++ ; } for ( i = j - 1 ; i >= 0 ; i -- ) { cout << sum [ i ]; } cout << endl ; }","title":"1022-D\u8fdb\u5236\u7684A+B"},{"location":"PAT-Basic-Level/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB/#1022-d\u8fdb\u5236\u7684ab","text":"","title":"1022 D\u8fdb\u5236\u7684A+B"},{"location":"PAT-Basic-Level/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8f93\u5165\u4e24\u4e2a\u975e\u8d1f 10 \u8fdb\u5236\u6574\u6570 A A \u548c B B ( \\le 2^{30} -1 \\le 2^{30} -1 )\uff0c\u8f93\u51fa A+B A+B \u7684 D D ( 1 < D \\le 10 1 < D \\le 10 )\u8fdb\u5236\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa 3 \u4e2a\u6574\u6570 A A \u3001 B B \u548c D D \u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa A+B A+B \u7684 D D \u8fdb\u5236\u6570\u3002 \u8f93\u5165\u6837\u4f8b 123 456 8 \u8f93\u51fa\u6837\u4f8b 1103 \u9e23\u8c22\u7528\u6237\u8c22\u6d69\u7136\u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB/#solution","text":"C++ #include <iostream> using namespace std ; int main () { int a , b , d ; cin >> a >> b >> d ; int sum [ 100000 ], i , j = 0 ; long long c = a + b ; for ( i = 0 ; c ; i ++ ) { sum [ i ] = c % d ; c /= d ; j ++ ; } for ( i = j - 1 ; i >= 0 ; i -- ) { cout << sum [ i ]; } cout << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/","text":"1023 \u7ec4\u4e2a\u6700\u5c0f\u6570 Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u6570\u5b57 0-9 \u5404\u82e5\u5e72\u4e2a\u3002\u4f60\u53ef\u4ee5\u4ee5\u4efb\u610f\u987a\u5e8f\u6392\u5217\u8fd9\u4e9b\u6570\u5b57\uff0c\u4f46\u5fc5\u987b\u5168\u90e8\u4f7f\u7528\u3002\u76ee\u6807\u662f\u4f7f\u5f97\u6700\u540e\u5f97\u5230\u7684\u6570\u5c3d\u53ef\u80fd\u5c0f\uff08\u6ce8\u610f 0 \u4e0d\u80fd\u505a\u9996\u4f4d\uff09\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a\u4e24\u4e2a 0\uff0c\u4e24\u4e2a 1\uff0c\u4e09\u4e2a 5\uff0c\u4e00\u4e2a 8\uff0c\u6211\u4eec\u5f97\u5230\u7684\u6700\u5c0f\u7684\u6570\u5c31\u662f 10015558\u3002 \u73b0\u7ed9\u5b9a\u6570\u5b57\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8f93\u51fa\u80fd\u591f\u7ec4\u6210\u7684\u6700\u5c0f\u7684\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 10 \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u987a\u5e8f\u8868\u793a\u6211\u4eec\u62e5\u6709\u6570\u5b57 0\u3001\u6570\u5b57 1\u3001\u2026\u2026\u6570\u5b57 9 \u7684\u4e2a\u6570\u3002\u6574\u6570\u95f4\u7528\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u300210 \u4e2a\u6570\u5b57\u7684\u603b\u4e2a\u6570\u4e0d\u8d85\u8fc7 50\uff0c\u4e14\u81f3\u5c11\u62e5\u6709 1 \u4e2a\u975e 0 \u7684\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u7ec4\u6210\u7684\u6700\u5c0f\u7684\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2 2 0 0 0 3 0 0 1 0 \u8f93\u51fa\u6837\u4f8b 10015558 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n [ 10 ], i , min = 100 ; for ( i = 0 ; i < 10 ; i ++ ) { scanf ( \"%d\" , & n [ i ]); if ( i && n [ i ] && i < min ) min = i ; } while ( n [ min ]) { printf ( \"%d\" , min ); n [ min ] -- ; while ( n [ 0 ]) { printf ( \"0\" ); n [ 0 ] -- ; } } for ( i = min + 1 ; i < 10 ; i ++ ) { while ( n [ i ]) { printf ( \"%d\" , i ); n [ i ] -- ; } } cout << \" \\n \" ; }","title":"1023-\u7ec4\u4e2a\u6700\u5c0f\u6570"},{"location":"PAT-Basic-Level/1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/#1023-\u7ec4\u4e2a\u6700\u5c0f\u6570","text":"","title":"1023 \u7ec4\u4e2a\u6700\u5c0f\u6570"},{"location":"PAT-Basic-Level/1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u6570\u5b57 0-9 \u5404\u82e5\u5e72\u4e2a\u3002\u4f60\u53ef\u4ee5\u4ee5\u4efb\u610f\u987a\u5e8f\u6392\u5217\u8fd9\u4e9b\u6570\u5b57\uff0c\u4f46\u5fc5\u987b\u5168\u90e8\u4f7f\u7528\u3002\u76ee\u6807\u662f\u4f7f\u5f97\u6700\u540e\u5f97\u5230\u7684\u6570\u5c3d\u53ef\u80fd\u5c0f\uff08\u6ce8\u610f 0 \u4e0d\u80fd\u505a\u9996\u4f4d\uff09\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a\u4e24\u4e2a 0\uff0c\u4e24\u4e2a 1\uff0c\u4e09\u4e2a 5\uff0c\u4e00\u4e2a 8\uff0c\u6211\u4eec\u5f97\u5230\u7684\u6700\u5c0f\u7684\u6570\u5c31\u662f 10015558\u3002 \u73b0\u7ed9\u5b9a\u6570\u5b57\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8f93\u51fa\u80fd\u591f\u7ec4\u6210\u7684\u6700\u5c0f\u7684\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa 10 \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u987a\u5e8f\u8868\u793a\u6211\u4eec\u62e5\u6709\u6570\u5b57 0\u3001\u6570\u5b57 1\u3001\u2026\u2026\u6570\u5b57 9 \u7684\u4e2a\u6570\u3002\u6574\u6570\u95f4\u7528\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u300210 \u4e2a\u6570\u5b57\u7684\u603b\u4e2a\u6570\u4e0d\u8d85\u8fc7 50\uff0c\u4e14\u81f3\u5c11\u62e5\u6709 1 \u4e2a\u975e 0 \u7684\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u7ec4\u6210\u7684\u6700\u5c0f\u7684\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2 2 0 0 0 3 0 0 1 0 \u8f93\u51fa\u6837\u4f8b 10015558","title":"Statement"},{"location":"PAT-Basic-Level/1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n [ 10 ], i , min = 100 ; for ( i = 0 ; i < 10 ; i ++ ) { scanf ( \"%d\" , & n [ i ]); if ( i && n [ i ] && i < min ) min = i ; } while ( n [ min ]) { printf ( \"%d\" , min ); n [ min ] -- ; while ( n [ 0 ]) { printf ( \"0\" ); n [ 0 ] -- ; } } for ( i = min + 1 ; i < 10 ; i ++ ) { while ( n [ i ]) { printf ( \"%d\" , i ); n [ i ] -- ; } } cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/","text":"1024 \u79d1\u5b66\u8ba1\u6570\u6cd5 Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u79d1\u5b66\u8ba1\u6570\u6cd5\u662f\u79d1\u5b66\u5bb6\u7528\u6765\u8868\u793a\u5f88\u5927\u6216\u5f88\u5c0f\u7684\u6570\u5b57\u7684\u4e00\u79cd\u65b9\u4fbf\u7684\u65b9\u6cd5\uff0c\u5176\u6ee1\u8db3\u6b63\u5219\u8868\u8fbe\u5f0f [+-][1-9] . [0-9]+E[+-][0-9]+\uff0c\u5373\u6570\u5b57\u7684\u6574\u6570\u90e8\u5206\u53ea\u6709 1 \u4f4d\uff0c\u5c0f\u6570\u90e8\u5206\u81f3\u5c11\u6709 1 \u4f4d\uff0c\u8be5\u6570\u5b57\u53ca\u5176\u6307\u6570\u90e8\u5206\u7684\u6b63\u8d1f\u53f7\u5373\u4f7f\u5bf9\u6b63\u6570\u4e5f\u5fc5\u5b9a\u660e\u786e\u7ed9\u51fa\u3002 \u73b0\u4ee5\u79d1\u5b66\u8ba1\u6570\u6cd5\u7684\u683c\u5f0f\u7ed9\u51fa\u5b9e\u6570 A A \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u6309\u666e\u901a\u6570\u5b57\u8868\u793a\u6cd5\u8f93\u51fa A A \uff0c\u5e76\u4fdd\u8bc1\u6240\u6709\u6709\u6548\u4f4d\u90fd\u88ab\u4fdd\u7559\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4ee5\u79d1\u5b66\u8ba1\u6570\u6cd5\u8868\u793a\u7684\u5b9e\u6570 A A \u3002\u8be5\u6570\u5b57\u7684\u5b58\u50a8\u957f\u5ea6\u4e0d\u8d85\u8fc7 9999 \u5b57\u8282\uff0c\u4e14\u5176\u6307\u6570\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 9999\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u6309\u666e\u901a\u6570\u5b57\u8868\u793a\u6cd5\u8f93\u51fa A A \uff0c\u5e76\u4fdd\u8bc1\u6240\u6709\u6709\u6548\u4f4d\u90fd\u88ab\u4fdd\u7559\uff0c\u5305\u62ec\u672b\u5c3e\u7684 0\u3002 \u8f93\u5165\u6837\u4f8b 1 +1.23400E-03 \u8f93\u51fa\u6837\u4f8b 1 0.00123400 \u8f93\u5165\u6837\u4f8b 2 -1.2E+10 \u8f93\u51fa\u6837\u4f8b 2 -12000000000 Solution C++ #include <cmath> #include <iomanip> #include <iostream> using namespace std ; int main () { string a ; cin >> a ; int i , temp2 = 1 ; double now = 0.1 , temp1 = 0 ; int wo , sum = 0 ; temp1 += a [ 1 ] - '0' ; for ( i = 3 ; i < a . length (); i ++ ) { if ( a [ i ] == 'E' ) { wo = i ; break ; } temp1 += ( a [ i ] - '0' ) * now ; now /= 10 ; sum ++ ; } int woc = 0 ; for ( i = a . length () - 1 ; i > wo + 1 ; i -- ) { woc += ( a [ i ] - '0' ) * temp2 ; temp2 *= 10 ; } double ri = temp1 / pow ( 10 , woc ); double gou = temp1 * pow ( 10 , woc ); if ( a [ 0 ] == '-' ) printf ( \"-\" ); if ( a [ wo + 1 ] == '-' ) { cout << fixed << setprecision ( sum + woc ) << ri ; } else { if ( woc >= sum ) cout << fixed << setprecision ( 0 ) << gou ; else cout << fixed << setprecision ( woc - sum ) << gou ; } }","title":"1024-\u79d1\u5b66\u8ba1\u6570\u6cd5"},{"location":"PAT-Basic-Level/1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/#1024-\u79d1\u5b66\u8ba1\u6570\u6cd5","text":"","title":"1024 \u79d1\u5b66\u8ba1\u6570\u6cd5"},{"location":"PAT-Basic-Level/1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u79d1\u5b66\u8ba1\u6570\u6cd5\u662f\u79d1\u5b66\u5bb6\u7528\u6765\u8868\u793a\u5f88\u5927\u6216\u5f88\u5c0f\u7684\u6570\u5b57\u7684\u4e00\u79cd\u65b9\u4fbf\u7684\u65b9\u6cd5\uff0c\u5176\u6ee1\u8db3\u6b63\u5219\u8868\u8fbe\u5f0f [+-][1-9] . [0-9]+E[+-][0-9]+\uff0c\u5373\u6570\u5b57\u7684\u6574\u6570\u90e8\u5206\u53ea\u6709 1 \u4f4d\uff0c\u5c0f\u6570\u90e8\u5206\u81f3\u5c11\u6709 1 \u4f4d\uff0c\u8be5\u6570\u5b57\u53ca\u5176\u6307\u6570\u90e8\u5206\u7684\u6b63\u8d1f\u53f7\u5373\u4f7f\u5bf9\u6b63\u6570\u4e5f\u5fc5\u5b9a\u660e\u786e\u7ed9\u51fa\u3002 \u73b0\u4ee5\u79d1\u5b66\u8ba1\u6570\u6cd5\u7684\u683c\u5f0f\u7ed9\u51fa\u5b9e\u6570 A A \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u6309\u666e\u901a\u6570\u5b57\u8868\u793a\u6cd5\u8f93\u51fa A A \uff0c\u5e76\u4fdd\u8bc1\u6240\u6709\u6709\u6548\u4f4d\u90fd\u88ab\u4fdd\u7559\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5373\u4e00\u4e2a\u4ee5\u79d1\u5b66\u8ba1\u6570\u6cd5\u8868\u793a\u7684\u5b9e\u6570 A A \u3002\u8be5\u6570\u5b57\u7684\u5b58\u50a8\u957f\u5ea6\u4e0d\u8d85\u8fc7 9999 \u5b57\u8282\uff0c\u4e14\u5176\u6307\u6570\u7684\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 9999\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u5728\u4e00\u884c\u4e2d\u6309\u666e\u901a\u6570\u5b57\u8868\u793a\u6cd5\u8f93\u51fa A A \uff0c\u5e76\u4fdd\u8bc1\u6240\u6709\u6709\u6548\u4f4d\u90fd\u88ab\u4fdd\u7559\uff0c\u5305\u62ec\u672b\u5c3e\u7684 0\u3002 \u8f93\u5165\u6837\u4f8b 1 +1.23400E-03 \u8f93\u51fa\u6837\u4f8b 1 0.00123400 \u8f93\u5165\u6837\u4f8b 2 -1.2E+10 \u8f93\u51fa\u6837\u4f8b 2 -12000000000","title":"Statement"},{"location":"PAT-Basic-Level/1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/#solution","text":"C++ #include <cmath> #include <iomanip> #include <iostream> using namespace std ; int main () { string a ; cin >> a ; int i , temp2 = 1 ; double now = 0.1 , temp1 = 0 ; int wo , sum = 0 ; temp1 += a [ 1 ] - '0' ; for ( i = 3 ; i < a . length (); i ++ ) { if ( a [ i ] == 'E' ) { wo = i ; break ; } temp1 += ( a [ i ] - '0' ) * now ; now /= 10 ; sum ++ ; } int woc = 0 ; for ( i = a . length () - 1 ; i > wo + 1 ; i -- ) { woc += ( a [ i ] - '0' ) * temp2 ; temp2 *= 10 ; } double ri = temp1 / pow ( 10 , woc ); double gou = temp1 * pow ( 10 , woc ); if ( a [ 0 ] == '-' ) printf ( \"-\" ); if ( a [ wo + 1 ] == '-' ) { cout << fixed << setprecision ( sum + woc ) << ri ; } else { if ( woc >= sum ) cout << fixed << setprecision ( 0 ) << gou ; else cout << fixed << setprecision ( woc - sum ) << gou ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","text":"1025 \u53cd\u8f6c\u94fe\u8868 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5e38\u6570 K K \u4ee5\u53ca\u4e00\u4e2a\u5355\u94fe\u8868 L L \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06 L L \u4e2d\u6bcf K K \u4e2a\u7ed3\u70b9\u53cd\u8f6c\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a 1\u21922\u21923\u21924\u21925\u21926\uff0c K K \u4e3a 3\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 3\u21922\u21921\u21926\u21925\u21924\uff1b\u5982\u679c K K \u4e3a 4\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 4\u21923\u21922\u21921\u21925\u21926\uff0c\u5373\u6700\u540e\u4e0d\u5230 K K \u4e2a\u5143\u7d20\u4e0d\u53cd\u8f6c\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3001\u7ed3\u70b9\u603b\u4e2a\u6570\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3001\u4ee5\u53ca\u6b63\u6574\u6570 K K ( \\le N \\le N )\uff0c\u5373\u8981\u6c42\u53cd\u8f6c\u7684\u5b50\u94fe\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff0c Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6574\u6570\u6570\u636e\uff0c Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 Solution C++ #include <bits/stdc++.h> using namespace std ; #define maxn 100000 struct node { int add , data , next ; } vsort [ maxn ], vout [ maxn ], temp ; int main () { map < int , node > p ; int first , N , K ; cin >> first >> N >> K ; int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . data , & temp . next ); p [ temp . add ] = temp ; } map < int , node >:: iterator it ; if ( first == -1 ) cout << \"-1 \\n \" ; else { int nextAdd = first ; for ( i = 0 ; nextAdd != -1 ; i ++ , nextAdd = p [ nextAdd ]. next ) vsort [ i ] = p [ nextAdd ]; int length = i ; int right = K - 1 ; for ( right = K - 1 , j = 0 ; right < length ; right += K ) { for ( i = right ; i > right - K ; i -- ) vout [ j ++ ] = vsort [ i ]; } for ( i = right - K + 1 ; i < length ; i ++ ) vout [ j ++ ] = vsort [ i ]; for ( i = 0 ; i < length - 1 ; i ++ ) { vout [ i ]. next = vout [ i + 1 ]. add ; printf ( \"%05d %d %05d \\n \" , vout [ i ]. add , vout [ i ]. data , vout [ i ]. next ); } printf ( \"%05d %d -1 \\n \" , vout [ i ]. add , vout [ i ]. data ); } }","title":"1025-\u53cd\u8f6c\u94fe\u8868"},{"location":"PAT-Basic-Level/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#1025-\u53cd\u8f6c\u94fe\u8868","text":"","title":"1025 \u53cd\u8f6c\u94fe\u8868"},{"location":"PAT-Basic-Level/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5e38\u6570 K K \u4ee5\u53ca\u4e00\u4e2a\u5355\u94fe\u8868 L L \uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06 L L \u4e2d\u6bcf K K \u4e2a\u7ed3\u70b9\u53cd\u8f6c\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a 1\u21922\u21923\u21924\u21925\u21926\uff0c K K \u4e3a 3\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 3\u21922\u21921\u21926\u21925\u21924\uff1b\u5982\u679c K K \u4e3a 4\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 4\u21923\u21922\u21921\u21925\u21926\uff0c\u5373\u6700\u540e\u4e0d\u5230 K K \u4e2a\u5143\u7d20\u4e0d\u53cd\u8f6c\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3001\u7ed3\u70b9\u603b\u4e2a\u6570\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3001\u4ee5\u53ca\u6b63\u6574\u6570 K K ( \\le N \\le N )\uff0c\u5373\u8981\u6c42\u53cd\u8f6c\u7684\u5b50\u94fe\u7ed3\u70b9\u7684\u4e2a\u6570\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff0c Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6574\u6570\u6570\u636e\uff0c Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1","title":"Statement"},{"location":"PAT-Basic-Level/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define maxn 100000 struct node { int add , data , next ; } vsort [ maxn ], vout [ maxn ], temp ; int main () { map < int , node > p ; int first , N , K ; cin >> first >> N >> K ; int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . data , & temp . next ); p [ temp . add ] = temp ; } map < int , node >:: iterator it ; if ( first == -1 ) cout << \"-1 \\n \" ; else { int nextAdd = first ; for ( i = 0 ; nextAdd != -1 ; i ++ , nextAdd = p [ nextAdd ]. next ) vsort [ i ] = p [ nextAdd ]; int length = i ; int right = K - 1 ; for ( right = K - 1 , j = 0 ; right < length ; right += K ) { for ( i = right ; i > right - K ; i -- ) vout [ j ++ ] = vsort [ i ]; } for ( i = right - K + 1 ; i < length ; i ++ ) vout [ j ++ ] = vsort [ i ]; for ( i = 0 ; i < length - 1 ; i ++ ) { vout [ i ]. next = vout [ i + 1 ]. add ; printf ( \"%05d %d %05d \\n \" , vout [ i ]. add , vout [ i ]. data , vout [ i ]. next ); } printf ( \"%05d %d -1 \\n \" , vout [ i ]. add , vout [ i ]. data ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/","text":"1026 \u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8981\u83b7\u5f97\u4e00\u4e2a C \u8bed\u8a00\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c\u5e38\u7528\u7684\u65b9\u6cd5\u662f\u8c03\u7528\u5934\u6587\u4ef6 time.h\uff0c\u5176\u4e2d\u63d0\u4f9b\u4e86 clock() \u51fd\u6570\uff0c\u53ef\u4ee5\u6355\u6349\u4ece\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c\u5230 clock() \u88ab\u8c03\u7528\u65f6\u6240\u8017\u8d39\u7684\u65f6\u95f4\u3002\u8fd9\u4e2a\u65f6\u95f4\u5355\u4f4d\u662f clock tick\uff0c\u5373\u201c\u65f6\u949f\u6253\u70b9\u201d\u3002\u540c\u65f6\u8fd8\u6709\u4e00\u4e2a\u5e38\u6570 CLK_TCK\uff0c\u7ed9\u51fa\u4e86\u673a\u5668\u65f6\u949f\u6bcf\u79d2\u6240\u8d70\u7684\u65f6\u949f\u6253\u70b9\u6570\u3002\u4e8e\u662f\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u51fd\u6570 f f \u7684\u8fd0\u884c\u65f6\u95f4\uff0c\u6211\u4eec\u53ea\u8981\u5728\u8c03\u7528 f f \u4e4b\u524d\u5148\u8c03\u7528 clock()\uff0c\u83b7\u5f97\u4e00\u4e2a\u65f6\u949f\u6253\u70b9\u6570 C1\uff1b\u5728 f f \u6267\u884c\u5b8c\u6210\u540e\u518d\u8c03\u7528 clock()\uff0c\u83b7\u5f97\u53e6\u4e00\u4e2a\u65f6\u949f\u6253\u70b9\u6570 C2\uff1b\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\u4e4b\u5dee (C2-C1) \u5c31\u662f f f \u8fd0\u884c\u6240\u6d88\u8017\u7684\u65f6\u949f\u6253\u70b9\u6570\uff0c\u518d\u9664\u4ee5\u5e38\u6570 CLK_TCK\uff0c\u5c31\u5f97\u5230\u4e86\u4ee5\u79d2\u4e3a\u5355\u4f4d\u7684\u8fd0\u884c\u65f6\u95f4\u3002 \u8fd9\u91cc\u4e0d\u59a8\u7b80\u5355\u5047\u8bbe\u5e38\u6570 CLK_TCK \u4e3a 100\u3002\u73b0\u7ed9\u5b9a\u88ab\u6d4b\u51fd\u6570\u524d\u540e\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\uff0c\u8bf7\u4f60\u7ed9\u51fa\u88ab\u6d4b\u51fd\u6570\u8fd0\u884c\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u7ed9\u51fa 2 \u4e2a\u6574\u6570 C1 \u548c C2\u3002\u6ce8\u610f\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\u80af\u5b9a\u4e0d\u76f8\u540c\uff0c\u5373 C1 < < C2\uff0c\u5e76\u4e14\u53d6\u503c\u5728 [0, 10^7] [0, 10^7] \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u88ab\u6d4b\u51fd\u6570\u8fd0\u884c\u7684\u65f6\u95f4\u3002\u8fd0\u884c\u65f6\u95f4\u5fc5\u987b\u6309\u7167 hh:mm:ss \uff08\u53732\u4f4d\u7684 \u65f6:\u5206:\u79d2 \uff09\u683c\u5f0f\u8f93\u51fa\uff1b\u4e0d\u8db3 1 \u79d2\u7684\u65f6\u95f4\u56db\u820d\u4e94\u5165\u5230\u79d2\u3002 \u8f93\u5165\u6837\u4f8b 123 4577973 \u8f93\u51fa\u6837\u4f8b 12:42:59 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int c1 , c2 , total , h , m , s ; cin >> c1 >> c2 ; total = (( c2 - c1 ) + 50 ) / 100 ; // cout<<total<<endl; h = total / 3600 ; m = total % 3600 / 60 ; s = total % 3600 % 60 ; printf ( \"%02d:%02d:%02d \\n \" , h , m , s ); }","title":"1026-\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4"},{"location":"PAT-Basic-Level/1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/#1026-\u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4","text":"","title":"1026 \u7a0b\u5e8f\u8fd0\u884c\u65f6\u95f4"},{"location":"PAT-Basic-Level/1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8981\u83b7\u5f97\u4e00\u4e2a C \u8bed\u8a00\u7a0b\u5e8f\u7684\u8fd0\u884c\u65f6\u95f4\uff0c\u5e38\u7528\u7684\u65b9\u6cd5\u662f\u8c03\u7528\u5934\u6587\u4ef6 time.h\uff0c\u5176\u4e2d\u63d0\u4f9b\u4e86 clock() \u51fd\u6570\uff0c\u53ef\u4ee5\u6355\u6349\u4ece\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c\u5230 clock() \u88ab\u8c03\u7528\u65f6\u6240\u8017\u8d39\u7684\u65f6\u95f4\u3002\u8fd9\u4e2a\u65f6\u95f4\u5355\u4f4d\u662f clock tick\uff0c\u5373\u201c\u65f6\u949f\u6253\u70b9\u201d\u3002\u540c\u65f6\u8fd8\u6709\u4e00\u4e2a\u5e38\u6570 CLK_TCK\uff0c\u7ed9\u51fa\u4e86\u673a\u5668\u65f6\u949f\u6bcf\u79d2\u6240\u8d70\u7684\u65f6\u949f\u6253\u70b9\u6570\u3002\u4e8e\u662f\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u51fd\u6570 f f \u7684\u8fd0\u884c\u65f6\u95f4\uff0c\u6211\u4eec\u53ea\u8981\u5728\u8c03\u7528 f f \u4e4b\u524d\u5148\u8c03\u7528 clock()\uff0c\u83b7\u5f97\u4e00\u4e2a\u65f6\u949f\u6253\u70b9\u6570 C1\uff1b\u5728 f f \u6267\u884c\u5b8c\u6210\u540e\u518d\u8c03\u7528 clock()\uff0c\u83b7\u5f97\u53e6\u4e00\u4e2a\u65f6\u949f\u6253\u70b9\u6570 C2\uff1b\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\u4e4b\u5dee (C2-C1) \u5c31\u662f f f \u8fd0\u884c\u6240\u6d88\u8017\u7684\u65f6\u949f\u6253\u70b9\u6570\uff0c\u518d\u9664\u4ee5\u5e38\u6570 CLK_TCK\uff0c\u5c31\u5f97\u5230\u4e86\u4ee5\u79d2\u4e3a\u5355\u4f4d\u7684\u8fd0\u884c\u65f6\u95f4\u3002 \u8fd9\u91cc\u4e0d\u59a8\u7b80\u5355\u5047\u8bbe\u5e38\u6570 CLK_TCK \u4e3a 100\u3002\u73b0\u7ed9\u5b9a\u88ab\u6d4b\u51fd\u6570\u524d\u540e\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\uff0c\u8bf7\u4f60\u7ed9\u51fa\u88ab\u6d4b\u51fd\u6570\u8fd0\u884c\u7684\u65f6\u95f4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u7ed9\u51fa 2 \u4e2a\u6574\u6570 C1 \u548c C2\u3002\u6ce8\u610f\u4e24\u6b21\u83b7\u5f97\u7684\u65f6\u949f\u6253\u70b9\u6570\u80af\u5b9a\u4e0d\u76f8\u540c\uff0c\u5373 C1 < < C2\uff0c\u5e76\u4e14\u53d6\u503c\u5728 [0, 10^7] [0, 10^7] \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u88ab\u6d4b\u51fd\u6570\u8fd0\u884c\u7684\u65f6\u95f4\u3002\u8fd0\u884c\u65f6\u95f4\u5fc5\u987b\u6309\u7167 hh:mm:ss \uff08\u53732\u4f4d\u7684 \u65f6:\u5206:\u79d2 \uff09\u683c\u5f0f\u8f93\u51fa\uff1b\u4e0d\u8db3 1 \u79d2\u7684\u65f6\u95f4\u56db\u820d\u4e94\u5165\u5230\u79d2\u3002 \u8f93\u5165\u6837\u4f8b 123 4577973 \u8f93\u51fa\u6837\u4f8b 12:42:59","title":"Statement"},{"location":"PAT-Basic-Level/1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int c1 , c2 , total , h , m , s ; cin >> c1 >> c2 ; total = (( c2 - c1 ) + 50 ) / 100 ; // cout<<total<<endl; h = total / 3600 ; m = total % 3600 / 60 ; s = total % 3600 % 60 ; printf ( \"%02d:%02d:%02d \\n \" , h , m , s ); }","title":"Solution"},{"location":"PAT-Basic-Level/1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/","text":"1027 \u6253\u5370\u6c99\u6f0f Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u628a\u7ed9\u5b9a\u7684\u7b26\u53f7\u6253\u5370\u6210\u6c99\u6f0f\u7684\u5f62\u72b6\u3002\u4f8b\u5982\u7ed9\u5b9a17\u4e2a\u201c*\u201d\uff0c\u8981\u6c42\u6309\u4e0b\u5217\u683c\u5f0f\u6253\u5370 ***** *** * *** ***** \u6240\u8c13\u201c\u6c99\u6f0f\u5f62\u72b6\u201d\uff0c\u662f\u6307\u6bcf\u884c\u8f93\u51fa\u5947\u6570\u4e2a\u7b26\u53f7\uff1b\u5404\u884c\u7b26\u53f7\u4e2d\u5fc3\u5bf9\u9f50\uff1b\u76f8\u90bb\u4e24\u884c\u7b26\u53f7\u6570\u5dee2\uff1b\u7b26\u53f7\u6570\u5148\u4ece\u5927\u5230\u5c0f\u987a\u5e8f\u9012\u51cf\u52301\uff0c\u518d\u4ece\u5c0f\u5230\u5927\u987a\u5e8f\u9012\u589e\uff1b\u9996\u5c3e\u7b26\u53f7\u6570\u76f8\u7b49\u3002 \u7ed9\u5b9a\u4efb\u610fN\u4e2a\u7b26\u53f7\uff0c\u4e0d\u4e00\u5b9a\u80fd\u6b63\u597d\u7ec4\u6210\u4e00\u4e2a\u6c99\u6f0f\u3002\u8981\u6c42\u6253\u5370\u51fa\u7684\u6c99\u6f0f\u80fd\u7528\u6389\u5c3d\u53ef\u80fd\u591a\u7684\u7b26\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa1\u4e2a\u6b63\u6574\u6570N\uff08 \\le \\le 1000\uff09\u548c\u4e00\u4e2a\u7b26\u53f7\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6253\u5370\u51fa\u7531\u7ed9\u5b9a\u7b26\u53f7\u7ec4\u6210\u7684\u6700\u5927\u7684\u6c99\u6f0f\u5f62\u72b6\uff0c\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5269\u4e0b\u6ca1\u7528\u6389\u7684\u7b26\u53f7\u6570\u3002 \u8f93\u5165\u6837\u4f8b 19 * \u8f93\u51fa\u6837\u4f8b ***** *** * *** ***** 2 Solution C++ #include <bits/stdc++.h> using namespace std ; int a [ 23 ] = { 1 , 7 , 17 , 31 , 49 , 71 , 97 , 127 , 161 , 199 , 241 , 287 , 337 , 391 , 449 , 511 , 577 , 647 , 721 , 799 , 881 , 967 , 1057 }, b [ 22 ] = { 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 , 27 , 29 , 31 , 33 , 35 , 37 , 39 , 41 , 43 , 45 }; int main () { int n , i , j , flag , k ; char c ; cin >> n >> c ; for ( i = 0 ; i < 23 ; i ++ ) if ( n < a [ i ]) break ; flag = i - 1 ; // cout<<flag<<endl; for ( i = 0 , j = flag - 1 ; i < flag ; i ++ , j -- ) { for ( k = 0 ; k < i ; k ++ ) printf ( \" \" ); for ( k = 0 ; k < b [ j ]; k ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } for ( i = 0 ; i < flag ; i ++ ) printf ( \" \" ); printf ( \"%c \\n \" , c ); for ( i = 0 , j = flag - 1 ; i < flag ; i ++ , j -- ) { for ( k = 0 ; k < j ; k ++ ) printf ( \" \" ); for ( k = 0 ; k < b [ i ]; k ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } cout << n - a [ flag ] << endl ; }","title":"1027-\u6253\u5370\u6c99\u6f0f"},{"location":"PAT-Basic-Level/1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#1027-\u6253\u5370\u6c99\u6f0f","text":"","title":"1027 \u6253\u5370\u6c99\u6f0f"},{"location":"PAT-Basic-Level/1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u628a\u7ed9\u5b9a\u7684\u7b26\u53f7\u6253\u5370\u6210\u6c99\u6f0f\u7684\u5f62\u72b6\u3002\u4f8b\u5982\u7ed9\u5b9a17\u4e2a\u201c*\u201d\uff0c\u8981\u6c42\u6309\u4e0b\u5217\u683c\u5f0f\u6253\u5370 ***** *** * *** ***** \u6240\u8c13\u201c\u6c99\u6f0f\u5f62\u72b6\u201d\uff0c\u662f\u6307\u6bcf\u884c\u8f93\u51fa\u5947\u6570\u4e2a\u7b26\u53f7\uff1b\u5404\u884c\u7b26\u53f7\u4e2d\u5fc3\u5bf9\u9f50\uff1b\u76f8\u90bb\u4e24\u884c\u7b26\u53f7\u6570\u5dee2\uff1b\u7b26\u53f7\u6570\u5148\u4ece\u5927\u5230\u5c0f\u987a\u5e8f\u9012\u51cf\u52301\uff0c\u518d\u4ece\u5c0f\u5230\u5927\u987a\u5e8f\u9012\u589e\uff1b\u9996\u5c3e\u7b26\u53f7\u6570\u76f8\u7b49\u3002 \u7ed9\u5b9a\u4efb\u610fN\u4e2a\u7b26\u53f7\uff0c\u4e0d\u4e00\u5b9a\u80fd\u6b63\u597d\u7ec4\u6210\u4e00\u4e2a\u6c99\u6f0f\u3002\u8981\u6c42\u6253\u5370\u51fa\u7684\u6c99\u6f0f\u80fd\u7528\u6389\u5c3d\u53ef\u80fd\u591a\u7684\u7b26\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u7ed9\u51fa1\u4e2a\u6b63\u6574\u6570N\uff08 \\le \\le 1000\uff09\u548c\u4e00\u4e2a\u7b26\u53f7\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u6253\u5370\u51fa\u7531\u7ed9\u5b9a\u7b26\u53f7\u7ec4\u6210\u7684\u6700\u5927\u7684\u6c99\u6f0f\u5f62\u72b6\uff0c\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5269\u4e0b\u6ca1\u7528\u6389\u7684\u7b26\u53f7\u6570\u3002 \u8f93\u5165\u6837\u4f8b 19 * \u8f93\u51fa\u6837\u4f8b ***** *** * *** ***** 2","title":"Statement"},{"location":"PAT-Basic-Level/1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int a [ 23 ] = { 1 , 7 , 17 , 31 , 49 , 71 , 97 , 127 , 161 , 199 , 241 , 287 , 337 , 391 , 449 , 511 , 577 , 647 , 721 , 799 , 881 , 967 , 1057 }, b [ 22 ] = { 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 , 27 , 29 , 31 , 33 , 35 , 37 , 39 , 41 , 43 , 45 }; int main () { int n , i , j , flag , k ; char c ; cin >> n >> c ; for ( i = 0 ; i < 23 ; i ++ ) if ( n < a [ i ]) break ; flag = i - 1 ; // cout<<flag<<endl; for ( i = 0 , j = flag - 1 ; i < flag ; i ++ , j -- ) { for ( k = 0 ; k < i ; k ++ ) printf ( \" \" ); for ( k = 0 ; k < b [ j ]; k ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } for ( i = 0 ; i < flag ; i ++ ) printf ( \" \" ); printf ( \"%c \\n \" , c ); for ( i = 0 , j = flag - 1 ; i < flag ; i ++ , j -- ) { for ( k = 0 ; k < j ; k ++ ) printf ( \" \" ); for ( k = 0 ; k < b [ i ]; k ++ ) printf ( \"%c\" , c ); printf ( \" \\n \" ); } cout << n - a [ flag ] << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/","text":"1028 \u4eba\u53e3\u666e\u67e5 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u57ce\u9547\u8fdb\u884c\u4eba\u53e3\u666e\u67e5\uff0c\u5f97\u5230\u4e86\u5168\u4f53\u5c45\u6c11\u7684\u751f\u65e5\u3002\u73b0\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u627e\u51fa\u9547\u4e0a\u6700\u5e74\u957f\u548c\u6700\u5e74\u8f7b\u7684\u4eba\u3002 \u8fd9\u91cc\u786e\u4fdd\u6bcf\u4e2a\u8f93\u5165\u7684\u65e5\u671f\u90fd\u662f\u5408\u6cd5\u7684\uff0c\u4f46\u4e0d\u4e00\u5b9a\u662f\u5408\u7406\u7684\u2014\u2014\u5047\u8bbe\u5df2\u77e5\u9547\u4e0a\u6ca1\u6709\u8d85\u8fc7 200 \u5c81\u7684\u8001\u4eba\uff0c\u800c\u4eca\u5929\u662f 2014 \u5e74 9 \u6708 6 \u65e5\uff0c\u6240\u4ee5\u8d85\u8fc7 200 \u5c81\u7684\u751f\u65e5\u548c\u672a\u51fa\u751f\u7684\u751f\u65e5\u90fd\u662f\u4e0d\u5408\u7406\u7684\uff0c\u5e94\u8be5\u88ab\u8fc7\u6ee4\u6389\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff0c\u53d6\u503c\u5728 (0, 10^5] (0, 10^5] \uff1b\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa 1 \u4e2a\u4eba\u7684\u59d3\u540d\uff08\u7531\u4e0d\u8d85\u8fc7 5 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u3001\u4ee5\u53ca\u6309 yyyy/mm/dd \uff08\u5373\u5e74/\u6708/\u65e5\uff09\u683c\u5f0f\u7ed9\u51fa\u7684\u751f\u65e5\u3002\u9898\u76ee\u4fdd\u8bc1\u6700\u5e74\u957f\u548c\u6700\u5e74\u8f7b\u7684\u4eba\u6ca1\u6709\u5e76\u5217\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u6709\u6548\u751f\u65e5\u7684\u4e2a\u6570\u3001\u6700\u5e74\u957f\u4eba\u548c\u6700\u5e74\u8f7b\u4eba\u7684\u59d3\u540d\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 5 John 2001/05/12 Tom 1814/09/06 Ann 2121/01/30 James 1814/09/05 Steve 1967/11/20 \u8f93\u51fa\u6837\u4f8b 3 Tom John Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 struct pp { string s ; int a , b , c ; } q [ MAXN ]; int jude ( int a , int b , int c ) { if ( a > 2014 || a < 1814 ) return 0 ; else if ( a == 2014 ) { if ( b > 9 ) return 0 ; else if ( b == 9 ) { if ( c > 6 ) return 0 ; } } else if ( a == 1814 ) { if ( b < 9 ) return 0 ; else if ( b == 9 ) { if ( c < 6 ) return 0 ; } } return 1 ; } int comp ( pp x , pp y ) { if ( x . a > y . a ) return 0 ; else if ( x . a == y . a ) { if ( x . b > y . b ) return 0 ; else if ( x . b == y . b ) { if ( x . c > y . c ) return 0 ; } } return 1 ; } int main () { string s ; int n , i , a , b , c , j = 0 ; cin >> n ; for ( i = 0 , j = 0 ; i < n ; i ++ ) { cin >> s ; scanf ( \"%d/%d/%d\" , & a , & b , & c ); if ( jude ( a , b , c )) { q [ j ]. s = s ; q [ j ]. a = a , q [ j ]. b = b , q [ j ]. c = c ; j ++ ; } } if ( j >= 2 ) sort ( q , q + j , comp ); printf ( \"%d\" , j ); if ( j > 1 ) cout << \" \" << q [ 0 ]. s << \" \" << q [ j - 1 ]. s ; else if ( j == 1 ) cout << \" \" << q [ 0 ]. s << \" \" << q [ 0 ]. s ; cout << endl ; }","title":"1028-\u4eba\u53e3\u666e\u67e5"},{"location":"PAT-Basic-Level/1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/#1028-\u4eba\u53e3\u666e\u67e5","text":"","title":"1028 \u4eba\u53e3\u666e\u67e5"},{"location":"PAT-Basic-Level/1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u67d0\u57ce\u9547\u8fdb\u884c\u4eba\u53e3\u666e\u67e5\uff0c\u5f97\u5230\u4e86\u5168\u4f53\u5c45\u6c11\u7684\u751f\u65e5\u3002\u73b0\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\uff0c\u627e\u51fa\u9547\u4e0a\u6700\u5e74\u957f\u548c\u6700\u5e74\u8f7b\u7684\u4eba\u3002 \u8fd9\u91cc\u786e\u4fdd\u6bcf\u4e2a\u8f93\u5165\u7684\u65e5\u671f\u90fd\u662f\u5408\u6cd5\u7684\uff0c\u4f46\u4e0d\u4e00\u5b9a\u662f\u5408\u7406\u7684\u2014\u2014\u5047\u8bbe\u5df2\u77e5\u9547\u4e0a\u6ca1\u6709\u8d85\u8fc7 200 \u5c81\u7684\u8001\u4eba\uff0c\u800c\u4eca\u5929\u662f 2014 \u5e74 9 \u6708 6 \u65e5\uff0c\u6240\u4ee5\u8d85\u8fc7 200 \u5c81\u7684\u751f\u65e5\u548c\u672a\u51fa\u751f\u7684\u751f\u65e5\u90fd\u662f\u4e0d\u5408\u7406\u7684\uff0c\u5e94\u8be5\u88ab\u8fc7\u6ee4\u6389\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff0c\u53d6\u503c\u5728 (0, 10^5] (0, 10^5] \uff1b\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa 1 \u4e2a\u4eba\u7684\u59d3\u540d\uff08\u7531\u4e0d\u8d85\u8fc7 5 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u3001\u4ee5\u53ca\u6309 yyyy/mm/dd \uff08\u5373\u5e74/\u6708/\u65e5\uff09\u683c\u5f0f\u7ed9\u51fa\u7684\u751f\u65e5\u3002\u9898\u76ee\u4fdd\u8bc1\u6700\u5e74\u957f\u548c\u6700\u5e74\u8f7b\u7684\u4eba\u6ca1\u6709\u5e76\u5217\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u987a\u5e8f\u8f93\u51fa\u6709\u6548\u751f\u65e5\u7684\u4e2a\u6570\u3001\u6700\u5e74\u957f\u4eba\u548c\u6700\u5e74\u8f7b\u4eba\u7684\u59d3\u540d\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 5 John 2001/05/12 Tom 1814/09/06 Ann 2121/01/30 James 1814/09/05 Steve 1967/11/20 \u8f93\u51fa\u6837\u4f8b 3 Tom John","title":"Statement"},{"location":"PAT-Basic-Level/1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 struct pp { string s ; int a , b , c ; } q [ MAXN ]; int jude ( int a , int b , int c ) { if ( a > 2014 || a < 1814 ) return 0 ; else if ( a == 2014 ) { if ( b > 9 ) return 0 ; else if ( b == 9 ) { if ( c > 6 ) return 0 ; } } else if ( a == 1814 ) { if ( b < 9 ) return 0 ; else if ( b == 9 ) { if ( c < 6 ) return 0 ; } } return 1 ; } int comp ( pp x , pp y ) { if ( x . a > y . a ) return 0 ; else if ( x . a == y . a ) { if ( x . b > y . b ) return 0 ; else if ( x . b == y . b ) { if ( x . c > y . c ) return 0 ; } } return 1 ; } int main () { string s ; int n , i , a , b , c , j = 0 ; cin >> n ; for ( i = 0 , j = 0 ; i < n ; i ++ ) { cin >> s ; scanf ( \"%d/%d/%d\" , & a , & b , & c ); if ( jude ( a , b , c )) { q [ j ]. s = s ; q [ j ]. a = a , q [ j ]. b = b , q [ j ]. c = c ; j ++ ; } } if ( j >= 2 ) sort ( q , q + j , comp ); printf ( \"%d\" , j ); if ( j > 1 ) cout << \" \" << q [ 0 ]. s << \" \" << q [ j - 1 ]. s ; else if ( j == 1 ) cout << \" \" << q [ 0 ]. s << \" \" << q [ 0 ]. s ; cout << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1029-%E6%97%A7%E9%94%AE%E7%9B%98/","text":"1029 \u65e7\u952e\u76d8 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u65e7\u952e\u76d8\u4e0a\u574f\u4e86\u51e0\u4e2a\u952e\uff0c\u4e8e\u662f\u5728\u6572\u4e00\u6bb5\u6587\u5b57\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u5c31\u4e0d\u4f1a\u51fa\u73b0\u3002\u73b0\u5728\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u4e00\u6bb5\u6587\u5b57\u3001\u4ee5\u53ca\u5b9e\u9645\u88ab\u8f93\u5165\u7684\u6587\u5b57\uff0c\u8bf7\u4f60\u5217\u51fa\u80af\u5b9a\u574f\u6389\u7684\u90a3\u4e9b\u952e\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 2 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u6587\u5b57\u3001\u4ee5\u53ca\u5b9e\u9645\u88ab\u8f93\u5165\u7684\u6587\u5b57\u3002\u6bcf\u6bb5\u6587\u5b57\u662f\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u4e32\uff0c\u7531\u5b57\u6bcd A-Z\uff08\u5305\u62ec\u5927\u3001\u5c0f\u5199\uff09\u3001\u6570\u5b57 0-9\u3001\u4ee5\u53ca\u4e0b\u5212\u7ebf _ \uff08\u4ee3\u8868\u7a7a\u683c\uff09\u7ec4\u6210\u3002\u9898\u76ee\u4fdd\u8bc1 2 \u4e2a\u5b57\u7b26\u4e32\u5747\u975e\u7a7a\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u53d1\u73b0\u987a\u5e8f\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u574f\u6389\u7684\u952e\u3002\u5176\u4e2d\u82f1\u6587\u5b57\u6bcd\u53ea\u8f93\u51fa\u5927\u5199\uff0c\u6bcf\u4e2a\u574f\u952e\u53ea\u8f93\u51fa\u4e00\u6b21\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u4e2a\u574f\u952e\u3002 \u8f93\u5165\u6837\u4f8b 7_This_is_a_test _hs_s_a_es \u8f93\u51fa\u6837\u4f8b 7TI Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; cin >> s1 >> s2 ; int len1 = s1 . size (), len2 = s2 . size (), i , j ; map < char , int > q ; for ( i = 0 ; i < len1 ; i ++ ) { if ( s1 [ i ] >= 'a' && s1 [ i ] <= 'z' ) s1 [ i ] -= 32 ; } for ( i = 0 ; i < len2 ; i ++ ) if ( s2 [ i ] >= 'a' && s2 [ i ] <= 'z' ) s2 [ i ] -= 32 ; for ( i = 0 , j = 0 ; i < len1 ; i ++ ) { if ( s1 [ i ] != s2 [ j ]) { if ( q [ s1 [ i ]] != 2 ) cout << s1 [ i ]; q [ s1 [ i ]] = 2 ; } else j ++ ; } cout << \" \\n \" ; }","title":"1029-\u65e7\u952e\u76d8"},{"location":"PAT-Basic-Level/1029-%E6%97%A7%E9%94%AE%E7%9B%98/#1029-\u65e7\u952e\u76d8","text":"","title":"1029 \u65e7\u952e\u76d8"},{"location":"PAT-Basic-Level/1029-%E6%97%A7%E9%94%AE%E7%9B%98/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u65e7\u952e\u76d8\u4e0a\u574f\u4e86\u51e0\u4e2a\u952e\uff0c\u4e8e\u662f\u5728\u6572\u4e00\u6bb5\u6587\u5b57\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u5c31\u4e0d\u4f1a\u51fa\u73b0\u3002\u73b0\u5728\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u4e00\u6bb5\u6587\u5b57\u3001\u4ee5\u53ca\u5b9e\u9645\u88ab\u8f93\u5165\u7684\u6587\u5b57\uff0c\u8bf7\u4f60\u5217\u51fa\u80af\u5b9a\u574f\u6389\u7684\u90a3\u4e9b\u952e\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 2 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u6587\u5b57\u3001\u4ee5\u53ca\u5b9e\u9645\u88ab\u8f93\u5165\u7684\u6587\u5b57\u3002\u6bcf\u6bb5\u6587\u5b57\u662f\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u4e32\uff0c\u7531\u5b57\u6bcd A-Z\uff08\u5305\u62ec\u5927\u3001\u5c0f\u5199\uff09\u3001\u6570\u5b57 0-9\u3001\u4ee5\u53ca\u4e0b\u5212\u7ebf _ \uff08\u4ee3\u8868\u7a7a\u683c\uff09\u7ec4\u6210\u3002\u9898\u76ee\u4fdd\u8bc1 2 \u4e2a\u5b57\u7b26\u4e32\u5747\u975e\u7a7a\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u53d1\u73b0\u987a\u5e8f\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u574f\u6389\u7684\u952e\u3002\u5176\u4e2d\u82f1\u6587\u5b57\u6bcd\u53ea\u8f93\u51fa\u5927\u5199\uff0c\u6bcf\u4e2a\u574f\u952e\u53ea\u8f93\u51fa\u4e00\u6b21\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u4e2a\u574f\u952e\u3002 \u8f93\u5165\u6837\u4f8b 7_This_is_a_test _hs_s_a_es \u8f93\u51fa\u6837\u4f8b 7TI","title":"Statement"},{"location":"PAT-Basic-Level/1029-%E6%97%A7%E9%94%AE%E7%9B%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; cin >> s1 >> s2 ; int len1 = s1 . size (), len2 = s2 . size (), i , j ; map < char , int > q ; for ( i = 0 ; i < len1 ; i ++ ) { if ( s1 [ i ] >= 'a' && s1 [ i ] <= 'z' ) s1 [ i ] -= 32 ; } for ( i = 0 ; i < len2 ; i ++ ) if ( s2 [ i ] >= 'a' && s2 [ i ] <= 'z' ) s2 [ i ] -= 32 ; for ( i = 0 , j = 0 ; i < len1 ; i ++ ) { if ( s1 [ i ] != s2 [ j ]) { if ( q [ s1 [ i ]] != 2 ) cout << s1 [ i ]; q [ s1 [ i ]] = 2 ; } else j ++ ; } cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/","text":"1030 \u5b8c\u7f8e\u6570\u5217 Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u5217\uff0c\u548c\u6b63\u6574\u6570 p p \uff0c\u8bbe\u8fd9\u4e2a\u6570\u5217\u4e2d\u7684\u6700\u5927\u503c\u662f M M \uff0c\u6700\u5c0f\u503c\u662f m m \uff0c\u5982\u679c M \\le mp M \\le mp \uff0c\u5219\u79f0\u8fd9\u4e2a\u6570\u5217\u662f\u5b8c\u7f8e\u6570\u5217\u3002 \u73b0\u5728\u7ed9\u5b9a\u53c2\u6570 p p \u548c\u4e00\u4e9b\u6b63\u6574\u6570\uff0c\u8bf7\u4f60\u4ece\u4e2d\u9009\u62e9\u5c3d\u53ef\u80fd\u591a\u7684\u6570\u6784\u6210\u4e00\u4e2a\u5b8c\u7f8e\u6570\u5217\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c p p \uff0c\u5176\u4e2d N N \uff08 \\le 10^5 \\le 10^5 \uff09\u662f\u8f93\u5165\u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570\uff0c p p \uff08 \\le 10^9 \\le 10^9 \uff09\u662f\u7ed9\u5b9a\u7684\u53c2\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a\u6570\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u591a\u53ef\u4ee5\u9009\u62e9\u591a\u5c11\u4e2a\u6570\u53ef\u4ee5\u7528\u5b83\u4eec\u7ec4\u6210\u4e00\u4e2a\u5b8c\u7f8e\u6570\u5217\u3002 \u8f93\u5165\u6837\u4f8b 10 8 2 3 20 4 5 1 6 7 8 9 \u8f93\u51fa\u6837\u4f8b 8 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 double a [ MAXN ]; int main () { int n , i , j , max = 0 ; double p ; long long num ; cin >> n >> p ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); sort ( a , a + n ); int total = 0 ; for ( i = 0 ; i < n ; i ++ ) { num = p * a [ i ]; for ( j = i + max ; j < n ; j ++ ) { if ( a [ j ] > num ) break ; if ( j - i + 1 > max ) max = j - i + 1 ; } } cout << max << endl ; }","title":"1030-\u5b8c\u7f8e\u6570\u5217"},{"location":"PAT-Basic-Level/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/#1030-\u5b8c\u7f8e\u6570\u5217","text":"","title":"1030 \u5b8c\u7f8e\u6570\u5217"},{"location":"PAT-Basic-Level/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u5217\uff0c\u548c\u6b63\u6574\u6570 p p \uff0c\u8bbe\u8fd9\u4e2a\u6570\u5217\u4e2d\u7684\u6700\u5927\u503c\u662f M M \uff0c\u6700\u5c0f\u503c\u662f m m \uff0c\u5982\u679c M \\le mp M \\le mp \uff0c\u5219\u79f0\u8fd9\u4e2a\u6570\u5217\u662f\u5b8c\u7f8e\u6570\u5217\u3002 \u73b0\u5728\u7ed9\u5b9a\u53c2\u6570 p p \u548c\u4e00\u4e9b\u6b63\u6574\u6570\uff0c\u8bf7\u4f60\u4ece\u4e2d\u9009\u62e9\u5c3d\u53ef\u80fd\u591a\u7684\u6570\u6784\u6210\u4e00\u4e2a\u5b8c\u7f8e\u6570\u5217\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \u548c p p \uff0c\u5176\u4e2d N N \uff08 \\le 10^5 \\le 10^5 \uff09\u662f\u8f93\u5165\u7684\u6b63\u6574\u6570\u7684\u4e2a\u6570\uff0c p p \uff08 \\le 10^9 \\le 10^9 \uff09\u662f\u7ed9\u5b9a\u7684\u53c2\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a\u6570\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u591a\u53ef\u4ee5\u9009\u62e9\u591a\u5c11\u4e2a\u6570\u53ef\u4ee5\u7528\u5b83\u4eec\u7ec4\u6210\u4e00\u4e2a\u5b8c\u7f8e\u6570\u5217\u3002 \u8f93\u5165\u6837\u4f8b 10 8 2 3 20 4 5 1 6 7 8 9 \u8f93\u51fa\u6837\u4f8b 8","title":"Statement"},{"location":"PAT-Basic-Level/1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 double a [ MAXN ]; int main () { int n , i , j , max = 0 ; double p ; long long num ; cin >> n >> p ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); sort ( a , a + n ); int total = 0 ; for ( i = 0 ; i < n ; i ++ ) { num = p * a [ i ]; for ( j = i + max ; j < n ; j ++ ) { if ( a [ j ] > num ) break ; if ( j - i + 1 > max ) max = j - i + 1 ; } } cout << max << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/","text":"1031 \u67e5\u9a8c\u8eab\u4efd\u8bc1 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5408\u6cd5\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u753117\u4f4d\u5730\u533a\u3001\u65e5\u671f\u7f16\u53f7\u548c\u987a\u5e8f\u7f16\u53f7\u52a01\u4f4d\u6821\u9a8c\u7801\u7ec4\u6210\u3002\u6821\u9a8c\u7801\u7684\u8ba1\u7b97\u89c4\u5219\u5982\u4e0b\uff1a \u9996\u5148\u5bf9\u524d17\u4f4d\u6570\u5b57\u52a0\u6743\u6c42\u548c\uff0c\u6743\u91cd\u5206\u914d\u4e3a\uff1a{7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2\uff0c1\uff0c6\uff0c3\uff0c7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2}\uff1b\u7136\u540e\u5c06\u8ba1\u7b97\u7684\u548c\u5bf911\u53d6\u6a21\u5f97\u5230\u503c Z \uff1b\u6700\u540e\u6309\u7167\u4ee5\u4e0b\u5173\u7cfb\u5bf9\u5e94 Z \u503c\u4e0e\u6821\u9a8c\u7801 M \u7684\u503c\uff1a Z\uff1a0 1 2 3 4 5 6 7 8 9 10 M\uff1a1 0 X 9 8 7 6 5 4 3 2 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u8eab\u4efd\u8bc1\u53f7\u7801\uff0c\u8bf7\u4f60\u9a8c\u8bc1\u6821\u9a8c\u7801\u7684\u6709\u6548\u6027\uff0c\u5e76\u8f93\u51fa\u6709\u95ee\u9898\u7684\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u662f\u8f93\u5165\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa1\u4e2a18\u4f4d\u8eab\u4efd\u8bc1\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u6bcf\u884c\u8f93\u51fa1\u4e2a\u6709\u95ee\u9898\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u3002\u8fd9\u91cc\u5e76\u4e0d\u68c0\u9a8c\u524d17\u4f4d\u662f\u5426\u5408\u7406\uff0c\u53ea\u68c0\u67e5\u524d17\u4f4d\u662f\u5426\u5168\u4e3a\u6570\u5b57\u4e14\u6700\u540e1\u4f4d\u6821\u9a8c\u7801\u8ba1\u7b97\u51c6\u786e\u3002\u5982\u679c\u6240\u6709\u53f7\u7801\u90fd\u6b63\u5e38\uff0c\u5219\u8f93\u51fa All passed \u3002 \u8f93\u5165\u6837\u4f8b1 4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u51fa\u6837\u4f8b1 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u5165\u6837\u4f8b2 2 320124198808240056 110108196711301862 \u8f93\u51fa\u6837\u4f8b2 All passed \u9e23\u8c22\u961c\u9633\u5e08\u8303\u5b66\u9662\u8303\u5efa\u4e2d\u8001\u5e08\u8865\u5145\u6570\u636e \u9e23\u8c22\u6d59\u6c5f\u5de5\u4e1a\u5927\u5b66\u4e4b\u6c5f\u5b66\u9662\u77f3\u6d17\u51e1\u8001\u5e08\u7ea0\u6b63\u6570\u636e Solution C++ #include <cstring> #include <iostream> using namespace std ; int main () { int a [ 17 ] = { 7 , 9 , 10 , 5 , 8 , 4 , 2 , 1 , 6 , 3 , 7 , 9 , 10 , 5 , 8 , 4 , 2 }; char c [ 19 ], b [ 12 ] = { '1' , '0' , 'X' , '9' , '8' , '7' , '6' , '5' , '4' , '3' , '2' }, num [ 100 ][ 19 ]; int n , i , j , k , sum = 0 , flag = 1 , count = 0 , m = 0 ; cin >> n ; getchar (); for ( i = 0 ; i < n ; i ++ ) { flag = 1 ; sum = 0 ; // add \u8fd9\u9519\u8bef\u53c8\u72af\u4e86\uff01\uff01\uff01 scanf ( \"%s\" , c ); for ( j = 0 ; j < 17 ; j ++ ) { if ( c [ j ] < 48 || c [ j ] > 57 ) { flag = 0 ; break ; } else { sum += ( c [ j ] - '0' ) * a [ j ]; } } sum %= 11 ; // cout<<sum<<endl; if ( b [ sum ] != c [ 17 ]) { flag = 0 ; } if ( ! flag ) { for ( k = 0 ; k < 18 ; k ++ ) { num [ m ][ k ] = c [ k ]; // k\u5faa\u73af\u4e8618\u6b21 \u4f60\u8fd9\u4e2am++ \u662f\u4e0d\u662f\u4e5f+\u4e8618\u6b21 } num [ m ][ 18 ] = '\\0' ; // add m ++ ; // add } } if ( m ) // add { for ( i = 0 ; i < m ; i ++ ) { printf ( \"%s \\n \" , num [ i ]); } } else cout << \"All passed \\n \" ; // add }","title":"1031-\u67e5\u9a8c\u8eab\u4efd\u8bc1"},{"location":"PAT-Basic-Level/1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#1031-\u67e5\u9a8c\u8eab\u4efd\u8bc1","text":"","title":"1031 \u67e5\u9a8c\u8eab\u4efd\u8bc1"},{"location":"PAT-Basic-Level/1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5408\u6cd5\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u753117\u4f4d\u5730\u533a\u3001\u65e5\u671f\u7f16\u53f7\u548c\u987a\u5e8f\u7f16\u53f7\u52a01\u4f4d\u6821\u9a8c\u7801\u7ec4\u6210\u3002\u6821\u9a8c\u7801\u7684\u8ba1\u7b97\u89c4\u5219\u5982\u4e0b\uff1a \u9996\u5148\u5bf9\u524d17\u4f4d\u6570\u5b57\u52a0\u6743\u6c42\u548c\uff0c\u6743\u91cd\u5206\u914d\u4e3a\uff1a{7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2\uff0c1\uff0c6\uff0c3\uff0c7\uff0c9\uff0c10\uff0c5\uff0c8\uff0c4\uff0c2}\uff1b\u7136\u540e\u5c06\u8ba1\u7b97\u7684\u548c\u5bf911\u53d6\u6a21\u5f97\u5230\u503c Z \uff1b\u6700\u540e\u6309\u7167\u4ee5\u4e0b\u5173\u7cfb\u5bf9\u5e94 Z \u503c\u4e0e\u6821\u9a8c\u7801 M \u7684\u503c\uff1a Z\uff1a0 1 2 3 4 5 6 7 8 9 10 M\uff1a1 0 X 9 8 7 6 5 4 3 2 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u8eab\u4efd\u8bc1\u53f7\u7801\uff0c\u8bf7\u4f60\u9a8c\u8bc1\u6821\u9a8c\u7801\u7684\u6709\u6548\u6027\uff0c\u5e76\u8f93\u51fa\u6709\u95ee\u9898\u7684\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u662f\u8f93\u5165\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u7684\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa1\u4e2a18\u4f4d\u8eab\u4efd\u8bc1\u53f7\u7801\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u6bcf\u884c\u8f93\u51fa1\u4e2a\u6709\u95ee\u9898\u7684\u8eab\u4efd\u8bc1\u53f7\u7801\u3002\u8fd9\u91cc\u5e76\u4e0d\u68c0\u9a8c\u524d17\u4f4d\u662f\u5426\u5408\u7406\uff0c\u53ea\u68c0\u67e5\u524d17\u4f4d\u662f\u5426\u5168\u4e3a\u6570\u5b57\u4e14\u6700\u540e1\u4f4d\u6821\u9a8c\u7801\u8ba1\u7b97\u51c6\u786e\u3002\u5982\u679c\u6240\u6709\u53f7\u7801\u90fd\u6b63\u5e38\uff0c\u5219\u8f93\u51fa All passed \u3002 \u8f93\u5165\u6837\u4f8b1 4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u51fa\u6837\u4f8b1 12010X198901011234 110108196711301866 37070419881216001X \u8f93\u5165\u6837\u4f8b2 2 320124198808240056 110108196711301862 \u8f93\u51fa\u6837\u4f8b2 All passed \u9e23\u8c22\u961c\u9633\u5e08\u8303\u5b66\u9662\u8303\u5efa\u4e2d\u8001\u5e08\u8865\u5145\u6570\u636e \u9e23\u8c22\u6d59\u6c5f\u5de5\u4e1a\u5927\u5b66\u4e4b\u6c5f\u5b66\u9662\u77f3\u6d17\u51e1\u8001\u5e08\u7ea0\u6b63\u6570\u636e","title":"Statement"},{"location":"PAT-Basic-Level/1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/#solution","text":"C++ #include <cstring> #include <iostream> using namespace std ; int main () { int a [ 17 ] = { 7 , 9 , 10 , 5 , 8 , 4 , 2 , 1 , 6 , 3 , 7 , 9 , 10 , 5 , 8 , 4 , 2 }; char c [ 19 ], b [ 12 ] = { '1' , '0' , 'X' , '9' , '8' , '7' , '6' , '5' , '4' , '3' , '2' }, num [ 100 ][ 19 ]; int n , i , j , k , sum = 0 , flag = 1 , count = 0 , m = 0 ; cin >> n ; getchar (); for ( i = 0 ; i < n ; i ++ ) { flag = 1 ; sum = 0 ; // add \u8fd9\u9519\u8bef\u53c8\u72af\u4e86\uff01\uff01\uff01 scanf ( \"%s\" , c ); for ( j = 0 ; j < 17 ; j ++ ) { if ( c [ j ] < 48 || c [ j ] > 57 ) { flag = 0 ; break ; } else { sum += ( c [ j ] - '0' ) * a [ j ]; } } sum %= 11 ; // cout<<sum<<endl; if ( b [ sum ] != c [ 17 ]) { flag = 0 ; } if ( ! flag ) { for ( k = 0 ; k < 18 ; k ++ ) { num [ m ][ k ] = c [ k ]; // k\u5faa\u73af\u4e8618\u6b21 \u4f60\u8fd9\u4e2am++ \u662f\u4e0d\u662f\u4e5f+\u4e8618\u6b21 } num [ m ][ 18 ] = '\\0' ; // add m ++ ; // add } } if ( m ) // add { for ( i = 0 ; i < m ; i ++ ) { printf ( \"%s \\n \" , num [ i ]); } } else cout << \"All passed \\n \" ; // add }","title":"Solution"},{"location":"PAT-Basic-Level/1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/","text":"1032 \u6316\u6398\u673a\u6280\u672f\u54ea\u5bb6\u5f3a Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e3a\u4e86\u7528\u4e8b\u5b9e\u8bf4\u660e\u6316\u6398\u673a\u6280\u672f\u5230\u5e95\u54ea\u5bb6\u5f3a\uff0cPAT \u7ec4\u7ec7\u4e86\u4e00\u573a\u6316\u6398\u673a\u6280\u80fd\u5927\u8d5b\u3002\u73b0\u8bf7\u4f60\u6839\u636e\u6bd4\u8d5b\u7ed3\u679c\u7edf\u8ba1\u51fa\u6280\u672f\u6700\u5f3a\u7684\u90a3\u4e2a\u5b66\u6821\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u53c2\u8d5b\u4eba\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u53c2\u8d5b\u8005\u7684\u4fe1\u606f\u548c\u6210\u7ee9\uff0c\u5305\u62ec\u5176\u6240\u4ee3\u8868\u7684\u5b66\u6821\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\u8fde\u7eed\u7f16\u53f7\uff09\u3001\u53ca\u5176\u6bd4\u8d5b\u6210\u7ee9\uff08\u767e\u5206\u5236\uff09\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u603b\u5f97\u5206\u6700\u9ad8\u7684\u5b66\u6821\u7684\u7f16\u53f7\u3001\u53ca\u5176\u603b\u5206\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u552f\u4e00\uff0c\u6ca1\u6709\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 6 3 65 2 80 1 100 2 70 3 40 3 0 \u8f93\u51fa\u6837\u4f8b 2 150 \u9e23\u8c22\u7528\u6237 \u7c73\u6cf0\u4e9a\u5fb7 \u8865\u5145\u6570\u636e\uff01 Solution C++ /*#include<bits/stdc++.h> using namespace std; map<int,int>q; int cmp(const pair<int, int>&x, const pair<int, int>&y) { return x.second > y.second; } int main() { int t; cin>>t; int i; int a,b; for(i=0;i<t;i++) { cin>>a>>b; q[a]+=b; } vector<int, int>v; for(auto it=q.begin();it!=q.end();it++) q.push_back(make_pair(it->first,it->second)); sort(q.begin(),q.end(),cmp); map<int,int>::iterator it; it=q.begin(); cout<<it->first<<\" \"<<it->second<<endl; }*/ #include <bits/stdc++.h> using namespace std ; int main () { int t ; cin >> t ; int i , a , b ; map < int , int > q ; for ( i = 0 ; i < t ; i ++ ) { cin >> a >> b ; q [ a ] += b ; } map < int , int >:: iterator it , max ; it = max = q . begin (); for ( it ++ ; it != q . end (); it ++ ) { if ( it -> second > max -> second ) max = it ; } cout << max -> first << \" \" << max -> second << endl ; }","title":"1032-\u6316\u6398\u673a\u6280\u672f\u54ea\u5bb6\u5f3a"},{"location":"PAT-Basic-Level/1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/#1032-\u6316\u6398\u673a\u6280\u672f\u54ea\u5bb6\u5f3a","text":"","title":"1032 \u6316\u6398\u673a\u6280\u672f\u54ea\u5bb6\u5f3a"},{"location":"PAT-Basic-Level/1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e3a\u4e86\u7528\u4e8b\u5b9e\u8bf4\u660e\u6316\u6398\u673a\u6280\u672f\u5230\u5e95\u54ea\u5bb6\u5f3a\uff0cPAT \u7ec4\u7ec7\u4e86\u4e00\u573a\u6316\u6398\u673a\u6280\u80fd\u5927\u8d5b\u3002\u73b0\u8bf7\u4f60\u6839\u636e\u6bd4\u8d5b\u7ed3\u679c\u7edf\u8ba1\u51fa\u6280\u672f\u6700\u5f3a\u7684\u90a3\u4e2a\u5b66\u6821\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u53c2\u8d5b\u4eba\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u53c2\u8d5b\u8005\u7684\u4fe1\u606f\u548c\u6210\u7ee9\uff0c\u5305\u62ec\u5176\u6240\u4ee3\u8868\u7684\u5b66\u6821\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\u8fde\u7eed\u7f16\u53f7\uff09\u3001\u53ca\u5176\u6bd4\u8d5b\u6210\u7ee9\uff08\u767e\u5206\u5236\uff09\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u603b\u5f97\u5206\u6700\u9ad8\u7684\u5b66\u6821\u7684\u7f16\u53f7\u3001\u53ca\u5176\u603b\u5206\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7b54\u6848\u552f\u4e00\uff0c\u6ca1\u6709\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 6 3 65 2 80 1 100 2 70 3 40 3 0 \u8f93\u51fa\u6837\u4f8b 2 150 \u9e23\u8c22\u7528\u6237 \u7c73\u6cf0\u4e9a\u5fb7 \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/#solution","text":"C++ /*#include<bits/stdc++.h> using namespace std; map<int,int>q; int cmp(const pair<int, int>&x, const pair<int, int>&y) { return x.second > y.second; } int main() { int t; cin>>t; int i; int a,b; for(i=0;i<t;i++) { cin>>a>>b; q[a]+=b; } vector<int, int>v; for(auto it=q.begin();it!=q.end();it++) q.push_back(make_pair(it->first,it->second)); sort(q.begin(),q.end(),cmp); map<int,int>::iterator it; it=q.begin(); cout<<it->first<<\" \"<<it->second<<endl; }*/ #include <bits/stdc++.h> using namespace std ; int main () { int t ; cin >> t ; int i , a , b ; map < int , int > q ; for ( i = 0 ; i < t ; i ++ ) { cin >> a >> b ; q [ a ] += b ; } map < int , int >:: iterator it , max ; it = max = q . begin (); for ( it ++ ; it != q . end (); it ++ ) { if ( it -> second > max -> second ) max = it ; } cout << max -> first << \" \" << max -> second << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/","text":"1033 \u65e7\u952e\u76d8\u6253\u5b57 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u65e7\u952e\u76d8\u4e0a\u574f\u4e86\u51e0\u4e2a\u952e\uff0c\u4e8e\u662f\u5728\u6572\u4e00\u6bb5\u6587\u5b57\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u5c31\u4e0d\u4f1a\u51fa\u73b0\u3002\u73b0\u5728\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u4e00\u6bb5\u6587\u5b57\u3001\u4ee5\u53ca\u574f\u6389\u7684\u90a3\u4e9b\u952e\uff0c\u6253\u51fa\u7684\u7ed3\u679c\u6587\u5b57\u4f1a\u662f\u600e\u6837\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 2 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa\u574f\u6389\u7684\u90a3\u4e9b\u952e\u3001\u4ee5\u53ca\u5e94\u8be5\u8f93\u5165\u7684\u6587\u5b57\u3002\u5176\u4e2d\u5bf9\u5e94\u82f1\u6587\u5b57\u6bcd\u7684\u574f\u952e\u4ee5\u5927\u5199\u7ed9\u51fa\uff1b\u6bcf\u6bb5\u6587\u5b57\u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u4e2a\u5b57\u7b26\u7684\u4e32\u3002\u53ef\u7528\u7684\u5b57\u7b26\u5305\u62ec\u5b57\u6bcd [ a - z , A - Z ]\u3001\u6570\u5b57 0 - 9 \u3001\u4ee5\u53ca\u4e0b\u5212\u7ebf _ \uff08\u4ee3\u8868\u7a7a\u683c\uff09\u3001 , \u3001 . \u3001 - \u3001 + \uff08\u4ee3\u8868\u4e0a\u6863\u952e\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u7b2c 2 \u884c\u8f93\u5165\u7684\u6587\u5b57\u4e32\u975e\u7a7a\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u4e0a\u6863\u952e\u574f\u6389\u4e86\uff0c\u90a3\u4e48\u5927\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u65e0\u6cd5\u88ab\u6253\u51fa\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u88ab\u6253\u51fa\u7684\u7ed3\u679c\u6587\u5b57\u3002\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u5b57\u7b26\u80fd\u88ab\u6253\u51fa\uff0c\u5219\u8f93\u51fa\u7a7a\u884c\u3002 \u8f93\u5165\u6837\u4f8b 7+IE. 7_This_is_a_test. \u8f93\u51fa\u6837\u4f8b _hs_s_a_tst Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; map < char , int > q ; getline ( cin , s1 ); int len = s1 . size (), i , flag = 0 , j ; for ( i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] == '+' ) { for ( j = 'A' ; j <= 'Z' ; j ++ ) q [ j ] = 2 ; } else if ( s1 [ i ] >= 'A' && s1 [ i ] <= 'Z' ) { q [ s1 [ i ]] = 2 ; q [ s1 [ i ] + 32 ] = 2 ; } else q [ s1 [ i ]] = 2 ; } getline ( cin , s1 ); len = s1 . size (); for ( i = 0 ; i < len ; i ++ ) { if ( q [ s1 [ i ]] != 2 ) { cout << s1 [ i ]; flag = 1 ; } } if ( ! flag ) cout << \" \\n \" ; }","title":"1033-\u65e7\u952e\u76d8\u6253\u5b57"},{"location":"PAT-Basic-Level/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/#1033-\u65e7\u952e\u76d8\u6253\u5b57","text":"","title":"1033 \u65e7\u952e\u76d8\u6253\u5b57"},{"location":"PAT-Basic-Level/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u65e7\u952e\u76d8\u4e0a\u574f\u4e86\u51e0\u4e2a\u952e\uff0c\u4e8e\u662f\u5728\u6572\u4e00\u6bb5\u6587\u5b57\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u5b57\u7b26\u5c31\u4e0d\u4f1a\u51fa\u73b0\u3002\u73b0\u5728\u7ed9\u51fa\u5e94\u8be5\u8f93\u5165\u7684\u4e00\u6bb5\u6587\u5b57\u3001\u4ee5\u53ca\u574f\u6389\u7684\u90a3\u4e9b\u952e\uff0c\u6253\u51fa\u7684\u7ed3\u679c\u6587\u5b57\u4f1a\u662f\u600e\u6837\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 2 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa\u574f\u6389\u7684\u90a3\u4e9b\u952e\u3001\u4ee5\u53ca\u5e94\u8be5\u8f93\u5165\u7684\u6587\u5b57\u3002\u5176\u4e2d\u5bf9\u5e94\u82f1\u6587\u5b57\u6bcd\u7684\u574f\u952e\u4ee5\u5927\u5199\u7ed9\u51fa\uff1b\u6bcf\u6bb5\u6587\u5b57\u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u4e2a\u5b57\u7b26\u7684\u4e32\u3002\u53ef\u7528\u7684\u5b57\u7b26\u5305\u62ec\u5b57\u6bcd [ a - z , A - Z ]\u3001\u6570\u5b57 0 - 9 \u3001\u4ee5\u53ca\u4e0b\u5212\u7ebf _ \uff08\u4ee3\u8868\u7a7a\u683c\uff09\u3001 , \u3001 . \u3001 - \u3001 + \uff08\u4ee3\u8868\u4e0a\u6863\u952e\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u7b2c 2 \u884c\u8f93\u5165\u7684\u6587\u5b57\u4e32\u975e\u7a7a\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u4e0a\u6863\u952e\u574f\u6389\u4e86\uff0c\u90a3\u4e48\u5927\u5199\u7684\u82f1\u6587\u5b57\u6bcd\u65e0\u6cd5\u88ab\u6253\u51fa\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u88ab\u6253\u51fa\u7684\u7ed3\u679c\u6587\u5b57\u3002\u5982\u679c\u6ca1\u6709\u4e00\u4e2a\u5b57\u7b26\u80fd\u88ab\u6253\u51fa\uff0c\u5219\u8f93\u51fa\u7a7a\u884c\u3002 \u8f93\u5165\u6837\u4f8b 7+IE. 7_This_is_a_test. \u8f93\u51fa\u6837\u4f8b _hs_s_a_tst","title":"Statement"},{"location":"PAT-Basic-Level/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s1 , s2 ; map < char , int > q ; getline ( cin , s1 ); int len = s1 . size (), i , flag = 0 , j ; for ( i = 0 ; i < len ; i ++ ) { if ( s1 [ i ] == '+' ) { for ( j = 'A' ; j <= 'Z' ; j ++ ) q [ j ] = 2 ; } else if ( s1 [ i ] >= 'A' && s1 [ i ] <= 'Z' ) { q [ s1 [ i ]] = 2 ; q [ s1 [ i ] + 32 ] = 2 ; } else q [ s1 [ i ]] = 2 ; } getline ( cin , s1 ); len = s1 . size (); for ( i = 0 ; i < len ; i ++ ) { if ( q [ s1 [ i ]] != 2 ) { cout << s1 [ i ]; flag = 1 ; } } if ( ! flag ) cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","text":"1034 \u6709\u7406\u6570\u56db\u5219\u8fd0\u7b97 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\uff0c\u8ba1\u7b97 2 \u4e2a\u6709\u7406\u6570\u7684\u548c\u3001\u5dee\u3001\u79ef\u3001\u5546\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309\u7167 a1/b1 a2/b2 \u7684\u683c\u5f0f\u7ed9\u51fa\u4e24\u4e2a\u5206\u6570\u5f62\u5f0f\u7684\u6709\u7406\u6570\uff0c\u5176\u4e2d\u5206\u5b50\u548c\u5206\u6bcd\u5168\u662f\u6574\u578b\u8303\u56f4\u5185\u7684\u6574\u6570\uff0c\u8d1f\u53f7\u53ea\u53ef\u80fd\u51fa\u73b0\u5728\u5206\u5b50\u524d\uff0c\u5206\u6bcd\u4e0d\u4e3a 0\u3002 \u8f93\u51fa\u683c\u5f0f \u5206\u522b\u5728 4 \u884c\u4e2d\u6309\u7167 \u6709\u7406\u65701 \u8fd0\u7b97\u7b26 \u6709\u7406\u65702 = \u7ed3\u679c \u7684\u683c\u5f0f\u987a\u5e8f\u8f93\u51fa 2 \u4e2a\u6709\u7406\u6570\u7684\u548c\u3001\u5dee\u3001\u79ef\u3001\u5546\u3002\u6ce8\u610f\u8f93\u51fa\u7684\u6bcf\u4e2a\u6709\u7406\u6570\u5fc5\u987b\u662f\u8be5\u6709\u7406\u6570\u7684\u6700\u7b80\u5f62\u5f0f k a/b \uff0c\u5176\u4e2d k \u662f\u6574\u6570\u90e8\u5206\uff0c a/b \u662f\u6700\u7b80\u5206\u6570\u90e8\u5206\uff1b\u82e5\u4e3a\u8d1f\u6570\uff0c\u5219\u987b\u52a0\u62ec\u53f7\uff1b\u82e5\u9664\u6cd5\u5206\u6bcd\u4e3a 0\uff0c\u5219\u8f93\u51fa Inf \u3002\u9898\u76ee\u4fdd\u8bc1\u6b63\u786e\u7684\u8f93\u51fa\u4e2d\u6ca1\u6709\u8d85\u8fc7\u6574\u578b\u8303\u56f4\u7684\u6574\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 2/3 -4/2 \u8f93\u51fa\u6837\u4f8b 1 2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) \u8f93\u5165\u6837\u4f8b 2 5/3 0/6 \u8f93\u51fa\u6837\u4f8b 2 1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf Solution C++ #include <bits/stdc++.h> using namespace std ; typedef long long LL ; LL gcd ( LL x , LL y ) { LL r ; while ( 1 ) { r = x % y ; if ( ! r ) break ; x = y ; y = r ; } return y ; } struct pp { LL a = 0 , b , total = 0 ; } n1 , n2 , n11 , n22 ; pp tran ( pp x ) { LL num = gcd ( x . a , x . b ); if ( num < 0 ) num *= -1 ; x . a /= num , x . b /= num ; x . total += x . a / x . b ; x . a %= x . b ; if ( x . a < 0 && x . total ) x . a *= -1 ; return x ; } void print ( pp x ) { if ( x . total != 0 && x . a != 0 ) { if ( x . total < 0 ) printf ( \"(%d %d/%d)\" , x . total , x . a , x . b ); else printf ( \"%d %d/%d\" , x . total , x . a , x . b ); } else if ( x . a ) { if ( x . a < 0 ) printf ( \"(%d/%d)\" , x . a , x . b ); else printf ( \"%d/%d\" , x . a , x . b ); } else if ( x . total ) { if ( x . total < 0 ) printf ( \"(%d)\" , x . total ); else printf ( \"%d\" , x . total ); } else printf ( \"0\" ); } pp pluss ( pp x , pp y ) { pp num ; LL m = ( x . b * y . b ) / gcd ( x . b , y . b ); num . a = ( x . a * ( m / x . b ) + y . a * ( m / y . b )), num . b = m ; num = tran ( num ); return num ; } pp minuss ( pp x , pp y ) { if ( y . total ) y . total *= -1 ; else if ( y . a ) y . a *= -1 ; pp num = pluss ( x , y ); return num ; } pp times ( pp x , pp y ) { pp num ; if ( x . a && y . a ) { num . a = x . a * y . a ; num . b = x . b * y . b ; } num = tran ( num ); return num ; } void paint ( pp x , pp y , pp num , char c ) { print ( x ); printf ( \" %c \" , c ); print ( y ); printf ( \" = \" ); print ( num ); cout << endl ; } int main () { scanf ( \"%lld/%lld %lld/%lld\" , & n1 . a , & n1 . b , & n2 . a , & n2 . b ); n11 = tran ( n1 ), n22 = tran ( n2 ); if ( n1 . a ) paint ( n11 , n22 , pluss ( n1 , n2 ), '+' ); else { printf ( \"0 + \" ); print ( n22 ); printf ( \" = \" ); print ( n22 ); cout << endl ; } if ( n1 . a ) paint ( n11 , n22 , minuss ( n1 , n2 ), '-' ); else { printf ( \"0 - \" ); print ( n22 ); printf ( \" = \" ); pp temp = n2 ; temp . a *= -1 ; print ( tran ( temp )); cout << endl ; } if ( n2 . a && n1 . a ) { paint ( n11 , n22 , times ( n1 , n2 ), '*' ); } else if ( n1 . a ) { print ( n11 ); printf ( \" * 0 = 0 \\n \" ); } else { printf ( \"0 * \" ); print ( n22 ); printf ( \" = 0 \\n \" ); } if ( n2 . a && n1 . a ) { if ( n2 . a < 0 ) n2 . a *= -1 , n2 . b *= -1 ; swap ( n2 . a , n2 . b ); paint ( n11 , n22 , times ( n1 , n2 ), '/' ); } else if ( n1 . a ) { print ( n11 ); printf ( \" / 0 = Inf \\n \" ); } else { printf ( \"0 / \" ); print ( n22 ); printf ( \" = 0 \\n \" ); } }","title":"1034-\u6709\u7406\u6570\u56db\u5219\u8fd0\u7b97"},{"location":"PAT-Basic-Level/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/#1034-\u6709\u7406\u6570\u56db\u5219\u8fd0\u7b97","text":"","title":"1034 \u6709\u7406\u6570\u56db\u5219\u8fd0\u7b97"},{"location":"PAT-Basic-Level/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u7f16\u5199\u7a0b\u5e8f\uff0c\u8ba1\u7b97 2 \u4e2a\u6709\u7406\u6570\u7684\u548c\u3001\u5dee\u3001\u79ef\u3001\u5546\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309\u7167 a1/b1 a2/b2 \u7684\u683c\u5f0f\u7ed9\u51fa\u4e24\u4e2a\u5206\u6570\u5f62\u5f0f\u7684\u6709\u7406\u6570\uff0c\u5176\u4e2d\u5206\u5b50\u548c\u5206\u6bcd\u5168\u662f\u6574\u578b\u8303\u56f4\u5185\u7684\u6574\u6570\uff0c\u8d1f\u53f7\u53ea\u53ef\u80fd\u51fa\u73b0\u5728\u5206\u5b50\u524d\uff0c\u5206\u6bcd\u4e0d\u4e3a 0\u3002 \u8f93\u51fa\u683c\u5f0f \u5206\u522b\u5728 4 \u884c\u4e2d\u6309\u7167 \u6709\u7406\u65701 \u8fd0\u7b97\u7b26 \u6709\u7406\u65702 = \u7ed3\u679c \u7684\u683c\u5f0f\u987a\u5e8f\u8f93\u51fa 2 \u4e2a\u6709\u7406\u6570\u7684\u548c\u3001\u5dee\u3001\u79ef\u3001\u5546\u3002\u6ce8\u610f\u8f93\u51fa\u7684\u6bcf\u4e2a\u6709\u7406\u6570\u5fc5\u987b\u662f\u8be5\u6709\u7406\u6570\u7684\u6700\u7b80\u5f62\u5f0f k a/b \uff0c\u5176\u4e2d k \u662f\u6574\u6570\u90e8\u5206\uff0c a/b \u662f\u6700\u7b80\u5206\u6570\u90e8\u5206\uff1b\u82e5\u4e3a\u8d1f\u6570\uff0c\u5219\u987b\u52a0\u62ec\u53f7\uff1b\u82e5\u9664\u6cd5\u5206\u6bcd\u4e3a 0\uff0c\u5219\u8f93\u51fa Inf \u3002\u9898\u76ee\u4fdd\u8bc1\u6b63\u786e\u7684\u8f93\u51fa\u4e2d\u6ca1\u6709\u8d85\u8fc7\u6574\u578b\u8303\u56f4\u7684\u6574\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 2/3 -4/2 \u8f93\u51fa\u6837\u4f8b 1 2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) \u8f93\u5165\u6837\u4f8b 2 5/3 0/6 \u8f93\u51fa\u6837\u4f8b 2 1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf","title":"Statement"},{"location":"PAT-Basic-Level/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; typedef long long LL ; LL gcd ( LL x , LL y ) { LL r ; while ( 1 ) { r = x % y ; if ( ! r ) break ; x = y ; y = r ; } return y ; } struct pp { LL a = 0 , b , total = 0 ; } n1 , n2 , n11 , n22 ; pp tran ( pp x ) { LL num = gcd ( x . a , x . b ); if ( num < 0 ) num *= -1 ; x . a /= num , x . b /= num ; x . total += x . a / x . b ; x . a %= x . b ; if ( x . a < 0 && x . total ) x . a *= -1 ; return x ; } void print ( pp x ) { if ( x . total != 0 && x . a != 0 ) { if ( x . total < 0 ) printf ( \"(%d %d/%d)\" , x . total , x . a , x . b ); else printf ( \"%d %d/%d\" , x . total , x . a , x . b ); } else if ( x . a ) { if ( x . a < 0 ) printf ( \"(%d/%d)\" , x . a , x . b ); else printf ( \"%d/%d\" , x . a , x . b ); } else if ( x . total ) { if ( x . total < 0 ) printf ( \"(%d)\" , x . total ); else printf ( \"%d\" , x . total ); } else printf ( \"0\" ); } pp pluss ( pp x , pp y ) { pp num ; LL m = ( x . b * y . b ) / gcd ( x . b , y . b ); num . a = ( x . a * ( m / x . b ) + y . a * ( m / y . b )), num . b = m ; num = tran ( num ); return num ; } pp minuss ( pp x , pp y ) { if ( y . total ) y . total *= -1 ; else if ( y . a ) y . a *= -1 ; pp num = pluss ( x , y ); return num ; } pp times ( pp x , pp y ) { pp num ; if ( x . a && y . a ) { num . a = x . a * y . a ; num . b = x . b * y . b ; } num = tran ( num ); return num ; } void paint ( pp x , pp y , pp num , char c ) { print ( x ); printf ( \" %c \" , c ); print ( y ); printf ( \" = \" ); print ( num ); cout << endl ; } int main () { scanf ( \"%lld/%lld %lld/%lld\" , & n1 . a , & n1 . b , & n2 . a , & n2 . b ); n11 = tran ( n1 ), n22 = tran ( n2 ); if ( n1 . a ) paint ( n11 , n22 , pluss ( n1 , n2 ), '+' ); else { printf ( \"0 + \" ); print ( n22 ); printf ( \" = \" ); print ( n22 ); cout << endl ; } if ( n1 . a ) paint ( n11 , n22 , minuss ( n1 , n2 ), '-' ); else { printf ( \"0 - \" ); print ( n22 ); printf ( \" = \" ); pp temp = n2 ; temp . a *= -1 ; print ( tran ( temp )); cout << endl ; } if ( n2 . a && n1 . a ) { paint ( n11 , n22 , times ( n1 , n2 ), '*' ); } else if ( n1 . a ) { print ( n11 ); printf ( \" * 0 = 0 \\n \" ); } else { printf ( \"0 * \" ); print ( n22 ); printf ( \" = 0 \\n \" ); } if ( n2 . a && n1 . a ) { if ( n2 . a < 0 ) n2 . a *= -1 , n2 . b *= -1 ; swap ( n2 . a , n2 . b ); paint ( n11 , n22 , times ( n1 , n2 ), '/' ); } else if ( n1 . a ) { print ( n11 ); printf ( \" / 0 = Inf \\n \" ); } else { printf ( \"0 / \" ); print ( n22 ); printf ( \" = 0 \\n \" ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6/","text":"1035 \u63d2\u5165\u4e0e\u5f52\u5e76 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u7ef4\u57fa\u767e\u79d1\u7684\u5b9a\u4e49\uff1a \u63d2\u5165\u6392\u5e8f \u662f\u8fed\u4ee3\u7b97\u6cd5\uff0c\u9010\u4e00\u83b7\u5f97\u8f93\u5165\u6570\u636e\uff0c\u9010\u6b65\u4ea7\u751f\u6709\u5e8f\u7684\u8f93\u51fa\u5e8f\u5217\u3002\u6bcf\u6b65\u8fed\u4ee3\u4e2d\uff0c\u7b97\u6cd5\u4ece\u8f93\u5165\u5e8f\u5217\u4e2d\u53d6\u51fa\u4e00\u5143\u7d20\uff0c\u5c06\u4e4b\u63d2\u5165\u6709\u5e8f\u5e8f\u5217\u4e2d\u6b63\u786e\u7684\u4f4d\u7f6e\u3002\u5982\u6b64\u8fed\u4ee3\u76f4\u5230\u5168\u90e8\u5143\u7d20\u6709\u5e8f\u3002 \u5f52\u5e76\u6392\u5e8f \u8fdb\u884c\u5982\u4e0b\u8fed\u4ee3\u64cd\u4f5c\uff1a\u9996\u5148\u5c06\u539f\u59cb\u5e8f\u5217\u770b\u6210 N \u4e2a\u53ea\u5305\u542b 1 \u4e2a\u5143\u7d20\u7684\u6709\u5e8f\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u6bcf\u6b21\u8fed\u4ee3\u5f52\u5e76\u4e24\u4e2a\u76f8\u90bb\u7684\u6709\u5e8f\u5b50\u5e8f\u5217\uff0c\u76f4\u5230\u6700\u540e\u53ea\u5269\u4e0b 1 \u4e2a\u6709\u5e8f\u7684\u5e8f\u5217\u3002 \u73b0\u7ed9\u5b9a\u539f\u59cb\u5e8f\u5217\u548c\u7531\u67d0\u6392\u5e8f\u7b97\u6cd5\u4ea7\u751f\u7684\u4e2d\u95f4\u5e8f\u5217\uff0c\u8bf7\u4f60\u5224\u65ad\u8be5\u7b97\u6cd5\u7a76\u7adf\u662f\u54ea\u79cd\u6392\u5e8f\u7b97\u6cd5\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N ( \\le \\le 100)\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u539f\u59cb\u5e8f\u5217\u7684 N \u4e2a\u6574\u6570\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u7531\u67d0\u6392\u5e8f\u7b97\u6cd5\u4ea7\u751f\u7684\u4e2d\u95f4\u5e8f\u5217\u3002\u8fd9\u91cc\u5047\u8bbe\u6392\u5e8f\u7684\u76ee\u6807\u5e8f\u5217\u662f\u5347\u5e8f\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c 1 \u884c\u4e2d\u8f93\u51fa Insertion Sort \u8868\u793a\u63d2\u5165\u6392\u5e8f\u3001\u6216 Merge Sort \u8868\u793a\u5f52\u5e76\u6392\u5e8f\uff1b\u7136\u540e\u5728\u7b2c 2 \u884c\u4e2d\u8f93\u51fa\u7528\u8be5\u6392\u5e8f\u7b97\u6cd5\u518d\u8fed\u4ee3\u4e00\u8f6e\u7684\u7ed3\u679c\u5e8f\u5217\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u7ec4\u6d4b\u8bd5\u7684\u7ed3\u679c\u662f\u552f\u4e00\u7684\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4e14\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 \u8f93\u51fa\u6837\u4f8b 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 \u8f93\u5165\u6837\u4f8b 2 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 \u8f93\u51fa\u6837\u4f8b 2 Merge Sort 1 2 3 8 4 5 7 9 0 6 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n ; scanf ( \"%d\" , & n ); vector < int > origin ( n ), target ( n ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%d\" , & origin [ i ]); } for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%d\" , & target [ i ]); } int index = -1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( target [ i ] < target [ i - 1 ]) { index = i ; break ; } } int flag = 0 ; for ( int i = index ; i < n ; ++ i ) { if ( target [ i ] != origin [ i ]) { flag = 1 ; break ; } } if ( flag == 0 ) { printf ( \"Insertion Sort \\n \" ); sort ( target . begin (), target . begin () + index + 1 ); for ( int i = 0 ; i < n - 1 ; i ++ ) printf ( \"%d \" , target [ i ]); printf ( \"%d \\n \" , target [ n - 1 ]); } else { printf ( \"Merge Sort \\n \" ); int k = 1 ; while ( flag ) { flag = 0 ; if ( ! equal ( origin . begin (), origin . end (), target . begin ())) { flag = 1 ; } k *= 2 ; for ( int i = 0 ; i < n / k ; ++ i ) { sort ( origin . begin () + i * k , origin . begin () + ( i + 1 ) * k ); } sort ( origin . begin () + k * ( n / k ), origin . end ()); } for ( int i = 0 ; i < n - 1 ; i ++ ) printf ( \"%d \" , origin [ i ]); printf ( \"%d \\n \" , origin [ n - 1 ]); } }","title":"1035-\u63d2\u5165\u4e0e\u5f52\u5e76"},{"location":"PAT-Basic-Level/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6/#1035-\u63d2\u5165\u4e0e\u5f52\u5e76","text":"","title":"1035 \u63d2\u5165\u4e0e\u5f52\u5e76"},{"location":"PAT-Basic-Level/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6839\u636e\u7ef4\u57fa\u767e\u79d1\u7684\u5b9a\u4e49\uff1a \u63d2\u5165\u6392\u5e8f \u662f\u8fed\u4ee3\u7b97\u6cd5\uff0c\u9010\u4e00\u83b7\u5f97\u8f93\u5165\u6570\u636e\uff0c\u9010\u6b65\u4ea7\u751f\u6709\u5e8f\u7684\u8f93\u51fa\u5e8f\u5217\u3002\u6bcf\u6b65\u8fed\u4ee3\u4e2d\uff0c\u7b97\u6cd5\u4ece\u8f93\u5165\u5e8f\u5217\u4e2d\u53d6\u51fa\u4e00\u5143\u7d20\uff0c\u5c06\u4e4b\u63d2\u5165\u6709\u5e8f\u5e8f\u5217\u4e2d\u6b63\u786e\u7684\u4f4d\u7f6e\u3002\u5982\u6b64\u8fed\u4ee3\u76f4\u5230\u5168\u90e8\u5143\u7d20\u6709\u5e8f\u3002 \u5f52\u5e76\u6392\u5e8f \u8fdb\u884c\u5982\u4e0b\u8fed\u4ee3\u64cd\u4f5c\uff1a\u9996\u5148\u5c06\u539f\u59cb\u5e8f\u5217\u770b\u6210 N \u4e2a\u53ea\u5305\u542b 1 \u4e2a\u5143\u7d20\u7684\u6709\u5e8f\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u6bcf\u6b21\u8fed\u4ee3\u5f52\u5e76\u4e24\u4e2a\u76f8\u90bb\u7684\u6709\u5e8f\u5b50\u5e8f\u5217\uff0c\u76f4\u5230\u6700\u540e\u53ea\u5269\u4e0b 1 \u4e2a\u6709\u5e8f\u7684\u5e8f\u5217\u3002 \u73b0\u7ed9\u5b9a\u539f\u59cb\u5e8f\u5217\u548c\u7531\u67d0\u6392\u5e8f\u7b97\u6cd5\u4ea7\u751f\u7684\u4e2d\u95f4\u5e8f\u5217\uff0c\u8bf7\u4f60\u5224\u65ad\u8be5\u7b97\u6cd5\u7a76\u7adf\u662f\u54ea\u79cd\u6392\u5e8f\u7b97\u6cd5\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N ( \\le \\le 100)\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u539f\u59cb\u5e8f\u5217\u7684 N \u4e2a\u6574\u6570\uff1b\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u7531\u67d0\u6392\u5e8f\u7b97\u6cd5\u4ea7\u751f\u7684\u4e2d\u95f4\u5e8f\u5217\u3002\u8fd9\u91cc\u5047\u8bbe\u6392\u5e8f\u7684\u76ee\u6807\u5e8f\u5217\u662f\u5347\u5e8f\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c 1 \u884c\u4e2d\u8f93\u51fa Insertion Sort \u8868\u793a\u63d2\u5165\u6392\u5e8f\u3001\u6216 Merge Sort \u8868\u793a\u5f52\u5e76\u6392\u5e8f\uff1b\u7136\u540e\u5728\u7b2c 2 \u884c\u4e2d\u8f93\u51fa\u7528\u8be5\u6392\u5e8f\u7b97\u6cd5\u518d\u8fed\u4ee3\u4e00\u8f6e\u7684\u7ed3\u679c\u5e8f\u5217\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u7ec4\u6d4b\u8bd5\u7684\u7ed3\u679c\u662f\u552f\u4e00\u7684\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4e14\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 1 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 \u8f93\u51fa\u6837\u4f8b 1 Insertion Sort 1 2 3 5 7 8 9 4 6 0 \u8f93\u5165\u6837\u4f8b 2 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 \u8f93\u51fa\u6837\u4f8b 2 Merge Sort 1 2 3 8 4 5 7 9 0 6","title":"Statement"},{"location":"PAT-Basic-Level/1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n ; scanf ( \"%d\" , & n ); vector < int > origin ( n ), target ( n ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%d\" , & origin [ i ]); } for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%d\" , & target [ i ]); } int index = -1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( target [ i ] < target [ i - 1 ]) { index = i ; break ; } } int flag = 0 ; for ( int i = index ; i < n ; ++ i ) { if ( target [ i ] != origin [ i ]) { flag = 1 ; break ; } } if ( flag == 0 ) { printf ( \"Insertion Sort \\n \" ); sort ( target . begin (), target . begin () + index + 1 ); for ( int i = 0 ; i < n - 1 ; i ++ ) printf ( \"%d \" , target [ i ]); printf ( \"%d \\n \" , target [ n - 1 ]); } else { printf ( \"Merge Sort \\n \" ); int k = 1 ; while ( flag ) { flag = 0 ; if ( ! equal ( origin . begin (), origin . end (), target . begin ())) { flag = 1 ; } k *= 2 ; for ( int i = 0 ; i < n / k ; ++ i ) { sort ( origin . begin () + i * k , origin . begin () + ( i + 1 ) * k ); } sort ( origin . begin () + k * ( n / k ), origin . end ()); } for ( int i = 0 ; i < n - 1 ; i ++ ) printf ( \"%d \" , origin [ i ]); printf ( \"%d \\n \" , origin [ n - 1 ]); } }","title":"Solution"},{"location":"PAT-Basic-Level/1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/","text":"1036 \u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u7f16\u7a0b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f8e\u56fd\u603b\u7edf\u5965\u5df4\u9a6c\u4e0d\u4ec5\u547c\u5401\u6240\u6709\u4eba\u90fd\u5b66\u4e60\u7f16\u7a0b\uff0c\u751a\u81f3\u4ee5\u8eab\u4f5c\u5219\u7f16\u5199\u4ee3\u7801\uff0c\u6210\u4e3a\u7f8e\u56fd\u5386\u53f2\u4e0a\u9996\u4f4d\u7f16\u5199\u8ba1\u7b97\u673a\u4ee3\u7801\u7684\u603b\u7edf\u30022014 \u5e74\u5e95\uff0c\u4e3a\u5e86\u795d\u201c\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u5468\u201d\u6b63\u5f0f\u542f\u52a8\uff0c\u5965\u5df4\u9a6c\u7f16\u5199\u4e86\u5f88\u7b80\u5355\u7684\u8ba1\u7b97\u673a\u4ee3\u7801\uff1a\u5728\u5c4f\u5e55\u4e0a\u753b\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002\u73b0\u5728\u4f60\u4e5f\u8ddf\u4ed6\u4e00\u8d77\u753b\u5427\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u65b9\u5f62\u8fb9\u957f N N \uff08 3\\le N\\le 20 3\\le N\\le 20 \uff09\u548c\u7ec4\u6210\u6b63\u65b9\u5f62\u8fb9\u7684\u67d0\u79cd\u5b57\u7b26 C\uff0c\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7531\u7ed9\u5b9a\u5b57\u7b26 C \u753b\u51fa\u7684\u6b63\u65b9\u5f62\u3002\u4f46\u662f\u6ce8\u610f\u5230\u884c\u95f4\u8ddd\u6bd4\u5217\u95f4\u8ddd\u5927\uff0c\u6240\u4ee5\u4e3a\u4e86\u8ba9\u7ed3\u679c\u770b\u4e0a\u53bb\u66f4\u50cf\u6b63\u65b9\u5f62\uff0c\u6211\u4eec\u8f93\u51fa\u7684\u884c\u6570\u5b9e\u9645\u4e0a\u662f\u5217\u6570\u7684 50%\uff08\u56db\u820d\u4e94\u5165\u53d6\u6574\uff09\u3002 \u8f93\u5165\u6837\u4f8b 10 a \u8f93\u51fa\u6837\u4f8b aaaaaaaaaa a a a a a a aaaaaaaaaa Solution C #include <stdio.h> int main () { int n , m , c ; scanf ( \"%d %c\" , & n , & c ); int i , j ; if ( n % 2 == 0 ) m = n / 2 ; else m = ( n / 2 ) + 1 ; for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( i == 1 || i == m || j == 1 || j == n ) printf ( \"%c\" , c ); else printf ( \" \" ); } printf ( \" \\n \" ); } }","title":"1036-\u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u7f16\u7a0b"},{"location":"PAT-Basic-Level/1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/#1036-\u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u7f16\u7a0b","text":"","title":"1036 \u8ddf\u5965\u5df4\u9a6c\u4e00\u8d77\u7f16\u7a0b"},{"location":"PAT-Basic-Level/1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f8e\u56fd\u603b\u7edf\u5965\u5df4\u9a6c\u4e0d\u4ec5\u547c\u5401\u6240\u6709\u4eba\u90fd\u5b66\u4e60\u7f16\u7a0b\uff0c\u751a\u81f3\u4ee5\u8eab\u4f5c\u5219\u7f16\u5199\u4ee3\u7801\uff0c\u6210\u4e3a\u7f8e\u56fd\u5386\u53f2\u4e0a\u9996\u4f4d\u7f16\u5199\u8ba1\u7b97\u673a\u4ee3\u7801\u7684\u603b\u7edf\u30022014 \u5e74\u5e95\uff0c\u4e3a\u5e86\u795d\u201c\u8ba1\u7b97\u673a\u79d1\u5b66\u6559\u80b2\u5468\u201d\u6b63\u5f0f\u542f\u52a8\uff0c\u5965\u5df4\u9a6c\u7f16\u5199\u4e86\u5f88\u7b80\u5355\u7684\u8ba1\u7b97\u673a\u4ee3\u7801\uff1a\u5728\u5c4f\u5e55\u4e0a\u753b\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002\u73b0\u5728\u4f60\u4e5f\u8ddf\u4ed6\u4e00\u8d77\u753b\u5427\uff01 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u65b9\u5f62\u8fb9\u957f N N \uff08 3\\le N\\le 20 3\\le N\\le 20 \uff09\u548c\u7ec4\u6210\u6b63\u65b9\u5f62\u8fb9\u7684\u67d0\u79cd\u5b57\u7b26 C\uff0c\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u7531\u7ed9\u5b9a\u5b57\u7b26 C \u753b\u51fa\u7684\u6b63\u65b9\u5f62\u3002\u4f46\u662f\u6ce8\u610f\u5230\u884c\u95f4\u8ddd\u6bd4\u5217\u95f4\u8ddd\u5927\uff0c\u6240\u4ee5\u4e3a\u4e86\u8ba9\u7ed3\u679c\u770b\u4e0a\u53bb\u66f4\u50cf\u6b63\u65b9\u5f62\uff0c\u6211\u4eec\u8f93\u51fa\u7684\u884c\u6570\u5b9e\u9645\u4e0a\u662f\u5217\u6570\u7684 50%\uff08\u56db\u820d\u4e94\u5165\u53d6\u6574\uff09\u3002 \u8f93\u5165\u6837\u4f8b 10 a \u8f93\u51fa\u6837\u4f8b aaaaaaaaaa a a a a a a aaaaaaaaaa","title":"Statement"},{"location":"PAT-Basic-Level/1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/#solution","text":"C #include <stdio.h> int main () { int n , m , c ; scanf ( \"%d %c\" , & n , & c ); int i , j ; if ( n % 2 == 0 ) m = n / 2 ; else m = ( n / 2 ) + 1 ; for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( i == 1 || i == m || j == 1 || j == n ) printf ( \"%c\" , c ); else printf ( \" \" ); } printf ( \" \\n \" ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/","text":"1037 \u5728\u970d\u683c\u6c83\u8328\u627e\u96f6\u94b1 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4f60\u662f\u54c8\u5229\u00b7\u6ce2\u7279\u8ff7\uff0c\u4f60\u4f1a\u77e5\u9053\u9b54\u6cd5\u4e16\u754c\u6709\u5b83\u81ea\u5df1\u7684\u8d27\u5e01\u7cfb\u7edf \u2014\u2014 \u5c31\u5982\u6d77\u683c\u544a\u8bc9\u54c8\u5229\u7684\uff1a\u201c\u5341\u4e03\u4e2a\u94f6\u897f\u53ef(Sickle)\u5151\u4e00\u4e2a\u52a0\u9686(Galleon)\uff0c\u4e8c\u5341\u4e5d\u4e2a\u7eb3\u7279(Knut)\u5151\u4e00\u4e2a\u897f\u53ef\uff0c\u5f88\u5bb9\u6613\u3002\u201d\u73b0\u5728\uff0c\u7ed9\u5b9a\u54c8\u5229\u5e94\u4ed8\u7684\u4ef7\u94b1 P P \u548c\u4ed6\u5b9e\u4ed8\u7684\u94b1 A A \uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u8ba1\u7b97\u4ed6\u5e94\u8be5\u88ab\u627e\u7684\u96f6\u94b1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 1 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa P P \u548c A A \uff0c\u683c\u5f0f\u4e3a Galleon.Sickle.Knut \uff0c\u5176\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u8fd9\u91cc Galleon \u662f [0, 10^7 10^7 ] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c Sickle \u662f [0, 17) \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c Knut \u662f [0, 29) \u533a\u95f4\u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7528\u4e0e\u8f93\u5165\u540c\u6837\u7684\u683c\u5f0f\u8f93\u51fa\u54c8\u5229\u5e94\u8be5\u88ab\u627e\u7684\u96f6\u94b1\u3002\u5982\u679c\u4ed6\u6ca1\u5e26\u591f\u94b1\uff0c\u90a3\u4e48\u8f93\u51fa\u7684\u5e94\u8be5\u662f\u8d1f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 10.16.27 14.1.28 \u8f93\u51fa\u6837\u4f8b 1 3.2.1 \u8f93\u5165\u6837\u4f8b 2 14.1.28 10.16.27 \u8f93\u51fa\u6837\u4f8b 2 -3.2.1 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c , d , e , f , tot1 = 0 , tot2 = 0 , total ; scanf ( \"%d.%d.%d %d.%d.%d\" , & a , & b , & c , & d , & e , & f ); tot1 = ( a * 17 + b ) * 29 + c ; tot2 = ( d * 17 + e ) * 29 + f ; if ( tot1 < tot2 ) { total = tot2 - tot1 ; a = total / 493 ; total %= 493 ; b = total / 29 ; c = total % 29 ; printf ( \"%d.%d.%d \\n \" , a , b , c ); } else if ( tot1 == tot2 ) printf ( \"0.0.0 \\n \" ); else { total = tot1 - tot2 ; a = total / 493 ; total %= 493 ; b = total / 29 ; c = total % 29 ; printf ( \"-%d.%d.%d \\n \" , a , b , c ); } }","title":"1037-\u5728\u970d\u683c\u6c83\u8328\u627e\u96f6\u94b1"},{"location":"PAT-Basic-Level/1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/#1037-\u5728\u970d\u683c\u6c83\u8328\u627e\u96f6\u94b1","text":"","title":"1037 \u5728\u970d\u683c\u6c83\u8328\u627e\u96f6\u94b1"},{"location":"PAT-Basic-Level/1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4f60\u662f\u54c8\u5229\u00b7\u6ce2\u7279\u8ff7\uff0c\u4f60\u4f1a\u77e5\u9053\u9b54\u6cd5\u4e16\u754c\u6709\u5b83\u81ea\u5df1\u7684\u8d27\u5e01\u7cfb\u7edf \u2014\u2014 \u5c31\u5982\u6d77\u683c\u544a\u8bc9\u54c8\u5229\u7684\uff1a\u201c\u5341\u4e03\u4e2a\u94f6\u897f\u53ef(Sickle)\u5151\u4e00\u4e2a\u52a0\u9686(Galleon)\uff0c\u4e8c\u5341\u4e5d\u4e2a\u7eb3\u7279(Knut)\u5151\u4e00\u4e2a\u897f\u53ef\uff0c\u5f88\u5bb9\u6613\u3002\u201d\u73b0\u5728\uff0c\u7ed9\u5b9a\u54c8\u5229\u5e94\u4ed8\u7684\u4ef7\u94b1 P P \u548c\u4ed6\u5b9e\u4ed8\u7684\u94b1 A A \uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5199\u4e00\u4e2a\u7a0b\u5e8f\u6765\u8ba1\u7b97\u4ed6\u5e94\u8be5\u88ab\u627e\u7684\u96f6\u94b1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728 1 \u884c\u4e2d\u5206\u522b\u7ed9\u51fa P P \u548c A A \uff0c\u683c\u5f0f\u4e3a Galleon.Sickle.Knut \uff0c\u5176\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u8fd9\u91cc Galleon \u662f [0, 10^7 10^7 ] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c Sickle \u662f [0, 17) \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c Knut \u662f [0, 29) \u533a\u95f4\u5185\u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7528\u4e0e\u8f93\u5165\u540c\u6837\u7684\u683c\u5f0f\u8f93\u51fa\u54c8\u5229\u5e94\u8be5\u88ab\u627e\u7684\u96f6\u94b1\u3002\u5982\u679c\u4ed6\u6ca1\u5e26\u591f\u94b1\uff0c\u90a3\u4e48\u8f93\u51fa\u7684\u5e94\u8be5\u662f\u8d1f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 10.16.27 14.1.28 \u8f93\u51fa\u6837\u4f8b 1 3.2.1 \u8f93\u5165\u6837\u4f8b 2 14.1.28 10.16.27 \u8f93\u51fa\u6837\u4f8b 2 -3.2.1","title":"Statement"},{"location":"PAT-Basic-Level/1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b , c , d , e , f , tot1 = 0 , tot2 = 0 , total ; scanf ( \"%d.%d.%d %d.%d.%d\" , & a , & b , & c , & d , & e , & f ); tot1 = ( a * 17 + b ) * 29 + c ; tot2 = ( d * 17 + e ) * 29 + f ; if ( tot1 < tot2 ) { total = tot2 - tot1 ; a = total / 493 ; total %= 493 ; b = total / 29 ; c = total % 29 ; printf ( \"%d.%d.%d \\n \" , a , b , c ); } else if ( tot1 == tot2 ) printf ( \"0.0.0 \\n \" ); else { total = tot1 - tot2 ; a = total / 493 ; total %= 493 ; b = total / 29 ; c = total % 29 ; printf ( \"-%d.%d.%d \\n \" , a , b , c ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/","text":"1038 \u7edf\u8ba1\u540c\u6210\u7ee9\u5b66\u751f Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u8bfb\u5165 N N \u540d\u5b66\u751f\u7684\u6210\u7ee9\uff0c\u5c06\u83b7\u5f97\u67d0\u4e00\u7ed9\u5b9a\u5206\u6570\u7684\u5b66\u751f\u4eba\u6570\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u5b66\u751f\u603b\u4eba\u6570\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u540d\u5b66\u751f\u7684\u767e\u5206\u5236\u6574\u6570\u6210\u7ee9\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u8981\u67e5\u8be2\u7684\u5206\u6570\u4e2a\u6570 K K \uff08\u4e0d\u8d85\u8fc7 N N \u7684\u6b63\u6574\u6570\uff09\uff0c\u968f\u540e\u662f K K \u4e2a\u5206\u6570\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u67e5\u8be2\u987a\u5e8f\u7ed9\u51fa\u5f97\u5206\u7b49\u4e8e\u6307\u5b9a\u5206\u6570\u7684\u5b66\u751f\u4eba\u6570\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 60 75 90 55 75 99 82 90 75 50 3 75 90 88 \u8f93\u51fa\u6837\u4f8b 3 2 0 Solution C++ #include <cstring> #include <iostream> using namespace std ; int main () { int n , m , a , i , j ; int num [ 100000 ] = { 0 }, list [ 100 ], joy [ 100 ] = { 0 }; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> num [ i ]; } cin >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> list [ i ]; for ( j = 0 ; j < n ; j ++ ) { if ( num [ j ] == list [ i ]) { joy [ list [ i ]] ++ ; } } } /*for(i=0; i<n; i++){ for(j=0; j<m; j++){ if(num[i]==list[j]){ joy[list[j]]++; } } }*/ for ( i = 0 ; i < m - 1 ; i ++ ) { cout << joy [ list [ i ]] << ' ' ; } cout << joy [ list [ m - 1 ]] << endl ; }","title":"1038-\u7edf\u8ba1\u540c\u6210\u7ee9\u5b66\u751f"},{"location":"PAT-Basic-Level/1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/#1038-\u7edf\u8ba1\u540c\u6210\u7ee9\u5b66\u751f","text":"","title":"1038 \u7edf\u8ba1\u540c\u6210\u7ee9\u5b66\u751f"},{"location":"PAT-Basic-Level/1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u8bfb\u5165 N N \u540d\u5b66\u751f\u7684\u6210\u7ee9\uff0c\u5c06\u83b7\u5f97\u67d0\u4e00\u7ed9\u5b9a\u5206\u6570\u7684\u5b66\u751f\u4eba\u6570\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u5b66\u751f\u603b\u4eba\u6570\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u540d\u5b66\u751f\u7684\u767e\u5206\u5236\u6574\u6570\u6210\u7ee9\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e\u4e00\u884c\u7ed9\u51fa\u8981\u67e5\u8be2\u7684\u5206\u6570\u4e2a\u6570 K K \uff08\u4e0d\u8d85\u8fc7 N N \u7684\u6b63\u6574\u6570\uff09\uff0c\u968f\u540e\u662f K K \u4e2a\u5206\u6570\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u67e5\u8be2\u987a\u5e8f\u7ed9\u51fa\u5f97\u5206\u7b49\u4e8e\u6307\u5b9a\u5206\u6570\u7684\u5b66\u751f\u4eba\u6570\uff0c\u4e2d\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u4f46\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 60 75 90 55 75 99 82 90 75 50 3 75 90 88 \u8f93\u51fa\u6837\u4f8b 3 2 0","title":"Statement"},{"location":"PAT-Basic-Level/1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/#solution","text":"C++ #include <cstring> #include <iostream> using namespace std ; int main () { int n , m , a , i , j ; int num [ 100000 ] = { 0 }, list [ 100 ], joy [ 100 ] = { 0 }; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> num [ i ]; } cin >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> list [ i ]; for ( j = 0 ; j < n ; j ++ ) { if ( num [ j ] == list [ i ]) { joy [ list [ i ]] ++ ; } } } /*for(i=0; i<n; i++){ for(j=0; j<m; j++){ if(num[i]==list[j]){ joy[list[j]]++; } } }*/ for ( i = 0 ; i < m - 1 ; i ++ ) { cout << joy [ list [ i ]] << ' ' ; } cout << joy [ list [ m - 1 ]] << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/","text":"1039 \u5230\u5e95\u4e70\u4e0d\u4e70 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u7ea2\u60f3\u4e70\u4e9b\u73e0\u5b50\u505a\u4e00\u4e32\u81ea\u5df1\u559c\u6b22\u7684\u73e0\u4e32\u3002\u5356\u73e0\u5b50\u7684\u644a\u4e3b\u6709\u5f88\u591a\u4e32\u4e94\u989c\u516d\u8272\u7684\u73e0\u4e32\uff0c\u4f46\u662f\u4e0d\u80af\u628a\u4efb\u4f55\u4e00\u4e32\u62c6\u6563\u4e86\u5356\u3002\u4e8e\u662f\u5c0f\u7ea2\u8981\u4f60\u5e2e\u5fd9\u5224\u65ad\u4e00\u4e0b\uff0c\u67d0\u4e32\u73e0\u5b50\u91cc\u662f\u5426\u5305\u542b\u4e86\u5168\u90e8\u81ea\u5df1\u60f3\u8981\u7684\u73e0\u5b50\uff1f\u5982\u679c\u662f\uff0c\u90a3\u4e48\u544a\u8bc9\u5979\u6709\u591a\u5c11\u591a\u4f59\u7684\u73e0\u5b50\uff1b\u5982\u679c\u4e0d\u662f\uff0c\u90a3\u4e48\u544a\u8bc9\u5979\u7f3a\u4e86\u591a\u5c11\u73e0\u5b50\u3002 \u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6211\u4eec\u7528[0-9]\u3001[a-z]\u3001[A-Z]\u8303\u56f4\u5185\u7684\u5b57\u7b26\u6765\u8868\u793a\u989c\u8272\u3002\u4f8b\u5982\u5728\u56fe1\u4e2d\uff0c\u7b2c3\u4e32\u662f\u5c0f\u7ea2\u60f3\u505a\u7684\u73e0\u4e32\uff1b\u90a3\u4e48\u7b2c1\u4e32\u53ef\u4ee5\u4e70\uff0c\u56e0\u4e3a\u5305\u542b\u4e86\u5168\u90e8\u5979\u60f3\u8981\u7684\u73e0\u5b50\uff0c\u8fd8\u591a\u4e868\u9897\u4e0d\u9700\u8981\u7684\u73e0\u5b50\uff1b\u7b2c2\u4e32\u4e0d\u80fd\u4e70\uff0c\u56e0\u4e3a\u6ca1\u6709\u9ed1\u8272\u73e0\u5b50\uff0c\u5e76\u4e14\u5c11\u4e86\u4e00\u9897\u7ea2\u8272\u7684\u73e0\u5b50\u3002 \u56fe 1 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5206\u522b\u5728 2 \u884c\u4e2d\u5148\u540e\u7ed9\u51fa\u644a\u4e3b\u7684\u73e0\u4e32\u548c\u5c0f\u7ea2\u60f3\u505a\u7684\u73e0\u4e32\uff0c\u4e24\u4e32\u90fd\u4e0d\u8d85\u8fc7 1000 \u4e2a\u73e0\u5b50\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u53ef\u4ee5\u4e70\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \u4ee5\u53ca\u6709\u591a\u5c11\u591a\u4f59\u7684\u73e0\u5b50\uff1b\u5982\u679c\u4e0d\u53ef\u4ee5\u4e70\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No \u4ee5\u53ca\u7f3a\u4e86\u591a\u5c11\u73e0\u5b50\u3002\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 1 ppRYYGrrYBR2258 YrR8RrY \u8f93\u51fa\u6837\u4f8b 1 Yes 8 \u8f93\u5165\u6837\u4f8b 2 ppRYYGrrYB225 YrR8RrY \u8f93\u51fa\u6837\u4f8b 2 No 2 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; map < char , int > q ; int len = s . size (), i , lack = 0 , total = 0 ; for ( i = 0 ; i < len ; i ++ ) q [ s [ i ]] ++ ; cin >> s ; len = s . size (); for ( i = 0 ; i < len ; i ++ ) { if ( q [ s [ i ]]) { q [ s [ i ]] -- ; } else lack ++ ; } if ( ! lack ) { map < char , int >:: iterator it ; for ( it = q . begin (); it != q . end (); it ++ ) total += it -> second ; printf ( \"Yes %d \\n \" , total ); } else printf ( \"No %d \\n \" , lack ); }","title":"1039-\u5230\u5e95\u4e70\u4e0d\u4e70"},{"location":"PAT-Basic-Level/1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/#1039-\u5230\u5e95\u4e70\u4e0d\u4e70","text":"","title":"1039 \u5230\u5e95\u4e70\u4e0d\u4e70"},{"location":"PAT-Basic-Level/1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u7ea2\u60f3\u4e70\u4e9b\u73e0\u5b50\u505a\u4e00\u4e32\u81ea\u5df1\u559c\u6b22\u7684\u73e0\u4e32\u3002\u5356\u73e0\u5b50\u7684\u644a\u4e3b\u6709\u5f88\u591a\u4e32\u4e94\u989c\u516d\u8272\u7684\u73e0\u4e32\uff0c\u4f46\u662f\u4e0d\u80af\u628a\u4efb\u4f55\u4e00\u4e32\u62c6\u6563\u4e86\u5356\u3002\u4e8e\u662f\u5c0f\u7ea2\u8981\u4f60\u5e2e\u5fd9\u5224\u65ad\u4e00\u4e0b\uff0c\u67d0\u4e32\u73e0\u5b50\u91cc\u662f\u5426\u5305\u542b\u4e86\u5168\u90e8\u81ea\u5df1\u60f3\u8981\u7684\u73e0\u5b50\uff1f\u5982\u679c\u662f\uff0c\u90a3\u4e48\u544a\u8bc9\u5979\u6709\u591a\u5c11\u591a\u4f59\u7684\u73e0\u5b50\uff1b\u5982\u679c\u4e0d\u662f\uff0c\u90a3\u4e48\u544a\u8bc9\u5979\u7f3a\u4e86\u591a\u5c11\u73e0\u5b50\u3002 \u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6211\u4eec\u7528[0-9]\u3001[a-z]\u3001[A-Z]\u8303\u56f4\u5185\u7684\u5b57\u7b26\u6765\u8868\u793a\u989c\u8272\u3002\u4f8b\u5982\u5728\u56fe1\u4e2d\uff0c\u7b2c3\u4e32\u662f\u5c0f\u7ea2\u60f3\u505a\u7684\u73e0\u4e32\uff1b\u90a3\u4e48\u7b2c1\u4e32\u53ef\u4ee5\u4e70\uff0c\u56e0\u4e3a\u5305\u542b\u4e86\u5168\u90e8\u5979\u60f3\u8981\u7684\u73e0\u5b50\uff0c\u8fd8\u591a\u4e868\u9897\u4e0d\u9700\u8981\u7684\u73e0\u5b50\uff1b\u7b2c2\u4e32\u4e0d\u80fd\u4e70\uff0c\u56e0\u4e3a\u6ca1\u6709\u9ed1\u8272\u73e0\u5b50\uff0c\u5e76\u4e14\u5c11\u4e86\u4e00\u9897\u7ea2\u8272\u7684\u73e0\u5b50\u3002 \u56fe 1 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5206\u522b\u5728 2 \u884c\u4e2d\u5148\u540e\u7ed9\u51fa\u644a\u4e3b\u7684\u73e0\u4e32\u548c\u5c0f\u7ea2\u60f3\u505a\u7684\u73e0\u4e32\uff0c\u4e24\u4e32\u90fd\u4e0d\u8d85\u8fc7 1000 \u4e2a\u73e0\u5b50\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u53ef\u4ee5\u4e70\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \u4ee5\u53ca\u6709\u591a\u5c11\u591a\u4f59\u7684\u73e0\u5b50\uff1b\u5982\u679c\u4e0d\u53ef\u4ee5\u4e70\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No \u4ee5\u53ca\u7f3a\u4e86\u591a\u5c11\u73e0\u5b50\u3002\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 1 ppRYYGrrYBR2258 YrR8RrY \u8f93\u51fa\u6837\u4f8b 1 Yes 8 \u8f93\u5165\u6837\u4f8b 2 ppRYYGrrYB225 YrR8RrY \u8f93\u51fa\u6837\u4f8b 2 No 2","title":"Statement"},{"location":"PAT-Basic-Level/1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; map < char , int > q ; int len = s . size (), i , lack = 0 , total = 0 ; for ( i = 0 ; i < len ; i ++ ) q [ s [ i ]] ++ ; cin >> s ; len = s . size (); for ( i = 0 ; i < len ; i ++ ) { if ( q [ s [ i ]]) { q [ s [ i ]] -- ; } else lack ++ ; } if ( ! lack ) { map < char , int >:: iterator it ; for ( it = q . begin (); it != q . end (); it ++ ) total += it -> second ; printf ( \"Yes %d \\n \" , total ); } else printf ( \"No %d \\n \" , lack ); }","title":"Solution"},{"location":"PAT-Basic-Level/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT/","text":"1040 \u6709\u51e0\u4e2aPAT Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b57\u7b26\u4e32 APPAPT \u4e2d\u5305\u542b\u4e86\u4e24\u4e2a\u5355\u8bcd PAT \uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a PAT \u662f\u7b2c 2 \u4f4d( P )\uff0c\u7b2c 4 \u4f4d( A )\uff0c\u7b2c 6 \u4f4d( T )\uff1b\u7b2c\u4e8c\u4e2a PAT \u662f\u7b2c 3 \u4f4d( P )\uff0c\u7b2c 4 \u4f4d( A )\uff0c\u7b2c 6 \u4f4d( T )\u3002 \u73b0\u7ed9\u5b9a\u5b57\u7b26\u4e32\uff0c\u95ee\u4e00\u5171\u53ef\u4ee5\u5f62\u6210\u591a\u5c11\u4e2a PAT \uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u53ea\u6709\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \uff0c\u53ea\u5305\u542b P \u3001 A \u3001 T \u4e09\u79cd\u5b57\u6bcd\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed9\u5b9a\u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u591a\u5c11\u4e2a PAT \u3002\u7531\u4e8e\u7ed3\u679c\u53ef\u80fd\u6bd4\u8f83\u5927\uff0c\u53ea\u8f93\u51fa\u5bf9 1000000007 \u53d6\u4f59\u6570\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b APPAPT \u8f93\u51fa\u6837\u4f8b 2 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; long long i , len = s . size (), tot1 = 0 , tot2 = 0 , total = 0 ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == 'T' ) tot1 ++ ; else if ( s [ i ] == 'A' ) tot2 += tot1 ; else total += tot2 ; total %= 1000000007 ; } cout << total << endl ; }","title":"1040-\u6709\u51e0\u4e2aPAT"},{"location":"PAT-Basic-Level/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT/#1040-\u6709\u51e0\u4e2apat","text":"","title":"1040 \u6709\u51e0\u4e2aPAT"},{"location":"PAT-Basic-Level/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b57\u7b26\u4e32 APPAPT \u4e2d\u5305\u542b\u4e86\u4e24\u4e2a\u5355\u8bcd PAT \uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a PAT \u662f\u7b2c 2 \u4f4d( P )\uff0c\u7b2c 4 \u4f4d( A )\uff0c\u7b2c 6 \u4f4d( T )\uff1b\u7b2c\u4e8c\u4e2a PAT \u662f\u7b2c 3 \u4f4d( P )\uff0c\u7b2c 4 \u4f4d( A )\uff0c\u7b2c 6 \u4f4d( T )\u3002 \u73b0\u7ed9\u5b9a\u5b57\u7b26\u4e32\uff0c\u95ee\u4e00\u5171\u53ef\u4ee5\u5f62\u6210\u591a\u5c11\u4e2a PAT \uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u53ea\u6709\u4e00\u884c\uff0c\u5305\u542b\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \uff0c\u53ea\u5305\u542b P \u3001 A \u3001 T \u4e09\u79cd\u5b57\u6bcd\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed9\u5b9a\u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u591a\u5c11\u4e2a PAT \u3002\u7531\u4e8e\u7ed3\u679c\u53ef\u80fd\u6bd4\u8f83\u5927\uff0c\u53ea\u8f93\u51fa\u5bf9 1000000007 \u53d6\u4f59\u6570\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b APPAPT \u8f93\u51fa\u6837\u4f8b 2","title":"Statement"},{"location":"PAT-Basic-Level/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; long long i , len = s . size (), tot1 = 0 , tot2 = 0 , total = 0 ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == 'T' ) tot1 ++ ; else if ( s [ i ] == 'A' ) tot2 += tot1 ; else total += tot2 ; total %= 1000000007 ; } cout << total << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/","text":"1041 \u8003\u8bd5\u5ea7\u4f4d\u53f7 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u4e2a PAT \u8003\u751f\u5728\u53c2\u52a0\u8003\u8bd5\u65f6\u90fd\u4f1a\u88ab\u5206\u914d\u4e24\u4e2a\u5ea7\u4f4d\u53f7\uff0c\u4e00\u4e2a\u662f\u8bd5\u673a\u5ea7\u4f4d\uff0c\u4e00\u4e2a\u662f\u8003\u8bd5\u5ea7\u4f4d\u3002\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u8003\u751f\u5728\u5165\u573a\u65f6\u5148\u5f97\u5230\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5165\u5ea7\u8fdb\u5165\u8bd5\u673a\u72b6\u6001\u540e\uff0c\u7cfb\u7edf\u4f1a\u663e\u793a\u8be5\u8003\u751f\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u8003\u8bd5\u65f6\u8003\u751f\u9700\u8981\u6362\u5230\u8003\u8bd5\u5ea7\u4f4d\u5c31\u5ea7\u3002\u4f46\u6709\u4e9b\u8003\u751f\u8fdf\u5230\u4e86\uff0c\u8bd5\u673a\u5df2\u7ecf\u7ed3\u675f\uff0c\u4ed6\u4eec\u53ea\u80fd\u62ff\u7740\u9886\u5230\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\u6c42\u52a9\u4e8e\u4f60\uff0c\u4ece\u540e\u53f0\u67e5\u51fa\u4ed6\u4eec\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u8bd5\u673a\u5ea7\u4f4d\u53f7 \u8003\u8bd5\u5ea7\u4f4d\u53f7 \u3002\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u7531 16 \u4f4d\u6570\u5b57\u7ec4\u6210\uff0c\u5ea7\u4f4d\u4ece 1 \u5230 N N \u7f16\u53f7\u3002\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u7684\u51c6\u8003\u8bc1\u53f7\u90fd\u4e0d\u540c\uff0c\u5e76\u4e14\u4efb\u4f55\u65f6\u5019\u90fd\u4e0d\u4f1a\u628a\u4e24\u4e2a\u4eba\u5206\u914d\u5230\u540c\u4e00\u4e2a\u5ea7\u4f4d\u4e0a\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le N \\le N \uff09\uff0c\u968f\u540e\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u4e2a\u5f85\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u6bcf\u4e2a\u9700\u8981\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u4e2d\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 \u8f93\u51fa\u6837\u4f8b 3310120150912002 2 3310120150912119 1 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 struct q { string s ; int a , b ; }; struct q a [ MAXN ]; int main () { int n , m , b ; cin >> n ; int i ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ]. s >> a [ i ]. a >> a [ i ]. b ; } cin >> m ; while ( m -- ) { cin >> b ; for ( i = 0 ; i < n ; i ++ ) { if ( b == a [ i ]. a ) { cout << a [ i ]. s << \" \" << a [ i ]. b << endl ; break ; } } } }","title":"1041-\u8003\u8bd5\u5ea7\u4f4d\u53f7"},{"location":"PAT-Basic-Level/1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#1041-\u8003\u8bd5\u5ea7\u4f4d\u53f7","text":"","title":"1041 \u8003\u8bd5\u5ea7\u4f4d\u53f7"},{"location":"PAT-Basic-Level/1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u4e2a PAT \u8003\u751f\u5728\u53c2\u52a0\u8003\u8bd5\u65f6\u90fd\u4f1a\u88ab\u5206\u914d\u4e24\u4e2a\u5ea7\u4f4d\u53f7\uff0c\u4e00\u4e2a\u662f\u8bd5\u673a\u5ea7\u4f4d\uff0c\u4e00\u4e2a\u662f\u8003\u8bd5\u5ea7\u4f4d\u3002\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u8003\u751f\u5728\u5165\u573a\u65f6\u5148\u5f97\u5230\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5165\u5ea7\u8fdb\u5165\u8bd5\u673a\u72b6\u6001\u540e\uff0c\u7cfb\u7edf\u4f1a\u663e\u793a\u8be5\u8003\u751f\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u8003\u8bd5\u65f6\u8003\u751f\u9700\u8981\u6362\u5230\u8003\u8bd5\u5ea7\u4f4d\u5c31\u5ea7\u3002\u4f46\u6709\u4e9b\u8003\u751f\u8fdf\u5230\u4e86\uff0c\u8bd5\u673a\u5df2\u7ecf\u7ed3\u675f\uff0c\u4ed6\u4eec\u53ea\u80fd\u62ff\u7740\u9886\u5230\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\u6c42\u52a9\u4e8e\u4f60\uff0c\u4ece\u540e\u53f0\u67e5\u51fa\u4ed6\u4eec\u7684\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u8bd5\u673a\u5ea7\u4f4d\u53f7 \u8003\u8bd5\u5ea7\u4f4d\u53f7 \u3002\u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u7531 16 \u4f4d\u6570\u5b57\u7ec4\u6210\uff0c\u5ea7\u4f4d\u4ece 1 \u5230 N N \u7f16\u53f7\u3002\u8f93\u5165\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u7684\u51c6\u8003\u8bc1\u53f7\u90fd\u4e0d\u540c\uff0c\u5e76\u4e14\u4efb\u4f55\u65f6\u5019\u90fd\u4e0d\u4f1a\u628a\u4e24\u4e2a\u4eba\u5206\u914d\u5230\u540c\u4e00\u4e2a\u5ea7\u4f4d\u4e0a\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M M \uff08 \\le N \\le N \uff09\uff0c\u968f\u540e\u4e00\u884c\u4e2d\u7ed9\u51fa M M \u4e2a\u5f85\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u6bcf\u4e2a\u9700\u8981\u67e5\u8be2\u7684\u8bd5\u673a\u5ea7\u4f4d\u53f7\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5bf9\u5e94\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u8003\u8bd5\u5ea7\u4f4d\u53f7\u7801\uff0c\u4e2d\u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 \u8f93\u51fa\u6837\u4f8b 3310120150912002 2 3310120150912119 1","title":"Statement"},{"location":"PAT-Basic-Level/1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 struct q { string s ; int a , b ; }; struct q a [ MAXN ]; int main () { int n , m , b ; cin >> n ; int i ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ]. s >> a [ i ]. a >> a [ i ]. b ; } cin >> m ; while ( m -- ) { cin >> b ; for ( i = 0 ; i < n ; i ++ ) { if ( b == a [ i ]. a ) { cout << a [ i ]. s << \" \" << a [ i ]. b << endl ; break ; } } } }","title":"Solution"},{"location":"PAT-Basic-Level/1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/","text":"1042 \u5b57\u7b26\u7edf\u8ba1 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bf7\u7f16\u5199\u7a0b\u5e8f\uff0c\u627e\u51fa\u4e00\u6bb5\u7ed9\u5b9a\u6587\u5b57\u4e2d\u51fa\u73b0\u6700\u9891\u7e41\u7684\u90a3\u4e2a\u82f1\u6587\u5b57\u6bcd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 1000 \u7684\u5b57\u7b26\u4e32\u3002\u5b57\u7b26\u4e32\u7531 ASCII \u7801\u8868\u4e2d\u4efb\u610f\u53ef\u89c1\u5b57\u7b26\u53ca\u7a7a\u683c\u7ec4\u6210\uff0c\u81f3\u5c11\u5305\u542b 1 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\uff08\u56de\u8f66\u4e0d\u7b97\u5728\u5185\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u90a3\u4e2a\u82f1\u6587\u5b57\u6bcd\u53ca\u5176\u51fa\u73b0\u6b21\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u6309\u5b57\u6bcd\u5e8f\u6700\u5c0f\u7684\u90a3\u4e2a\u5b57\u6bcd\u3002\u7edf\u8ba1\u65f6\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff0c\u8f93\u51fa\u5c0f\u5199\u5b57\u6bcd\u3002 \u8f93\u5165\u6837\u4f8b This is a simple TEST. There ARE numbers and other symbols 1&2&3........... \u8f93\u51fa\u6837\u4f8b e 7 Solution C++ #include <cctype> #include <cstring> #include <iostream> int main () { int n , i , num [ 128 ] = { 0 }; char c ; while ( scanf ( \"%c\" , & c ) && c != 10 ) { n = c ; if ( c >= 'a' && c <= 'z' ) { num [ n ] ++ ; } else if ( c >= 'A' && c <= 'Z' ) { n += 32 ; num [ n ] ++ ; } } int m = 0 ; int flag ; for ( i = 97 ; i < 123 ; i ++ ) { if ( m < num [ i ]) { m = num [ i ]; flag = i ; } else if ( m == num [ i ]) { if ( flag > i ) { m = num [ i ]; flag = i ; } } } printf ( \"%c %d \\n \" , flag , m ); return 0 ; }","title":"1042-\u5b57\u7b26\u7edf\u8ba1"},{"location":"PAT-Basic-Level/1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/#1042-\u5b57\u7b26\u7edf\u8ba1","text":"","title":"1042 \u5b57\u7b26\u7edf\u8ba1"},{"location":"PAT-Basic-Level/1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bf7\u7f16\u5199\u7a0b\u5e8f\uff0c\u627e\u51fa\u4e00\u6bb5\u7ed9\u5b9a\u6587\u5b57\u4e2d\u51fa\u73b0\u6700\u9891\u7e41\u7684\u90a3\u4e2a\u82f1\u6587\u5b57\u6bcd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 1000 \u7684\u5b57\u7b26\u4e32\u3002\u5b57\u7b26\u4e32\u7531 ASCII \u7801\u8868\u4e2d\u4efb\u610f\u53ef\u89c1\u5b57\u7b26\u53ca\u7a7a\u683c\u7ec4\u6210\uff0c\u81f3\u5c11\u5305\u542b 1 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\uff08\u56de\u8f66\u4e0d\u7b97\u5728\u5185\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u51fa\u73b0\u9891\u7387\u6700\u9ad8\u7684\u90a3\u4e2a\u82f1\u6587\u5b57\u6bcd\u53ca\u5176\u51fa\u73b0\u6b21\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u8f93\u51fa\u6309\u5b57\u6bcd\u5e8f\u6700\u5c0f\u7684\u90a3\u4e2a\u5b57\u6bcd\u3002\u7edf\u8ba1\u65f6\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff0c\u8f93\u51fa\u5c0f\u5199\u5b57\u6bcd\u3002 \u8f93\u5165\u6837\u4f8b This is a simple TEST. There ARE numbers and other symbols 1&2&3........... \u8f93\u51fa\u6837\u4f8b e 7","title":"Statement"},{"location":"PAT-Basic-Level/1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/#solution","text":"C++ #include <cctype> #include <cstring> #include <iostream> int main () { int n , i , num [ 128 ] = { 0 }; char c ; while ( scanf ( \"%c\" , & c ) && c != 10 ) { n = c ; if ( c >= 'a' && c <= 'z' ) { num [ n ] ++ ; } else if ( c >= 'A' && c <= 'Z' ) { n += 32 ; num [ n ] ++ ; } } int m = 0 ; int flag ; for ( i = 97 ; i < 123 ; i ++ ) { if ( m < num [ i ]) { m = num [ i ]; flag = i ; } else if ( m == num [ i ]) { if ( flag > i ) { m = num [ i ]; flag = i ; } } } printf ( \"%c %d \\n \" , flag , m ); return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1043-%E8%BE%93%E5%87%BAPATest/","text":"1043 \u8f93\u51faPATest Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 PATestPATest.... \u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u516d\u79cd\u5b57\u7b26\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 PATest \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b redlesPayBestPATTopTeePHPereatitAPPT \u8f93\u51fa\u6837\u4f8b PATestPATestPTetPTePePee Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; int i , len = s . size (), n [ 6 ] = { 0 }, max = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] == 'P' ) n [ 0 ] ++ ; else if ( s [ i ] == 'A' ) n [ 1 ] ++ ; else if ( s [ i ] == 'T' ) n [ 2 ] ++ ; else if ( s [ i ] == 'e' ) n [ 3 ] ++ ; else if ( s [ i ] == 's' ) n [ 4 ] ++ ; else if ( s [ i ] == 't' ) n [ 5 ] ++ ; } for ( i = 0 ; i < 6 ; i ++ ) { if ( n [ i ] > max ) max = n [ i ]; } for ( i = 0 ; i < max ; i ++ ) { if ( n [ 0 ]) { printf ( \"P\" ); n [ 0 ] -- ; } if ( n [ 1 ]) { printf ( \"A\" ); n [ 1 ] -- ; } if ( n [ 2 ]) { printf ( \"T\" ); n [ 2 ] -- ; } if ( n [ 3 ]) { printf ( \"e\" ); n [ 3 ] -- ; } if ( n [ 4 ]) { printf ( \"s\" ); n [ 4 ] -- ; } if ( n [ 5 ]) { printf ( \"t\" ); n [ 5 ] -- ; } } cout << \" \\n \" ; }","title":"1043-\u8f93\u51faPATest"},{"location":"PAT-Basic-Level/1043-%E8%BE%93%E5%87%BAPATest/#1043-\u8f93\u51fapatest","text":"","title":"1043 \u8f93\u51faPATest"},{"location":"PAT-Basic-Level/1043-%E8%BE%93%E5%87%BAPATest/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 PATestPATest.... \u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u516d\u79cd\u5b57\u7b26\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 PATest \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b redlesPayBestPATTopTeePHPereatitAPPT \u8f93\u51fa\u6837\u4f8b PATestPATestPTetPTePePee","title":"Statement"},{"location":"PAT-Basic-Level/1043-%E8%BE%93%E5%87%BAPATest/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; cin >> s ; int i , len = s . size (), n [ 6 ] = { 0 }, max = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] == 'P' ) n [ 0 ] ++ ; else if ( s [ i ] == 'A' ) n [ 1 ] ++ ; else if ( s [ i ] == 'T' ) n [ 2 ] ++ ; else if ( s [ i ] == 'e' ) n [ 3 ] ++ ; else if ( s [ i ] == 's' ) n [ 4 ] ++ ; else if ( s [ i ] == 't' ) n [ 5 ] ++ ; } for ( i = 0 ; i < 6 ; i ++ ) { if ( n [ i ] > max ) max = n [ i ]; } for ( i = 0 ; i < max ; i ++ ) { if ( n [ 0 ]) { printf ( \"P\" ); n [ 0 ] -- ; } if ( n [ 1 ]) { printf ( \"A\" ); n [ 1 ] -- ; } if ( n [ 2 ]) { printf ( \"T\" ); n [ 2 ] -- ; } if ( n [ 3 ]) { printf ( \"e\" ); n [ 3 ] -- ; } if ( n [ 4 ]) { printf ( \"s\" ); n [ 4 ] -- ; } if ( n [ 5 ]) { printf ( \"t\" ); n [ 5 ] -- ; } } cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/","text":"1044 \u706b\u661f\u6570\u5b57 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u706b\u661f\u4eba\u662f\u4ee5 13 \u8fdb\u5236\u8ba1\u6570\u7684\uff1a \u5730\u7403\u4eba\u7684 0 \u88ab\u706b\u661f\u4eba\u79f0\u4e3a tret\u3002 \u5730\u7403\u4eba\u6570\u5b57 1 \u5230 12 \u7684\u706b\u661f\u6587\u5206\u522b\u4e3a\uff1ajan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec\u3002 \u706b\u661f\u4eba\u5c06\u8fdb\u4f4d\u4ee5\u540e\u7684 12 \u4e2a\u9ad8\u4f4d\u6570\u5b57\u5206\u522b\u79f0\u4e3a\uff1atam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou\u3002 \u4f8b\u5982\u5730\u7403\u4eba\u7684\u6570\u5b57 29 \u7ffb\u8bd1\u6210\u706b\u661f\u6587\u5c31\u662f hel mar \uff1b\u800c\u706b\u661f\u6587 elo nov \u5bf9\u5e94\u5730\u7403\u6570\u5b57 115 \u3002\u4e3a\u4e86\u65b9\u4fbf\u4ea4\u6d41\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5b9e\u73b0\u5730\u7403\u548c\u706b\u661f\u6570\u5b57\u4e4b\u95f4\u7684\u4e92\u8bd1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 <100 <100 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a [0, 169) \u533a\u95f4\u5185\u7684\u6570\u5b57 \u2014\u2014 \u6216\u8005\u662f\u5730\u7403\u6587\uff0c\u6216\u8005\u662f\u706b\u661f\u6587\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u8f93\u5165\u7684\u6bcf\u4e00\u884c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ffb\u8bd1\u540e\u7684\u53e6\u4e00\u79cd\u8bed\u8a00\u7684\u6570\u5b57\u3002 \u8f93\u5165\u6837\u4f8b 4 29 5 elo nov tam \u8f93\u51fa\u6837\u4f8b hel mar may 115 13 Solution C++ #include <bits/stdc++.h> using namespace std ; string s1 [ 13 ] = { \"tret\" , \"jan\" , \"feb\" , \"mar\" , \"apr\" , \"may\" , \"jun\" , \"jly\" , \"aug\" , \"sep\" , \"oct\" , \"nov\" , \"dec\" }, s2 [ 12 ] = { \"tam\" , \"hel\" , \"maa\" , \"huh\" , \"tou\" , \"kes\" , \"hei\" , \"elo\" , \"syy\" , \"lok\" , \"mer\" , \"jou\" }; int change ( string s ) { int i , j = 1 , len = s . size (), num = 0 ; for ( i = len - 1 ; i >= 0 ; i -- , j *= 10 ) { num += ( s [ i ] - '0' ) * j ; } return num ; } int main () { int t ; cin >> t ; getchar (); while ( t -- ) { string s ; getline ( cin , s ); int i , len = s . size (), n ; if ( s [ 0 ] > '0' && s [ 0 ] <= '9' ) { n = change ( s ); if ( n >= 13 ) { cout << s2 [( n / 13 ) - 1 ]; if ( n % 13 ) cout << \" \" ; else cout << endl ; n %= 13 ; } if ( n ) cout << s1 [ n ] << endl ; } else if ( s [ 0 ] == '0' ) cout << \"tret\" << endl ; else { int total = 0 ; string num = \"\" ; if ( len == 7 ) { for ( i = 0 ; i < 3 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 12 ; i ++ ) if ( num == s2 [ i ]) total += ( i + 1 ) * 13 ; num = \"\" ; for ( i = 4 ; i < 7 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 13 ; i ++ ) if ( num == s1 [ i ]) total += i ; } else { int flag = 1 ; for ( i = 0 ; i < 3 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 12 ; i ++ ) if ( num == s2 [ i ]) total += ( i + 1 ) * 13 , flag = 0 ; if ( flag ) { for ( i = 0 ; i < 13 ; i ++ ) if ( num == s1 [ i ]) total += i ; } } cout << total << endl ; } } }","title":"1044-\u706b\u661f\u6570\u5b57"},{"location":"PAT-Basic-Level/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/#1044-\u706b\u661f\u6570\u5b57","text":"","title":"1044 \u706b\u661f\u6570\u5b57"},{"location":"PAT-Basic-Level/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u706b\u661f\u4eba\u662f\u4ee5 13 \u8fdb\u5236\u8ba1\u6570\u7684\uff1a \u5730\u7403\u4eba\u7684 0 \u88ab\u706b\u661f\u4eba\u79f0\u4e3a tret\u3002 \u5730\u7403\u4eba\u6570\u5b57 1 \u5230 12 \u7684\u706b\u661f\u6587\u5206\u522b\u4e3a\uff1ajan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec\u3002 \u706b\u661f\u4eba\u5c06\u8fdb\u4f4d\u4ee5\u540e\u7684 12 \u4e2a\u9ad8\u4f4d\u6570\u5b57\u5206\u522b\u79f0\u4e3a\uff1atam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou\u3002 \u4f8b\u5982\u5730\u7403\u4eba\u7684\u6570\u5b57 29 \u7ffb\u8bd1\u6210\u706b\u661f\u6587\u5c31\u662f hel mar \uff1b\u800c\u706b\u661f\u6587 elo nov \u5bf9\u5e94\u5730\u7403\u6570\u5b57 115 \u3002\u4e3a\u4e86\u65b9\u4fbf\u4ea4\u6d41\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5b9e\u73b0\u5730\u7403\u548c\u706b\u661f\u6570\u5b57\u4e4b\u95f4\u7684\u4e92\u8bd1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 <100 <100 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a [0, 169) \u533a\u95f4\u5185\u7684\u6570\u5b57 \u2014\u2014 \u6216\u8005\u662f\u5730\u7403\u6587\uff0c\u6216\u8005\u662f\u706b\u661f\u6587\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u5e94\u8f93\u5165\u7684\u6bcf\u4e00\u884c\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ffb\u8bd1\u540e\u7684\u53e6\u4e00\u79cd\u8bed\u8a00\u7684\u6570\u5b57\u3002 \u8f93\u5165\u6837\u4f8b 4 29 5 elo nov tam \u8f93\u51fa\u6837\u4f8b hel mar may 115 13","title":"Statement"},{"location":"PAT-Basic-Level/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; string s1 [ 13 ] = { \"tret\" , \"jan\" , \"feb\" , \"mar\" , \"apr\" , \"may\" , \"jun\" , \"jly\" , \"aug\" , \"sep\" , \"oct\" , \"nov\" , \"dec\" }, s2 [ 12 ] = { \"tam\" , \"hel\" , \"maa\" , \"huh\" , \"tou\" , \"kes\" , \"hei\" , \"elo\" , \"syy\" , \"lok\" , \"mer\" , \"jou\" }; int change ( string s ) { int i , j = 1 , len = s . size (), num = 0 ; for ( i = len - 1 ; i >= 0 ; i -- , j *= 10 ) { num += ( s [ i ] - '0' ) * j ; } return num ; } int main () { int t ; cin >> t ; getchar (); while ( t -- ) { string s ; getline ( cin , s ); int i , len = s . size (), n ; if ( s [ 0 ] > '0' && s [ 0 ] <= '9' ) { n = change ( s ); if ( n >= 13 ) { cout << s2 [( n / 13 ) - 1 ]; if ( n % 13 ) cout << \" \" ; else cout << endl ; n %= 13 ; } if ( n ) cout << s1 [ n ] << endl ; } else if ( s [ 0 ] == '0' ) cout << \"tret\" << endl ; else { int total = 0 ; string num = \"\" ; if ( len == 7 ) { for ( i = 0 ; i < 3 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 12 ; i ++ ) if ( num == s2 [ i ]) total += ( i + 1 ) * 13 ; num = \"\" ; for ( i = 4 ; i < 7 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 13 ; i ++ ) if ( num == s1 [ i ]) total += i ; } else { int flag = 1 ; for ( i = 0 ; i < 3 ; i ++ ) num += s [ i ]; for ( i = 0 ; i < 12 ; i ++ ) if ( num == s2 [ i ]) total += ( i + 1 ) * 13 , flag = 0 ; if ( flag ) { for ( i = 0 ; i < 13 ; i ++ ) if ( num == s1 [ i ]) total += i ; } } cout << total << endl ; } } }","title":"Solution"},{"location":"PAT-Basic-Level/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","text":"1045 \u5feb\u901f\u6392\u5e8f Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8457\u540d\u7684\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u91cc\u6709\u4e00\u4e2a\u7ecf\u5178\u7684\u5212\u5206\u8fc7\u7a0b\uff1a\u6211\u4eec\u901a\u5e38\u91c7\u7528\u67d0\u79cd\u65b9\u6cd5\u53d6\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u4e3b\u5143\uff0c\u901a\u8fc7\u4ea4\u6362\uff0c\u628a\u6bd4\u4e3b\u5143\u5c0f\u7684\u5143\u7d20\u653e\u5230\u5b83\u7684\u5de6\u8fb9\uff0c\u6bd4\u4e3b\u5143\u5927\u7684\u5143\u7d20\u653e\u5230\u5b83\u7684\u53f3\u8fb9\u3002 \u7ed9\u5b9a\u5212\u5206\u540e\u7684 N N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u8bf7\u95ee\u6709\u591a\u5c11\u4e2a\u5143\u7d20\u53ef\u80fd\u662f\u5212\u5206\u524d\u9009\u53d6\u7684\u4e3b\u5143\uff1f \u4f8b\u5982\u7ed9\u5b9a N = 5 N = 5 , \u6392\u5217\u662f1\u30013\u30012\u30014\u30015\u3002\u5219\uff1a 1 \u7684\u5de6\u8fb9\u6ca1\u6709\u5143\u7d20\uff0c\u53f3\u8fb9\u7684\u5143\u7d20\u90fd\u6bd4\u5b83\u5927\uff0c\u6240\u4ee5\u5b83\u53ef\u80fd\u662f\u4e3b\u5143\uff1b \u5c3d\u7ba1 3 \u7684\u5de6\u8fb9\u5143\u7d20\u90fd\u6bd4\u5b83\u5c0f\uff0c\u4f46\u5176\u53f3\u8fb9\u7684 2 \u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u5b83\u4e0d\u80fd\u662f\u4e3b\u5143\uff1b \u5c3d\u7ba1 2 \u7684\u53f3\u8fb9\u5143\u7d20\u90fd\u6bd4\u5b83\u5927\uff0c\u4f46\u5176\u5de6\u8fb9\u7684 3 \u6bd4\u5b83\u5927\uff0c\u6240\u4ee5\u5b83\u4e0d\u80fd\u662f\u4e3b\u5143\uff1b \u7c7b\u4f3c\u539f\u56e0\uff0c4 \u548c 5 \u90fd\u53ef\u80fd\u662f\u4e3b\u5143\u3002 \u56e0\u6b64\uff0c\u6709 3 \u4e2a\u5143\u7d20\u53ef\u80fd\u662f\u4e3b\u5143\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff1b \u7b2c 2 \u884c\u662f\u7a7a\u683c\u5206\u9694\u7684 N N \u4e2a\u4e0d\u540c\u7684\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a\u6570\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c 1 \u884c\u4e2d\u8f93\u51fa\u6709\u53ef\u80fd\u662f\u4e3b\u5143\u7684\u5143\u7d20\u4e2a\u6570\uff1b\u5728\u7b2c 2 \u884c\u4e2d\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8fd9\u4e9b\u5143\u7d20\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 1 3 2 4 5 \u8f93\u51fa\u6837\u4f8b 3 1 4 5 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int a [ MAXN ][ 2 ], b [ MAXN ]; int main () { int n , i , j , min , max ; cin >> n ; scanf ( \"%d\" , & a [ 0 ][ 0 ]); max = a [ 0 ][ 0 ]; a [ 0 ][ 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ][ 0 ]); a [ i ][ 1 ] = 1 ; if ( a [ i ][ 0 ] < max ) a [ i ][ 1 ] = 0 ; else max = a [ i ][ 0 ]; } min = a [ n - 1 ][ 0 ]; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ][ 0 ] > min ) a [ i ][ 1 ] = 0 ; else min = a [ i ][ 0 ]; } for ( i = 0 , j = 0 ; i < n ; i ++ ) { if ( a [ i ][ 1 ]) b [ j ++ ] = a [ i ][ 0 ]; } sort ( b , b + j ); printf ( \"%d \\n \" , j ); if ( j ) printf ( \"%d\" , b [ 0 ]); for ( i = 1 ; i < j ; i ++ ) printf ( \" %d\" , b [ i ]); printf ( \" \\n \" ); }","title":"1045-\u5feb\u901f\u6392\u5e8f"},{"location":"PAT-Basic-Level/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#1045-\u5feb\u901f\u6392\u5e8f","text":"","title":"1045 \u5feb\u901f\u6392\u5e8f"},{"location":"PAT-Basic-Level/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u8457\u540d\u7684\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u91cc\u6709\u4e00\u4e2a\u7ecf\u5178\u7684\u5212\u5206\u8fc7\u7a0b\uff1a\u6211\u4eec\u901a\u5e38\u91c7\u7528\u67d0\u79cd\u65b9\u6cd5\u53d6\u4e00\u4e2a\u5143\u7d20\u4f5c\u4e3a\u4e3b\u5143\uff0c\u901a\u8fc7\u4ea4\u6362\uff0c\u628a\u6bd4\u4e3b\u5143\u5c0f\u7684\u5143\u7d20\u653e\u5230\u5b83\u7684\u5de6\u8fb9\uff0c\u6bd4\u4e3b\u5143\u5927\u7684\u5143\u7d20\u653e\u5230\u5b83\u7684\u53f3\u8fb9\u3002 \u7ed9\u5b9a\u5212\u5206\u540e\u7684 N N \u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u6b63\u6574\u6570\u7684\u6392\u5217\uff0c\u8bf7\u95ee\u6709\u591a\u5c11\u4e2a\u5143\u7d20\u53ef\u80fd\u662f\u5212\u5206\u524d\u9009\u53d6\u7684\u4e3b\u5143\uff1f \u4f8b\u5982\u7ed9\u5b9a N = 5 N = 5 , \u6392\u5217\u662f1\u30013\u30012\u30014\u30015\u3002\u5219\uff1a 1 \u7684\u5de6\u8fb9\u6ca1\u6709\u5143\u7d20\uff0c\u53f3\u8fb9\u7684\u5143\u7d20\u90fd\u6bd4\u5b83\u5927\uff0c\u6240\u4ee5\u5b83\u53ef\u80fd\u662f\u4e3b\u5143\uff1b \u5c3d\u7ba1 3 \u7684\u5de6\u8fb9\u5143\u7d20\u90fd\u6bd4\u5b83\u5c0f\uff0c\u4f46\u5176\u53f3\u8fb9\u7684 2 \u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u5b83\u4e0d\u80fd\u662f\u4e3b\u5143\uff1b \u5c3d\u7ba1 2 \u7684\u53f3\u8fb9\u5143\u7d20\u90fd\u6bd4\u5b83\u5927\uff0c\u4f46\u5176\u5de6\u8fb9\u7684 3 \u6bd4\u5b83\u5927\uff0c\u6240\u4ee5\u5b83\u4e0d\u80fd\u662f\u4e3b\u5143\uff1b \u7c7b\u4f3c\u539f\u56e0\uff0c4 \u548c 5 \u90fd\u53ef\u80fd\u662f\u4e3b\u5143\u3002 \u56e0\u6b64\uff0c\u6709 3 \u4e2a\u5143\u7d20\u53ef\u80fd\u662f\u4e3b\u5143\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^5 \\le 10^5 \uff09\uff1b \u7b2c 2 \u884c\u662f\u7a7a\u683c\u5206\u9694\u7684 N N \u4e2a\u4e0d\u540c\u7684\u6b63\u6574\u6570\uff0c\u6bcf\u4e2a\u6570\u4e0d\u8d85\u8fc7 10^9 10^9 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c 1 \u884c\u4e2d\u8f93\u51fa\u6709\u53ef\u80fd\u662f\u4e3b\u5143\u7684\u5143\u7d20\u4e2a\u6570\uff1b\u5728\u7b2c 2 \u884c\u4e2d\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8fd9\u4e9b\u5143\u7d20\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 1 3 2 4 5 \u8f93\u51fa\u6837\u4f8b 3 1 4 5","title":"Statement"},{"location":"PAT-Basic-Level/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int a [ MAXN ][ 2 ], b [ MAXN ]; int main () { int n , i , j , min , max ; cin >> n ; scanf ( \"%d\" , & a [ 0 ][ 0 ]); max = a [ 0 ][ 0 ]; a [ 0 ][ 1 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { scanf ( \"%d\" , & a [ i ][ 0 ]); a [ i ][ 1 ] = 1 ; if ( a [ i ][ 0 ] < max ) a [ i ][ 1 ] = 0 ; else max = a [ i ][ 0 ]; } min = a [ n - 1 ][ 0 ]; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ][ 0 ] > min ) a [ i ][ 1 ] = 0 ; else min = a [ i ][ 0 ]; } for ( i = 0 , j = 0 ; i < n ; i ++ ) { if ( a [ i ][ 1 ]) b [ j ++ ] = a [ i ][ 0 ]; } sort ( b , b + j ); printf ( \"%d \\n \" , j ); if ( j ) printf ( \"%d\" , b [ 0 ]); for ( i = 1 ; i < j ; i ++ ) printf ( \" %d\" , b [ i ]); printf ( \" \\n \" ); }","title":"Solution"},{"location":"PAT-Basic-Level/1046-%E5%88%92%E6%8B%B3/","text":"1046 \u5212\u62f3 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5212\u62f3\u662f\u53e4\u8001\u4e2d\u56fd\u9152\u6587\u5316\u7684\u4e00\u4e2a\u6709\u8da3\u7684\u7ec4\u6210\u90e8\u5206\u3002\u9152\u684c\u4e0a\u4e24\u4eba\u5212\u62f3\u7684\u65b9\u6cd5\u4e3a\uff1a\u6bcf\u4eba\u53e3\u4e2d\u558a\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u540c\u65f6\u7528\u624b\u6bd4\u5212\u51fa\u4e00\u4e2a\u6570\u5b57\u3002\u5982\u679c\u8c01\u6bd4\u5212\u51fa\u7684\u6570\u5b57\u6b63\u597d\u7b49\u4e8e\u4e24\u4eba\u558a\u51fa\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u8c01\u5c31\u8d62\u4e86\uff0c\u8f93\u5bb6\u7f5a\u4e00\u676f\u9152\u3002\u4e24\u4eba\u540c\u8d62\u6216\u4e24\u4eba\u540c\u8f93\u5219\u7ee7\u7eed\u4e0b\u4e00\u8f6e\uff0c\u76f4\u5230\u552f\u4e00\u7684\u8d62\u5bb6\u51fa\u73b0\u3002 \u4e0b\u9762\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u5212\u62f3\u8bb0\u5f55\uff0c\u8bf7\u4f60\u7edf\u8ba1\u4ed6\u4eec\u6700\u540e\u5206\u522b\u559d\u4e86\u591a\u5c11\u676f\u9152\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u8f6e\u5212\u62f3\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u4e3a\uff1a \u7532\u558a \u7532\u5212 \u4e59\u558a \u4e59\u5212 \u5176\u4e2d \u558a \u662f\u558a\u51fa\u7684\u6570\u5b57\uff0c \u5212 \u662f\u5212\u51fa\u7684\u6570\u5b57\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff08\u4e24\u53ea\u624b\u4e00\u8d77\u5212\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u559d\u9152\u7684\u676f\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 5 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 \u8f93\u51fa\u6837\u4f8b 1 2 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , tot1 = 0 , tot2 = 0 , total ; cin >> t ; while ( t -- ) { int a , b , c , d ; scanf ( \"%d%d%d%d\" , & a , & b , & c , & d ); total = a + c ; if ( b == total && d != total ) tot2 ++ ; else if ( d == total && b != total ) tot1 ++ ; } cout << tot1 << \" \" << tot2 << endl ; }","title":"1046-\u5212\u62f3"},{"location":"PAT-Basic-Level/1046-%E5%88%92%E6%8B%B3/#1046-\u5212\u62f3","text":"","title":"1046 \u5212\u62f3"},{"location":"PAT-Basic-Level/1046-%E5%88%92%E6%8B%B3/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5212\u62f3\u662f\u53e4\u8001\u4e2d\u56fd\u9152\u6587\u5316\u7684\u4e00\u4e2a\u6709\u8da3\u7684\u7ec4\u6210\u90e8\u5206\u3002\u9152\u684c\u4e0a\u4e24\u4eba\u5212\u62f3\u7684\u65b9\u6cd5\u4e3a\uff1a\u6bcf\u4eba\u53e3\u4e2d\u558a\u51fa\u4e00\u4e2a\u6570\u5b57\uff0c\u540c\u65f6\u7528\u624b\u6bd4\u5212\u51fa\u4e00\u4e2a\u6570\u5b57\u3002\u5982\u679c\u8c01\u6bd4\u5212\u51fa\u7684\u6570\u5b57\u6b63\u597d\u7b49\u4e8e\u4e24\u4eba\u558a\u51fa\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u8c01\u5c31\u8d62\u4e86\uff0c\u8f93\u5bb6\u7f5a\u4e00\u676f\u9152\u3002\u4e24\u4eba\u540c\u8d62\u6216\u4e24\u4eba\u540c\u8f93\u5219\u7ee7\u7eed\u4e0b\u4e00\u8f6e\uff0c\u76f4\u5230\u552f\u4e00\u7684\u8d62\u5bb6\u51fa\u73b0\u3002 \u4e0b\u9762\u7ed9\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u7684\u5212\u62f3\u8bb0\u5f55\uff0c\u8bf7\u4f60\u7edf\u8ba1\u4ed6\u4eec\u6700\u540e\u5206\u522b\u559d\u4e86\u591a\u5c11\u676f\u9152\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u5148\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u8f6e\u5212\u62f3\u7684\u8bb0\u5f55\uff0c\u683c\u5f0f\u4e3a\uff1a \u7532\u558a \u7532\u5212 \u4e59\u558a \u4e59\u5212 \u5176\u4e2d \u558a \u662f\u558a\u51fa\u7684\u6570\u5b57\uff0c \u5212 \u662f\u5212\u51fa\u7684\u6570\u5b57\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff08\u4e24\u53ea\u624b\u4e00\u8d77\u5212\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa\u7532\u3001\u4e59\u4e24\u4eba\u559d\u9152\u7684\u676f\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 5 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 \u8f93\u51fa\u6837\u4f8b 1 2","title":"Statement"},{"location":"PAT-Basic-Level/1046-%E5%88%92%E6%8B%B3/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , tot1 = 0 , tot2 = 0 , total ; cin >> t ; while ( t -- ) { int a , b , c , d ; scanf ( \"%d%d%d%d\" , & a , & b , & c , & d ); total = a + c ; if ( b == total && d != total ) tot2 ++ ; else if ( d == total && b != total ) tot1 ++ ; } cout << tot1 << \" \" << tot2 << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B/","text":"1047 \u7f16\u7a0b\u56e2\u4f53\u8d5b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f16\u7a0b\u56e2\u4f53\u8d5b\u7684\u89c4\u5219\u4e3a\uff1a\u6bcf\u4e2a\u53c2\u8d5b\u961f\u7531\u82e5\u5e72\u961f\u5458\u7ec4\u6210\uff1b\u6240\u6709\u961f\u5458\u72ec\u7acb\u6bd4\u8d5b\uff1b\u53c2\u8d5b\u961f\u7684\u6210\u7ee9\u4e3a\u6240\u6709\u961f\u5458\u7684\u6210\u7ee9\u548c\uff1b\u6210\u7ee9\u6700\u9ad8\u7684\u961f\u83b7\u80dc\u3002 \u73b0\u7ed9\u5b9a\u6240\u6709\u961f\u5458\u7684\u6bd4\u8d5b\u6210\u7ee9\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u627e\u51fa\u51a0\u519b\u961f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u6240\u6709\u53c2\u8d5b\u961f\u5458\u603b\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u961f\u5458\u7684\u6210\u7ee9\uff0c\u683c\u5f0f\u4e3a\uff1a \u961f\u4f0d\u7f16\u53f7-\u961f\u5458\u7f16\u53f7 \u6210\u7ee9 \uff0c\u5176\u4e2d \u961f\u4f0d\u7f16\u53f7 \u4e3a 1 \u5230 1000 \u7684\u6b63\u6574\u6570\uff0c \u961f\u5458\u7f16\u53f7 \u4e3a 1 \u5230 10 \u7684\u6b63\u6574\u6570\uff0c \u6210\u7ee9 \u4e3a 0 \u5230 100 \u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u51a0\u519b\u961f\u7684\u7f16\u53f7\u548c\u603b\u6210\u7ee9\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u51a0\u519b\u961f\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 6 3-10 99 11-5 87 102-1 0 102-3 100 11-9 89 3-2 61 \u8f93\u51fa\u6837\u4f8b 11 176 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { map < int , int > q ; int a , b , c ; int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d-%d %d\" , & a , & b , & c ); q [ a ] += c ; } int flag , max = 0 ; map < int , int >:: iterator it ; for ( it = q . begin (); it != q . end (); it ++ ) { if ( it -> second > max ) { max = it -> second ; flag = it -> first ; } } cout << flag << \" \" << max << endl ; }","title":"1047-\u7f16\u7a0b\u56e2\u4f53\u8d5b"},{"location":"PAT-Basic-Level/1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B/#1047-\u7f16\u7a0b\u56e2\u4f53\u8d5b","text":"","title":"1047 \u7f16\u7a0b\u56e2\u4f53\u8d5b"},{"location":"PAT-Basic-Level/1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7f16\u7a0b\u56e2\u4f53\u8d5b\u7684\u89c4\u5219\u4e3a\uff1a\u6bcf\u4e2a\u53c2\u8d5b\u961f\u7531\u82e5\u5e72\u961f\u5458\u7ec4\u6210\uff1b\u6240\u6709\u961f\u5458\u72ec\u7acb\u6bd4\u8d5b\uff1b\u53c2\u8d5b\u961f\u7684\u6210\u7ee9\u4e3a\u6240\u6709\u961f\u5458\u7684\u6210\u7ee9\u548c\uff1b\u6210\u7ee9\u6700\u9ad8\u7684\u961f\u83b7\u80dc\u3002 \u73b0\u7ed9\u5b9a\u6240\u6709\u961f\u5458\u7684\u6bd4\u8d5b\u6210\u7ee9\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u627e\u51fa\u51a0\u519b\u961f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u5373\u6240\u6709\u53c2\u8d5b\u961f\u5458\u603b\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u961f\u5458\u7684\u6210\u7ee9\uff0c\u683c\u5f0f\u4e3a\uff1a \u961f\u4f0d\u7f16\u53f7-\u961f\u5458\u7f16\u53f7 \u6210\u7ee9 \uff0c\u5176\u4e2d \u961f\u4f0d\u7f16\u53f7 \u4e3a 1 \u5230 1000 \u7684\u6b63\u6574\u6570\uff0c \u961f\u5458\u7f16\u53f7 \u4e3a 1 \u5230 10 \u7684\u6b63\u6574\u6570\uff0c \u6210\u7ee9 \u4e3a 0 \u5230 100 \u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u51a0\u519b\u961f\u7684\u7f16\u53f7\u548c\u603b\u6210\u7ee9\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u51a0\u519b\u961f\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 6 3-10 99 11-5 87 102-1 0 102-3 100 11-9 89 3-2 61 \u8f93\u51fa\u6837\u4f8b 11 176","title":"Statement"},{"location":"PAT-Basic-Level/1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { map < int , int > q ; int a , b , c ; int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d-%d %d\" , & a , & b , & c ); q [ a ] += c ; } int flag , max = 0 ; map < int , int >:: iterator it ; for ( it = q . begin (); it != q . end (); it ++ ) { if ( it -> second > max ) { max = it -> second ; flag = it -> first ; } } cout << flag << \" \" << max << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/","text":"1048 \u6570\u5b57\u52a0\u5bc6 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5b9e\u73b0\u4e00\u79cd\u6570\u5b57\u52a0\u5bc6\u65b9\u6cd5\u3002\u9996\u5148\u56fa\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u7528\u6b63\u6574\u6570 A\uff0c\u5bf9\u4efb\u4e00\u6b63\u6574\u6570 B\uff0c\u5c06\u5176\u6bcf 1 \u4f4d\u6570\u5b57\u4e0e A \u7684\u5bf9\u5e94\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u8fdb\u884c\u4ee5\u4e0b\u8fd0\u7b97\uff1a\u5bf9\u5947\u6570\u4f4d\uff0c\u5bf9\u5e94\u4f4d\u7684\u6570\u5b57\u76f8\u52a0\u540e\u5bf9 13 \u53d6\u4f59\u2014\u2014\u8fd9\u91cc\u7528 J \u4ee3\u8868 10\u3001Q \u4ee3\u8868 11\u3001K \u4ee3\u8868 12\uff1b\u5bf9\u5076\u6570\u4f4d\uff0c\u7528 B \u7684\u6570\u5b57\u51cf\u53bb A \u7684\u6570\u5b57\uff0c\u82e5\u7ed3\u679c\u4e3a\u8d1f\u6570\uff0c\u5219\u518d\u52a0 10\u3002\u8fd9\u91cc\u4ee4\u4e2a\u4f4d\u4e3a\u7b2c 1 \u4f4d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A \u548c B\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u4f4d\u7684\u6b63\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 1234567 368782971 \u8f93\u51fa\u6837\u4f8b 3695Q8118 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string a , b , s = \"\" ; cin >> a >> b ; int len1 = a . size (), len2 = b . size (), i , j , k , num , len ; if ( len1 < len2 ) for ( i = len2 - len1 ; i > 0 ; i -- ) a . insert ( 0 , \"0\" ); else for ( i = len1 - len2 ; i > 0 ; i -- ) b . insert ( 0 , \"0\" ); // cout<<a<<endl; // cout<<b<<endl; len1 = a . size (), len2 = b . size (); for ( i = len1 - 1 , k = 1 , j = len2 - 1 ; i >= 0 && j >= 0 ; i -- , j -- , k ++ ) { if ( k % 2 ) { num = a [ i ] - '0' + b [ j ] - '0' ; num %= 13 ; // cout<<num<<endl; if ( num <= 9 ) s += num + '0' ; else if ( num == 10 ) s += \"J\" ; else if ( num == 11 ) s += \"Q\" ; else if ( num == 12 ) s += \"K\" ; // cout<<s<<endl; } else { num = b [ j ] - a [ i ]; // cout<<num<<endl; if ( num < 0 ) num += 10 ; s += num + '0' ; // cout<<s<<endl; } } // cout<<b[j]<<endl; /*if(len1<len2) for(;j>=0;j--) s+=b[j]; else if(len1>len2) for(;i>=0;i--) s+=\"0\";*/ len = s . size (); for ( i = len - 1 ; i >= 0 ; i -- ) cout << s [ i ]; cout << \" \\n \" ; }","title":"1048-\u6570\u5b57\u52a0\u5bc6"},{"location":"PAT-Basic-Level/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/#1048-\u6570\u5b57\u52a0\u5bc6","text":"","title":"1048 \u6570\u5b57\u52a0\u5bc6"},{"location":"PAT-Basic-Level/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5b9e\u73b0\u4e00\u79cd\u6570\u5b57\u52a0\u5bc6\u65b9\u6cd5\u3002\u9996\u5148\u56fa\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u7528\u6b63\u6574\u6570 A\uff0c\u5bf9\u4efb\u4e00\u6b63\u6574\u6570 B\uff0c\u5c06\u5176\u6bcf 1 \u4f4d\u6570\u5b57\u4e0e A \u7684\u5bf9\u5e94\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\u8fdb\u884c\u4ee5\u4e0b\u8fd0\u7b97\uff1a\u5bf9\u5947\u6570\u4f4d\uff0c\u5bf9\u5e94\u4f4d\u7684\u6570\u5b57\u76f8\u52a0\u540e\u5bf9 13 \u53d6\u4f59\u2014\u2014\u8fd9\u91cc\u7528 J \u4ee3\u8868 10\u3001Q \u4ee3\u8868 11\u3001K \u4ee3\u8868 12\uff1b\u5bf9\u5076\u6570\u4f4d\uff0c\u7528 B \u7684\u6570\u5b57\u51cf\u53bb A \u7684\u6570\u5b57\uff0c\u82e5\u7ed3\u679c\u4e3a\u8d1f\u6570\uff0c\u5219\u518d\u52a0 10\u3002\u8fd9\u91cc\u4ee4\u4e2a\u4f4d\u4e3a\u7b2c 1 \u4f4d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa A \u548c B\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 100 \u4f4d\u7684\u6b63\u6574\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 1234567 368782971 \u8f93\u51fa\u6837\u4f8b 3695Q8118","title":"Statement"},{"location":"PAT-Basic-Level/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string a , b , s = \"\" ; cin >> a >> b ; int len1 = a . size (), len2 = b . size (), i , j , k , num , len ; if ( len1 < len2 ) for ( i = len2 - len1 ; i > 0 ; i -- ) a . insert ( 0 , \"0\" ); else for ( i = len1 - len2 ; i > 0 ; i -- ) b . insert ( 0 , \"0\" ); // cout<<a<<endl; // cout<<b<<endl; len1 = a . size (), len2 = b . size (); for ( i = len1 - 1 , k = 1 , j = len2 - 1 ; i >= 0 && j >= 0 ; i -- , j -- , k ++ ) { if ( k % 2 ) { num = a [ i ] - '0' + b [ j ] - '0' ; num %= 13 ; // cout<<num<<endl; if ( num <= 9 ) s += num + '0' ; else if ( num == 10 ) s += \"J\" ; else if ( num == 11 ) s += \"Q\" ; else if ( num == 12 ) s += \"K\" ; // cout<<s<<endl; } else { num = b [ j ] - a [ i ]; // cout<<num<<endl; if ( num < 0 ) num += 10 ; s += num + '0' ; // cout<<s<<endl; } } // cout<<b[j]<<endl; /*if(len1<len2) for(;j>=0;j--) s+=b[j]; else if(len1>len2) for(;i>=0;i--) s+=\"0\";*/ len = s . size (); for ( i = len - 1 ; i >= 0 ; i -- ) cout << s [ i ]; cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/","text":"1049 \u6570\u5217\u7684\u7247\u6bb5\u548c Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570\u6570\u5217\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e2d\u622a\u53d6\u4efb\u610f\u7684\u8fde\u7eed\u7684\u51e0\u4e2a\u6570\uff0c\u79f0\u4e3a\u7247\u6bb5\u3002\u4f8b\u5982\uff0c\u7ed9\u5b9a\u6570\u5217 { 0.1, 0.2, 0.3, 0.4 }\uff0c\u6211\u4eec\u6709 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) \u8fd9 10 \u4e2a\u7247\u6bb5\u3002 \u7ed9\u5b9a\u6b63\u6574\u6570\u6570\u5217\uff0c\u6c42\u51fa\u5168\u90e8\u7247\u6bb5\u5305\u542b\u7684\u6240\u6709\u7684\u6570\u4e4b\u548c\u3002\u5982\u672c\u4f8b\u4e2d 10 \u4e2a\u7247\u6bb5\u603b\u548c\u662f 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u8868\u793a\u6570\u5217\u4e2d\u6570\u7684\u4e2a\u6570\uff0c\u7b2c\u4e8c\u884c\u7ed9\u51fa $N $ \u4e2a\u4e0d\u8d85\u8fc7 1.0 \u7684\u6b63\u6570\uff0c\u662f\u6570\u5217\u4e2d\u7684\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u5e8f\u5217\u6240\u6709\u7247\u6bb5\u5305\u542b\u7684\u6570\u4e4b\u548c\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 4 0.1 0.2 0.3 0.4 \u8f93\u51fa\u6837\u4f8b 5.00 \u611f\u8c22 Ruihan Zheng \u5bf9\u6d4b\u8bd5\u6570\u636e\u7684\u4fee\u6b63\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 double a [ MAXN ]; double b [ MAXN ]; int main () { int n , i , j , m , flag = 0 , k ; double total = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); if ( n % 2 ) m = ( n + 1 ) / 2 ; else m = n / 2 , flag = 1 ; b [ 0 ] = ( double ) n ; for ( i = n - 1 , j = 1 ; j < m ; j ++ , i -- ) b [ j ] = i * ( j + 1 ); if ( flag ) for ( k = j - 1 ; j < n ; j ++ , k -- ) b [ j ] = b [ k ]; else for ( k = j - 2 ; j < n ; j ++ , k -- ) b [ j ] = b [ k ]; // for(i=0;i<n;i++) b[i]=(n-i)*(i+1); for ( i = 0 ; i < n ; i ++ ) { total += ( double ) b [ i ] * a [ i ]; } printf ( \"%.2f \\n \" , total ); }","title":"1049-\u6570\u5217\u7684\u7247\u6bb5\u548c"},{"location":"PAT-Basic-Level/1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/#1049-\u6570\u5217\u7684\u7247\u6bb5\u548c","text":"","title":"1049 \u6570\u5217\u7684\u7247\u6bb5\u548c"},{"location":"PAT-Basic-Level/1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6570\u6570\u5217\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e2d\u622a\u53d6\u4efb\u610f\u7684\u8fde\u7eed\u7684\u51e0\u4e2a\u6570\uff0c\u79f0\u4e3a\u7247\u6bb5\u3002\u4f8b\u5982\uff0c\u7ed9\u5b9a\u6570\u5217 { 0.1, 0.2, 0.3, 0.4 }\uff0c\u6211\u4eec\u6709 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) \u8fd9 10 \u4e2a\u7247\u6bb5\u3002 \u7ed9\u5b9a\u6b63\u6574\u6570\u6570\u5217\uff0c\u6c42\u51fa\u5168\u90e8\u7247\u6bb5\u5305\u542b\u7684\u6240\u6709\u7684\u6570\u4e4b\u548c\u3002\u5982\u672c\u4f8b\u4e2d 10 \u4e2a\u7247\u6bb5\u603b\u548c\u662f 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N N \uff0c\u8868\u793a\u6570\u5217\u4e2d\u6570\u7684\u4e2a\u6570\uff0c\u7b2c\u4e8c\u884c\u7ed9\u51fa $N $ \u4e2a\u4e0d\u8d85\u8fc7 1.0 \u7684\u6b63\u6570\uff0c\u662f\u6570\u5217\u4e2d\u7684\u6570\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8be5\u5e8f\u5217\u6240\u6709\u7247\u6bb5\u5305\u542b\u7684\u6570\u4e4b\u548c\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 4 0.1 0.2 0.3 0.4 \u8f93\u51fa\u6837\u4f8b 5.00 \u611f\u8c22 Ruihan Zheng \u5bf9\u6d4b\u8bd5\u6570\u636e\u7684\u4fee\u6b63\u3002","title":"Statement"},{"location":"PAT-Basic-Level/1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 double a [ MAXN ]; double b [ MAXN ]; int main () { int n , i , j , m , flag = 0 , k ; double total = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); if ( n % 2 ) m = ( n + 1 ) / 2 ; else m = n / 2 , flag = 1 ; b [ 0 ] = ( double ) n ; for ( i = n - 1 , j = 1 ; j < m ; j ++ , i -- ) b [ j ] = i * ( j + 1 ); if ( flag ) for ( k = j - 1 ; j < n ; j ++ , k -- ) b [ j ] = b [ k ]; else for ( k = j - 2 ; j < n ; j ++ , k -- ) b [ j ] = b [ k ]; // for(i=0;i<n;i++) b[i]=(n-i)*(i+1); for ( i = 0 ; i < n ; i ++ ) { total += ( double ) b [ i ] * a [ i ]; } printf ( \"%.2f \\n \" , total ); }","title":"Solution"},{"location":"PAT-Basic-Level/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","text":"1050 \u87ba\u65cb\u77e9\u9635 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5c06\u7ed9\u5b9a\u7684 N N \u4e2a\u6b63\u6574\u6570\u6309\u975e\u9012\u589e\u7684\u987a\u5e8f\uff0c\u586b\u5165\u201c\u87ba\u65cb\u77e9\u9635\u201d\u3002\u6240\u8c13\u201c\u87ba\u65cb\u77e9\u9635\u201d\uff0c\u662f\u6307\u4ece\u5de6\u4e0a\u89d2\u7b2c 1 \u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6309\u987a\u65f6\u9488\u87ba\u65cb\u65b9\u5411\u586b\u5145\u3002\u8981\u6c42\u77e9\u9635\u7684\u89c4\u6a21\u4e3a m m \u884c n n \u5217\uff0c\u6ee1\u8db3\u6761\u4ef6\uff1a m\\times n m\\times n \u7b49\u4e8e N N \uff1b m\\ge n m\\ge n \uff1b\u4e14 m-n m-n \u53d6\u6240\u6709\u53ef\u80fd\u503c\u4e2d\u7684\u6700\u5c0f\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff0c\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u5f85\u586b\u5145\u7684\u6b63\u6574\u6570\u3002\u6240\u6709\u6570\u5b57\u4e0d\u8d85\u8fc7 10^4 10^4 \uff0c\u76f8\u90bb\u6570\u5b57\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u87ba\u65cb\u77e9\u9635\u3002\u6bcf\u884c n n \u4e2a\u6570\u5b57\uff0c\u5171 m m \u884c\u3002\u76f8\u90bb\u6570\u5b57\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 12 37 76 20 98 76 42 53 95 60 81 58 93 \u8f93\u51fa\u6837\u4f8b 98 95 93 42 37 81 53 20 76 58 60 76 Solution C++ #include <limits.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int comp ( const void * p , const void * q ); int main () { int n , x , y ; scanf ( \"%d\" , & n ); int num [ n ]; int i , j ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); } qsort ( num , n , sizeof ( int ), comp ); int M , N ; int flag1 = 0 , flag2 = 0 ; int min = INT_MAX ; for ( M = 1 ; M <= n ; M ++ ) { for ( N = 1 ; N <= n ; N ++ ) { if ( M * N == n && M - N < min && M >= N ) { min = M - N ; flag1 = M ; flag2 = N ; } } } // printf(\"%d %d\\n\",flag1,flag2); int num2 [ flag1 ][ flag2 ]; memset ( num2 , 0 , sizeof ( num2 )); num2 [ x = 0 ][ y = 0 ] = num [ 0 ]; int tot = 1 ; while ( tot < n ) { while ( y + 1 < flag2 && ! num2 [ x ][ y + 1 ]) num2 [ x ][ ++ y ] = num [ tot ++ ]; //\u5411\u53f3 while ( y - 1 >= 0 && ! num2 [ x ][ y - 1 ]) num2 [ x ][ -- y ] = num [ tot ++ ]; //\u5411\u5de6 while ( x - 1 >= 0 && ! num2 [ x - 1 ][ y ]) num2 [ -- x ][ y ] = num [ tot ++ ]; //\u5de6\u4e0a while ( x + 1 < flag1 && ! num2 [ x + 1 ][ y ]) num2 [ ++ x ][ y ] = num [ tot ++ ]; //\u53f3\u4e0b } for ( i = 0 ; i < flag1 ; i ++ ) { for ( j = 0 ; j < flag2 ; j ++ ) { if ( j ) printf ( \" %d\" , num2 [ i ][ j ]); else printf ( \"%d\" , num2 [ i ][ j ]); } printf ( \" \\n \" ); } } int comp ( const void * p , const void * q ) { return ( * ( int * ) q - * ( int * ) p ); }","title":"1050-\u87ba\u65cb\u77e9\u9635"},{"location":"PAT-Basic-Level/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/#1050-\u87ba\u65cb\u77e9\u9635","text":"","title":"1050 \u87ba\u65cb\u77e9\u9635"},{"location":"PAT-Basic-Level/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u5c06\u7ed9\u5b9a\u7684 N N \u4e2a\u6b63\u6574\u6570\u6309\u975e\u9012\u589e\u7684\u987a\u5e8f\uff0c\u586b\u5165\u201c\u87ba\u65cb\u77e9\u9635\u201d\u3002\u6240\u8c13\u201c\u87ba\u65cb\u77e9\u9635\u201d\uff0c\u662f\u6307\u4ece\u5de6\u4e0a\u89d2\u7b2c 1 \u4e2a\u683c\u5b50\u5f00\u59cb\uff0c\u6309\u987a\u65f6\u9488\u87ba\u65cb\u65b9\u5411\u586b\u5145\u3002\u8981\u6c42\u77e9\u9635\u7684\u89c4\u6a21\u4e3a m m \u884c n n \u5217\uff0c\u6ee1\u8db3\u6761\u4ef6\uff1a m\\times n m\\times n \u7b49\u4e8e N N \uff1b m\\ge n m\\ge n \uff1b\u4e14 m-n m-n \u53d6\u6240\u6709\u53ef\u80fd\u503c\u4e2d\u7684\u6700\u5c0f\u503c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c 1 \u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff0c\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u5f85\u586b\u5145\u7684\u6b63\u6574\u6570\u3002\u6240\u6709\u6570\u5b57\u4e0d\u8d85\u8fc7 10^4 10^4 \uff0c\u76f8\u90bb\u6570\u5b57\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u87ba\u65cb\u77e9\u9635\u3002\u6bcf\u884c n n \u4e2a\u6570\u5b57\uff0c\u5171 m m \u884c\u3002\u76f8\u90bb\u6570\u5b57\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 12 37 76 20 98 76 42 53 95 60 81 58 93 \u8f93\u51fa\u6837\u4f8b 98 95 93 42 37 81 53 20 76 58 60 76","title":"Statement"},{"location":"PAT-Basic-Level/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/#solution","text":"C++ #include <limits.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int comp ( const void * p , const void * q ); int main () { int n , x , y ; scanf ( \"%d\" , & n ); int num [ n ]; int i , j ; for ( i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & num [ i ]); } qsort ( num , n , sizeof ( int ), comp ); int M , N ; int flag1 = 0 , flag2 = 0 ; int min = INT_MAX ; for ( M = 1 ; M <= n ; M ++ ) { for ( N = 1 ; N <= n ; N ++ ) { if ( M * N == n && M - N < min && M >= N ) { min = M - N ; flag1 = M ; flag2 = N ; } } } // printf(\"%d %d\\n\",flag1,flag2); int num2 [ flag1 ][ flag2 ]; memset ( num2 , 0 , sizeof ( num2 )); num2 [ x = 0 ][ y = 0 ] = num [ 0 ]; int tot = 1 ; while ( tot < n ) { while ( y + 1 < flag2 && ! num2 [ x ][ y + 1 ]) num2 [ x ][ ++ y ] = num [ tot ++ ]; //\u5411\u53f3 while ( y - 1 >= 0 && ! num2 [ x ][ y - 1 ]) num2 [ x ][ -- y ] = num [ tot ++ ]; //\u5411\u5de6 while ( x - 1 >= 0 && ! num2 [ x - 1 ][ y ]) num2 [ -- x ][ y ] = num [ tot ++ ]; //\u5de6\u4e0a while ( x + 1 < flag1 && ! num2 [ x + 1 ][ y ]) num2 [ ++ x ][ y ] = num [ tot ++ ]; //\u53f3\u4e0b } for ( i = 0 ; i < flag1 ; i ++ ) { for ( j = 0 ; j < flag2 ; j ++ ) { if ( j ) printf ( \" %d\" , num2 [ i ][ j ]); else printf ( \"%d\" , num2 [ i ][ j ]); } printf ( \" \\n \" ); } } int comp ( const void * p , const void * q ) { return ( * ( int * ) q - * ( int * ) p ); }","title":"Solution"},{"location":"PAT-Basic-Level/1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/","text":"1051 \u590d\u6570\u4e58\u6cd5 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u590d\u6570\u53ef\u4ee5\u5199\u6210 (A + Bi) (A + Bi) \u7684\u5e38\u89c4\u5f62\u5f0f\uff0c\u5176\u4e2d A A \u662f\u5b9e\u90e8\uff0c B B \u662f\u865a\u90e8\uff0c i i \u662f\u865a\u6570\u5355\u4f4d\uff0c\u6ee1\u8db3 i^2 = -1 i^2 = -1 \uff1b\u4e5f\u53ef\u4ee5\u5199\u6210\u6781\u5750\u6807\u4e0b\u7684\u6307\u6570\u5f62\u5f0f (R\\times e^{(Pi)}) (R\\times e^{(Pi)}) \uff0c\u5176\u4e2d R R \u662f\u590d\u6570\u6a21\uff0c P P \u662f\u8f90\u89d2\uff0c i i \u662f\u865a\u6570\u5355\u4f4d\uff0c\u5176\u7b49\u4ef7\u4e8e\u4e09\u89d2\u5f62\u5f0f R(\\cos (P) + i \\sin (P)) R(\\cos (P) + i \\sin (P)) \u3002 \u73b0\u7ed9\u5b9a\u4e24\u4e2a\u590d\u6570\u7684 R R \u548c P P \uff0c\u8981\u6c42\u8f93\u51fa\u4e24\u6570\u4e58\u79ef\u7684\u5e38\u89c4\u5f62\u5f0f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa\u4e24\u4e2a\u590d\u6570\u7684 R_1 R_1 , P_1 P_1 , R_2 R_2 , P_2 P_2 \uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167 A+Bi \u7684\u683c\u5f0f\u8f93\u51fa\u4e24\u6570\u4e58\u79ef\u7684\u5e38\u89c4\u5f62\u5f0f\uff0c\u5b9e\u90e8\u548c\u865a\u90e8\u5747\u4fdd\u7559 2 \u4f4d\u5c0f\u6570\u3002\u6ce8\u610f\uff1a\u5982\u679c B \u662f\u8d1f\u6570\uff0c\u5219\u5e94\u8be5\u5199\u6210 A-|B|i \u7684\u5f62\u5f0f\u3002 \u8f93\u5165\u6837\u4f8b 2.3 3.5 5.2 0.4 \u8f93\u51fa\u6837\u4f8b -8.68-8.23i Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { double a , b , c , d , r , p ; cin >> a >> b >> c >> d ; r = a * c , p = b + d ; a = r * cos ( p ), b = r * sin ( p ); if ( a > -0.005 && a < 0 ) a += 0.005 ; if ( b > -0.005 && b < 0 ) b += 0.005 ; if ( a && b ) printf ( \"%.2lf%+.2lfi \\n \" , a , b ); else if ( b ) printf ( \"%.2lfi \\n \" , b ); else if ( a ) printf ( \"%.2lf \\n \" , a ); }","title":"1051-\u590d\u6570\u4e58\u6cd5"},{"location":"PAT-Basic-Level/1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/#1051-\u590d\u6570\u4e58\u6cd5","text":"","title":"1051 \u590d\u6570\u4e58\u6cd5"},{"location":"PAT-Basic-Level/1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u590d\u6570\u53ef\u4ee5\u5199\u6210 (A + Bi) (A + Bi) \u7684\u5e38\u89c4\u5f62\u5f0f\uff0c\u5176\u4e2d A A \u662f\u5b9e\u90e8\uff0c B B \u662f\u865a\u90e8\uff0c i i \u662f\u865a\u6570\u5355\u4f4d\uff0c\u6ee1\u8db3 i^2 = -1 i^2 = -1 \uff1b\u4e5f\u53ef\u4ee5\u5199\u6210\u6781\u5750\u6807\u4e0b\u7684\u6307\u6570\u5f62\u5f0f (R\\times e^{(Pi)}) (R\\times e^{(Pi)}) \uff0c\u5176\u4e2d R R \u662f\u590d\u6570\u6a21\uff0c P P \u662f\u8f90\u89d2\uff0c i i \u662f\u865a\u6570\u5355\u4f4d\uff0c\u5176\u7b49\u4ef7\u4e8e\u4e09\u89d2\u5f62\u5f0f R(\\cos (P) + i \\sin (P)) R(\\cos (P) + i \\sin (P)) \u3002 \u73b0\u7ed9\u5b9a\u4e24\u4e2a\u590d\u6570\u7684 R R \u548c P P \uff0c\u8981\u6c42\u8f93\u51fa\u4e24\u6570\u4e58\u79ef\u7684\u5e38\u89c4\u5f62\u5f0f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u4f9d\u6b21\u7ed9\u51fa\u4e24\u4e2a\u590d\u6570\u7684 R_1 R_1 , P_1 P_1 , R_2 R_2 , P_2 P_2 \uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167 A+Bi \u7684\u683c\u5f0f\u8f93\u51fa\u4e24\u6570\u4e58\u79ef\u7684\u5e38\u89c4\u5f62\u5f0f\uff0c\u5b9e\u90e8\u548c\u865a\u90e8\u5747\u4fdd\u7559 2 \u4f4d\u5c0f\u6570\u3002\u6ce8\u610f\uff1a\u5982\u679c B \u662f\u8d1f\u6570\uff0c\u5219\u5e94\u8be5\u5199\u6210 A-|B|i \u7684\u5f62\u5f0f\u3002 \u8f93\u5165\u6837\u4f8b 2.3 3.5 5.2 0.4 \u8f93\u51fa\u6837\u4f8b -8.68-8.23i","title":"Statement"},{"location":"PAT-Basic-Level/1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { double a , b , c , d , r , p ; cin >> a >> b >> c >> d ; r = a * c , p = b + d ; a = r * cos ( p ), b = r * sin ( p ); if ( a > -0.005 && a < 0 ) a += 0.005 ; if ( b > -0.005 && b < 0 ) b += 0.005 ; if ( a && b ) printf ( \"%.2lf%+.2lfi \\n \" , a , b ); else if ( b ) printf ( \"%.2lfi \\n \" , b ); else if ( a ) printf ( \"%.2lf \\n \" , a ); }","title":"Solution"},{"location":"PAT-Basic-Level/1052-%E5%8D%96%E4%B8%AA%E8%90%8C/","text":"1052 \u5356\u4e2a\u840c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u840c\u840c\u54d2\u8868\u60c5\u7b26\u53f7\u901a\u5e38\u7531\u201c\u624b\u201d\u3001\u201c\u773c\u201d\u3001\u201c\u53e3\u201d\u4e09\u4e2a\u4e3b\u8981\u90e8\u5206\u7ec4\u6210\u3002\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4e00\u4e2a\u8868\u60c5\u7b26\u53f7\u662f\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u7684\uff1a [\u5de6\u624b]([\u5de6\u773c][\u53e3][\u53f3\u773c])[\u53f3\u624b] \u73b0\u7ed9\u51fa\u53ef\u9009\u7528\u7684\u7b26\u53f7\u96c6\u5408\uff0c\u8bf7\u4f60\u6309\u7528\u6237\u7684\u8981\u6c42\u8f93\u51fa\u8868\u60c5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u524d\u4e09\u884c\u987a\u5e8f\u5bf9\u5e94\u7ed9\u51fa\u624b\u3001\u773c\u3001\u53e3\u7684\u53ef\u9009\u7b26\u53f7\u96c6\u3002\u6bcf\u4e2a\u7b26\u53f7\u62ec\u5728\u4e00\u5bf9\u65b9\u62ec\u53f7 [] \u5185\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u96c6\u5408\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u7b26\u53f7\uff0c\u5e76\u4e0d\u8d85\u8fc7 10 \u4e2a\u7b26\u53f7\uff1b\u6bcf\u4e2a\u7b26\u53f7\u5305\u542b 1 \u5230 4 \u4e2a\u975e\u7a7a\u5b57\u7b26\u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K\uff0c\u4e3a\u7528\u6237\u8bf7\u6c42\u7684\u4e2a\u6570\u3002\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7528\u6237\u7684\u7b26\u53f7\u9009\u62e9\uff0c\u987a\u5e8f\u4e3a\u5de6\u624b\u3001\u5de6\u773c\u3001\u53e3\u3001\u53f3\u773c\u3001\u53f3\u624b\u2014\u2014\u8fd9\u91cc\u53ea\u7ed9\u51fa\u7b26\u53f7\u5728\u76f8\u5e94\u96c6\u5408\u4e2d\u7684\u5e8f\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u7528\u6237\u8bf7\u6c42\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u751f\u6210\u7684\u8868\u60c5\u3002\u82e5\u7528\u6237\u9009\u62e9\u7684\u5e8f\u53f7\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa Are you kidding me? @\\/@ \u3002 \u8f93\u5165\u6837\u4f8b [\u256e][\u256d][o][~\\][/~] [<][>] [\u256f][\u2570][^][-][=][>][<][@][\u2299] [\u0414][\u25bd][_][\u03b5][^] ... 4 1 1 2 2 2 6 8 1 5 5 3 3 4 3 3 2 10 3 9 3 \u8f93\u51fa\u6837\u4f8b \u256e(\u256f\u25bd\u2570)\u256d <(@\u0414=)/~ o(^\u03b5^)o Are you kidding me? @\\/@ Solution C++ #include <bits/stdc++.h> using namespace std ; struct pp { string s [ 10 ]; } q [ 3 ]; int main () { string s ; int i , j , k , l , len , tot [ 3 ] = { 0 }; for ( i = 0 ; i < 3 ; i ++ ) { getline ( cin , s ); // cout<<s<<endl; len = s . size (); for ( j = 0 , l = 0 ; j < len ; j ++ ) { if ( s [ j ] == '[' ) { // cout<<j<<endl; for ( k = j + 1 ; s [ k ] != ']' ; k ++ ) { q [ i ]. s [ l ] += s [ k ]; } // cout<<q[i].s[l]<<endl; l ++ ; j = k ; } } tot [ i ] = l ; // cout<<l<<endl; } int t ; cin >> t ; while ( t -- ) { s = \"\" ; int n [ 5 ], flag = 1 , a [ 5 ] = { 0 , 1 , 2 , 1 , 0 }; for ( i = 0 ; i < 5 ; i ++ ) cin >> n [ i ]; for ( i = 0 ; i < 5 ; i ++ ) { n [ i ] -- ; if ( n [ i ] > tot [ a [ i ]] - 1 || n [ i ] < 0 ) { flag = 0 ; // cout<<\"1\\n\"; break ; } else { s += q [ a [ i ]]. s [ n [ i ]]; } if ( ! i ) s += \"(\" ; else if ( i == 3 ) s += \")\" ; } if ( flag ) cout << s << endl ; else cout << \"Are you kidding me? @ \\\\ /@ \\n \" ; } }","title":"1052-\u5356\u4e2a\u840c"},{"location":"PAT-Basic-Level/1052-%E5%8D%96%E4%B8%AA%E8%90%8C/#1052-\u5356\u4e2a\u840c","text":"","title":"1052 \u5356\u4e2a\u840c"},{"location":"PAT-Basic-Level/1052-%E5%8D%96%E4%B8%AA%E8%90%8C/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u840c\u840c\u54d2\u8868\u60c5\u7b26\u53f7\u901a\u5e38\u7531\u201c\u624b\u201d\u3001\u201c\u773c\u201d\u3001\u201c\u53e3\u201d\u4e09\u4e2a\u4e3b\u8981\u90e8\u5206\u7ec4\u6210\u3002\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4e00\u4e2a\u8868\u60c5\u7b26\u53f7\u662f\u6309\u4e0b\u5217\u683c\u5f0f\u8f93\u51fa\u7684\uff1a [\u5de6\u624b]([\u5de6\u773c][\u53e3][\u53f3\u773c])[\u53f3\u624b] \u73b0\u7ed9\u51fa\u53ef\u9009\u7528\u7684\u7b26\u53f7\u96c6\u5408\uff0c\u8bf7\u4f60\u6309\u7528\u6237\u7684\u8981\u6c42\u8f93\u51fa\u8868\u60c5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u524d\u4e09\u884c\u987a\u5e8f\u5bf9\u5e94\u7ed9\u51fa\u624b\u3001\u773c\u3001\u53e3\u7684\u53ef\u9009\u7b26\u53f7\u96c6\u3002\u6bcf\u4e2a\u7b26\u53f7\u62ec\u5728\u4e00\u5bf9\u65b9\u62ec\u53f7 [] \u5185\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u96c6\u5408\u90fd\u81f3\u5c11\u6709\u4e00\u4e2a\u7b26\u53f7\uff0c\u5e76\u4e0d\u8d85\u8fc7 10 \u4e2a\u7b26\u53f7\uff1b\u6bcf\u4e2a\u7b26\u53f7\u5305\u542b 1 \u5230 4 \u4e2a\u975e\u7a7a\u5b57\u7b26\u3002 \u4e4b\u540e\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K\uff0c\u4e3a\u7528\u6237\u8bf7\u6c42\u7684\u4e2a\u6570\u3002\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7528\u6237\u7684\u7b26\u53f7\u9009\u62e9\uff0c\u987a\u5e8f\u4e3a\u5de6\u624b\u3001\u5de6\u773c\u3001\u53e3\u3001\u53f3\u773c\u3001\u53f3\u624b\u2014\u2014\u8fd9\u91cc\u53ea\u7ed9\u51fa\u7b26\u53f7\u5728\u76f8\u5e94\u96c6\u5408\u4e2d\u7684\u5e8f\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u7528\u6237\u8bf7\u6c42\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u751f\u6210\u7684\u8868\u60c5\u3002\u82e5\u7528\u6237\u9009\u62e9\u7684\u5e8f\u53f7\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa Are you kidding me? @\\/@ \u3002 \u8f93\u5165\u6837\u4f8b [\u256e][\u256d][o][~\\][/~] [<][>] [\u256f][\u2570][^][-][=][>][<][@][\u2299] [\u0414][\u25bd][_][\u03b5][^] ... 4 1 1 2 2 2 6 8 1 5 5 3 3 4 3 3 2 10 3 9 3 \u8f93\u51fa\u6837\u4f8b \u256e(\u256f\u25bd\u2570)\u256d <(@\u0414=)/~ o(^\u03b5^)o Are you kidding me? @\\/@","title":"Statement"},{"location":"PAT-Basic-Level/1052-%E5%8D%96%E4%B8%AA%E8%90%8C/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; struct pp { string s [ 10 ]; } q [ 3 ]; int main () { string s ; int i , j , k , l , len , tot [ 3 ] = { 0 }; for ( i = 0 ; i < 3 ; i ++ ) { getline ( cin , s ); // cout<<s<<endl; len = s . size (); for ( j = 0 , l = 0 ; j < len ; j ++ ) { if ( s [ j ] == '[' ) { // cout<<j<<endl; for ( k = j + 1 ; s [ k ] != ']' ; k ++ ) { q [ i ]. s [ l ] += s [ k ]; } // cout<<q[i].s[l]<<endl; l ++ ; j = k ; } } tot [ i ] = l ; // cout<<l<<endl; } int t ; cin >> t ; while ( t -- ) { s = \"\" ; int n [ 5 ], flag = 1 , a [ 5 ] = { 0 , 1 , 2 , 1 , 0 }; for ( i = 0 ; i < 5 ; i ++ ) cin >> n [ i ]; for ( i = 0 ; i < 5 ; i ++ ) { n [ i ] -- ; if ( n [ i ] > tot [ a [ i ]] - 1 || n [ i ] < 0 ) { flag = 0 ; // cout<<\"1\\n\"; break ; } else { s += q [ a [ i ]]. s [ n [ i ]]; } if ( ! i ) s += \"(\" ; else if ( i == 3 ) s += \")\" ; } if ( flag ) cout << s << endl ; else cout << \"Are you kidding me? @ \\\\ /@ \\n \" ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/","text":"1053 \u4f4f\u623f\u7a7a\u7f6e\u7387 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u4e0d\u6253\u6270\u5c45\u6c11\u7684\u524d\u63d0\u4e0b\uff0c\u7edf\u8ba1\u4f4f\u623f\u7a7a\u7f6e\u7387\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u6839\u636e\u6bcf\u6237\u7528\u7535\u91cf\u7684\u8fde\u7eed\u53d8\u5316\u89c4\u5f8b\u8fdb\u884c\u5224\u65ad\u3002\u5224\u65ad\u65b9\u6cd5\u5982\u4e0b\uff1a \u5728\u89c2\u5bdf\u671f\u5185\uff0c\u82e5\u5b58\u5728\u8d85\u8fc7\u4e00\u534a\u7684\u65e5\u5b50\u7528\u7535\u91cf\u4f4e\u4e8e\u67d0\u7ed9\u5b9a\u7684\u9608\u503c e e \uff0c\u5219\u8be5\u4f4f\u623f\u4e3a\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\uff1b \u82e5\u89c2\u5bdf\u671f\u8d85\u8fc7\u67d0\u7ed9\u5b9a\u9608\u503c D D \u5929\uff0c\u4e14\u6ee1\u8db3\u4e0a\u4e00\u4e2a\u6761\u4ef6\uff0c\u5219\u8be5\u4f4f\u623f\u4e3a\u201c\u7a7a\u7f6e\u201d\u3002 \u73b0\u7ed9\u5b9a\u67d0\u5c45\u6c11\u533a\u7684\u4f4f\u6237\u7528\u7535\u91cf\u6570\u636e\uff0c\u8bf7\u4f60\u7edf\u8ba1\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\u7684\u6bd4\u7387\u548c\u201c\u7a7a\u7f6e\u201d\u6bd4\u7387\uff0c\u5373\u4ee5\u4e0a\u4e24\u79cd\u72b6\u6001\u7684\u4f4f\u623f\u5360\u5c45\u6c11\u533a\u4f4f\u623f\u603b\u5957\u6570\u7684\u767e\u5206\u6bd4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u5c45\u6c11\u533a\u4f4f\u623f\u603b\u5957\u6570\uff1b\u6b63\u5b9e\u6570 e e \uff0c\u5373\u4f4e\u7535\u91cf\u9608\u503c\uff1b\u6b63\u6574\u6570 D D \uff0c\u5373\u89c2\u5bdf\u671f\u9608\u503c\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u5957\u4f4f\u623f\u7684\u7528\u7535\u91cf\u6570\u636e\uff1a K K E_1 E_1 E_2 E_2 \u2026 E_K E_K \u5176\u4e2d K K \u4e3a\u89c2\u5bdf\u7684\u5929\u6570\uff0c E_i E_i \u4e3a\u7b2c i i \u5929\u7684\u7528\u7535\u91cf\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\u7684\u6bd4\u7387\u548c\u201c\u7a7a\u7f6e\u201d\u6bd4\u7387\u7684\u767e\u5206\u6bd4\u503c\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 5 0.5 10 6 0.3 0.4 0.5 0.2 0.8 0.6 10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5 5 0.4 0.3 0.5 0.1 0.7 11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 \u8f93\u51fa\u6837\u4f8b 40.0% 20.0% \uff08\u6837\u4f8b\u89e3\u91ca\uff1a\u7b2c2\u30013\u6237\u4e3a\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\uff0c\u7b2c4\u6237\u4e3a\u201c\u7a7a\u7f6e\u201d\uff0c\u5176\u4ed6\u6237\u4e0d\u662f\u7a7a\u7f6e\u3002\uff09 Solution C++ #include <iostream> #include <map> #include <string> using namespace std ; int main () { int n , d , a , i , j = 0 , k = 0 , c ; double e , list [ 1000 ], p , q ; map < int , int > map ; cin >> n >> e >> d ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; c = 0 ; for ( j = 0 ; j < a ; j ++ ) { cin >> list [ j ]; if ( list [ j ] < e ) { c ++ ; } } if ( c * 2 > a ) { map [ i ] ++ ; if ( a > d ) { map [ i ] ++ ; } } } j = 0 , k = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( map [ i ] == 1 ) { j ++ ; } else if ( map [ i ] == 2 ) { k ++ ; } } p = 1.0 * j / n ; q = 1.0 * k / n ; printf ( \"%.1f\" , 100 * p ); cout << \"% \" ; printf ( \"%.1f% \\n \" , 100 * q ); }","title":"1053-\u4f4f\u623f\u7a7a\u7f6e\u7387"},{"location":"PAT-Basic-Level/1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/#1053-\u4f4f\u623f\u7a7a\u7f6e\u7387","text":"","title":"1053 \u4f4f\u623f\u7a7a\u7f6e\u7387"},{"location":"PAT-Basic-Level/1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u4e0d\u6253\u6270\u5c45\u6c11\u7684\u524d\u63d0\u4e0b\uff0c\u7edf\u8ba1\u4f4f\u623f\u7a7a\u7f6e\u7387\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u6839\u636e\u6bcf\u6237\u7528\u7535\u91cf\u7684\u8fde\u7eed\u53d8\u5316\u89c4\u5f8b\u8fdb\u884c\u5224\u65ad\u3002\u5224\u65ad\u65b9\u6cd5\u5982\u4e0b\uff1a \u5728\u89c2\u5bdf\u671f\u5185\uff0c\u82e5\u5b58\u5728\u8d85\u8fc7\u4e00\u534a\u7684\u65e5\u5b50\u7528\u7535\u91cf\u4f4e\u4e8e\u67d0\u7ed9\u5b9a\u7684\u9608\u503c e e \uff0c\u5219\u8be5\u4f4f\u623f\u4e3a\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\uff1b \u82e5\u89c2\u5bdf\u671f\u8d85\u8fc7\u67d0\u7ed9\u5b9a\u9608\u503c D D \u5929\uff0c\u4e14\u6ee1\u8db3\u4e0a\u4e00\u4e2a\u6761\u4ef6\uff0c\u5219\u8be5\u4f4f\u623f\u4e3a\u201c\u7a7a\u7f6e\u201d\u3002 \u73b0\u7ed9\u5b9a\u67d0\u5c45\u6c11\u533a\u7684\u4f4f\u6237\u7528\u7535\u91cf\u6570\u636e\uff0c\u8bf7\u4f60\u7edf\u8ba1\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\u7684\u6bd4\u7387\u548c\u201c\u7a7a\u7f6e\u201d\u6bd4\u7387\uff0c\u5373\u4ee5\u4e0a\u4e24\u79cd\u72b6\u6001\u7684\u4f4f\u623f\u5360\u5c45\u6c11\u533a\u4f4f\u623f\u603b\u5957\u6570\u7684\u767e\u5206\u6bd4\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\uff0c\u4e3a\u5c45\u6c11\u533a\u4f4f\u623f\u603b\u5957\u6570\uff1b\u6b63\u5b9e\u6570 e e \uff0c\u5373\u4f4e\u7535\u91cf\u9608\u503c\uff1b\u6b63\u6574\u6570 D D \uff0c\u5373\u89c2\u5bdf\u671f\u9608\u503c\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u5957\u4f4f\u623f\u7684\u7528\u7535\u91cf\u6570\u636e\uff1a K K E_1 E_1 E_2 E_2 \u2026 E_K E_K \u5176\u4e2d K K \u4e3a\u89c2\u5bdf\u7684\u5929\u6570\uff0c E_i E_i \u4e3a\u7b2c i i \u5929\u7684\u7528\u7535\u91cf\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\u7684\u6bd4\u7387\u548c\u201c\u7a7a\u7f6e\u201d\u6bd4\u7387\u7684\u767e\u5206\u6bd4\u503c\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 5 0.5 10 6 0.3 0.4 0.5 0.2 0.8 0.6 10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5 5 0.4 0.3 0.5 0.1 0.7 11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 \u8f93\u51fa\u6837\u4f8b 40.0% 20.0% \uff08\u6837\u4f8b\u89e3\u91ca\uff1a\u7b2c2\u30013\u6237\u4e3a\u201c\u53ef\u80fd\u7a7a\u7f6e\u201d\uff0c\u7b2c4\u6237\u4e3a\u201c\u7a7a\u7f6e\u201d\uff0c\u5176\u4ed6\u6237\u4e0d\u662f\u7a7a\u7f6e\u3002\uff09","title":"Statement"},{"location":"PAT-Basic-Level/1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/#solution","text":"C++ #include <iostream> #include <map> #include <string> using namespace std ; int main () { int n , d , a , i , j = 0 , k = 0 , c ; double e , list [ 1000 ], p , q ; map < int , int > map ; cin >> n >> e >> d ; for ( i = 0 ; i < n ; i ++ ) { cin >> a ; c = 0 ; for ( j = 0 ; j < a ; j ++ ) { cin >> list [ j ]; if ( list [ j ] < e ) { c ++ ; } } if ( c * 2 > a ) { map [ i ] ++ ; if ( a > d ) { map [ i ] ++ ; } } } j = 0 , k = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( map [ i ] == 1 ) { j ++ ; } else if ( map [ i ] == 2 ) { k ++ ; } } p = 1.0 * j / n ; q = 1.0 * k / n ; printf ( \"%.1f\" , 100 * p ); cout << \"% \" ; printf ( \"%.1f% \\n \" , 100 * q ); }","title":"Solution"},{"location":"PAT-Basic-Level/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/","text":"1054 \u6c42\u5e73\u5747\u503c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u57fa\u672c\u8981\u6c42\u975e\u5e38\u7b80\u5355\uff1a\u7ed9\u5b9a N N \u4e2a\u5b9e\u6570\uff0c\u8ba1\u7b97\u5b83\u4eec\u7684\u5e73\u5747\u503c\u3002\u4f46\u590d\u6742\u7684\u662f\u6709\u4e9b\u8f93\u5165\u6570\u636e\u53ef\u80fd\u662f\u975e\u6cd5\u7684\u3002\u4e00\u4e2a\u201c\u5408\u6cd5\u201d\u7684\u8f93\u5165\u662f [ -1000, 1000 -1000, 1000 ] \u533a\u95f4\u5185\u7684\u5b9e\u6570\uff0c\u5e76\u4e14\u6700\u591a\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002\u5f53\u4f60\u8ba1\u7b97\u5e73\u5747\u503c\u7684\u65f6\u5019\uff0c\u4e0d\u80fd\u628a\u90a3\u4e9b\u975e\u6cd5\u7684\u6570\u636e\u7b97\u5728\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u5b9e\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u975e\u6cd5\u8f93\u5165\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa ERROR: X is not a legal number \uff0c\u5176\u4e2d X \u662f\u8f93\u5165\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\uff1a The average of K numbers is Y \uff0c\u5176\u4e2d K \u662f\u5408\u6cd5\u8f93\u5165\u7684\u4e2a\u6570\uff0c Y \u662f\u5b83\u4eec\u7684\u5e73\u5747\u503c\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002\u5982\u679c\u5e73\u5747\u503c\u65e0\u6cd5\u8ba1\u7b97\uff0c\u5219\u7528 Undefined \u66ff\u6362 Y \u3002\u5982\u679c K \u4e3a 1\uff0c\u5219\u8f93\u51fa The average of 1 number is Y \u3002 \u8f93\u5165\u6837\u4f8b 1 7 5 -3.2 aaa 9999 2.3.4 7.123 2.35 \u8f93\u51fa\u6837\u4f8b 1 ERROR: aaa is not a legal number ERROR: 9999 is not a legal number ERROR: 2.3.4 is not a legal number ERROR: 7.123 is not a legal number The average of 3 numbers is 1.38 \u8f93\u5165\u6837\u4f8b 2 2 aaa -9999 \u8f93\u51fa\u6837\u4f8b 2 ERROR: aaa is not a legal number ERROR: -9999 is not a legal number The average of 0 numbers is Undefined Solution C++ #include <bits/stdc++.h> using namespace std ; int jude ( string s ) { int i , len = s . size (), flag = 0 ; if ( s [ 0 ] == '-' ) i = 1 ; else i = 0 ; for (; i < len ; i ++ ) { if (( s [ i ] >= '0' && s [ i ] <= '9' )) { continue ; } else if ( s [ i ] == '.' ) { if ( len - i - 1 > 2 || flag ) return 0 ; else flag = 1 ; } else return 0 ; } if ( flag ) return 2 ; else return 1 ; } double tran ( string s ) { while ( s [ 0 ] == '0' ) s . erase ( 0 , 1 ); int i , len = s . size (), j = pow ( 10 , len - 1 ); double num = 0 ; for ( i = 0 ; i < len ; i ++ , j /= 10 ) { num += ( s [ i ] - '0' ) * j ; } return num ; } double change ( string s , int x ) { int flag = 0 ; if ( s [ 0 ] == '-' ) { s . erase ( 0 , 1 ); flag = 1 ; } int len = s . size (), i , j ; double num = 0 ; string s1 = \"\" ; if ( x == 1 ) num += tran ( s ); else if ( x == 2 ) { for ( i = 0 ; s [ i ] != '.' ; i ++ ) s1 += s [ i ]; num += tran ( s1 ); s1 = \"\" ; for ( i ++ , j = 0 ; i < len ; i ++ , j ++ ) s1 += s [ i ]; num += ( tran ( s1 ) * pow ( 0.1 , j )); } if ( flag ) num *= -1 ; return num ; } int main () { int n , i , j , total = 0 , flag ; string s ; cin >> n ; double tot = 0 ; for ( i = 0 ; i < n ; i ++ ) { double num ; flag = 1 ; cin >> s ; if ( jude ( s )) { num = change ( s , jude ( s )); // cout<<num<<endl; if ( num <= 1000 && num >= -1000 ) total ++ , tot += num , flag = 0 ; } if ( flag ) cout << \"ERROR: \" << s << \" is not a legal number \\n \" ; } if ( total > 1 ) printf ( \"The average of %d numbers is %.2lf\" , total , tot / total ); else if ( total == 1 ) printf ( \"The average of 1 number is %.2lf\" , tot ); else cout << \"The average of 0 numbers is Undefined\" ; }","title":"1054-\u6c42\u5e73\u5747\u503c"},{"location":"PAT-Basic-Level/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/#1054-\u6c42\u5e73\u5747\u503c","text":"","title":"1054 \u6c42\u5e73\u5747\u503c"},{"location":"PAT-Basic-Level/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u7684\u57fa\u672c\u8981\u6c42\u975e\u5e38\u7b80\u5355\uff1a\u7ed9\u5b9a N N \u4e2a\u5b9e\u6570\uff0c\u8ba1\u7b97\u5b83\u4eec\u7684\u5e73\u5747\u503c\u3002\u4f46\u590d\u6742\u7684\u662f\u6709\u4e9b\u8f93\u5165\u6570\u636e\u53ef\u80fd\u662f\u975e\u6cd5\u7684\u3002\u4e00\u4e2a\u201c\u5408\u6cd5\u201d\u7684\u8f93\u5165\u662f [ -1000, 1000 -1000, 1000 ] \u533a\u95f4\u5185\u7684\u5b9e\u6570\uff0c\u5e76\u4e14\u6700\u591a\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002\u5f53\u4f60\u8ba1\u7b97\u5e73\u5747\u503c\u7684\u65f6\u5019\uff0c\u4e0d\u80fd\u628a\u90a3\u4e9b\u975e\u6cd5\u7684\u6570\u636e\u7b97\u5728\u5185\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 100 \\le 100 \uff09\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N N \u4e2a\u5b9e\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u975e\u6cd5\u8f93\u5165\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa ERROR: X is not a legal number \uff0c\u5176\u4e2d X \u662f\u8f93\u5165\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\uff1a The average of K numbers is Y \uff0c\u5176\u4e2d K \u662f\u5408\u6cd5\u8f93\u5165\u7684\u4e2a\u6570\uff0c Y \u662f\u5b83\u4eec\u7684\u5e73\u5747\u503c\uff0c\u7cbe\u786e\u5230\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002\u5982\u679c\u5e73\u5747\u503c\u65e0\u6cd5\u8ba1\u7b97\uff0c\u5219\u7528 Undefined \u66ff\u6362 Y \u3002\u5982\u679c K \u4e3a 1\uff0c\u5219\u8f93\u51fa The average of 1 number is Y \u3002 \u8f93\u5165\u6837\u4f8b 1 7 5 -3.2 aaa 9999 2.3.4 7.123 2.35 \u8f93\u51fa\u6837\u4f8b 1 ERROR: aaa is not a legal number ERROR: 9999 is not a legal number ERROR: 2.3.4 is not a legal number ERROR: 7.123 is not a legal number The average of 3 numbers is 1.38 \u8f93\u5165\u6837\u4f8b 2 2 aaa -9999 \u8f93\u51fa\u6837\u4f8b 2 ERROR: aaa is not a legal number ERROR: -9999 is not a legal number The average of 0 numbers is Undefined","title":"Statement"},{"location":"PAT-Basic-Level/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int jude ( string s ) { int i , len = s . size (), flag = 0 ; if ( s [ 0 ] == '-' ) i = 1 ; else i = 0 ; for (; i < len ; i ++ ) { if (( s [ i ] >= '0' && s [ i ] <= '9' )) { continue ; } else if ( s [ i ] == '.' ) { if ( len - i - 1 > 2 || flag ) return 0 ; else flag = 1 ; } else return 0 ; } if ( flag ) return 2 ; else return 1 ; } double tran ( string s ) { while ( s [ 0 ] == '0' ) s . erase ( 0 , 1 ); int i , len = s . size (), j = pow ( 10 , len - 1 ); double num = 0 ; for ( i = 0 ; i < len ; i ++ , j /= 10 ) { num += ( s [ i ] - '0' ) * j ; } return num ; } double change ( string s , int x ) { int flag = 0 ; if ( s [ 0 ] == '-' ) { s . erase ( 0 , 1 ); flag = 1 ; } int len = s . size (), i , j ; double num = 0 ; string s1 = \"\" ; if ( x == 1 ) num += tran ( s ); else if ( x == 2 ) { for ( i = 0 ; s [ i ] != '.' ; i ++ ) s1 += s [ i ]; num += tran ( s1 ); s1 = \"\" ; for ( i ++ , j = 0 ; i < len ; i ++ , j ++ ) s1 += s [ i ]; num += ( tran ( s1 ) * pow ( 0.1 , j )); } if ( flag ) num *= -1 ; return num ; } int main () { int n , i , j , total = 0 , flag ; string s ; cin >> n ; double tot = 0 ; for ( i = 0 ; i < n ; i ++ ) { double num ; flag = 1 ; cin >> s ; if ( jude ( s )) { num = change ( s , jude ( s )); // cout<<num<<endl; if ( num <= 1000 && num >= -1000 ) total ++ , tot += num , flag = 0 ; } if ( flag ) cout << \"ERROR: \" << s << \" is not a legal number \\n \" ; } if ( total > 1 ) printf ( \"The average of %d numbers is %.2lf\" , total , tot / total ); else if ( total == 1 ) printf ( \"The average of 1 number is %.2lf\" , tot ); else cout << \"The average of 0 numbers is Undefined\" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1055-%E9%9B%86%E4%BD%93%E7%85%A7/","text":"1055 \u96c6\u4f53\u7167 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u62cd\u96c6\u4f53\u7167\u65f6\u961f\u5f62\u5f88\u91cd\u8981\uff0c\u8fd9\u91cc\u5bf9\u7ed9\u5b9a\u7684 N N \u4e2a\u4eba K K \u6392\u7684\u961f\u5f62\u8bbe\u8ba1\u6392\u961f\u89c4\u5219\u5982\u4e0b\uff1a \u6bcf\u6392\u4eba\u6570\u4e3a N/K N/K \uff08\u5411\u4e0b\u53d6\u6574\uff09\uff0c\u591a\u51fa\u6765\u7684\u4eba\u5168\u90e8\u7ad9\u5728\u6700\u540e\u4e00\u6392\uff1b \u540e\u6392\u6240\u6709\u4eba\u7684\u4e2a\u5b50\u90fd\u4e0d\u6bd4\u524d\u6392\u4efb\u4f55\u4eba\u77ee\uff1b \u6bcf\u6392\u4e2d\u6700\u9ad8\u8005\u7ad9\u4e2d\u95f4\uff08\u4e2d\u95f4\u4f4d\u7f6e\u4e3a m/2+1 m/2+1 \uff0c\u5176\u4e2d m m \u4e3a\u8be5\u6392\u4eba\u6570\uff0c\u9664\u6cd5\u5411\u4e0b\u53d6\u6574\uff09\uff1b \u6bcf\u6392\u5176\u4ed6\u4eba\u4ee5\u4e2d\u95f4\u4eba\u4e3a\u8f74\uff0c\u6309\u8eab\u9ad8\u975e\u589e\u5e8f\uff0c\u5148\u53f3\u540e\u5de6\u4ea4\u66ff\u5165\u961f\u7ad9\u5728\u4e2d\u95f4\u4eba\u7684\u4e24\u4fa7\uff08\u4f8b\u59825\u4eba\u8eab\u9ad8\u4e3a190\u3001188\u3001186\u3001175\u3001170\uff0c\u5219\u961f\u5f62\u4e3a175\u3001188\u3001190\u3001186\u3001170\u3002\u8fd9\u91cc\u5047\u8bbe\u4f60\u9762\u5bf9\u62cd\u7167\u8005\uff0c\u6240\u4ee5\u4f60\u7684\u5de6\u8fb9\u662f\u4e2d\u95f4\u4eba\u7684\u53f3\u8fb9\uff09\uff1b \u82e5\u591a\u4eba\u8eab\u9ad8\u76f8\u540c\uff0c\u5219\u6309\u540d\u5b57\u7684\u5b57\u5178\u5e8f\u5347\u5e8f\u6392\u5217\u3002\u8fd9\u91cc\u4fdd\u8bc1\u65e0\u91cd\u540d\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7ec4\u62cd\u7167\u4eba\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8f93\u51fa\u4ed6\u4eec\u7684\u961f\u5f62\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff0c\u603b\u4eba\u6570\uff09\u548c K K \uff08 \\le 10 \\le 10 \uff0c\u603b\u6392\u6570\uff09\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u540d\u5b57\uff08\u4e0d\u5305\u542b\u7a7a\u683c\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc7 8 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff09\u548c\u8eab\u9ad8\uff08[30, 300] \u533a\u95f4\u5185\u7684\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u62cd\u7167\u7684\u961f\u5f62\u3002\u5373K\u6392\u4eba\u540d\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\uff1a\u5047\u8bbe\u4f60\u9762\u5bf9\u62cd\u7167\u8005\uff0c\u540e\u6392\u7684\u4eba\u8f93\u51fa\u5728\u4e0a\u65b9\uff0c\u524d\u6392\u8f93\u51fa\u5728\u4e0b\u65b9\u3002 \u8f93\u5165\u6837\u4f8b 10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 \u8f93\u51fa\u6837\u4f8b Bob Tom Joe Nick Ann Mike Eva Tim Amy John Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 struct pp { string s ; int n ; } q [ MAXN ], p [ MAXN ]; int comp ( pp x , pp y ) { if ( x . n != y . n ) return x . n > y . n ; else return x . s < y . s ; } void lists ( int a [], int x ) { memset ( a , 0 , sizeof ( a )); int i , j , k , l ; l = x / 2 + 1 ; for ( i = l - 1 , j = l , k = 0 ; k < x ; k ++ ) { if ( k % 2 == 1 || k == 0 ) { a [ i ] = k ; i -- ; } else { a [ j ] = k ; j ++ ; } } } int a [ MAXN ]; int main () { int N , K , n , m ; int i , j , k , l ; string s = \"\" ; cin >> N >> K ; n = floor ( N / K ); m = N + n - n * K ; for ( i = 0 ; i < N ; i ++ ) cin >> q [ i ]. s >> q [ i ]. n ; sort ( q , q + N , comp ); lists ( a , m ); for ( i = 0 ; i < m ; i ++ ) p [ i ] = q [ i ]; for ( i = 0 ; i < m ; i ++ ) s += p [ a [ i ]]. s , s += \" \" ; s . erase ( s . size () - 1 , 1 ); cout << s << endl ; s . clear (); lists ( a , n ); for (; i < N ; i += n ) { for ( j = i , k = 0 ; k < n ; j ++ , k ++ ) p [ k ] = q [ j ]; for ( j = 0 ; j < n ; j ++ ) s += p [ a [ j ]]. s , s += \" \" ; s . erase ( s . size () - 1 , 1 ); cout << s << endl ; s . clear (); } }","title":"1055-\u96c6\u4f53\u7167"},{"location":"PAT-Basic-Level/1055-%E9%9B%86%E4%BD%93%E7%85%A7/#1055-\u96c6\u4f53\u7167","text":"","title":"1055 \u96c6\u4f53\u7167"},{"location":"PAT-Basic-Level/1055-%E9%9B%86%E4%BD%93%E7%85%A7/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u62cd\u96c6\u4f53\u7167\u65f6\u961f\u5f62\u5f88\u91cd\u8981\uff0c\u8fd9\u91cc\u5bf9\u7ed9\u5b9a\u7684 N N \u4e2a\u4eba K K \u6392\u7684\u961f\u5f62\u8bbe\u8ba1\u6392\u961f\u89c4\u5219\u5982\u4e0b\uff1a \u6bcf\u6392\u4eba\u6570\u4e3a N/K N/K \uff08\u5411\u4e0b\u53d6\u6574\uff09\uff0c\u591a\u51fa\u6765\u7684\u4eba\u5168\u90e8\u7ad9\u5728\u6700\u540e\u4e00\u6392\uff1b \u540e\u6392\u6240\u6709\u4eba\u7684\u4e2a\u5b50\u90fd\u4e0d\u6bd4\u524d\u6392\u4efb\u4f55\u4eba\u77ee\uff1b \u6bcf\u6392\u4e2d\u6700\u9ad8\u8005\u7ad9\u4e2d\u95f4\uff08\u4e2d\u95f4\u4f4d\u7f6e\u4e3a m/2+1 m/2+1 \uff0c\u5176\u4e2d m m \u4e3a\u8be5\u6392\u4eba\u6570\uff0c\u9664\u6cd5\u5411\u4e0b\u53d6\u6574\uff09\uff1b \u6bcf\u6392\u5176\u4ed6\u4eba\u4ee5\u4e2d\u95f4\u4eba\u4e3a\u8f74\uff0c\u6309\u8eab\u9ad8\u975e\u589e\u5e8f\uff0c\u5148\u53f3\u540e\u5de6\u4ea4\u66ff\u5165\u961f\u7ad9\u5728\u4e2d\u95f4\u4eba\u7684\u4e24\u4fa7\uff08\u4f8b\u59825\u4eba\u8eab\u9ad8\u4e3a190\u3001188\u3001186\u3001175\u3001170\uff0c\u5219\u961f\u5f62\u4e3a175\u3001188\u3001190\u3001186\u3001170\u3002\u8fd9\u91cc\u5047\u8bbe\u4f60\u9762\u5bf9\u62cd\u7167\u8005\uff0c\u6240\u4ee5\u4f60\u7684\u5de6\u8fb9\u662f\u4e2d\u95f4\u4eba\u7684\u53f3\u8fb9\uff09\uff1b \u82e5\u591a\u4eba\u8eab\u9ad8\u76f8\u540c\uff0c\u5219\u6309\u540d\u5b57\u7684\u5b57\u5178\u5e8f\u5347\u5e8f\u6392\u5217\u3002\u8fd9\u91cc\u4fdd\u8bc1\u65e0\u91cd\u540d\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7ec4\u62cd\u7167\u4eba\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u8f93\u51fa\u4ed6\u4eec\u7684\u961f\u5f62\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff0c\u603b\u4eba\u6570\uff09\u548c K K \uff08 \\le 10 \\le 10 \uff0c\u603b\u6392\u6570\uff09\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4eba\u7684\u540d\u5b57\uff08\u4e0d\u5305\u542b\u7a7a\u683c\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc7 8 \u4e2a\u82f1\u6587\u5b57\u6bcd\uff09\u548c\u8eab\u9ad8\uff08[30, 300] \u533a\u95f4\u5185\u7684\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u62cd\u7167\u7684\u961f\u5f62\u3002\u5373K\u6392\u4eba\u540d\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u6ce8\u610f\uff1a\u5047\u8bbe\u4f60\u9762\u5bf9\u62cd\u7167\u8005\uff0c\u540e\u6392\u7684\u4eba\u8f93\u51fa\u5728\u4e0a\u65b9\uff0c\u524d\u6392\u8f93\u51fa\u5728\u4e0b\u65b9\u3002 \u8f93\u5165\u6837\u4f8b 10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 \u8f93\u51fa\u6837\u4f8b Bob Tom Joe Nick Ann Mike Eva Tim Amy John","title":"Statement"},{"location":"PAT-Basic-Level/1055-%E9%9B%86%E4%BD%93%E7%85%A7/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 struct pp { string s ; int n ; } q [ MAXN ], p [ MAXN ]; int comp ( pp x , pp y ) { if ( x . n != y . n ) return x . n > y . n ; else return x . s < y . s ; } void lists ( int a [], int x ) { memset ( a , 0 , sizeof ( a )); int i , j , k , l ; l = x / 2 + 1 ; for ( i = l - 1 , j = l , k = 0 ; k < x ; k ++ ) { if ( k % 2 == 1 || k == 0 ) { a [ i ] = k ; i -- ; } else { a [ j ] = k ; j ++ ; } } } int a [ MAXN ]; int main () { int N , K , n , m ; int i , j , k , l ; string s = \"\" ; cin >> N >> K ; n = floor ( N / K ); m = N + n - n * K ; for ( i = 0 ; i < N ; i ++ ) cin >> q [ i ]. s >> q [ i ]. n ; sort ( q , q + N , comp ); lists ( a , m ); for ( i = 0 ; i < m ; i ++ ) p [ i ] = q [ i ]; for ( i = 0 ; i < m ; i ++ ) s += p [ a [ i ]]. s , s += \" \" ; s . erase ( s . size () - 1 , 1 ); cout << s << endl ; s . clear (); lists ( a , n ); for (; i < N ; i += n ) { for ( j = i , k = 0 ; k < n ; j ++ , k ++ ) p [ k ] = q [ j ]; for ( j = 0 ; j < n ; j ++ ) s += p [ a [ j ]]. s , s += \" \" ; s . erase ( s . size () - 1 , 1 ); cout << s << endl ; s . clear (); } }","title":"Solution"},{"location":"PAT-Basic-Level/1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/","text":"1056 \u7ec4\u5408\u6570\u7684\u548c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u4e2a\u975e 0 \u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u7528\u5176\u4e2d\u4efb\u610f 2 \u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u7ec4\u5408\u6210 1 \u4e2a 2 \u4f4d\u7684\u6570\u5b57\u3002\u8981\u6c42\u6240\u6709\u53ef\u80fd\u7ec4\u5408\u51fa\u6765\u7684 2 \u4f4d\u6570\u5b57\u7684\u548c\u3002\u4f8b\u5982\u7ed9\u5b9a 2\u30015\u30018\uff0c\u5219\u53ef\u4ee5\u7ec4\u5408\u51fa\uff1a25\u300128\u300152\u300158\u300182\u300185\uff0c\u5b83\u4eec\u7684\u548c\u4e3a330\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u5148\u7ed9\u51fa N\uff081 < < N < < 10\uff09\uff0c\u968f\u540e\u7ed9\u51fa N \u4e2a\u4e0d\u540c\u7684\u975e 0 \u4e2a\u4f4d\u6570\u5b57\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u6240\u6709\u53ef\u80fd\u7ec4\u5408\u51fa\u6765\u76842\u4f4d\u6570\u5b57\u7684\u548c\u3002 \u8f93\u5165\u6837\u4f8b 3 2 8 5 \u8f93\u51fa\u6837\u4f8b 330 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , a [ 10 ], i , j , total = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { total += a [ i ] * 10 + a [ j ]; } } for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = i - 1 ; j >= 0 ; j -- ) { total += a [ i ] * 10 + a [ j ]; } } cout << total << endl ; }","title":"1056-\u7ec4\u5408\u6570\u7684\u548c"},{"location":"PAT-Basic-Level/1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/#1056-\u7ec4\u5408\u6570\u7684\u548c","text":"","title":"1056 \u7ec4\u5408\u6570\u7684\u548c"},{"location":"PAT-Basic-Level/1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u4e2a\u975e 0 \u7684\u4e2a\u4f4d\u6570\u5b57\uff0c\u7528\u5176\u4e2d\u4efb\u610f 2 \u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u7ec4\u5408\u6210 1 \u4e2a 2 \u4f4d\u7684\u6570\u5b57\u3002\u8981\u6c42\u6240\u6709\u53ef\u80fd\u7ec4\u5408\u51fa\u6765\u7684 2 \u4f4d\u6570\u5b57\u7684\u548c\u3002\u4f8b\u5982\u7ed9\u5b9a 2\u30015\u30018\uff0c\u5219\u53ef\u4ee5\u7ec4\u5408\u51fa\uff1a25\u300128\u300152\u300158\u300182\u300185\uff0c\u5b83\u4eec\u7684\u548c\u4e3a330\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u5148\u7ed9\u51fa N\uff081 < < N < < 10\uff09\uff0c\u968f\u540e\u7ed9\u51fa N \u4e2a\u4e0d\u540c\u7684\u975e 0 \u4e2a\u4f4d\u6570\u5b57\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u6240\u6709\u53ef\u80fd\u7ec4\u5408\u51fa\u6765\u76842\u4f4d\u6570\u5b57\u7684\u548c\u3002 \u8f93\u5165\u6837\u4f8b 3 2 8 5 \u8f93\u51fa\u6837\u4f8b 330","title":"Statement"},{"location":"PAT-Basic-Level/1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , a [ 10 ], i , j , total = 0 ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { total += a [ i ] * 10 + a [ j ]; } } for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = i - 1 ; j >= 0 ; j -- ) { total += a [ i ] * 10 + a [ j ]; } } cout << total << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/","text":"1057 \u6570\u96f6\u58f9 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u5b57\u7b26\u4e32\uff0c\u672c\u9898\u8981\u6c42\u4f60\u5c06\u5176\u4e2d\u6240\u6709\u82f1\u6587\u5b57\u6bcd\u7684\u5e8f\u53f7\uff08\u5b57\u6bcd a-z \u5bf9\u5e94\u5e8f\u53f7 1-26\uff0c\u4e0d\u5206\u5927\u5c0f\u5199\uff09\u76f8\u52a0\uff0c\u5f97\u5230\u6574\u6570 N\uff0c\u7136\u540e\u518d\u5206\u6790\u4e00\u4e0b N \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u6709\u591a\u5c11 0\u3001\u591a\u5c11 1\u3002\u4f8b\u5982\u7ed9\u5b9a\u5b57\u7b26\u4e32 PAT (Basic) \uff0c\u5176\u5b57\u6bcd\u5e8f\u53f7\u4e4b\u548c\u4e3a\uff1a16+1+20+2+1+19+9+3=71\uff0c\u800c 71 \u7684\u4e8c\u8fdb\u5236\u662f 1000111\uff0c\u5373\u6709 3 \u4e2a 0\u30014 \u4e2a 1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \u3001\u4ee5\u56de\u8f66\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa 0 \u7684\u4e2a\u6570\u548c 1 \u7684\u4e2a\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u82e5\u5b57\u7b26\u4e32\u4e2d\u4e0d\u5b58\u5728\u5b57\u6bcd\uff0c\u5219\u89c6\u4e3a N \u4e0d\u5b58\u5728\uff0c\u4e5f\u5c31\u6ca1\u6709 0 \u548c 1\u3002 \u8f93\u5165\u6837\u4f8b PAT (Basic) \u8f93\u51fa\u6837\u4f8b 3 4 \u9e23\u8c22\u6d59\u6c5f\u5de5\u4e1a\u5927\u5b66\u4e4b\u6c5f\u5b66\u9662\u77f3\u6d17\u51e1\u8001\u5e08\u8865\u5145\u9898\u9762\u8bf4\u660e\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; int total = 0 , i , tot1 = 0 , tot2 = 0 ; getline ( cin , s ); int len = s . size (); for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) { total += ( s [ i ] - 'A' + 1 ); } else if ( s [ i ] >= 'a' && s [ i ] <= 'z' ) { total += ( s [ i ] - 'a' + 1 ); } } /*cout<<total<<endl; if(total%2) tot2++; else tot1++; cout<<total%2<<endl;*/ while ( total ) { if ( total % 2 ) tot2 ++ ; else tot1 ++ ; total /= 2 ; // cout<<total%2<<endl; } cout << tot1 << \" \" << tot2 << endl ; }","title":"1057-\u6570\u96f6\u58f9"},{"location":"PAT-Basic-Level/1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/#1057-\u6570\u96f6\u58f9","text":"","title":"1057 \u6570\u96f6\u58f9"},{"location":"PAT-Basic-Level/1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u5b57\u7b26\u4e32\uff0c\u672c\u9898\u8981\u6c42\u4f60\u5c06\u5176\u4e2d\u6240\u6709\u82f1\u6587\u5b57\u6bcd\u7684\u5e8f\u53f7\uff08\u5b57\u6bcd a-z \u5bf9\u5e94\u5e8f\u53f7 1-26\uff0c\u4e0d\u5206\u5927\u5c0f\u5199\uff09\u76f8\u52a0\uff0c\u5f97\u5230\u6574\u6570 N\uff0c\u7136\u540e\u518d\u5206\u6790\u4e00\u4e0b N \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u6709\u591a\u5c11 0\u3001\u591a\u5c11 1\u3002\u4f8b\u5982\u7ed9\u5b9a\u5b57\u7b26\u4e32 PAT (Basic) \uff0c\u5176\u5b57\u6bcd\u5e8f\u53f7\u4e4b\u548c\u4e3a\uff1a16+1+20+2+1+19+9+3=71\uff0c\u800c 71 \u7684\u4e8c\u8fdb\u5236\u662f 1000111\uff0c\u5373\u6709 3 \u4e2a 0\u30014 \u4e2a 1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^5 10^5 \u3001\u4ee5\u56de\u8f66\u7ed3\u675f\u7684\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5148\u540e\u8f93\u51fa 0 \u7684\u4e2a\u6570\u548c 1 \u7684\u4e2a\u6570\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u82e5\u5b57\u7b26\u4e32\u4e2d\u4e0d\u5b58\u5728\u5b57\u6bcd\uff0c\u5219\u89c6\u4e3a N \u4e0d\u5b58\u5728\uff0c\u4e5f\u5c31\u6ca1\u6709 0 \u548c 1\u3002 \u8f93\u5165\u6837\u4f8b PAT (Basic) \u8f93\u51fa\u6837\u4f8b 3 4 \u9e23\u8c22\u6d59\u6c5f\u5de5\u4e1a\u5927\u5b66\u4e4b\u6c5f\u5b66\u9662\u77f3\u6d17\u51e1\u8001\u5e08\u8865\u5145\u9898\u9762\u8bf4\u660e\u3002","title":"Statement"},{"location":"PAT-Basic-Level/1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s ; int total = 0 , i , tot1 = 0 , tot2 = 0 ; getline ( cin , s ); int len = s . size (); for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= 'A' && s [ i ] <= 'Z' ) { total += ( s [ i ] - 'A' + 1 ); } else if ( s [ i ] >= 'a' && s [ i ] <= 'z' ) { total += ( s [ i ] - 'a' + 1 ); } } /*cout<<total<<endl; if(total%2) tot2++; else tot1++; cout<<total%2<<endl;*/ while ( total ) { if ( total % 2 ) tot2 ++ ; else tot1 ++ ; total /= 2 ; // cout<<total%2<<endl; } cout << tot1 << \" \" << tot2 << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1058-%E9%80%89%E6%8B%A9%E9%A2%98/","text":"1058 \u9009\u62e9\u9898 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u6279\u6539\u591a\u9009\u9898\u662f\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\uff0c\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u6279\u6539\u591a\u9009\u9898\uff0c\u5e76\u4e14\u6307\u51fa\u54ea\u9053\u9898\u9519\u7684\u4eba\u6700\u591a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u591a\u9009\u9898\u7684\u4e2a\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u4e00\u9053\u9898\u7684\u6ee1\u5206\u503c\uff08\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u5c11\u4e8e 2 \u4e14\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u6b63\u786e\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7\u9009\u9879\u4e2a\u6570\u7684\u6b63\u6574\u6570\uff09\u3001\u6240\u6709\u6b63\u786e\u9009\u9879\u3002\u6ce8\u610f\u6bcf\u9898\u7684\u9009\u9879\u4ece\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd a \u5f00\u59cb\u987a\u6b21\u6392\u5217\u3002\u5404\u9879\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\uff0c\u5176\u6bcf\u9898\u7b54\u6848\u683c\u5f0f\u4e3a (\u9009\u4e2d\u7684\u9009\u9879\u4e2a\u6570 \u9009\u98791 \u2026\u2026) \uff0c\u6309\u9898\u76ee\u987a\u5e8f\u7ed9\u51fa\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u5373\u4e0d\u5b58\u5728\u9009\u4e2d\u7684\u9009\u9879\u6570\u8d85\u8fc7\u5b9e\u9645\u9009\u9879\u6570\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\u3002\u6ce8\u610f\u5224\u9898\u65f6\u53ea\u6709\u9009\u62e9\u5168\u90e8\u6b63\u786e\u624d\u80fd\u5f97\u5230\u8be5\u9898\u7684\u5206\u6570\u3002\u6700\u540e\u4e00\u884c\u8f93\u51fa\u9519\u5f97\u6700\u591a\u7684\u9898\u76ee\u7684\u9519\u8bef\u6b21\u6570\u548c\u7f16\u53f7\uff08\u9898\u76ee\u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u4ece 1 \u5f00\u59cb\u7f16\u53f7\uff09\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6309\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6240\u6709\u9898\u76ee\u90fd\u6ca1\u6709\u4eba\u9519\uff0c\u5219\u5728\u6700\u540e\u4e00\u884c\u8f93\u51fa Too simple \u3002 \u8f93\u5165\u6837\u4f8b 3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) \u8f93\u51fa\u6837\u4f8b 3 6 5 2 2 3 4 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 struct pp { int score , choice , truth , wrong = 0 ; map < char , int > code ; } q [ MAXN ]; int main () { int n , m , i , j , k ; cin >> n >> m ; char c ; string s ; for ( i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & q [ i ]. score , & q [ i ]. choice , & q [ i ]. truth ); for ( j = 0 ; j < q [ i ]. truth ; j ++ ) { scanf ( \" %c\" , & c ); q [ i ]. code [ c ] = 1 ; } } int flag , num , total , max = -1 ; for ( i = 0 ; i < n ; i ++ ) { total = 0 ; for ( j = 0 ; j < m ; j ++ ) { flag = 1 ; scanf ( \" %c\" , & c ); cin >> num ; if ( num != q [ j ]. truth ) flag = 0 , q [ j ]. wrong ++ ; for ( k = 0 ; k < num ; k ++ ) { scanf ( \" %c\" , & c ); if ( ! q [ j ]. code [ c ] && flag ) { q [ j ]. wrong ++ ; flag = 0 ; } } scanf ( \"%c\" , & c ); if ( flag ) total += q [ j ]. score ; if ( q [ j ]. wrong > max && q [ j ]. wrong ) max = q [ j ]. wrong ; } cout << total << endl ; } if ( max != -1 ) { cout << max ; for ( i = 0 ; i < m ; i ++ ) { if ( q [ i ]. wrong == max ) printf ( \" %d\" , i + 1 ); } } else cout << \"Too simple\" ; cout << \" \\n \" ; }","title":"1058-\u9009\u62e9\u9898"},{"location":"PAT-Basic-Level/1058-%E9%80%89%E6%8B%A9%E9%A2%98/#1058-\u9009\u62e9\u9898","text":"","title":"1058 \u9009\u62e9\u9898"},{"location":"PAT-Basic-Level/1058-%E9%80%89%E6%8B%A9%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB \u6279\u6539\u591a\u9009\u9898\u662f\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\uff0c\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u6279\u6539\u591a\u9009\u9898\uff0c\u5e76\u4e14\u6307\u51fa\u54ea\u9053\u9898\u9519\u7684\u4eba\u6700\u591a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u591a\u9009\u9898\u7684\u4e2a\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u4e00\u9053\u9898\u7684\u6ee1\u5206\u503c\uff08\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u5c11\u4e8e 2 \u4e14\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u6b63\u786e\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7\u9009\u9879\u4e2a\u6570\u7684\u6b63\u6574\u6570\uff09\u3001\u6240\u6709\u6b63\u786e\u9009\u9879\u3002\u6ce8\u610f\u6bcf\u9898\u7684\u9009\u9879\u4ece\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd a \u5f00\u59cb\u987a\u6b21\u6392\u5217\u3002\u5404\u9879\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\uff0c\u5176\u6bcf\u9898\u7b54\u6848\u683c\u5f0f\u4e3a (\u9009\u4e2d\u7684\u9009\u9879\u4e2a\u6570 \u9009\u98791 \u2026\u2026) \uff0c\u6309\u9898\u76ee\u987a\u5e8f\u7ed9\u51fa\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u5373\u4e0d\u5b58\u5728\u9009\u4e2d\u7684\u9009\u9879\u6570\u8d85\u8fc7\u5b9e\u9645\u9009\u9879\u6570\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\u3002\u6ce8\u610f\u5224\u9898\u65f6\u53ea\u6709\u9009\u62e9\u5168\u90e8\u6b63\u786e\u624d\u80fd\u5f97\u5230\u8be5\u9898\u7684\u5206\u6570\u3002\u6700\u540e\u4e00\u884c\u8f93\u51fa\u9519\u5f97\u6700\u591a\u7684\u9898\u76ee\u7684\u9519\u8bef\u6b21\u6570\u548c\u7f16\u53f7\uff08\u9898\u76ee\u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u4ece 1 \u5f00\u59cb\u7f16\u53f7\uff09\u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6309\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6240\u6709\u9898\u76ee\u90fd\u6ca1\u6709\u4eba\u9519\uff0c\u5219\u5728\u6700\u540e\u4e00\u884c\u8f93\u51fa Too simple \u3002 \u8f93\u5165\u6837\u4f8b 3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) \u8f93\u51fa\u6837\u4f8b 3 6 5 2 2 3 4","title":"Statement"},{"location":"PAT-Basic-Level/1058-%E9%80%89%E6%8B%A9%E9%A2%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 struct pp { int score , choice , truth , wrong = 0 ; map < char , int > code ; } q [ MAXN ]; int main () { int n , m , i , j , k ; cin >> n >> m ; char c ; string s ; for ( i = 0 ; i < m ; i ++ ) { scanf ( \"%d%d%d\" , & q [ i ]. score , & q [ i ]. choice , & q [ i ]. truth ); for ( j = 0 ; j < q [ i ]. truth ; j ++ ) { scanf ( \" %c\" , & c ); q [ i ]. code [ c ] = 1 ; } } int flag , num , total , max = -1 ; for ( i = 0 ; i < n ; i ++ ) { total = 0 ; for ( j = 0 ; j < m ; j ++ ) { flag = 1 ; scanf ( \" %c\" , & c ); cin >> num ; if ( num != q [ j ]. truth ) flag = 0 , q [ j ]. wrong ++ ; for ( k = 0 ; k < num ; k ++ ) { scanf ( \" %c\" , & c ); if ( ! q [ j ]. code [ c ] && flag ) { q [ j ]. wrong ++ ; flag = 0 ; } } scanf ( \"%c\" , & c ); if ( flag ) total += q [ j ]. score ; if ( q [ j ]. wrong > max && q [ j ]. wrong ) max = q [ j ]. wrong ; } cout << total << endl ; } if ( max != -1 ) { cout << max ; for ( i = 0 ; i < m ; i ++ ) { if ( q [ i ]. wrong == max ) printf ( \" %d\" , i + 1 ); } } else cout << \"Too simple\" ; cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/","text":"1059 C\u8bed\u8a00\u7ade\u8d5b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB C \u8bed\u8a00\u7ade\u8d5b\u662f\u6d59\u6c5f\u5927\u5b66\u8ba1\u7b97\u673a\u5b66\u9662\u4e3b\u6301\u7684\u4e00\u4e2a\u6b22\u4e50\u7684\u7ade\u8d5b\u3002\u65e2\u7136\u7ade\u8d5b\u4e3b\u65e8\u662f\u4e3a\u4e86\u597d\u73a9\uff0c\u9881\u5956\u89c4\u5219\u4e5f\u5c31\u5236\u5b9a\u5f97\u5f88\u6ed1\u7a3d\uff1a 0\u3001\u51a0\u519b\u5c06\u8d62\u5f97\u4e00\u4efd\u201c\u795e\u79d8\u5927\u5956\u201d\uff08\u6bd4\u5982\u5f88\u5de8\u5927\u7684\u4e00\u672c\u5b66\u751f\u7814\u7a76\u8bba\u6587\u96c6\u2026\u2026\uff09\u3002 1\u3001\u6392\u540d\u4e3a\u7d20\u6570\u7684\u5b66\u751f\u5c06\u8d62\u5f97\u6700\u597d\u7684\u5956\u54c1 \u2014\u2014 \u5c0f\u9ec4\u4eba\u73a9\u5076\uff01 2\u3001\u5176\u4ed6\u4eba\u5c06\u5f97\u5230\u5de7\u514b\u529b\u3002 \u7ed9\u5b9a\u6bd4\u8d5b\u7684\u6700\u7ec8\u6392\u540d\u4ee5\u53ca\u4e00\u7cfb\u5217\u53c2\u8d5b\u8005\u7684 ID\uff0c\u4f60\u8981\u7ed9\u51fa\u8fd9\u4e9b\u53c2\u8d5b\u8005\u5e94\u8be5\u83b7\u5f97\u7684\u5956\u54c1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u53c2\u8d5b\u8005\u4eba\u6570\u3002\u968f\u540e N N \u884c\u7ed9\u51fa\u6700\u7ec8\u6392\u540d\uff0c\u6bcf\u884c\u6309\u6392\u540d\u987a\u5e8f\u7ed9\u51fa\u4e00\u4f4d\u53c2\u8d5b\u8005\u7684 ID\uff084 \u4f4d\u6570\u5b57\u7ec4\u6210\uff09\u3002\u63a5\u4e0b\u6765\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \u4ee5\u53ca K K \u4e2a\u9700\u8981\u67e5\u8be2\u7684 ID\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u8981\u67e5\u8be2\u7684 ID\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa ID: \u5956\u54c1 \uff0c\u5176\u4e2d\u5956\u54c1\u6216\u8005\u662f Mystery Award \uff08\u795e\u79d8\u5927\u5956\uff09\u3001\u6216\u8005\u662f Minion \uff08\u5c0f\u9ec4\u4eba\uff09\u3001\u6216\u8005\u662f Chocolate \uff08\u5de7\u514b\u529b\uff09\u3002\u5982\u679c\u6240\u67e5 ID \u6839\u672c\u4e0d\u5728\u6392\u540d\u91cc\uff0c\u6253\u5370 Are you kidding? \uff08\u800d\u6211\u5462\uff1f\uff09\u3002\u5982\u679c\u8be5 ID \u5df2\u7ecf\u67e5\u8fc7\u4e86\uff08\u5373\u5956\u54c1\u5df2\u7ecf\u9886\u8fc7\u4e86\uff09\uff0c\u6253\u5370 ID: Checked \uff08\u4e0d\u80fd\u591a\u5403\u591a\u5360\uff09\u3002 \u8f93\u5165\u6837\u4f8b 6 1111 6666 8888 1234 5555 0001 6 8888 0001 1111 2222 8888 2222 \u8f93\u51fa\u6837\u4f8b 8888: Minion 0001: Chocolate 1111: Mystery Award 2222: Are you kidding? 8888: Checked 2222: Are you kidding? Solution C++ #include <bits/stdc++.h> using namespace std ; int isPrime ( int x ) { int flag ; int n ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 ) flag = 1 ; else if ( x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { for ( n = 3 ; n <= ( x - 1 ); n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { map < string , string > q ; string s ; int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> s ; if ( i ) { if ( isPrime ( i + 1 )) q [ s ] = \"Minion\" ; else q [ s ] = \"Chocolate\" ; } else q [ s ] = \"Mystery Award\" ; } int t ; cin >> t ; while ( t -- ) { cin >> s ; cout << s << \": \" ; if ( q [ s ] == \"\" ) cout << \"Are you kidding? \\n \" ; else { cout << q [ s ] << endl ; q [ s ] = \"Checked\" ; } } }","title":"1059-C\u8bed\u8a00\u7ade\u8d5b"},{"location":"PAT-Basic-Level/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/#1059-c\u8bed\u8a00\u7ade\u8d5b","text":"","title":"1059 C\u8bed\u8a00\u7ade\u8d5b"},{"location":"PAT-Basic-Level/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB C \u8bed\u8a00\u7ade\u8d5b\u662f\u6d59\u6c5f\u5927\u5b66\u8ba1\u7b97\u673a\u5b66\u9662\u4e3b\u6301\u7684\u4e00\u4e2a\u6b22\u4e50\u7684\u7ade\u8d5b\u3002\u65e2\u7136\u7ade\u8d5b\u4e3b\u65e8\u662f\u4e3a\u4e86\u597d\u73a9\uff0c\u9881\u5956\u89c4\u5219\u4e5f\u5c31\u5236\u5b9a\u5f97\u5f88\u6ed1\u7a3d\uff1a 0\u3001\u51a0\u519b\u5c06\u8d62\u5f97\u4e00\u4efd\u201c\u795e\u79d8\u5927\u5956\u201d\uff08\u6bd4\u5982\u5f88\u5de8\u5927\u7684\u4e00\u672c\u5b66\u751f\u7814\u7a76\u8bba\u6587\u96c6\u2026\u2026\uff09\u3002 1\u3001\u6392\u540d\u4e3a\u7d20\u6570\u7684\u5b66\u751f\u5c06\u8d62\u5f97\u6700\u597d\u7684\u5956\u54c1 \u2014\u2014 \u5c0f\u9ec4\u4eba\u73a9\u5076\uff01 2\u3001\u5176\u4ed6\u4eba\u5c06\u5f97\u5230\u5de7\u514b\u529b\u3002 \u7ed9\u5b9a\u6bd4\u8d5b\u7684\u6700\u7ec8\u6392\u540d\u4ee5\u53ca\u4e00\u7cfb\u5217\u53c2\u8d5b\u8005\u7684 ID\uff0c\u4f60\u8981\u7ed9\u51fa\u8fd9\u4e9b\u53c2\u8d5b\u8005\u5e94\u8be5\u83b7\u5f97\u7684\u5956\u54c1\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u662f\u53c2\u8d5b\u8005\u4eba\u6570\u3002\u968f\u540e N N \u884c\u7ed9\u51fa\u6700\u7ec8\u6392\u540d\uff0c\u6bcf\u884c\u6309\u6392\u540d\u987a\u5e8f\u7ed9\u51fa\u4e00\u4f4d\u53c2\u8d5b\u8005\u7684 ID\uff084 \u4f4d\u6570\u5b57\u7ec4\u6210\uff09\u3002\u63a5\u4e0b\u6765\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 K K \u4ee5\u53ca K K \u4e2a\u9700\u8981\u67e5\u8be2\u7684 ID\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u8981\u67e5\u8be2\u7684 ID\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa ID: \u5956\u54c1 \uff0c\u5176\u4e2d\u5956\u54c1\u6216\u8005\u662f Mystery Award \uff08\u795e\u79d8\u5927\u5956\uff09\u3001\u6216\u8005\u662f Minion \uff08\u5c0f\u9ec4\u4eba\uff09\u3001\u6216\u8005\u662f Chocolate \uff08\u5de7\u514b\u529b\uff09\u3002\u5982\u679c\u6240\u67e5 ID \u6839\u672c\u4e0d\u5728\u6392\u540d\u91cc\uff0c\u6253\u5370 Are you kidding? \uff08\u800d\u6211\u5462\uff1f\uff09\u3002\u5982\u679c\u8be5 ID \u5df2\u7ecf\u67e5\u8fc7\u4e86\uff08\u5373\u5956\u54c1\u5df2\u7ecf\u9886\u8fc7\u4e86\uff09\uff0c\u6253\u5370 ID: Checked \uff08\u4e0d\u80fd\u591a\u5403\u591a\u5360\uff09\u3002 \u8f93\u5165\u6837\u4f8b 6 1111 6666 8888 1234 5555 0001 6 8888 0001 1111 2222 8888 2222 \u8f93\u51fa\u6837\u4f8b 8888: Minion 0001: Chocolate 1111: Mystery Award 2222: Are you kidding? 8888: Checked 2222: Are you kidding?","title":"Statement"},{"location":"PAT-Basic-Level/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int isPrime ( int x ) { int flag ; int n ; if ( x <= 1 ) flag = 0 ; else if ( x == 2 ) flag = 1 ; else if ( x == 3 ) flag = 1 ; else if ( x % 2 == 0 ) flag = 0 ; else { for ( n = 3 ; n <= ( x - 1 ); n += 2 ) { if ( x % n == 0 ) { flag = 0 ; break ; } else { flag = 1 ; } } } return flag ; } int main () { map < string , string > q ; string s ; int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) { cin >> s ; if ( i ) { if ( isPrime ( i + 1 )) q [ s ] = \"Minion\" ; else q [ s ] = \"Chocolate\" ; } else q [ s ] = \"Mystery Award\" ; } int t ; cin >> t ; while ( t -- ) { cin >> s ; cout << s << \": \" ; if ( q [ s ] == \"\" ) cout << \"Are you kidding? \\n \" ; else { cout << q [ s ] << endl ; q [ s ] = \"Checked\" ; } } }","title":"Solution"},{"location":"PAT-Basic-Level/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/","text":"1060 \u7231\u4e01\u987f\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB \u82f1\u56fd\u5929\u6587\u5b66\u5bb6\u7231\u4e01\u987f\u5f88\u559c\u6b22\u9a91\u8f66\u3002\u636e\u8bf4\u4ed6\u4e3a\u4e86\u70ab\u8000\u81ea\u5df1\u7684\u9a91\u8f66\u529f\u529b\uff0c\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u201c\u7231\u4e01\u987f\u6570\u201d E E \uff0c\u5373\u6ee1\u8db3\u6709 E E \u5929\u9a91\u8f66\u8d85\u8fc7 E E \u82f1\u91cc\u7684\u6700\u5927\u6574\u6570 E E \u3002\u636e\u8bf4\u7231\u4e01\u987f\u81ea\u5df1\u7684 E E \u7b49\u4e8e87\u3002 \u73b0\u7ed9\u5b9a\u67d0\u4eba N N \u5929\u7684\u9a91\u8f66\u8ddd\u79bb\uff0c\u8bf7\u4f60\u7b97\u51fa\u5bf9\u5e94\u7684\u7231\u4e01\u987f\u6570 E E \uff08 \\le N \\le N \uff09\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\uff0c\u5373\u8fde\u7eed\u9a91\u8f66\u7684\u5929\u6570\uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u6bcf\u5929\u7684\u9a91\u8f66\u8ddd\u79bb\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa N N \u5929\u7684\u7231\u4e01\u987f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 10 6 7 6 9 3 10 8 2 7 8 \u8f93\u51fa\u6837\u4f8b 6 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int a [ MAXN ]; int comp ( int x , int y ) { return x > y ; } int main () { int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a , a + i , comp ); int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > i + 1 ) flag = i + 1 ; } cout << flag << endl ; }","title":"1060-\u7231\u4e01\u987f\u6570"},{"location":"PAT-Basic-Level/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/#1060-\u7231\u4e01\u987f\u6570","text":"","title":"1060 \u7231\u4e01\u987f\u6570"},{"location":"PAT-Basic-Level/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB \u82f1\u56fd\u5929\u6587\u5b66\u5bb6\u7231\u4e01\u987f\u5f88\u559c\u6b22\u9a91\u8f66\u3002\u636e\u8bf4\u4ed6\u4e3a\u4e86\u70ab\u8000\u81ea\u5df1\u7684\u9a91\u8f66\u529f\u529b\uff0c\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u201c\u7231\u4e01\u987f\u6570\u201d E E \uff0c\u5373\u6ee1\u8db3\u6709 E E \u5929\u9a91\u8f66\u8d85\u8fc7 E E \u82f1\u91cc\u7684\u6700\u5927\u6574\u6570 E E \u3002\u636e\u8bf4\u7231\u4e01\u987f\u81ea\u5df1\u7684 E E \u7b49\u4e8e87\u3002 \u73b0\u7ed9\u5b9a\u67d0\u4eba N N \u5929\u7684\u9a91\u8f66\u8ddd\u79bb\uff0c\u8bf7\u4f60\u7b97\u51fa\u5bf9\u5e94\u7684\u7231\u4e01\u987f\u6570 E E \uff08 \\le N \\le N \uff09\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\uff0c\u5373\u8fde\u7eed\u9a91\u8f66\u7684\u5929\u6570\uff1b\u7b2c\u4e8c\u884c\u7ed9\u51fa N N \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u4ee3\u8868\u6bcf\u5929\u7684\u9a91\u8f66\u8ddd\u79bb\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa N N \u5929\u7684\u7231\u4e01\u987f\u6570\u3002 \u8f93\u5165\u6837\u4f8b 10 6 7 6 9 3 10 8 2 7 8 \u8f93\u51fa\u6837\u4f8b 6","title":"Statement"},{"location":"PAT-Basic-Level/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100000 int a [ MAXN ]; int comp ( int x , int y ) { return x > y ; } int main () { int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%d\" , & a [ i ]); sort ( a , a + i , comp ); int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > i + 1 ) flag = i + 1 ; } cout << flag << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1061-%E5%88%A4%E6%96%AD%E9%A2%98/","text":"1061 \u5224\u65ad\u9898 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5224\u65ad\u9898\u7684\u8bc4\u5224\u5f88\u7b80\u5355\uff0c\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u5224\u9898\u5e76\u7edf\u8ba1\u5b66\u751f\u4eec\u5224\u65ad\u9898\u7684\u5f97\u5206\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 N \u548c M\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u5224\u65ad\u9898\u6570\u91cf\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa M \u4e2a\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff0c\u662f\u6bcf\u9053\u9898\u7684\u6ee1\u5206\u503c\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u6bcf\u9053\u9898\u5bf9\u5e94\u7684\u6b63\u786e\u7b54\u6848\uff0c0 \u4ee3\u8868\u201c\u975e\u201d\uff0c1 \u4ee3\u8868\u201c\u662f\u201d\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u89e3\u7b54\u3002\u6570\u5b57\u95f4\u5747\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 3 6 2 1 3 3 4 5 0 0 1 0 1 1 0 1 1 0 0 1 1 0 1 0 1 0 1 1 0 0 1 1 \u8f93\u51fa\u6837\u4f8b 13 11 12 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int ans [ MAXN ], soc [ MAXN ], a [ MAXN ][ MAXN ]; int main () { int n , m ; cin >> n >> m ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { cin >> soc [ i ]; } for ( i = 0 ; i < m ; i ++ ) { cin >> ans [ i ]; } for ( i = 0 ; i < n ; i ++ ) { int total = 0 ; for ( j = 0 ; j < m ; j ++ ) { cin >> a [ i ][ j ]; if ( a [ i ][ j ] == ans [ j ]) total += soc [ j ]; } cout << total << endl ; } }","title":"1061-\u5224\u65ad\u9898"},{"location":"PAT-Basic-Level/1061-%E5%88%A4%E6%96%AD%E9%A2%98/#1061-\u5224\u65ad\u9898","text":"","title":"1061 \u5224\u65ad\u9898"},{"location":"PAT-Basic-Level/1061-%E5%88%A4%E6%96%AD%E9%A2%98/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5224\u65ad\u9898\u7684\u8bc4\u5224\u5f88\u7b80\u5355\uff0c\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u5224\u9898\u5e76\u7edf\u8ba1\u5b66\u751f\u4eec\u5224\u65ad\u9898\u7684\u5f97\u5206\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 N \u548c M\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u5224\u65ad\u9898\u6570\u91cf\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa M \u4e2a\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff0c\u662f\u6bcf\u9053\u9898\u7684\u6ee1\u5206\u503c\u3002\u7b2c\u4e09\u884c\u7ed9\u51fa\u6bcf\u9053\u9898\u5bf9\u5e94\u7684\u6b63\u786e\u7b54\u6848\uff0c0 \u4ee3\u8868\u201c\u975e\u201d\uff0c1 \u4ee3\u8868\u201c\u662f\u201d\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u89e3\u7b54\u3002\u6570\u5b57\u95f4\u5747\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 3 6 2 1 3 3 4 5 0 0 1 0 1 1 0 1 1 0 0 1 1 0 1 0 1 0 1 1 0 0 1 1 \u8f93\u51fa\u6837\u4f8b 13 11 12","title":"Statement"},{"location":"PAT-Basic-Level/1061-%E5%88%A4%E6%96%AD%E9%A2%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int ans [ MAXN ], soc [ MAXN ], a [ MAXN ][ MAXN ]; int main () { int n , m ; cin >> n >> m ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { cin >> soc [ i ]; } for ( i = 0 ; i < m ; i ++ ) { cin >> ans [ i ]; } for ( i = 0 ; i < n ; i ++ ) { int total = 0 ; for ( j = 0 ; j < m ; j ++ ) { cin >> a [ i ][ j ]; if ( a [ i ][ j ] == ans [ j ]) total += soc [ j ]; } cout << total << endl ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/","text":"1062 \u6700\u7b80\u5206\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5206\u6570\u4e00\u822c\u5199\u6210\u4e24\u4e2a\u6574\u6570\u76f8\u9664\u7684\u5f62\u5f0f\uff1a N/M N/M \uff0c\u5176\u4e2d M M \u4e0d\u4e3a0\u3002\u6700\u7b80\u5206\u6570\u662f\u6307\u5206\u5b50\u548c\u5206\u6bcd\u6ca1\u6709\u516c\u7ea6\u6570\u7684\u5206\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u73b0\u7ed9\u5b9a\u4e24\u4e2a\u4e0d\u76f8\u7b49\u7684\u6b63\u5206\u6570 N_1/M_1 N_1/M_1 \u548c N_2/M_2 N_2/M_2 \uff0c\u8981\u6c42\u4f60\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u5217\u51fa\u5b83\u4eec\u4e4b\u95f4\u5206\u6bcd\u4e3a K K \u7684\u6700\u7b80\u5206\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309 N/M N/M \u7684\u683c\u5f0f\u7ed9\u51fa\u4e24\u4e2a\u6b63\u5206\u6570\uff0c\u968f\u540e\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u5206\u6bcd K K \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u6240\u6709\u6574\u6570\u90fd\u4e0d\u8d85\u8fc7 1000\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309 N/M N/M \u7684\u683c\u5f0f\u5217\u51fa\u4e24\u4e2a\u7ed9\u5b9a\u5206\u6570\u4e4b\u95f4\u5206\u6bcd\u4e3a K K \u7684\u6240\u6709\u6700\u7b80\u5206\u6570\uff0c\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u4e2a\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 7/18 13/20 12 \u8f93\u51fa\u6837\u4f8b 5/12 7/12 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int gcd ( int x , int y ) { int r ; while ( 1 ) { r = x % y ; if ( ! r ) break ; x = y ; y = r ; } return y ; } int main () { int a , b , c , d , k ; scanf ( \"%d/%d %d/%d %d\" , & a , & b , & c , & d , & k ); double n , m , p ; n = ( double ) a / b , m = ( double ) c / d ; if ( n > m ) swap ( n , m ); int i , flag = 0 ; for ( i = 1 ; i <= k ; i ++ ) { p = ( double ) i / k ; if ( p > n && p < m && gcd ( i , k ) == 1 ) { if ( flag ) printf ( \" %d/%d\" , i , k ); else { flag = 1 ; printf ( \"%d/%d\" , i , k ); } } } cout << endl ; }","title":"1062-\u6700\u7b80\u5206\u6570"},{"location":"PAT-Basic-Level/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/#1062-\u6700\u7b80\u5206\u6570","text":"","title":"1062 \u6700\u7b80\u5206\u6570"},{"location":"PAT-Basic-Level/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e00\u4e2a\u5206\u6570\u4e00\u822c\u5199\u6210\u4e24\u4e2a\u6574\u6570\u76f8\u9664\u7684\u5f62\u5f0f\uff1a N/M N/M \uff0c\u5176\u4e2d M M \u4e0d\u4e3a0\u3002\u6700\u7b80\u5206\u6570\u662f\u6307\u5206\u5b50\u548c\u5206\u6bcd\u6ca1\u6709\u516c\u7ea6\u6570\u7684\u5206\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u73b0\u7ed9\u5b9a\u4e24\u4e2a\u4e0d\u76f8\u7b49\u7684\u6b63\u5206\u6570 N_1/M_1 N_1/M_1 \u548c N_2/M_2 N_2/M_2 \uff0c\u8981\u6c42\u4f60\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u5217\u51fa\u5b83\u4eec\u4e4b\u95f4\u5206\u6bcd\u4e3a K K \u7684\u6700\u7b80\u5206\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u6309 N/M N/M \u7684\u683c\u5f0f\u7ed9\u51fa\u4e24\u4e2a\u6b63\u5206\u6570\uff0c\u968f\u540e\u662f\u4e00\u4e2a\u6b63\u6574\u6570\u5206\u6bcd K K \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u6240\u6709\u6574\u6570\u90fd\u4e0d\u8d85\u8fc7 1000\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309 N/M N/M \u7684\u683c\u5f0f\u5217\u51fa\u4e24\u4e2a\u7ed9\u5b9a\u5206\u6570\u4e4b\u95f4\u5206\u6bcd\u4e3a K K \u7684\u6240\u6709\u6700\u7b80\u5206\u6570\uff0c\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u6709 1 \u4e2a\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 7/18 13/20 12 \u8f93\u51fa\u6837\u4f8b 5/12 7/12","title":"Statement"},{"location":"PAT-Basic-Level/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int gcd ( int x , int y ) { int r ; while ( 1 ) { r = x % y ; if ( ! r ) break ; x = y ; y = r ; } return y ; } int main () { int a , b , c , d , k ; scanf ( \"%d/%d %d/%d %d\" , & a , & b , & c , & d , & k ); double n , m , p ; n = ( double ) a / b , m = ( double ) c / d ; if ( n > m ) swap ( n , m ); int i , flag = 0 ; for ( i = 1 ; i <= k ; i ++ ) { p = ( double ) i / k ; if ( p > n && p < m && gcd ( i , k ) == 1 ) { if ( flag ) printf ( \" %d/%d\" , i , k ); else { flag = 1 ; printf ( \"%d/%d\" , i , k ); } } } cout << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/","text":"1063 \u8ba1\u7b97\u8c31\u534a\u5f84 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u6570\u5b66\u4e2d\uff0c\u77e9\u9635\u7684\u201c\u8c31\u534a\u5f84\u201d\u662f\u6307\u5176\u7279\u5f81\u503c\u7684\u6a21\u96c6\u5408\u7684\u4e0a\u786e\u754c\u3002\u6362\u8a00\u4e4b\uff0c\u5bf9\u4e8e\u7ed9\u5b9a\u7684 n n \u4e2a\u590d\u6570\u7a7a\u95f4\u7684\u7279\u5f81\u503c { a_1+b_1i, \\cdots , a_n+b_ni a_1+b_1i, \\cdots , a_n+b_ni }\uff0c\u5b83\u4eec\u7684\u6a21\u4e3a\u5b9e\u90e8\u4e0e\u865a\u90e8\u7684\u5e73\u65b9\u548c\u7684\u5f00\u65b9\uff0c\u800c\u201c\u8c31\u534a\u5f84\u201d\u5c31\u662f\u6700\u5927\u6a21\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u590d\u6570\u7a7a\u95f4\u7684\u7279\u5f81\u503c\uff0c\u8bf7\u4f60\u8ba1\u7b97\u5e76\u8f93\u51fa\u8fd9\u4e9b\u7279\u5f81\u503c\u7684\u8c31\u534a\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N\uff08 \\le \\le 10 000\uff09\u662f\u8f93\u5165\u7684\u7279\u5f81\u503c\u7684\u4e2a\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa 1 \u4e2a\u7279\u5f81\u503c\u7684\u5b9e\u90e8\u548c\u865a\u90e8\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b9e\u90e8\u548c\u865a\u90e8\u5747\u4e3a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 1000 \u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8c31\u534a\u5f84\uff0c\u56db\u820d\u4e94\u5165\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 5 0 1 2 0 -1 0 3 3 0 -3 \u8f93\u51fa\u6837\u4f8b 4.24 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , i ; cin >> t ; double a , b , total , max = 0 ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%lf%lf\" , & a , & b ); total = a * a + b * b ; total = sqrt ( total ); if ( total > max ) max = total ; } printf ( \"%.2lf \\n \" , max ); }","title":"1063-\u8ba1\u7b97\u8c31\u534a\u5f84"},{"location":"PAT-Basic-Level/1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/#1063-\u8ba1\u7b97\u8c31\u534a\u5f84","text":"","title":"1063 \u8ba1\u7b97\u8c31\u534a\u5f84"},{"location":"PAT-Basic-Level/1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u6570\u5b66\u4e2d\uff0c\u77e9\u9635\u7684\u201c\u8c31\u534a\u5f84\u201d\u662f\u6307\u5176\u7279\u5f81\u503c\u7684\u6a21\u96c6\u5408\u7684\u4e0a\u786e\u754c\u3002\u6362\u8a00\u4e4b\uff0c\u5bf9\u4e8e\u7ed9\u5b9a\u7684 n n \u4e2a\u590d\u6570\u7a7a\u95f4\u7684\u7279\u5f81\u503c { a_1+b_1i, \\cdots , a_n+b_ni a_1+b_1i, \\cdots , a_n+b_ni }\uff0c\u5b83\u4eec\u7684\u6a21\u4e3a\u5b9e\u90e8\u4e0e\u865a\u90e8\u7684\u5e73\u65b9\u548c\u7684\u5f00\u65b9\uff0c\u800c\u201c\u8c31\u534a\u5f84\u201d\u5c31\u662f\u6700\u5927\u6a21\u3002 \u73b0\u5728\u7ed9\u5b9a\u4e00\u4e9b\u590d\u6570\u7a7a\u95f4\u7684\u7279\u5f81\u503c\uff0c\u8bf7\u4f60\u8ba1\u7b97\u5e76\u8f93\u51fa\u8fd9\u4e9b\u7279\u5f81\u503c\u7684\u8c31\u534a\u5f84\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N\uff08 \\le \\le 10 000\uff09\u662f\u8f93\u5165\u7684\u7279\u5f81\u503c\u7684\u4e2a\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa 1 \u4e2a\u7279\u5f81\u503c\u7684\u5b9e\u90e8\u548c\u865a\u90e8\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b9e\u90e8\u548c\u865a\u90e8\u5747\u4e3a\u7edd\u5bf9\u503c\u4e0d\u8d85\u8fc7 1000 \u7684\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u8c31\u534a\u5f84\uff0c\u56db\u820d\u4e94\u5165\u4fdd\u7559\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 5 0 1 2 0 -1 0 3 3 0 -3 \u8f93\u51fa\u6837\u4f8b 4.24","title":"Statement"},{"location":"PAT-Basic-Level/1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , i ; cin >> t ; double a , b , total , max = 0 ; for ( i = 0 ; i < t ; i ++ ) { scanf ( \"%lf%lf\" , & a , & b ); total = a * a + b * b ; total = sqrt ( total ); if ( total > max ) max = total ; } printf ( \"%.2lf \\n \" , max ); }","title":"Solution"},{"location":"PAT-Basic-Level/1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/","text":"1064 \u670b\u53cb\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4e24\u4e2a\u6574\u6570\u5404\u4f4d\u6570\u5b57\u7684\u548c\u662f\u4e00\u6837\u7684\uff0c\u5219\u88ab\u79f0\u4e3a\u662f\u201c\u670b\u53cb\u6570\u201d\uff0c\u800c\u90a3\u4e2a\u516c\u5171\u7684\u548c\u5c31\u662f\u5b83\u4eec\u7684\u201c\u670b\u53cb\u8bc1\u53f7\u201d\u3002\u4f8b\u5982 123 \u548c 51 \u5c31\u662f\u670b\u53cb\u6570\uff0c\u56e0\u4e3a 1+2+3 = 5+1 = 6\uff0c\u800c 6 \u5c31\u662f\u5b83\u4eec\u7684\u670b\u53cb\u8bc1\u53f7\u3002\u7ed9\u5b9a\u4e00\u4e9b\u6574\u6570\uff0c\u8981\u6c42\u4f60\u7edf\u8ba1\u4e00\u4e0b\u5b83\u4eec\u4e2d\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u670b\u53cb\u8bc1\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N \u4e2a\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u6570\u5b57\u5c0f\u4e8e 10^4 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u8f93\u51fa\u7ed9\u5b9a\u6570\u5b57\u4e2d\u4e0d\u540c\u7684\u670b\u53cb\u8bc1\u53f7\u7684\u4e2a\u6570\uff1b\u968f\u540e\u4e00\u884c\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8fd9\u4e9b\u670b\u53cb\u8bc1\u53f7\uff0c\u6570\u5b57\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\uff0c\u4e14\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 123 899 51 998 27 33 36 12 \u8f93\u51fa\u6837\u4f8b 4 3 6 9 26 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 map < int , int > a ; int main () { int n1 ; cin >> n1 ; int i , j ; string s ; int count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) { cin >> s ; int len = s . size (), total = 0 ; for ( j = 0 ; j < len ; j ++ ) { total += ( s [ j ] - 48 ); } if ( a [ total ] == 1 ) continue ; else { a [ total ] = 1 ; count ++ ; } } cout << count << endl ; map < int , int >:: iterator it ; it = a . begin (); cout << it -> first ; for ( it ++ ; it != a . end (); it ++ ) cout << \" \" << it -> first ; cout << endl ; }","title":"1064-\u670b\u53cb\u6570"},{"location":"PAT-Basic-Level/1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/#1064-\u670b\u53cb\u6570","text":"","title":"1064 \u670b\u53cb\u6570"},{"location":"PAT-Basic-Level/1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u4e24\u4e2a\u6574\u6570\u5404\u4f4d\u6570\u5b57\u7684\u548c\u662f\u4e00\u6837\u7684\uff0c\u5219\u88ab\u79f0\u4e3a\u662f\u201c\u670b\u53cb\u6570\u201d\uff0c\u800c\u90a3\u4e2a\u516c\u5171\u7684\u548c\u5c31\u662f\u5b83\u4eec\u7684\u201c\u670b\u53cb\u8bc1\u53f7\u201d\u3002\u4f8b\u5982 123 \u548c 51 \u5c31\u662f\u670b\u53cb\u6570\uff0c\u56e0\u4e3a 1+2+3 = 5+1 = 6\uff0c\u800c 6 \u5c31\u662f\u5b83\u4eec\u7684\u670b\u53cb\u8bc1\u53f7\u3002\u7ed9\u5b9a\u4e00\u4e9b\u6574\u6570\uff0c\u8981\u6c42\u4f60\u7edf\u8ba1\u4e00\u4e0b\u5b83\u4eec\u4e2d\u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u670b\u53cb\u8bc1\u53f7\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N\u3002\u968f\u540e\u4e00\u884c\u7ed9\u51fa N \u4e2a\u6b63\u6574\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u6240\u6709\u6570\u5b57\u5c0f\u4e8e 10^4 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u8f93\u51fa\u7ed9\u5b9a\u6570\u5b57\u4e2d\u4e0d\u540c\u7684\u670b\u53cb\u8bc1\u53f7\u7684\u4e2a\u6570\uff1b\u968f\u540e\u4e00\u884c\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u8fd9\u4e9b\u670b\u53cb\u8bc1\u53f7\uff0c\u6570\u5b57\u95f4\u9694\u4e00\u4e2a\u7a7a\u683c\uff0c\u4e14\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 8 123 899 51 998 27 33 36 12 \u8f93\u51fa\u6837\u4f8b 4 3 6 9 26","title":"Statement"},{"location":"PAT-Basic-Level/1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 map < int , int > a ; int main () { int n1 ; cin >> n1 ; int i , j ; string s ; int count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) { cin >> s ; int len = s . size (), total = 0 ; for ( j = 0 ; j < len ; j ++ ) { total += ( s [ j ] - 48 ); } if ( a [ total ] == 1 ) continue ; else { a [ total ] = 1 ; count ++ ; } } cout << count << endl ; map < int , int >:: iterator it ; it = a . begin (); cout << it -> first ; for ( it ++ ; it != a . end (); it ++ ) cout << \" \" << it -> first ; cout << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1065-%E5%8D%95%E8%BA%AB%E7%8B%97/","text":"1065 \u5355\u8eab\u72d7 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u5355\u8eab\u72d7\u201d\u662f\u4e2d\u6587\u5bf9\u4e8e\u5355\u8eab\u4eba\u58eb\u7684\u4e00\u79cd\u7231\u79f0\u3002\u672c\u9898\u8bf7\u4f60\u4ece\u4e0a\u4e07\u4eba\u7684\u5927\u578b\u6d3e\u5bf9\u4e2d\u627e\u51fa\u843d\u5355\u7684\u5ba2\u4eba\uff0c\u4ee5\u4fbf\u7ed9\u4e88\u7279\u6b8a\u5173\u7231\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 50 000\uff09\uff0c\u662f\u5df2\u77e5\u592b\u59bb/\u4f34\u4fa3\u7684\u5bf9\u6570\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u592b\u59bb/\u4f34\u4fa3\u2014\u2014\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6bcf\u4eba\u5bf9\u5e94\u4e00\u4e2a ID \u53f7\uff0c\u4e3a 5 \u4f4d\u6570\u5b57\uff08\u4ece 00000 \u5230 99999\uff09\uff0cID \u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff1b\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M\uff08 \\le \\le 10 000\uff09\uff0c\u4e3a\u53c2\u52a0\u6d3e\u5bf9\u7684\u603b\u4eba\u6570\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u8fd9 M \u4f4d\u5ba2\u4eba\u7684 ID\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u65e0\u4eba\u91cd\u5a5a\u6216\u811a\u8e29\u4e24\u6761\u8239\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u8f93\u51fa\u843d\u5355\u5ba2\u4eba\u7684\u603b\u4eba\u6570\uff1b\u968f\u540e\u7b2c\u4e8c\u884c\u6309 ID \u9012\u589e\u987a\u5e8f\u5217\u51fa\u843d\u5355\u7684\u5ba2\u4eba\u3002ID \u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 11111 22222 33333 44444 55555 66666 7 55555 44444 10000 88888 22222 11111 23333 \u8f93\u51fa\u6837\u4f8b 5 10000 23333 44444 55555 88888 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 50000 string a [ MAXN ], b [ MAXN ]; int comp ( string x , string y ) { return x < y ; } int main () { map < string , string > p ; map < string , int > q ; int N , i , j , k , t ; cin >> N ; string s1 , s2 ; for ( i = 0 ; i < N ; i ++ ) { cin >> s1 >> s2 ; p [ s1 ] = s2 ; p [ s2 ] = s1 ; q [ s1 ] = 1 ; q [ s2 ] = 1 ; } cin >> t ; for ( i = 0 , j = 0 , k = 0 ; i < t ; i ++ ) { cin >> s1 ; if ( q [ s1 ]) { q [ s1 ] = 2 ; b [ k ++ ] = s1 ; } else a [ j ++ ] = s1 ; } for ( i = 0 ; i < k ; i ++ ) { if ( q [ p [ b [ i ]]] != 2 ) a [ j ++ ] = b [ i ]; } sort ( a , a + j , comp ); cout << j << endl ; if ( j ) { cout << a [ 0 ]; for ( i = 1 ; i < j ; i ++ ) cout << \" \" << a [ i ]; cout << endl ; } }","title":"1065-\u5355\u8eab\u72d7"},{"location":"PAT-Basic-Level/1065-%E5%8D%95%E8%BA%AB%E7%8B%97/#1065-\u5355\u8eab\u72d7","text":"","title":"1065 \u5355\u8eab\u72d7"},{"location":"PAT-Basic-Level/1065-%E5%8D%95%E8%BA%AB%E7%8B%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u5355\u8eab\u72d7\u201d\u662f\u4e2d\u6587\u5bf9\u4e8e\u5355\u8eab\u4eba\u58eb\u7684\u4e00\u79cd\u7231\u79f0\u3002\u672c\u9898\u8bf7\u4f60\u4ece\u4e0a\u4e07\u4eba\u7684\u5927\u578b\u6d3e\u5bf9\u4e2d\u627e\u51fa\u843d\u5355\u7684\u5ba2\u4eba\uff0c\u4ee5\u4fbf\u7ed9\u4e88\u7279\u6b8a\u5173\u7231\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 50 000\uff09\uff0c\u662f\u5df2\u77e5\u592b\u59bb/\u4f34\u4fa3\u7684\u5bf9\u6570\uff1b\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u592b\u59bb/\u4f34\u4fa3\u2014\u2014\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u6bcf\u4eba\u5bf9\u5e94\u4e00\u4e2a ID \u53f7\uff0c\u4e3a 5 \u4f4d\u6570\u5b57\uff08\u4ece 00000 \u5230 99999\uff09\uff0cID \u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff1b\u4e4b\u540e\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 M\uff08 \\le \\le 10 000\uff09\uff0c\u4e3a\u53c2\u52a0\u6d3e\u5bf9\u7684\u603b\u4eba\u6570\uff1b\u968f\u540e\u4e00\u884c\u7ed9\u51fa\u8fd9 M \u4f4d\u5ba2\u4eba\u7684 ID\uff0c\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u65e0\u4eba\u91cd\u5a5a\u6216\u811a\u8e29\u4e24\u6761\u8239\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u7b2c\u4e00\u884c\u8f93\u51fa\u843d\u5355\u5ba2\u4eba\u7684\u603b\u4eba\u6570\uff1b\u968f\u540e\u7b2c\u4e8c\u884c\u6309 ID \u9012\u589e\u987a\u5e8f\u5217\u51fa\u843d\u5355\u7684\u5ba2\u4eba\u3002ID \u95f4\u7528 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 11111 22222 33333 44444 55555 66666 7 55555 44444 10000 88888 22222 11111 23333 \u8f93\u51fa\u6837\u4f8b 5 10000 23333 44444 55555 88888","title":"Statement"},{"location":"PAT-Basic-Level/1065-%E5%8D%95%E8%BA%AB%E7%8B%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 50000 string a [ MAXN ], b [ MAXN ]; int comp ( string x , string y ) { return x < y ; } int main () { map < string , string > p ; map < string , int > q ; int N , i , j , k , t ; cin >> N ; string s1 , s2 ; for ( i = 0 ; i < N ; i ++ ) { cin >> s1 >> s2 ; p [ s1 ] = s2 ; p [ s2 ] = s1 ; q [ s1 ] = 1 ; q [ s2 ] = 1 ; } cin >> t ; for ( i = 0 , j = 0 , k = 0 ; i < t ; i ++ ) { cin >> s1 ; if ( q [ s1 ]) { q [ s1 ] = 2 ; b [ k ++ ] = s1 ; } else a [ j ++ ] = s1 ; } for ( i = 0 ; i < k ; i ++ ) { if ( q [ p [ b [ i ]]] != 2 ) a [ j ++ ] = b [ i ]; } sort ( a , a + j , comp ); cout << j << endl ; if ( j ) { cout << a [ 0 ]; for ( i = 1 ; i < j ; i ++ ) cout << \" \" << a [ i ]; cout << endl ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/","text":"1066 \u56fe\u50cf\u8fc7\u6ee4 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fe\u50cf\u8fc7\u6ee4\u662f\u628a\u56fe\u50cf\u4e2d\u4e0d\u91cd\u8981\u7684\u50cf\u7d20\u90fd\u67d3\u6210\u80cc\u666f\u8272\uff0c\u4f7f\u5f97\u91cd\u8981\u90e8\u5206\u88ab\u51f8\u663e\u51fa\u6765\u3002\u73b0\u7ed9\u5b9a\u4e00\u5e45\u9ed1\u767d\u56fe\u50cf\uff0c\u8981\u6c42\u4f60\u5c06\u7070\u5ea6\u503c\u4f4d\u4e8e\u67d0\u6307\u5b9a\u533a\u95f4\u5185\u7684\u6240\u6709\u50cf\u7d20\u989c\u8272\u90fd\u7528\u4e00\u79cd\u6307\u5b9a\u7684\u989c\u8272\u66ff\u6362\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u5e45\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5373\u4e24\u4e2a\u6b63\u6574\u6570 M M \u548c N N \uff08 0 < M, N \\le 500 0 < M, N \\le 500 \uff09\uff0c\u53e6\u5916\u662f\u5f85\u8fc7\u6ee4\u7684\u7070\u5ea6\u503c\u533a\u95f4\u7aef\u70b9 A A \u548c B B \uff08 0 \\le A < B \\le 255 0 \\le A < B \\le 255 \uff09\u3001\u4ee5\u53ca\u6307\u5b9a\u7684\u66ff\u6362\u7070\u5ea6\u503c\u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u50cf\u7d20\u70b9\u7684\u7070\u5ea6\u503c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6240\u6709\u7070\u5ea6\u503c\u90fd\u5728 [0, 255] \u533a\u95f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u6309\u8981\u6c42\u8fc7\u6ee4\u540e\u7684\u56fe\u50cf\u3002\u5373\u8f93\u51fa M M \u884c\uff0c\u6bcf\u884c N N \u4e2a\u50cf\u7d20\u7070\u5ea6\u503c\uff0c\u6bcf\u4e2a\u7070\u5ea6\u503c\u5360 3 \u4f4d\uff08\u4f8b\u5982\u9ed1\u8272\u8981\u663e\u793a\u4e3a 000 \uff09\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 5 100 150 0 3 189 254 101 119 150 233 151 99 100 88 123 149 0 255 \u8f93\u51fa\u6837\u4f8b 003 189 254 000 000 000 233 151 099 000 088 000 000 000 255 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int m , n , a , b , flag , i , j , num ; cin >> m >> n >> a >> b >> flag ; for ( i = 0 ; i < m ; i ++ ) { scanf ( \"%d\" , & num ); if ( num >= a && num <= b ) printf ( \"%03d\" , flag ); else printf ( \"%03d\" , num ); for ( j = 1 ; j < n ; j ++ ) { scanf ( \"%d\" , & num ); if ( num >= a && num <= b ) printf ( \" %03d\" , flag ); else printf ( \" %03d\" , num ); } cout << endl ; } }","title":"1066-\u56fe\u50cf\u8fc7\u6ee4"},{"location":"PAT-Basic-Level/1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/#1066-\u56fe\u50cf\u8fc7\u6ee4","text":"","title":"1066 \u56fe\u50cf\u8fc7\u6ee4"},{"location":"PAT-Basic-Level/1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u56fe\u50cf\u8fc7\u6ee4\u662f\u628a\u56fe\u50cf\u4e2d\u4e0d\u91cd\u8981\u7684\u50cf\u7d20\u90fd\u67d3\u6210\u80cc\u666f\u8272\uff0c\u4f7f\u5f97\u91cd\u8981\u90e8\u5206\u88ab\u51f8\u663e\u51fa\u6765\u3002\u73b0\u7ed9\u5b9a\u4e00\u5e45\u9ed1\u767d\u56fe\u50cf\uff0c\u8981\u6c42\u4f60\u5c06\u7070\u5ea6\u503c\u4f4d\u4e8e\u67d0\u6307\u5b9a\u533a\u95f4\u5185\u7684\u6240\u6709\u50cf\u7d20\u989c\u8272\u90fd\u7528\u4e00\u79cd\u6307\u5b9a\u7684\u989c\u8272\u66ff\u6362\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u5e45\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff0c\u5373\u4e24\u4e2a\u6b63\u6574\u6570 M M \u548c N N \uff08 0 < M, N \\le 500 0 < M, N \\le 500 \uff09\uff0c\u53e6\u5916\u662f\u5f85\u8fc7\u6ee4\u7684\u7070\u5ea6\u503c\u533a\u95f4\u7aef\u70b9 A A \u548c B B \uff08 0 \\le A < B \\le 255 0 \\le A < B \\le 255 \uff09\u3001\u4ee5\u53ca\u6307\u5b9a\u7684\u66ff\u6362\u7070\u5ea6\u503c\u3002\u968f\u540e M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u50cf\u7d20\u70b9\u7684\u7070\u5ea6\u503c\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6240\u6709\u7070\u5ea6\u503c\u90fd\u5728 [0, 255] \u533a\u95f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u6309\u8981\u6c42\u8fc7\u6ee4\u540e\u7684\u56fe\u50cf\u3002\u5373\u8f93\u51fa M M \u884c\uff0c\u6bcf\u884c N N \u4e2a\u50cf\u7d20\u7070\u5ea6\u503c\uff0c\u6bcf\u4e2a\u7070\u5ea6\u503c\u5360 3 \u4f4d\uff08\u4f8b\u5982\u9ed1\u8272\u8981\u663e\u793a\u4e3a 000 \uff09\uff0c\u5176\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 3 5 100 150 0 3 189 254 101 119 150 233 151 99 100 88 123 149 0 255 \u8f93\u51fa\u6837\u4f8b 003 189 254 000 000 000 233 151 099 000 088 000 000 000 255","title":"Statement"},{"location":"PAT-Basic-Level/1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int m , n , a , b , flag , i , j , num ; cin >> m >> n >> a >> b >> flag ; for ( i = 0 ; i < m ; i ++ ) { scanf ( \"%d\" , & num ); if ( num >= a && num <= b ) printf ( \"%03d\" , flag ); else printf ( \"%03d\" , num ); for ( j = 1 ; j < n ; j ++ ) { scanf ( \"%d\" , & num ); if ( num >= a && num <= b ) printf ( \" %03d\" , flag ); else printf ( \" %03d\" , num ); } cout << endl ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1067-%E8%AF%95%E5%AF%86%E7%A0%81/","text":"1067 \u8bd5\u5bc6\u7801 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u8bd5\u56fe\u767b\u5f55\u67d0\u4e2a\u7cfb\u7edf\u5374\u5fd8\u4e86\u5bc6\u7801\u65f6\uff0c\u7cfb\u7edf\u4e00\u822c\u53ea\u4f1a\u5141\u8bb8\u4f60\u5c1d\u8bd5\u6709\u9650\u591a\u6b21\uff0c\u5f53\u8d85\u51fa\u5141\u8bb8\u6b21\u6570\u65f6\uff0c\u8d26\u53f7\u5c31\u4f1a\u88ab\u9501\u6b7b\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a\u5c0f\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u5bc6\u7801\uff08\u957f\u5ea6\u4e0d\u8d85\u8fc7 20 \u7684\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u3001Tab\u3001\u56de\u8f66\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\u548c\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 10\uff09\uff0c\u5206\u522b\u662f\u6b63\u786e\u7684\u5bc6\u7801\u548c\u7cfb\u7edf\u5141\u8bb8\u5c1d\u8bd5\u7684\u6b21\u6570\u3002\u968f\u540e\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4ee5\u56de\u8f66\u7ed3\u675f\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u662f\u7528\u6237\u5c1d\u8bd5\u8f93\u5165\u7684\u5bc6\u7801\u3002\u8f93\u5165\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u6b21\u5c1d\u8bd5\u3002\u5f53\u8bfb\u5230\u4e00\u884c\u53ea\u6709\u5355\u4e2a # \u5b57\u7b26\u65f6\uff0c\u8f93\u5165\u7ed3\u675f\uff0c\u5e76\u4e14\u8fd9\u4e00\u884c\u4e0d\u662f\u7528\u6237\u7684\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7528\u6237\u7684\u6bcf\u4e2a\u8f93\u5165\uff0c\u5982\u679c\u662f\u6b63\u786e\u7684\u5bc6\u7801\u4e14\u5c1d\u8bd5\u6b21\u6570\u4e0d\u8d85\u8fc7 N\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Welcome in \uff0c\u5e76\u7ed3\u675f\u7a0b\u5e8f\uff1b\u5982\u679c\u662f\u9519\u8bef\u7684\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u6309\u683c\u5f0f\u8f93\u51fa Wrong password: \u7528\u6237\u8f93\u5165\u7684\u9519\u8bef\u5bc6\u7801 \uff1b\u5f53\u9519\u8bef\u5c1d\u8bd5\u8fbe\u5230 N \u6b21\u65f6\uff0c\u518d\u8f93\u51fa\u4e00\u884c Account locked \uff0c\u5e76\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 Correct%pw 3 correct%pw Correct@PW whatisthepassword! Correct%pw # \u8f93\u51fa\u6837\u4f8b 1 Wrong password: correct%pw Wrong password: Correct@PW Wrong password: whatisthepassword! Account locked \u8f93\u5165\u6837\u4f8b 2 cool@gplt 3 coolman@gplt coollady@gplt cool@gplt try again # \u8f93\u51fa\u6837\u4f8b 2 Wrong password: coolman@gplt Wrong password: coollady@gplt Welcome in Solution C++ #include <iostream> using namespace std ; int main () { string password , temp ; int n , cnt = 0 ; cin >> password >> n ; getchar (); while ( 1 ) { getline ( cin , temp ); if ( temp != \"#\" ) { cnt ++ ; } else { break ; } if ( cnt <= n && temp == password ) { cout << \"Welcome in\" ; break ; } else if ( cnt <= n && temp != password ) { cout << \"Wrong password: \" << temp << endl ; if ( cnt == n ) { cout << \"Account locked\" ; break ; } } } return 0 ; }","title":"1067-\u8bd5\u5bc6\u7801"},{"location":"PAT-Basic-Level/1067-%E8%AF%95%E5%AF%86%E7%A0%81/#1067-\u8bd5\u5bc6\u7801","text":"","title":"1067 \u8bd5\u5bc6\u7801"},{"location":"PAT-Basic-Level/1067-%E8%AF%95%E5%AF%86%E7%A0%81/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u8bd5\u56fe\u767b\u5f55\u67d0\u4e2a\u7cfb\u7edf\u5374\u5fd8\u4e86\u5bc6\u7801\u65f6\uff0c\u7cfb\u7edf\u4e00\u822c\u53ea\u4f1a\u5141\u8bb8\u4f60\u5c1d\u8bd5\u6709\u9650\u591a\u6b21\uff0c\u5f53\u8d85\u51fa\u5141\u8bb8\u6b21\u6570\u65f6\uff0c\u8d26\u53f7\u5c31\u4f1a\u88ab\u9501\u6b7b\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a\u5c0f\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u5bc6\u7801\uff08\u957f\u5ea6\u4e0d\u8d85\u8fc7 20 \u7684\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u3001Tab\u3001\u56de\u8f66\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\u548c\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 10\uff09\uff0c\u5206\u522b\u662f\u6b63\u786e\u7684\u5bc6\u7801\u548c\u7cfb\u7edf\u5141\u8bb8\u5c1d\u8bd5\u7684\u6b21\u6570\u3002\u968f\u540e\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4ee5\u56de\u8f66\u7ed3\u675f\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u662f\u7528\u6237\u5c1d\u8bd5\u8f93\u5165\u7684\u5bc6\u7801\u3002\u8f93\u5165\u4fdd\u8bc1\u81f3\u5c11\u6709\u4e00\u6b21\u5c1d\u8bd5\u3002\u5f53\u8bfb\u5230\u4e00\u884c\u53ea\u6709\u5355\u4e2a # \u5b57\u7b26\u65f6\uff0c\u8f93\u5165\u7ed3\u675f\uff0c\u5e76\u4e14\u8fd9\u4e00\u884c\u4e0d\u662f\u7528\u6237\u7684\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7528\u6237\u7684\u6bcf\u4e2a\u8f93\u5165\uff0c\u5982\u679c\u662f\u6b63\u786e\u7684\u5bc6\u7801\u4e14\u5c1d\u8bd5\u6b21\u6570\u4e0d\u8d85\u8fc7 N\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Welcome in \uff0c\u5e76\u7ed3\u675f\u7a0b\u5e8f\uff1b\u5982\u679c\u662f\u9519\u8bef\u7684\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u6309\u683c\u5f0f\u8f93\u51fa Wrong password: \u7528\u6237\u8f93\u5165\u7684\u9519\u8bef\u5bc6\u7801 \uff1b\u5f53\u9519\u8bef\u5c1d\u8bd5\u8fbe\u5230 N \u6b21\u65f6\uff0c\u518d\u8f93\u51fa\u4e00\u884c Account locked \uff0c\u5e76\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 Correct%pw 3 correct%pw Correct@PW whatisthepassword! Correct%pw # \u8f93\u51fa\u6837\u4f8b 1 Wrong password: correct%pw Wrong password: Correct@PW Wrong password: whatisthepassword! Account locked \u8f93\u5165\u6837\u4f8b 2 cool@gplt 3 coolman@gplt coollady@gplt cool@gplt try again # \u8f93\u51fa\u6837\u4f8b 2 Wrong password: coolman@gplt Wrong password: coollady@gplt Welcome in","title":"Statement"},{"location":"PAT-Basic-Level/1067-%E8%AF%95%E5%AF%86%E7%A0%81/#solution","text":"C++ #include <iostream> using namespace std ; int main () { string password , temp ; int n , cnt = 0 ; cin >> password >> n ; getchar (); while ( 1 ) { getline ( cin , temp ); if ( temp != \"#\" ) { cnt ++ ; } else { break ; } if ( cnt <= n && temp == password ) { cout << \"Welcome in\" ; break ; } else if ( cnt <= n && temp != password ) { cout << \"Wrong password: \" << temp << endl ; if ( cnt == n ) { cout << \"Account locked\" ; break ; } } } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2/","text":"1068 \u4e07\u7eff\u4e1b\u4e2d\u4e00\u70b9\u7ea2 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u8ba1\u7b97\u673a\u800c\u8a00\uff0c\u989c\u8272\u4e0d\u8fc7\u662f\u50cf\u7d20\u70b9\u5bf9\u5e94\u7684\u4e00\u4e2a 24 \u4f4d\u7684\u6570\u503c\u3002\u73b0\u7ed9\u5b9a\u4e00\u5e45\u5206\u8fa8\u7387\u4e3a M\\times N M\\times N \u7684\u753b\uff0c\u8981\u6c42\u4f60\u627e\u51fa\u4e07\u7eff\u4e1b\u4e2d\u7684\u4e00\u70b9\u7ea2\uff0c\u5373\u6709\u72ec\u4e00\u65e0\u4e8c\u989c\u8272\u7684\u90a3\u4e2a\u50cf\u7d20\u70b9\uff0c\u5e76\u4e14\u8be5\u70b9\u7684\u989c\u8272\u4e0e\u5176\u5468\u56f4 8 \u4e2a\u76f8\u90bb\u50cf\u7d20\u7684\u989c\u8272\u5dee\u5145\u5206\u5927\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f M M \u548c N N \uff08 \\le \\le 1000\uff09\uff0c\u5373\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff1b\u4ee5\u53ca TOL\uff0c\u662f\u6240\u6c42\u50cf\u7d20\u70b9\u4e0e\u76f8\u90bb\u70b9\u7684\u989c\u8272\u5dee\u9608\u503c\uff0c\u8272\u5dee\u8d85\u8fc7 TOL \u7684\u70b9\u624d\u88ab\u8003\u8651\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa M M \u4e2a\u50cf\u7d20\u7684\u989c\u8272\u503c\uff0c\u8303\u56f4\u5728 [0, 2^{24}) [0, 2^{24}) \u5185\u3002\u6240\u6709\u540c\u884c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u6216 TAB \u5206\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167 (x, y): color \u7684\u683c\u5f0f\u8f93\u51fa\u6240\u6c42\u50cf\u7d20\u70b9\u7684\u4f4d\u7f6e\u4ee5\u53ca\u989c\u8272\u503c\uff0c\u5176\u4e2d\u4f4d\u7f6e x \u548c y \u5206\u522b\u662f\u8be5\u50cf\u7d20\u5728\u56fe\u50cf\u77e9\u9635\u4e2d\u7684\u5217\u3001\u884c\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\u7f16\u53f7\uff09\u3002\u5982\u679c\u8fd9\u6837\u7684\u70b9\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa Not Unique \uff1b\u5982\u679c\u8fd9\u6837\u7684\u70b9\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa Not Exist \u3002 \u8f93\u5165\u6837\u4f8b 1 8 6 200 0 0 0 0 0 0 0 0 65280 65280 65280 16711479 65280 65280 65280 65280 16711479 65280 65280 65280 16711680 65280 65280 65280 65280 65280 65280 65280 65280 65280 165280 165280 65280 65280 16777015 65280 65280 165280 65480 165280 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 \u8f93\u51fa\u6837\u4f8b 1 (5, 3): 16711680 \u8f93\u5165\u6837\u4f8b 2 4 5 2 0 0 0 0 0 0 3 0 0 0 0 0 0 5 0 0 0 0 0 0 \u8f93\u51fa\u6837\u4f8b 2 Not Unique \u8f93\u5165\u6837\u4f8b 3 3 3 5 1 2 3 3 4 5 5 6 7 \u8f93\u51fa\u6837\u4f8b 3 Not Exist Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int a [ MAXN ][ MAXN ]; int tran ( int x1 , int y1 , int x2 , int y2 ) { return abs ( a [ x1 ][ y1 ] - a [ x2 ][ y2 ]); } int main () { int m , n , i , j , tol , num , x , y , color , total = 0 , flag ; map < int , int > q ; cin >> m >> n >> tol ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); q [ a [ i ][ j ]] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { flag = 1 ; if ( i ) { if ( tran ( i , j , i - 1 , j ) <= tol ) flag = 0 ; if ( j ) { if ( tran ( i , j , i - 1 , j - 1 ) <= tol ) flag = 0 ; } if ( m - j - 1 ) { if ( tran ( i , j , i - 1 , j + 1 ) <= tol ) flag = 0 ; } } if ( j ) { if ( tran ( i , j , i , j - 1 ) <= tol ) flag = 0 ; } if ( n - i - 1 ) { if ( tran ( i , j , i + 1 , j ) <= tol ) flag = 0 ; if ( j ) { if ( tran ( i , j , i + 1 , j - 1 ) <= tol ) flag = 0 ; } if ( m - j - 1 ) { if ( tran ( i , j , i + 1 , j + 1 ) <= tol ) flag = 0 ; } } if ( m - j - 1 ) { if ( tran ( i , j , i , j + 1 ) <= tol ) flag = 0 ; } if ( flag && q [ a [ i ][ j ]] == 1 ) total ++ , x = j + 1 , y = i + 1 , color = a [ i ][ j ]; } } if ( total > 1 ) cout << \"Not Unique\" ; else if ( total ) printf ( \"(%d, %d): %d\" , x , y , color ); else cout << \"Not Exist\" ; cout << \" \\n \" ; }","title":"1068-\u4e07\u7eff\u4e1b\u4e2d\u4e00\u70b9\u7ea2"},{"location":"PAT-Basic-Level/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2/#1068-\u4e07\u7eff\u4e1b\u4e2d\u4e00\u70b9\u7ea2","text":"","title":"1068 \u4e07\u7eff\u4e1b\u4e2d\u4e00\u70b9\u7ea2"},{"location":"PAT-Basic-Level/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u8ba1\u7b97\u673a\u800c\u8a00\uff0c\u989c\u8272\u4e0d\u8fc7\u662f\u50cf\u7d20\u70b9\u5bf9\u5e94\u7684\u4e00\u4e2a 24 \u4f4d\u7684\u6570\u503c\u3002\u73b0\u7ed9\u5b9a\u4e00\u5e45\u5206\u8fa8\u7387\u4e3a M\\times N M\\times N \u7684\u753b\uff0c\u8981\u6c42\u4f60\u627e\u51fa\u4e07\u7eff\u4e1b\u4e2d\u7684\u4e00\u70b9\u7ea2\uff0c\u5373\u6709\u72ec\u4e00\u65e0\u4e8c\u989c\u8272\u7684\u90a3\u4e2a\u50cf\u7d20\u70b9\uff0c\u5e76\u4e14\u8be5\u70b9\u7684\u989c\u8272\u4e0e\u5176\u5468\u56f4 8 \u4e2a\u76f8\u90bb\u50cf\u7d20\u7684\u989c\u8272\u5dee\u5145\u5206\u5927\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f M M \u548c N N \uff08 \\le \\le 1000\uff09\uff0c\u5373\u56fe\u50cf\u7684\u5206\u8fa8\u7387\uff1b\u4ee5\u53ca TOL\uff0c\u662f\u6240\u6c42\u50cf\u7d20\u70b9\u4e0e\u76f8\u90bb\u70b9\u7684\u989c\u8272\u5dee\u9608\u503c\uff0c\u8272\u5dee\u8d85\u8fc7 TOL \u7684\u70b9\u624d\u88ab\u8003\u8651\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa M M \u4e2a\u50cf\u7d20\u7684\u989c\u8272\u503c\uff0c\u8303\u56f4\u5728 [0, 2^{24}) [0, 2^{24}) \u5185\u3002\u6240\u6709\u540c\u884c\u6570\u5b57\u95f4\u7528\u7a7a\u683c\u6216 TAB \u5206\u5f00\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u7167 (x, y): color \u7684\u683c\u5f0f\u8f93\u51fa\u6240\u6c42\u50cf\u7d20\u70b9\u7684\u4f4d\u7f6e\u4ee5\u53ca\u989c\u8272\u503c\uff0c\u5176\u4e2d\u4f4d\u7f6e x \u548c y \u5206\u522b\u662f\u8be5\u50cf\u7d20\u5728\u56fe\u50cf\u77e9\u9635\u4e2d\u7684\u5217\u3001\u884c\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\u7f16\u53f7\uff09\u3002\u5982\u679c\u8fd9\u6837\u7684\u70b9\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa Not Unique \uff1b\u5982\u679c\u8fd9\u6837\u7684\u70b9\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa Not Exist \u3002 \u8f93\u5165\u6837\u4f8b 1 8 6 200 0 0 0 0 0 0 0 0 65280 65280 65280 16711479 65280 65280 65280 65280 16711479 65280 65280 65280 16711680 65280 65280 65280 65280 65280 65280 65280 65280 65280 165280 165280 65280 65280 16777015 65280 65280 165280 65480 165280 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 \u8f93\u51fa\u6837\u4f8b 1 (5, 3): 16711680 \u8f93\u5165\u6837\u4f8b 2 4 5 2 0 0 0 0 0 0 3 0 0 0 0 0 0 5 0 0 0 0 0 0 \u8f93\u51fa\u6837\u4f8b 2 Not Unique \u8f93\u5165\u6837\u4f8b 3 3 3 5 1 2 3 3 4 5 5 6 7 \u8f93\u51fa\u6837\u4f8b 3 Not Exist","title":"Statement"},{"location":"PAT-Basic-Level/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 1000 int a [ MAXN ][ MAXN ]; int tran ( int x1 , int y1 , int x2 , int y2 ) { return abs ( a [ x1 ][ y1 ] - a [ x2 ][ y2 ]); } int main () { int m , n , i , j , tol , num , x , y , color , total = 0 , flag ; map < int , int > q ; cin >> m >> n >> tol ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { scanf ( \"%d\" , & a [ i ][ j ]); q [ a [ i ][ j ]] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { flag = 1 ; if ( i ) { if ( tran ( i , j , i - 1 , j ) <= tol ) flag = 0 ; if ( j ) { if ( tran ( i , j , i - 1 , j - 1 ) <= tol ) flag = 0 ; } if ( m - j - 1 ) { if ( tran ( i , j , i - 1 , j + 1 ) <= tol ) flag = 0 ; } } if ( j ) { if ( tran ( i , j , i , j - 1 ) <= tol ) flag = 0 ; } if ( n - i - 1 ) { if ( tran ( i , j , i + 1 , j ) <= tol ) flag = 0 ; if ( j ) { if ( tran ( i , j , i + 1 , j - 1 ) <= tol ) flag = 0 ; } if ( m - j - 1 ) { if ( tran ( i , j , i + 1 , j + 1 ) <= tol ) flag = 0 ; } } if ( m - j - 1 ) { if ( tran ( i , j , i , j + 1 ) <= tol ) flag = 0 ; } if ( flag && q [ a [ i ][ j ]] == 1 ) total ++ , x = j + 1 , y = i + 1 , color = a [ i ][ j ]; } } if ( total > 1 ) cout << \"Not Unique\" ; else if ( total ) printf ( \"(%d, %d): %d\" , x , y , color ); else cout << \"Not Exist\" ; cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/","text":"1069 \u5fae\u535a\u8f6c\u53d1\u62bd\u5956 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u660e PAT \u8003\u4e86\u6ee1\u5206\uff0c\u9ad8\u5174\u4e4b\u4f59\u51b3\u5b9a\u53d1\u8d77\u5fae\u535a\u8f6c\u53d1\u62bd\u5956\u6d3b\u52a8\uff0c\u4ece\u8f6c\u53d1\u7684\u7f51\u53cb\u4e2d\u6309\u987a\u5e8f\u6bcf\u9694 N \u4e2a\u4eba\u5c31\u53d1\u51fa\u4e00\u4e2a\u7ea2\u5305\u3002\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5e2e\u52a9\u4ed6\u786e\u5b9a\u4e2d\u5956\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6b63\u6574\u6570 M\uff08 \\le \\le 1000\uff09\u3001N \u548c S\uff0c\u5206\u522b\u662f\u8f6c\u53d1\u7684\u603b\u91cf\u3001\u5c0f\u660e\u51b3\u5b9a\u7684\u4e2d\u5956\u95f4\u9694\u3001\u4ee5\u53ca\u7b2c\u4e00\u4f4d\u4e2d\u5956\u8005\u7684\u5e8f\u53f7\uff08\u7f16\u53f7\u4ece 1 \u5f00\u59cb\uff09\u3002\u968f\u540e M \u884c\uff0c\u987a\u5e8f\u7ed9\u51fa\u8f6c\u53d1\u5fae\u535a\u7684\u7f51\u53cb\u7684\u6635\u79f0\uff08\u4e0d\u8d85\u8fc7 20 \u4e2a\u5b57\u7b26\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u56de\u8f66\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\u3002 \u6ce8\u610f\uff1a\u53ef\u80fd\u6709\u4eba\u8f6c\u53d1\u591a\u6b21\uff0c\u4f46\u4e0d\u80fd\u4e2d\u5956\u591a\u6b21\u3002\u6240\u4ee5\u5982\u679c\u5904\u4e8e\u5f53\u524d\u4e2d\u5956\u4f4d\u7f6e\u7684\u7f51\u53cb\u5df2\u7ecf\u4e2d\u8fc7\u5956\uff0c\u5219\u8df3\u8fc7\u4ed6\u987a\u6b21\u53d6\u4e0b\u4e00\u4f4d\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u4e2d\u5956\u540d\u5355\uff0c\u6bcf\u4e2a\u6635\u79f0\u5360\u4e00\u884c\u3002\u5982\u679c\u6ca1\u6709\u4eba\u4e2d\u5956\uff0c\u5219\u8f93\u51fa Keep going... \u3002 \u8f93\u5165\u6837\u4f8b 1 9 3 2 Imgonnawin! PickMe PickMe LookHere Imgonnawin! TryAgainAgain TryAgainAgain Imgonnawin! TryAgainAgain \u8f93\u51fa\u6837\u4f8b 1 PickMe Imgonnawin! TryAgainAgain \u8f93\u5165\u6837\u4f8b 2 2 3 5 Imgonnawin! PickMe \u8f93\u51fa\u6837\u4f8b 2 Keep going... \u9e23\u8c22\u7528\u6237 \u8c22\u6210\u661f \u8865\u5145\u6570\u636e\uff01 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int i , m , n , s ; string list ; map < string , int > q ; cin >> m >> n >> s ; int j = s ; getchar (); if ( s > m ) { cout << \"Keep going... \\n \" ; } else { for ( i = 1 ; i <= m ; i ++ ) { cin >> list ; if ( i == j ) { if ( q [ list ] == 0 ) { q [ list ] = 1 ; j += n ; cout << list << endl ; } else { j ++ ; } } } } }","title":"1069-\u5fae\u535a\u8f6c\u53d1\u62bd\u5956"},{"location":"PAT-Basic-Level/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/#1069-\u5fae\u535a\u8f6c\u53d1\u62bd\u5956","text":"","title":"1069 \u5fae\u535a\u8f6c\u53d1\u62bd\u5956"},{"location":"PAT-Basic-Level/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5c0f\u660e PAT \u8003\u4e86\u6ee1\u5206\uff0c\u9ad8\u5174\u4e4b\u4f59\u51b3\u5b9a\u53d1\u8d77\u5fae\u535a\u8f6c\u53d1\u62bd\u5956\u6d3b\u52a8\uff0c\u4ece\u8f6c\u53d1\u7684\u7f51\u53cb\u4e2d\u6309\u987a\u5e8f\u6bcf\u9694 N \u4e2a\u4eba\u5c31\u53d1\u51fa\u4e00\u4e2a\u7ea2\u5305\u3002\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5e2e\u52a9\u4ed6\u786e\u5b9a\u4e2d\u5956\u540d\u5355\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e09\u4e2a\u6b63\u6574\u6570 M\uff08 \\le \\le 1000\uff09\u3001N \u548c S\uff0c\u5206\u522b\u662f\u8f6c\u53d1\u7684\u603b\u91cf\u3001\u5c0f\u660e\u51b3\u5b9a\u7684\u4e2d\u5956\u95f4\u9694\u3001\u4ee5\u53ca\u7b2c\u4e00\u4f4d\u4e2d\u5956\u8005\u7684\u5e8f\u53f7\uff08\u7f16\u53f7\u4ece 1 \u5f00\u59cb\uff09\u3002\u968f\u540e M \u884c\uff0c\u987a\u5e8f\u7ed9\u51fa\u8f6c\u53d1\u5fae\u535a\u7684\u7f51\u53cb\u7684\u6635\u79f0\uff08\u4e0d\u8d85\u8fc7 20 \u4e2a\u5b57\u7b26\u3001\u4e0d\u5305\u542b\u7a7a\u683c\u56de\u8f66\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff09\u3002 \u6ce8\u610f\uff1a\u53ef\u80fd\u6709\u4eba\u8f6c\u53d1\u591a\u6b21\uff0c\u4f46\u4e0d\u80fd\u4e2d\u5956\u591a\u6b21\u3002\u6240\u4ee5\u5982\u679c\u5904\u4e8e\u5f53\u524d\u4e2d\u5956\u4f4d\u7f6e\u7684\u7f51\u53cb\u5df2\u7ecf\u4e2d\u8fc7\u5956\uff0c\u5219\u8df3\u8fc7\u4ed6\u987a\u6b21\u53d6\u4e0b\u4e00\u4f4d\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u8f93\u51fa\u4e2d\u5956\u540d\u5355\uff0c\u6bcf\u4e2a\u6635\u79f0\u5360\u4e00\u884c\u3002\u5982\u679c\u6ca1\u6709\u4eba\u4e2d\u5956\uff0c\u5219\u8f93\u51fa Keep going... \u3002 \u8f93\u5165\u6837\u4f8b 1 9 3 2 Imgonnawin! PickMe PickMe LookHere Imgonnawin! TryAgainAgain TryAgainAgain Imgonnawin! TryAgainAgain \u8f93\u51fa\u6837\u4f8b 1 PickMe Imgonnawin! TryAgainAgain \u8f93\u5165\u6837\u4f8b 2 2 3 5 Imgonnawin! PickMe \u8f93\u51fa\u6837\u4f8b 2 Keep going... \u9e23\u8c22\u7528\u6237 \u8c22\u6210\u661f \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int i , m , n , s ; string list ; map < string , int > q ; cin >> m >> n >> s ; int j = s ; getchar (); if ( s > m ) { cout << \"Keep going... \\n \" ; } else { for ( i = 1 ; i <= m ; i ++ ) { cin >> list ; if ( i == j ) { if ( q [ list ] == 0 ) { q [ list ] = 1 ; j += n ; cout << list << endl ; } else { j ++ ; } } } } }","title":"Solution"},{"location":"PAT-Basic-Level/1070-%E7%BB%93%E7%BB%B3/","text":"1070 \u7ed3\u7ef3 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u6bb5\u4e00\u6bb5\u7684\u7ef3\u5b50\uff0c\u4f60\u9700\u8981\u628a\u5b83\u4eec\u4e32\u6210\u4e00\u6761\u7ef3\u3002\u6bcf\u6b21\u4e32\u8fde\u7684\u65f6\u5019\uff0c\u662f\u628a\u4e24\u6bb5\u7ef3\u5b50\u5bf9\u6298\uff0c\u518d\u5982\u4e0b\u56fe\u6240\u793a\u5957\u63a5\u5728\u4e00\u8d77\u3002\u8fd9\u6837\u5f97\u5230\u7684\u7ef3\u5b50\u53c8\u88ab\u5f53\u6210\u662f\u53e6\u4e00\u6bb5\u7ef3\u5b50\uff0c\u53ef\u4ee5\u518d\u6b21\u5bf9\u6298\u53bb\u8ddf\u53e6\u4e00\u6bb5\u7ef3\u5b50\u4e32\u8fde\u3002\u6bcf\u6b21\u4e32\u8fde\u540e\uff0c\u539f\u6765\u4e24\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u5c31\u4f1a\u51cf\u534a\u3002 \u7ed9\u5b9a N N \u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\uff0c\u4f60\u9700\u8981\u627e\u51fa\u5b83\u4eec\u80fd\u4e32\u6210\u7684\u7ef3\u5b50\u7684\u6700\u5927\u957f\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N ( 2 \\le N \\le 10^4 2 \\le N \\le 10^4 )\uff1b\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5373\u539f\u59cb\u7ef3\u6bb5\u7684\u957f\u5ea6\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6240\u6709\u6574\u6570\u90fd\u4e0d\u8d85\u8fc7 10^4 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u4e32\u6210\u7684\u7ef3\u5b50\u7684\u6700\u5927\u957f\u5ea6\u3002\u7ed3\u679c\u5411\u4e0b\u53d6\u6574\uff0c\u5373\u53d6\u4e3a\u4e0d\u8d85\u8fc7\u6700\u5927\u957f\u5ea6\u7684\u6700\u8fd1\u6574\u6570\u3002 \u8f93\u5165\u6837\u4f8b 8 10 15 12 3 4 13 1 15 \u8f93\u51fa\u6837\u4f8b 14 Solution C++ #include <bits/stdc++.h> using namespace std ; #define maxn 10000 double a [ maxn ]; int main () { int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); sort ( a , a + i ); double total = a [ 0 ]; for ( i = 1 ; i < n ; i ++ ) total = ( a [ i ] / 2 ) + ( total / 2 ); int num = floor ( total ); printf ( \"%d \\n \" , num ); }","title":"1070-\u7ed3\u7ef3"},{"location":"PAT-Basic-Level/1070-%E7%BB%93%E7%BB%B3/#1070-\u7ed3\u7ef3","text":"","title":"1070 \u7ed3\u7ef3"},{"location":"PAT-Basic-Level/1070-%E7%BB%93%E7%BB%B3/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u6bb5\u4e00\u6bb5\u7684\u7ef3\u5b50\uff0c\u4f60\u9700\u8981\u628a\u5b83\u4eec\u4e32\u6210\u4e00\u6761\u7ef3\u3002\u6bcf\u6b21\u4e32\u8fde\u7684\u65f6\u5019\uff0c\u662f\u628a\u4e24\u6bb5\u7ef3\u5b50\u5bf9\u6298\uff0c\u518d\u5982\u4e0b\u56fe\u6240\u793a\u5957\u63a5\u5728\u4e00\u8d77\u3002\u8fd9\u6837\u5f97\u5230\u7684\u7ef3\u5b50\u53c8\u88ab\u5f53\u6210\u662f\u53e6\u4e00\u6bb5\u7ef3\u5b50\uff0c\u53ef\u4ee5\u518d\u6b21\u5bf9\u6298\u53bb\u8ddf\u53e6\u4e00\u6bb5\u7ef3\u5b50\u4e32\u8fde\u3002\u6bcf\u6b21\u4e32\u8fde\u540e\uff0c\u539f\u6765\u4e24\u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\u5c31\u4f1a\u51cf\u534a\u3002 \u7ed9\u5b9a N N \u6bb5\u7ef3\u5b50\u7684\u957f\u5ea6\uff0c\u4f60\u9700\u8981\u627e\u51fa\u5b83\u4eec\u80fd\u4e32\u6210\u7684\u7ef3\u5b50\u7684\u6700\u5927\u957f\u5ea6\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N ( 2 \\le N \\le 10^4 2 \\le N \\le 10^4 )\uff1b\u7b2c 2 \u884c\u7ed9\u51fa N N \u4e2a\u6b63\u6574\u6570\uff0c\u5373\u539f\u59cb\u7ef3\u6bb5\u7684\u957f\u5ea6\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u6240\u6709\u6574\u6570\u90fd\u4e0d\u8d85\u8fc7 10^4 10^4 \u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u80fd\u591f\u4e32\u6210\u7684\u7ef3\u5b50\u7684\u6700\u5927\u957f\u5ea6\u3002\u7ed3\u679c\u5411\u4e0b\u53d6\u6574\uff0c\u5373\u53d6\u4e3a\u4e0d\u8d85\u8fc7\u6700\u5927\u957f\u5ea6\u7684\u6700\u8fd1\u6574\u6570\u3002 \u8f93\u5165\u6837\u4f8b 8 10 15 12 3 4 13 1 15 \u8f93\u51fa\u6837\u4f8b 14","title":"Statement"},{"location":"PAT-Basic-Level/1070-%E7%BB%93%E7%BB%B3/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define maxn 10000 double a [ maxn ]; int main () { int n , i ; cin >> n ; for ( i = 0 ; i < n ; i ++ ) scanf ( \"%lf\" , & a [ i ]); sort ( a , a + i ); double total = a [ 0 ]; for ( i = 1 ; i < n ; i ++ ) total = ( a [ i ] / 2 ) + ( total / 2 ); int num = floor ( total ); printf ( \"%d \\n \" , num ); }","title":"Solution"},{"location":"PAT-Basic-Level/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/","text":"1071 \u5c0f\u8d4c\u6021\u60c5 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5e38\u8a00\u9053\u201c\u5c0f\u8d4c\u6021\u60c5\u201d\u3002\u8fd9\u662f\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u5c0f\u6e38\u620f\uff1a\u9996\u5148\u7531\u8ba1\u7b97\u673a\u7ed9\u51fa\u7b2c\u4e00\u4e2a\u6574\u6570\uff1b\u7136\u540e\u73a9\u5bb6\u4e0b\u6ce8\u8d4c\u7b2c\u4e8c\u4e2a\u6574\u6570\u5c06\u4f1a\u6bd4\u7b2c\u4e00\u4e2a\u6570\u5927\u8fd8\u662f\u5c0f\uff1b\u73a9\u5bb6\u4e0b\u6ce8 t \u4e2a\u7b79\u7801\u540e\uff0c\u8ba1\u7b97\u673a\u7ed9\u51fa\u7b2c\u4e8c\u4e2a\u6570\u3002\u82e5\u73a9\u5bb6\u731c\u5bf9\u4e86\uff0c\u5219\u7cfb\u7edf\u5956\u52b1\u73a9\u5bb6 t \u4e2a\u7b79\u7801\uff1b\u5426\u5219\u6263\u9664\u73a9\u5bb6 t \u4e2a\u7b79\u7801\u3002 \u6ce8\u610f\uff1a\u73a9\u5bb6\u4e0b\u6ce8\u7684\u7b79\u7801\u6570\u4e0d\u80fd\u8d85\u8fc7\u81ea\u5df1\u5e10\u6237\u4e0a\u62e5\u6709\u7684\u7b79\u7801\u6570\u3002\u5f53\u73a9\u5bb6\u8f93\u5149\u4e86\u5168\u90e8\u7b79\u7801\u540e\uff0c\u6e38\u620f\u5c31\u7ed3\u675f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570 T \u548c K\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u7cfb\u7edf\u5728\u521d\u59cb\u72b6\u6001\u4e0b\u8d60\u9001\u7ed9\u73a9\u5bb6\u7684\u7b79\u7801\u6570\u3001\u4ee5\u53ca\u9700\u8981\u5904\u7406\u7684\u6e38\u620f\u6b21\u6570\u3002\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u6b21\u6e38\u620f\uff0c\u987a\u5e8f\u7ed9\u51fa 4 \u4e2a\u6570\u5b57\uff1a n1 b t n2 \u5176\u4e2d n1 \u548c n2 \u662f\u8ba1\u7b97\u673a\u5148\u540e\u7ed9\u51fa\u7684\u4e24\u4e2a[0, 9]\u5185\u7684\u6574\u6570\uff0c\u4fdd\u8bc1\u4e24\u4e2a\u6570\u5b57\u4e0d\u76f8\u7b49\u3002 b \u4e3a 0 \u8868\u793a\u73a9\u5bb6\u8d4c \u5c0f \uff0c\u4e3a 1 \u8868\u793a\u73a9\u5bb6\u8d4c \u5927 \u3002 t \u8868\u793a\u73a9\u5bb6\u4e0b\u6ce8\u7684\u7b79\u7801\u6570\uff0c\u4fdd\u8bc1\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u6e38\u620f\uff0c\u6839\u636e\u4e0b\u5217\u60c5\u51b5\u5bf9\u5e94\u8f93\u51fa\uff08\u5176\u4e2d t \u662f\u73a9\u5bb6\u4e0b\u6ce8\u91cf\uff0c x \u662f\u73a9\u5bb6\u5f53\u524d\u6301\u6709\u7684\u7b79\u7801\u91cf\uff09\uff1a \u73a9\u5bb6\u8d62\uff0c\u8f93\u51fa Win t! Total = x. \uff1b \u73a9\u5bb6\u8f93\uff0c\u8f93\u51fa Lose t. Total = x. \uff1b \u73a9\u5bb6\u4e0b\u6ce8\u8d85\u8fc7\u6301\u6709\u7684\u7b79\u7801\u91cf\uff0c\u8f93\u51fa Not enough tokens. Total = x. \uff1b \u73a9\u5bb6\u8f93\u5149\u540e\uff0c\u8f93\u51fa Game Over. \u5e76\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 100 4 8 0 100 2 3 1 50 1 5 1 200 6 7 0 200 8 \u8f93\u51fa\u6837\u4f8b 1 Win 100! Total = 200. Lose 50. Total = 150. Not enough tokens. Total = 150. Not enough tokens. Total = 150. \u8f93\u5165\u6837\u4f8b 2 100 4 8 0 100 2 3 1 200 1 5 1 200 6 7 0 200 8 \u8f93\u51fa\u6837\u4f8b 2 Win 100! Total = 200. Lose 200. Total = 0. Game Over. Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , k , i , j ; cin >> t >> k ; for ( i = 0 ; i < k ; i ++ ) { int n1 , b , a , n2 ; cin >> n1 >> b >> a >> n2 ; if ( t < a ) printf ( \"Not enough tokens. Total = %d. \\n \" , t ); else if (( b && n2 > n1 ) || ( b == 0 && n2 < n1 )) { t += a ; printf ( \"Win %d! Total = %d. \\n \" , a , t ); } else { t -= a ; printf ( \"Lose %d. Total = %d. \\n \" , a , t ); if ( t <= 0 ) { printf ( \"Game Over. \\n \" ); break ; } } } }","title":"1071-\u5c0f\u8d4c\u6021\u60c5"},{"location":"PAT-Basic-Level/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/#1071-\u5c0f\u8d4c\u6021\u60c5","text":"","title":"1071 \u5c0f\u8d4c\u6021\u60c5"},{"location":"PAT-Basic-Level/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5e38\u8a00\u9053\u201c\u5c0f\u8d4c\u6021\u60c5\u201d\u3002\u8fd9\u662f\u4e00\u4e2a\u5f88\u7b80\u5355\u7684\u5c0f\u6e38\u620f\uff1a\u9996\u5148\u7531\u8ba1\u7b97\u673a\u7ed9\u51fa\u7b2c\u4e00\u4e2a\u6574\u6570\uff1b\u7136\u540e\u73a9\u5bb6\u4e0b\u6ce8\u8d4c\u7b2c\u4e8c\u4e2a\u6574\u6570\u5c06\u4f1a\u6bd4\u7b2c\u4e00\u4e2a\u6570\u5927\u8fd8\u662f\u5c0f\uff1b\u73a9\u5bb6\u4e0b\u6ce8 t \u4e2a\u7b79\u7801\u540e\uff0c\u8ba1\u7b97\u673a\u7ed9\u51fa\u7b2c\u4e8c\u4e2a\u6570\u3002\u82e5\u73a9\u5bb6\u731c\u5bf9\u4e86\uff0c\u5219\u7cfb\u7edf\u5956\u52b1\u73a9\u5bb6 t \u4e2a\u7b79\u7801\uff1b\u5426\u5219\u6263\u9664\u73a9\u5bb6 t \u4e2a\u7b79\u7801\u3002 \u6ce8\u610f\uff1a\u73a9\u5bb6\u4e0b\u6ce8\u7684\u7b79\u7801\u6570\u4e0d\u80fd\u8d85\u8fc7\u81ea\u5df1\u5e10\u6237\u4e0a\u62e5\u6709\u7684\u7b79\u7801\u6570\u3002\u5f53\u73a9\u5bb6\u8f93\u5149\u4e86\u5168\u90e8\u7b79\u7801\u540e\uff0c\u6e38\u620f\u5c31\u7ed3\u675f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570 T \u548c K\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u7cfb\u7edf\u5728\u521d\u59cb\u72b6\u6001\u4e0b\u8d60\u9001\u7ed9\u73a9\u5bb6\u7684\u7b79\u7801\u6570\u3001\u4ee5\u53ca\u9700\u8981\u5904\u7406\u7684\u6e38\u620f\u6b21\u6570\u3002\u968f\u540e K \u884c\uff0c\u6bcf\u884c\u5bf9\u5e94\u4e00\u6b21\u6e38\u620f\uff0c\u987a\u5e8f\u7ed9\u51fa 4 \u4e2a\u6570\u5b57\uff1a n1 b t n2 \u5176\u4e2d n1 \u548c n2 \u662f\u8ba1\u7b97\u673a\u5148\u540e\u7ed9\u51fa\u7684\u4e24\u4e2a[0, 9]\u5185\u7684\u6574\u6570\uff0c\u4fdd\u8bc1\u4e24\u4e2a\u6570\u5b57\u4e0d\u76f8\u7b49\u3002 b \u4e3a 0 \u8868\u793a\u73a9\u5bb6\u8d4c \u5c0f \uff0c\u4e3a 1 \u8868\u793a\u73a9\u5bb6\u8d4c \u5927 \u3002 t \u8868\u793a\u73a9\u5bb6\u4e0b\u6ce8\u7684\u7b79\u7801\u6570\uff0c\u4fdd\u8bc1\u5728\u6574\u578b\u8303\u56f4\u5185\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u6b21\u6e38\u620f\uff0c\u6839\u636e\u4e0b\u5217\u60c5\u51b5\u5bf9\u5e94\u8f93\u51fa\uff08\u5176\u4e2d t \u662f\u73a9\u5bb6\u4e0b\u6ce8\u91cf\uff0c x \u662f\u73a9\u5bb6\u5f53\u524d\u6301\u6709\u7684\u7b79\u7801\u91cf\uff09\uff1a \u73a9\u5bb6\u8d62\uff0c\u8f93\u51fa Win t! Total = x. \uff1b \u73a9\u5bb6\u8f93\uff0c\u8f93\u51fa Lose t. Total = x. \uff1b \u73a9\u5bb6\u4e0b\u6ce8\u8d85\u8fc7\u6301\u6709\u7684\u7b79\u7801\u91cf\uff0c\u8f93\u51fa Not enough tokens. Total = x. \uff1b \u73a9\u5bb6\u8f93\u5149\u540e\uff0c\u8f93\u51fa Game Over. \u5e76\u7ed3\u675f\u7a0b\u5e8f\u3002 \u8f93\u5165\u6837\u4f8b 1 100 4 8 0 100 2 3 1 50 1 5 1 200 6 7 0 200 8 \u8f93\u51fa\u6837\u4f8b 1 Win 100! Total = 200. Lose 50. Total = 150. Not enough tokens. Total = 150. Not enough tokens. Total = 150. \u8f93\u5165\u6837\u4f8b 2 100 4 8 0 100 2 3 1 200 1 5 1 200 6 7 0 200 8 \u8f93\u51fa\u6837\u4f8b 2 Win 100! Total = 200. Lose 200. Total = 0. Game Over.","title":"Statement"},{"location":"PAT-Basic-Level/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int t , k , i , j ; cin >> t >> k ; for ( i = 0 ; i < k ; i ++ ) { int n1 , b , a , n2 ; cin >> n1 >> b >> a >> n2 ; if ( t < a ) printf ( \"Not enough tokens. Total = %d. \\n \" , t ); else if (( b && n2 > n1 ) || ( b == 0 && n2 < n1 )) { t += a ; printf ( \"Win %d! Total = %d. \\n \" , a , t ); } else { t -= a ; printf ( \"Lose %d. Total = %d. \\n \" , a , t ); if ( t <= 0 ) { printf ( \"Game Over. \\n \" ); break ; } } } }","title":"Solution"},{"location":"PAT-Basic-Level/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/","text":"1072 \u5f00\u5b66\u5bc4\u8bed Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u56fe\u662f\u4e0a\u6d77\u67d0\u6821\u7684\u65b0\u5b66\u671f\u5f00\u5b66\u5bc4\u8bed\uff1a\u5929\u5c06\u964d\u5927\u4efb\u4e8e\u65af\u4eba\u4e5f\uff0c\u5fc5\u5148\u5220\u5176\u5fae\u535a\uff0c\u5378\u5176 QQ\uff0c\u5c01\u5176\u7535\u8111\uff0c\u593a\u5176\u624b\u673a\uff0c\u6536\u5176 ipad\uff0c\u65ad\u5176 wifi\uff0c\u4f7f\u5176\u767e\u65e0\u804a\u8d56\uff0c\u7136\u540e\uff0c\u51c0\u9762\u3001\u7406\u53d1\u3001\u6574\u8863\uff0c\u7136\u540e\u601d\u8fc7\u3001\u8bfb\u4e66\u3001\u953b\u70bc\u3001\u660e\u667a\u3001\u5f00\u609f\u3001\u7cbe\u8fdb\u3002\u800c\u540e\u5fc5\u6210\u5927\u5668\u4e5f\uff01 \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8fd9\u6240\u5b66\u6821\u7684\u8001\u5e08\u68c0\u67e5\u6240\u6709\u5b66\u751f\u7684\u7269\u54c1\uff0c\u4ee5\u52a9\u5176\u6210\u5927\u5668\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 6\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u79cd\u7c7b\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa M \u4e2a\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u7f16\u53f7\uff0c\u5176\u4e2d\u7f16\u53f7\u4e3a 4 \u4f4d\u6570\u5b57\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b66\u751f\u7684\u59d3\u540d\u7f29\u5199\uff08\u7531 1-4 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\uff09\u3001\u4e2a\u4eba\u7269\u54c1\u6570\u91cf K\uff080 \\le \\le K \\le \\le 10\uff09\u3001\u4ee5\u53ca K \u4e2a\u7269\u54c1\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u987a\u6b21\u68c0\u67e5\u6bcf\u4e2a\u5b66\u751f\u643a\u5e26\u7684\u7269\u54c1\uff0c\u5982\u679c\u6709\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u5b58\u5728\uff0c\u5219\u6309\u4ee5\u4e0b\u683c\u5f0f\u8f93\u51fa\u8be5\u751f\u7684\u4fe1\u606f\u548c\u5176\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u7684\u4fe1\u606f\uff08\u6ce8\u610f\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\uff09\uff1a \u59d3\u540d\u7f29\u5199: \u7269\u54c1\u7f16\u53f71 \u7269\u54c1\u7f16\u53f72 \u2026\u2026 \u6700\u540e\u4e00\u884c\u8f93\u51fa\u5b58\u5728\u95ee\u9898\u7684\u5b66\u751f\u7684\u603b\u4eba\u6570\u548c\u88ab\u67e5\u7f34\u7269\u54c1\u7684\u603b\u6570\u3002 \u8f93\u5165\u6837\u4f8b 4 2 2333 6666 CYLL 3 1234 2345 3456 U 4 9966 6666 8888 6666 GG 2 2333 7777 JJ 3 0012 6666 2333 \u8f93\u51fa\u6837\u4f8b U: 6666 6666 GG: 2333 JJ: 6666 2333 3 5 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , m , i , j , tot1 = 0 , tot2 = 0 , total , flag ; string s , name ; map < string , int > q ; cin >> n >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> s ; q [ s ] = 2 ; } for ( i = 0 ; i < n ; i ++ ) { cin >> name ; cin >> total ; flag = 0 ; for ( j = 0 ; j < total ; j ++ ) { cin >> s ; if ( q [ s ] == 2 ) { if ( flag ) { tot2 ++ ; cout << \" \" << s ; } else { tot1 ++ , tot2 ++ ; flag = 1 ; cout << name << \": \" << s ; } } } if ( flag ) printf ( \" \\n \" ); } cout << tot1 << \" \" << tot2 << endl ; }","title":"1072-\u5f00\u5b66\u5bc4\u8bed"},{"location":"PAT-Basic-Level/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/#1072-\u5f00\u5b66\u5bc4\u8bed","text":"","title":"1072 \u5f00\u5b66\u5bc4\u8bed"},{"location":"PAT-Basic-Level/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u56fe\u662f\u4e0a\u6d77\u67d0\u6821\u7684\u65b0\u5b66\u671f\u5f00\u5b66\u5bc4\u8bed\uff1a\u5929\u5c06\u964d\u5927\u4efb\u4e8e\u65af\u4eba\u4e5f\uff0c\u5fc5\u5148\u5220\u5176\u5fae\u535a\uff0c\u5378\u5176 QQ\uff0c\u5c01\u5176\u7535\u8111\uff0c\u593a\u5176\u624b\u673a\uff0c\u6536\u5176 ipad\uff0c\u65ad\u5176 wifi\uff0c\u4f7f\u5176\u767e\u65e0\u804a\u8d56\uff0c\u7136\u540e\uff0c\u51c0\u9762\u3001\u7406\u53d1\u3001\u6574\u8863\uff0c\u7136\u540e\u601d\u8fc7\u3001\u8bfb\u4e66\u3001\u953b\u70bc\u3001\u660e\u667a\u3001\u5f00\u609f\u3001\u7cbe\u8fdb\u3002\u800c\u540e\u5fc5\u6210\u5927\u5668\u4e5f\uff01 \u672c\u9898\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8fd9\u6240\u5b66\u6821\u7684\u8001\u5e08\u68c0\u67e5\u6240\u6709\u5b66\u751f\u7684\u7269\u54c1\uff0c\u4ee5\u52a9\u5176\u6210\u5927\u5668\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 6\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u79cd\u7c7b\u6570\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa M \u4e2a\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u7f16\u53f7\uff0c\u5176\u4e2d\u7f16\u53f7\u4e3a 4 \u4f4d\u6570\u5b57\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u5b66\u751f\u7684\u59d3\u540d\u7f29\u5199\uff08\u7531 1-4 \u4e2a\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\uff09\u3001\u4e2a\u4eba\u7269\u54c1\u6570\u91cf K\uff080 \\le \\le K \\le \\le 10\uff09\u3001\u4ee5\u53ca K \u4e2a\u7269\u54c1\u7684\u7f16\u53f7\u3002 \u8f93\u51fa\u683c\u5f0f \u987a\u6b21\u68c0\u67e5\u6bcf\u4e2a\u5b66\u751f\u643a\u5e26\u7684\u7269\u54c1\uff0c\u5982\u679c\u6709\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u5b58\u5728\uff0c\u5219\u6309\u4ee5\u4e0b\u683c\u5f0f\u8f93\u51fa\u8be5\u751f\u7684\u4fe1\u606f\u548c\u5176\u9700\u8981\u88ab\u67e5\u7f34\u7684\u7269\u54c1\u7684\u4fe1\u606f\uff08\u6ce8\u610f\u884c\u672b\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\uff09\uff1a \u59d3\u540d\u7f29\u5199: \u7269\u54c1\u7f16\u53f71 \u7269\u54c1\u7f16\u53f72 \u2026\u2026 \u6700\u540e\u4e00\u884c\u8f93\u51fa\u5b58\u5728\u95ee\u9898\u7684\u5b66\u751f\u7684\u603b\u4eba\u6570\u548c\u88ab\u67e5\u7f34\u7269\u54c1\u7684\u603b\u6570\u3002 \u8f93\u5165\u6837\u4f8b 4 2 2333 6666 CYLL 3 1234 2345 3456 U 4 9966 6666 8888 6666 GG 2 2333 7777 JJ 3 0012 6666 2333 \u8f93\u51fa\u6837\u4f8b U: 6666 6666 GG: 2333 JJ: 6666 2333 3 5","title":"Statement"},{"location":"PAT-Basic-Level/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n , m , i , j , tot1 = 0 , tot2 = 0 , total , flag ; string s , name ; map < string , int > q ; cin >> n >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> s ; q [ s ] = 2 ; } for ( i = 0 ; i < n ; i ++ ) { cin >> name ; cin >> total ; flag = 0 ; for ( j = 0 ; j < total ; j ++ ) { cin >> s ; if ( q [ s ] == 2 ) { if ( flag ) { tot2 ++ ; cout << \" \" << s ; } else { tot1 ++ , tot2 ++ ; flag = 1 ; cout << name << \": \" << s ; } } } if ( flag ) printf ( \" \\n \" ); } cout << tot1 << \" \" << tot2 << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95/","text":"1073 \u591a\u9009\u9898\u5e38\u89c1\u8ba1\u5206\u6cd5 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6279\u6539\u591a\u9009\u9898\u662f\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\uff0c\u6709\u5f88\u591a\u4e0d\u540c\u7684\u8ba1\u5206\u65b9\u6cd5\u3002\u6709\u4e00\u79cd\u6700\u5e38\u89c1\u7684\u8ba1\u5206\u65b9\u6cd5\u662f\uff1a\u5982\u679c\u8003\u751f\u9009\u62e9\u4e86\u90e8\u5206\u6b63\u786e\u9009\u9879\uff0c\u5e76\u4e14\u6ca1\u6709\u9009\u62e9\u4efb\u4f55\u9519\u8bef\u9009\u9879\uff0c\u5219\u5f97\u5230 50% \u5206\u6570\uff1b\u5982\u679c\u8003\u751f\u9009\u62e9\u4e86\u4efb\u4f55\u4e00\u4e2a\u9519\u8bef\u7684\u9009\u9879\uff0c\u5219\u4e0d\u80fd\u5f97\u5206\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u6279\u6539\u591a\u9009\u9898\uff0c\u5e76\u4e14\u6307\u51fa\u54ea\u9053\u9898\u7684\u54ea\u4e2a\u9009\u9879\u9519\u7684\u4eba\u6700\u591a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u591a\u9009\u9898\u7684\u4e2a\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u4e00\u9053\u9898\u7684\u6ee1\u5206\u503c\uff08\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u5c11\u4e8e 2 \u4e14\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u6b63\u786e\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7\u9009\u9879\u4e2a\u6570\u7684\u6b63\u6574\u6570\uff09\u3001\u6240\u6709\u6b63\u786e\u9009\u9879\u3002\u6ce8\u610f\u6bcf\u9898\u7684\u9009\u9879\u4ece\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd a \u5f00\u59cb\u987a\u6b21\u6392\u5217\u3002\u5404\u9879\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\uff0c\u5176\u6bcf\u9898\u7b54\u6848\u683c\u5f0f\u4e3a (\u9009\u4e2d\u7684\u9009\u9879\u4e2a\u6570 \u9009\u98791 \u2026\u2026) \uff0c\u6309\u9898\u76ee\u987a\u5e8f\u7ed9\u51fa\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u5373\u4e0d\u5b58\u5728\u9009\u4e2d\u7684\u9009\u9879\u6570\u8d85\u8fc7\u5b9e\u9645\u9009\u9879\u6570\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002\u6700\u540e\u8f93\u51fa\u9519\u5f97\u6700\u591a\u7684\u9898\u76ee\u9009\u9879\u7684\u4fe1\u606f\uff0c\u683c\u5f0f\u4e3a\uff1a \u9519\u8bef\u6b21\u6570 \u9898\u76ee\u7f16\u53f7\uff08\u9898\u76ee\u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u4ece1\u5f00\u59cb\u7f16\u53f7\uff09-\u9009\u9879\u53f7 \u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6bcf\u884c\u4e00\u4e2a\u9009\u9879\uff0c\u6309\u9898\u76ee\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\uff1b\u518d\u5e76\u5217\u5219\u6309\u9009\u9879\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6240\u6709\u9898\u76ee\u90fd\u6ca1\u6709\u4eba\u9519\uff0c\u5219\u5728\u6700\u540e\u4e00\u884c\u8f93\u51fa Too simple \u3002 \u8f93\u5165\u6837\u4f8b 1 3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (3 b d e) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (1 c) (4 a b c d) \u8f93\u51fa\u6837\u4f8b 1 3.5 6.0 2.5 2 2-e 2 3-a 2 3-b \u8f93\u5165\u6837\u4f8b 2 2 2 3 4 2 a c 2 5 1 b (2 a c) (1 b) (2 a c) (1 b) \u8f93\u51fa\u6837\u4f8b 2 5.0 5.0 Too simple Solution C++ #include <algorithm> #include <cmath> #include <cstring> #include <iostream> using namespace std ; struct joy { int grade , num , choice , wrong [ 5 ] = { 0 }, max = -2 , flag [ 5 ] = { 0 }, number ; int tr [ 122 ] = { 0 }; }; void print ( joy x ) { int i ; for ( i = 0 ; i < 5 ; i ++ ) { if ( x . flag [ i ]) { printf ( \"%d %d-%c \\n \" , x . wrong [ i ], x . number , i + 'a' ); } } } int main () { int n , m , i , j , k , a , b [ 122 ] = { 0 }, temp , h , max = -1 ; char p , x ; double sum = 0.0 ; struct joy list [ 100 ]; cin >> n >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> list [ i ]. grade >> list [ i ]. num >> list [ i ]. choice ; list [ i ]. number = i + 1 ; for ( j = 0 ; j < list [ i ]. choice ; j ++ ) { scanf ( \" %c\" , & p ); // cout<<p<<endl; /*if(p==10){ break; }*/ temp = p ; list [ i ]. tr [ temp ] ++ ; } } int flag = 1 ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = 0.0 ; for ( j = 0 ; j < m ; j ++ ) { count = 0 , flag = 1 ; // add memset ( b , 0 , sizeof ( b )); // add scanf ( \" %c %d\" , & x , & a ); // cout<<a<<endl; for ( k = 0 ; k < a ; k ++ ) { scanf ( \" %c\" , & p ); // cout<<p<<endl; temp = p ; b [ temp ] ++ ; } cin >> x ; // add for ( h = 97 ; h < 102 ; h ++ ) { if ( b [ h ] == list [ j ]. tr [ h ]) { if ( b [ h ]) count ++ ; } else if ( b [ h ] > list [ j ]. tr [ h ]) { flag = 0 ; list [ j ]. wrong [ h - 'a' ] ++ ; // replace } else list [ j ]. wrong [ h - 'a' ] ++ ; if ( list [ j ]. wrong [ h - 'a' ] > list [ j ]. max && list [ j ]. wrong [ h - 'a' ]) list [ j ]. max = list [ j ]. wrong [ h - 'a' ]; // add } if ( list [ j ]. max > max ) max = list [ j ]. max ; // cout<<count<<endl; if ( flag ) { // remove if ( count == list [ j ]. choice ) { // choice replace num sum += 1.0 * list [ j ]. grade ; } else { sum += list [ j ]. grade / 2.0 ; } } // remove } // cout<<sum<<endl; /*for(j=0; j<m; j++){ if(flag){ if(count==list[j].num){ sum+=1.0*list[j].grade; }else{ sum+=list[j].grade/2.0; } } cin>>x; }*/ printf ( \"%.1f \\n \" , sum ); } for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < 5 ; j ++ ) { if ( list [ i ]. wrong [ j ] == list [ i ]. max ) list [ i ]. flag [ j ] = 1 ; } } flag = 1 ; for ( i = 0 ; i < m ; i ++ ) { if ( list [ i ]. max == max ) { print ( list [ i ]); flag = 0 ; } } if ( flag ) cout << \"Too simple \\n \" ; }","title":"1073-\u591a\u9009\u9898\u5e38\u89c1\u8ba1\u5206\u6cd5"},{"location":"PAT-Basic-Level/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95/#1073-\u591a\u9009\u9898\u5e38\u89c1\u8ba1\u5206\u6cd5","text":"","title":"1073 \u591a\u9009\u9898\u5e38\u89c1\u8ba1\u5206\u6cd5"},{"location":"PAT-Basic-Level/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6279\u6539\u591a\u9009\u9898\u662f\u6bd4\u8f83\u9ebb\u70e6\u7684\u4e8b\u60c5\uff0c\u6709\u5f88\u591a\u4e0d\u540c\u7684\u8ba1\u5206\u65b9\u6cd5\u3002\u6709\u4e00\u79cd\u6700\u5e38\u89c1\u7684\u8ba1\u5206\u65b9\u6cd5\u662f\uff1a\u5982\u679c\u8003\u751f\u9009\u62e9\u4e86\u90e8\u5206\u6b63\u786e\u9009\u9879\uff0c\u5e76\u4e14\u6ca1\u6709\u9009\u62e9\u4efb\u4f55\u9519\u8bef\u9009\u9879\uff0c\u5219\u5f97\u5230 50% \u5206\u6570\uff1b\u5982\u679c\u8003\u751f\u9009\u62e9\u4e86\u4efb\u4f55\u4e00\u4e2a\u9519\u8bef\u7684\u9009\u9879\uff0c\u5219\u4e0d\u80fd\u5f97\u5206\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u6279\u6539\u591a\u9009\u9898\uff0c\u5e76\u4e14\u6307\u51fa\u54ea\u9053\u9898\u7684\u54ea\u4e2a\u9009\u9879\u9519\u7684\u4eba\u6700\u591a\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 1000\uff09\u548c M\uff08 \\le \\le 100\uff09\uff0c\u5206\u522b\u662f\u5b66\u751f\u4eba\u6570\u548c\u591a\u9009\u9898\u7684\u4e2a\u6570\u3002\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u987a\u6b21\u7ed9\u51fa\u4e00\u9053\u9898\u7684\u6ee1\u5206\u503c\uff08\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u5c11\u4e8e 2 \u4e14\u4e0d\u8d85\u8fc7 5 \u7684\u6b63\u6574\u6570\uff09\u3001\u6b63\u786e\u9009\u9879\u4e2a\u6570\uff08\u4e0d\u8d85\u8fc7\u9009\u9879\u4e2a\u6570\u7684\u6b63\u6574\u6570\uff09\u3001\u6240\u6709\u6b63\u786e\u9009\u9879\u3002\u6ce8\u610f\u6bcf\u9898\u7684\u9009\u9879\u4ece\u5c0f\u5199\u82f1\u6587\u5b57\u6bcd a \u5f00\u59cb\u987a\u6b21\u6392\u5217\u3002\u5404\u9879\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002\u6700\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\uff0c\u5176\u6bcf\u9898\u7b54\u6848\u683c\u5f0f\u4e3a (\u9009\u4e2d\u7684\u9009\u9879\u4e2a\u6570 \u9009\u98791 \u2026\u2026) \uff0c\u6309\u9898\u76ee\u987a\u5e8f\u7ed9\u51fa\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u5b66\u751f\u7684\u7b54\u9898\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u5373\u4e0d\u5b58\u5728\u9009\u4e2d\u7684\u9009\u9879\u6570\u8d85\u8fc7\u5b9e\u9645\u9009\u9879\u6570\u7684\u60c5\u51b5\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u7ed9\u51fa\u6bcf\u4e2a\u5b66\u751f\u7684\u5f97\u5206\uff0c\u6bcf\u4e2a\u5206\u6570\u5360\u4e00\u884c\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 1 \u4f4d\u3002\u6700\u540e\u8f93\u51fa\u9519\u5f97\u6700\u591a\u7684\u9898\u76ee\u9009\u9879\u7684\u4fe1\u606f\uff0c\u683c\u5f0f\u4e3a\uff1a \u9519\u8bef\u6b21\u6570 \u9898\u76ee\u7f16\u53f7\uff08\u9898\u76ee\u6309\u7167\u8f93\u5165\u7684\u987a\u5e8f\u4ece1\u5f00\u59cb\u7f16\u53f7\uff09-\u9009\u9879\u53f7 \u3002\u5982\u679c\u6709\u5e76\u5217\uff0c\u5219\u6bcf\u884c\u4e00\u4e2a\u9009\u9879\uff0c\u6309\u9898\u76ee\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\uff1b\u518d\u5e76\u5217\u5219\u6309\u9009\u9879\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u6240\u6709\u9898\u76ee\u90fd\u6ca1\u6709\u4eba\u9519\uff0c\u5219\u5728\u6700\u540e\u4e00\u884c\u8f93\u51fa Too simple \u3002 \u8f93\u5165\u6837\u4f8b 1 3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (3 b d e) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (1 c) (4 a b c d) \u8f93\u51fa\u6837\u4f8b 1 3.5 6.0 2.5 2 2-e 2 3-a 2 3-b \u8f93\u5165\u6837\u4f8b 2 2 2 3 4 2 a c 2 5 1 b (2 a c) (1 b) (2 a c) (1 b) \u8f93\u51fa\u6837\u4f8b 2 5.0 5.0 Too simple","title":"Statement"},{"location":"PAT-Basic-Level/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95/#solution","text":"C++ #include <algorithm> #include <cmath> #include <cstring> #include <iostream> using namespace std ; struct joy { int grade , num , choice , wrong [ 5 ] = { 0 }, max = -2 , flag [ 5 ] = { 0 }, number ; int tr [ 122 ] = { 0 }; }; void print ( joy x ) { int i ; for ( i = 0 ; i < 5 ; i ++ ) { if ( x . flag [ i ]) { printf ( \"%d %d-%c \\n \" , x . wrong [ i ], x . number , i + 'a' ); } } } int main () { int n , m , i , j , k , a , b [ 122 ] = { 0 }, temp , h , max = -1 ; char p , x ; double sum = 0.0 ; struct joy list [ 100 ]; cin >> n >> m ; for ( i = 0 ; i < m ; i ++ ) { cin >> list [ i ]. grade >> list [ i ]. num >> list [ i ]. choice ; list [ i ]. number = i + 1 ; for ( j = 0 ; j < list [ i ]. choice ; j ++ ) { scanf ( \" %c\" , & p ); // cout<<p<<endl; /*if(p==10){ break; }*/ temp = p ; list [ i ]. tr [ temp ] ++ ; } } int flag = 1 ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = 0.0 ; for ( j = 0 ; j < m ; j ++ ) { count = 0 , flag = 1 ; // add memset ( b , 0 , sizeof ( b )); // add scanf ( \" %c %d\" , & x , & a ); // cout<<a<<endl; for ( k = 0 ; k < a ; k ++ ) { scanf ( \" %c\" , & p ); // cout<<p<<endl; temp = p ; b [ temp ] ++ ; } cin >> x ; // add for ( h = 97 ; h < 102 ; h ++ ) { if ( b [ h ] == list [ j ]. tr [ h ]) { if ( b [ h ]) count ++ ; } else if ( b [ h ] > list [ j ]. tr [ h ]) { flag = 0 ; list [ j ]. wrong [ h - 'a' ] ++ ; // replace } else list [ j ]. wrong [ h - 'a' ] ++ ; if ( list [ j ]. wrong [ h - 'a' ] > list [ j ]. max && list [ j ]. wrong [ h - 'a' ]) list [ j ]. max = list [ j ]. wrong [ h - 'a' ]; // add } if ( list [ j ]. max > max ) max = list [ j ]. max ; // cout<<count<<endl; if ( flag ) { // remove if ( count == list [ j ]. choice ) { // choice replace num sum += 1.0 * list [ j ]. grade ; } else { sum += list [ j ]. grade / 2.0 ; } } // remove } // cout<<sum<<endl; /*for(j=0; j<m; j++){ if(flag){ if(count==list[j].num){ sum+=1.0*list[j].grade; }else{ sum+=list[j].grade/2.0; } } cin>>x; }*/ printf ( \"%.1f \\n \" , sum ); } for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < 5 ; j ++ ) { if ( list [ i ]. wrong [ j ] == list [ i ]. max ) list [ i ]. flag [ j ] = 1 ; } } flag = 1 ; for ( i = 0 ; i < m ; i ++ ) { if ( list [ i ]. max == max ) { print ( list [ i ]); flag = 0 ; } } if ( flag ) cout << \"Too simple \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8/","text":"1074 \u5b87\u5b99\u65e0\u654c\u52a0\u6cd5\u5668 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5730\u7403\u4eba\u4e60\u60ef\u4f7f\u7528\u5341\u8fdb\u5236\u6570\uff0c\u5e76\u4e14\u9ed8\u8ba4\u4e00\u4e2a\u6570\u5b57\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u5341\u8fdb\u5236\u7684\u3002\u800c\u5728 PAT \u661f\u4eba\u5f00\u6302\u7684\u4e16\u754c\u91cc\uff0c\u6bcf\u4e2a\u6570\u5b57\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4e0d\u540c\u8fdb\u5236\u7684\uff0c\u8fd9\u79cd\u795e\u5947\u7684\u6570\u5b57\u79f0\u4e3a\u201cPAT\u6570\u201d\u3002\u6bcf\u4e2a PAT \u661f\u4eba\u90fd\u5fc5\u987b\u719f\u8bb0\u5404\u4f4d\u6570\u5b57\u7684\u8fdb\u5236\u8868\uff0c\u4f8b\u5982\u201c\u2026\u20260527\u201d\u5c31\u8868\u793a\u6700\u4f4e\u4f4d\u662f 7 \u8fdb\u5236\u6570\u3001\u7b2c 2 \u4f4d\u662f 2 \u8fdb\u5236\u6570\u3001\u7b2c 3 \u4f4d\u662f 5 \u8fdb\u5236\u6570\u3001\u7b2c 4 \u4f4d\u662f 10 \u8fdb\u5236\u6570\uff0c\u7b49\u7b49\u3002\u6bcf\u4e00\u4f4d\u7684\u8fdb\u5236 d \u6216\u8005\u662f 0\uff08\u8868\u793a\u5341\u8fdb\u5236\uff09\u3001\u6216\u8005\u662f [2\uff0c9] \u533a\u95f4\u5185\u7684\u6574\u6570\u3002\u7406\u8bba\u4e0a\u8fd9\u4e2a\u8fdb\u5236\u8868\u5e94\u8be5\u5305\u542b\u65e0\u7a77\u591a\u4f4d\u6570\u5b57\uff0c\u4f46\u4ece\u5b9e\u9645\u5e94\u7528\u51fa\u53d1\uff0cPAT \u661f\u4eba\u901a\u5e38\u53ea\u9700\u8981\u8bb0\u4f4f\u524d 20 \u4f4d\u5c31\u591f\u7528\u4e86\uff0c\u4ee5\u540e\u5404\u4f4d\u9ed8\u8ba4\u4e3a 10 \u8fdb\u5236\u3002 \u5728\u8fd9\u6837\u7684\u6570\u5b57\u7cfb\u7edf\u4e2d\uff0c\u5373\u4f7f\u662f\u7b80\u5355\u7684\u52a0\u6cd5\u8fd0\u7b97\u4e5f\u53d8\u5f97\u4e0d\u7b80\u5355\u3002\u4f8b\u5982\u5bf9\u5e94\u8fdb\u5236\u8868\u201c0527\u201d\uff0c\u8be5\u5982\u4f55\u8ba1\u7b97\u201c6203 + 415\u201d\u5462\uff1f\u6211\u4eec\u5f97\u9996\u5148\u8ba1\u7b97\u6700\u4f4e\u4f4d\uff1a3 + 5 = 8\uff1b\u56e0\u4e3a\u6700\u4f4e\u4f4d\u662f 7 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 1 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 2 \u4f4d\u662f\uff1a0 + 1 + 1\uff08\u8fdb\u4f4d\uff09= 2\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 2 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 0 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 3 \u4f4d\u662f\uff1a2 + 4 + 1\uff08\u8fdb\u4f4d\uff09= 7\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 5 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 2 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 4 \u4f4d\u662f\uff1a6 + 1\uff08\u8fdb\u4f4d\uff09= 7\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 10 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u5f97\u5230 7\u3002\u6700\u540e\u6211\u4eec\u5f97\u5230\uff1a6203 + 415 = 7201\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a N \u4f4d\u7684\u8fdb\u5236\u8868\uff080 < < N \\le \\le 20\uff09\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u968f\u540e\u4e24\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 N \u4f4d\u7684\u975e\u8d1f\u7684 PAT \u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e24\u4e2a PAT \u6570\u4e4b\u548c\u3002 \u8f93\u5165\u6837\u4f8b 30527 06203 415 \u8f93\u51fa\u6837\u4f8b 7201 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { string s , s1 , s2 ; cin >> s >> s1 >> s2 ; int len = s . size (), len1 = s1 . size (), len2 = s2 . size (), i , j , k , a [ 20 ] = { 0 }, b [ 21 ] = { 0 }, num ; for ( i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { a [ j ] = s [ i ] - '0' ; if ( ! a [ j ]) a [ j ] = 10 ; } if ( len1 < len2 ) { len = len2 - len1 ; for ( i = 0 ; i < len ; i ++ ) s1 . insert ( 0 , \"0\" ); } else if ( len1 > len2 ) { len = len1 - len2 ; for ( i = 0 ; i < len ; i ++ ) s2 . insert ( 0 , \"0\" ); } len = max ( len1 , len2 ); for ( i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { num = s1 [ i ] + s2 [ i ] - '0' - '0' ; b [ j ] += num ; b [ j + 1 ] = b [ j ] / a [ j ]; b [ j ] %= a [ j ]; } int flag = 1 ; for ( i = j ; i >= 0 ; i -- ) if ( b [ i ]) break ; for (; i >= 0 ; i -- ) cout << b [ i ], flag = 0 ; if ( flag ) cout << \"0\" ; cout << \" \\n \" ; }","title":"1074-\u5b87\u5b99\u65e0\u654c\u52a0\u6cd5\u5668"},{"location":"PAT-Basic-Level/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8/#1074-\u5b87\u5b99\u65e0\u654c\u52a0\u6cd5\u5668","text":"","title":"1074 \u5b87\u5b99\u65e0\u654c\u52a0\u6cd5\u5668"},{"location":"PAT-Basic-Level/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5730\u7403\u4eba\u4e60\u60ef\u4f7f\u7528\u5341\u8fdb\u5236\u6570\uff0c\u5e76\u4e14\u9ed8\u8ba4\u4e00\u4e2a\u6570\u5b57\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u5341\u8fdb\u5236\u7684\u3002\u800c\u5728 PAT \u661f\u4eba\u5f00\u6302\u7684\u4e16\u754c\u91cc\uff0c\u6bcf\u4e2a\u6570\u5b57\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4e0d\u540c\u8fdb\u5236\u7684\uff0c\u8fd9\u79cd\u795e\u5947\u7684\u6570\u5b57\u79f0\u4e3a\u201cPAT\u6570\u201d\u3002\u6bcf\u4e2a PAT \u661f\u4eba\u90fd\u5fc5\u987b\u719f\u8bb0\u5404\u4f4d\u6570\u5b57\u7684\u8fdb\u5236\u8868\uff0c\u4f8b\u5982\u201c\u2026\u20260527\u201d\u5c31\u8868\u793a\u6700\u4f4e\u4f4d\u662f 7 \u8fdb\u5236\u6570\u3001\u7b2c 2 \u4f4d\u662f 2 \u8fdb\u5236\u6570\u3001\u7b2c 3 \u4f4d\u662f 5 \u8fdb\u5236\u6570\u3001\u7b2c 4 \u4f4d\u662f 10 \u8fdb\u5236\u6570\uff0c\u7b49\u7b49\u3002\u6bcf\u4e00\u4f4d\u7684\u8fdb\u5236 d \u6216\u8005\u662f 0\uff08\u8868\u793a\u5341\u8fdb\u5236\uff09\u3001\u6216\u8005\u662f [2\uff0c9] \u533a\u95f4\u5185\u7684\u6574\u6570\u3002\u7406\u8bba\u4e0a\u8fd9\u4e2a\u8fdb\u5236\u8868\u5e94\u8be5\u5305\u542b\u65e0\u7a77\u591a\u4f4d\u6570\u5b57\uff0c\u4f46\u4ece\u5b9e\u9645\u5e94\u7528\u51fa\u53d1\uff0cPAT \u661f\u4eba\u901a\u5e38\u53ea\u9700\u8981\u8bb0\u4f4f\u524d 20 \u4f4d\u5c31\u591f\u7528\u4e86\uff0c\u4ee5\u540e\u5404\u4f4d\u9ed8\u8ba4\u4e3a 10 \u8fdb\u5236\u3002 \u5728\u8fd9\u6837\u7684\u6570\u5b57\u7cfb\u7edf\u4e2d\uff0c\u5373\u4f7f\u662f\u7b80\u5355\u7684\u52a0\u6cd5\u8fd0\u7b97\u4e5f\u53d8\u5f97\u4e0d\u7b80\u5355\u3002\u4f8b\u5982\u5bf9\u5e94\u8fdb\u5236\u8868\u201c0527\u201d\uff0c\u8be5\u5982\u4f55\u8ba1\u7b97\u201c6203 + 415\u201d\u5462\uff1f\u6211\u4eec\u5f97\u9996\u5148\u8ba1\u7b97\u6700\u4f4e\u4f4d\uff1a3 + 5 = 8\uff1b\u56e0\u4e3a\u6700\u4f4e\u4f4d\u662f 7 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 1 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 2 \u4f4d\u662f\uff1a0 + 1 + 1\uff08\u8fdb\u4f4d\uff09= 2\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 2 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 0 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 3 \u4f4d\u662f\uff1a2 + 4 + 1\uff08\u8fdb\u4f4d\uff09= 7\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 5 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5f97\u5230 2 \u548c 1 \u4e2a\u8fdb\u4f4d\u3002\u7b2c 4 \u4f4d\u662f\uff1a6 + 1\uff08\u8fdb\u4f4d\uff09= 7\uff1b\u56e0\u4e3a\u6b64\u4f4d\u662f 10 \u8fdb\u5236\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u5f97\u5230 7\u3002\u6700\u540e\u6211\u4eec\u5f97\u5230\uff1a6203 + 415 = 7201\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a N \u4f4d\u7684\u8fdb\u5236\u8868\uff080 < < N \\le \\le 20\uff09\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u968f\u540e\u4e24\u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 N \u4f4d\u7684\u975e\u8d1f\u7684 PAT \u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u4e24\u4e2a PAT \u6570\u4e4b\u548c\u3002 \u8f93\u5165\u6837\u4f8b 30527 06203 415 \u8f93\u51fa\u6837\u4f8b 7201","title":"Statement"},{"location":"PAT-Basic-Level/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { string s , s1 , s2 ; cin >> s >> s1 >> s2 ; int len = s . size (), len1 = s1 . size (), len2 = s2 . size (), i , j , k , a [ 20 ] = { 0 }, b [ 21 ] = { 0 }, num ; for ( i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { a [ j ] = s [ i ] - '0' ; if ( ! a [ j ]) a [ j ] = 10 ; } if ( len1 < len2 ) { len = len2 - len1 ; for ( i = 0 ; i < len ; i ++ ) s1 . insert ( 0 , \"0\" ); } else if ( len1 > len2 ) { len = len1 - len2 ; for ( i = 0 ; i < len ; i ++ ) s2 . insert ( 0 , \"0\" ); } len = max ( len1 , len2 ); for ( i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { num = s1 [ i ] + s2 [ i ] - '0' - '0' ; b [ j ] += num ; b [ j + 1 ] = b [ j ] / a [ j ]; b [ j ] %= a [ j ]; } int flag = 1 ; for ( i = j ; i >= 0 ; i -- ) if ( b [ i ]) break ; for (; i >= 0 ; i -- ) cout << b [ i ], flag = 0 ; if ( flag ) cout << \"0\" ; cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/","text":"1075 \u94fe\u8868\u5143\u7d20\u5206\u7c7b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06\u94fe\u8868\u5143\u7d20\u8fdb\u884c\u5206\u7c7b\u6392\u5217\uff0c\u4f7f\u5f97\u6240\u6709\u8d1f\u503c\u5143\u7d20\u90fd\u6392\u5728\u975e\u8d1f\u503c\u5143\u7d20\u7684\u524d\u9762\uff0c\u800c [0, K] \u533a\u95f4\u5185\u7684\u5143\u7d20\u90fd\u6392\u5728\u5927\u4e8e K \u7684\u5143\u7d20\u524d\u9762\u3002\u4f46\u6bcf\u4e00\u7c7b\u5185\u90e8\u5143\u7d20\u7684\u987a\u5e8f\u662f\u4e0d\u80fd\u6539\u53d8\u7684\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a\u94fe\u8868\u4e3a 18\u21927\u2192-4\u21920\u21925\u2192-6\u219210\u219211\u2192-2\uff0cK \u4e3a 10\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a -4\u2192-6\u2192-2\u21927\u21920\u21925\u219210\u219218\u219211\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\uff1a\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\uff1b\u7ed3\u70b9\u603b\u4e2a\u6570\uff0c\u5373\u6b63\u6574\u6570N ( \\le 10^5 \\le 10^5 )\uff1b\u4ee5\u53ca\u6b63\u6574\u6570K ( \\le 10^3 \\le 10^3 )\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff1b Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6570\u636e\uff0c\u4e3a [-10^5, 10^5] [-10^5, 10^5] \u533a\u95f4\u5185\u7684\u6574\u6570\uff1b Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u94fe\u8868\u4e0d\u4e3a\u7a7a\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6309\u94fe\u8868\u4ece\u5934\u5230\u5c3e\u7684\u987a\u5e8f\u8f93\u51fa\u91cd\u6392\u540e\u7684\u7ed3\u679c\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 9 10 23333 10 27777 00000 0 99999 00100 18 12309 68237 -6 23333 33218 -4 00000 48652 -2 -1 99999 5 68237 27777 11 48652 12309 7 33218 \u8f93\u51fa\u6837\u4f8b 33218 -4 68237 68237 -6 48652 48652 -2 12309 12309 7 00000 00000 0 99999 99999 5 23333 23333 10 00100 00100 18 27777 27777 11 -1 Solution C++ #include <bits/stdc++.h> using namespace std ; #define maxn 100000 struct node { int add , data , next , level ; } temp , total [ maxn ]; typedef vector < node > no ; void print ( node x ) { printf ( \"%05d %d %05d \\n \" , x . add , x . data , x . next ); } void print1 ( node x ) { printf ( \"%05d %d -1 \\n \" , x . add , x . data ); } int main () { int first , N , K , len ; cin >> first >> N >> K ; int i , j , k ; map < int , node > vin ; no zero , one , two ; for ( i = 0 ; i < N ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . data , & temp . next ); if ( temp . data < 0 ) temp . level = 0 ; else if ( temp . data <= K ) temp . level = 1 ; else temp . level = 2 ; vin [ temp . add ] = temp ; } int addnext = first ; if ( first == -1 ) cout << \"-1 \\n \" ; else { for (; addnext != -1 ; addnext = vin [ addnext ]. next ) { if ( vin [ addnext ]. level == 0 ) zero . push_back ( vin [ addnext ]); else if ( vin [ addnext ]. level == 1 ) one . push_back ( vin [ addnext ]); else two . push_back ( vin [ addnext ]); } for ( len = zero . size (), i = 0 , j = 0 ; i < len ; i ++ ) total [ j ++ ] = zero [ i ]; for ( len = one . size (), i = 0 ; i < len ; i ++ ) total [ j ++ ] = one [ i ]; for ( len = two . size (), i = 0 ; i < len ; i ++ ) total [ j ++ ] = two [ i ]; for ( i = 0 ; i < j - 1 ; i ++ ) { total [ i ]. next = total [ i + 1 ]. add ; print ( total [ i ]); } print1 ( total [ i ]); } }","title":"1075-\u94fe\u8868\u5143\u7d20\u5206\u7c7b"},{"location":"PAT-Basic-Level/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/#1075-\u94fe\u8868\u5143\u7d20\u5206\u7c7b","text":"","title":"1075 \u94fe\u8868\u5143\u7d20\u5206\u7c7b"},{"location":"PAT-Basic-Level/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06\u94fe\u8868\u5143\u7d20\u8fdb\u884c\u5206\u7c7b\u6392\u5217\uff0c\u4f7f\u5f97\u6240\u6709\u8d1f\u503c\u5143\u7d20\u90fd\u6392\u5728\u975e\u8d1f\u503c\u5143\u7d20\u7684\u524d\u9762\uff0c\u800c [0, K] \u533a\u95f4\u5185\u7684\u5143\u7d20\u90fd\u6392\u5728\u5927\u4e8e K \u7684\u5143\u7d20\u524d\u9762\u3002\u4f46\u6bcf\u4e00\u7c7b\u5185\u90e8\u5143\u7d20\u7684\u987a\u5e8f\u662f\u4e0d\u80fd\u6539\u53d8\u7684\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a\u94fe\u8868\u4e3a 18\u21927\u2192-4\u21920\u21925\u2192-6\u219210\u219211\u2192-2\uff0cK \u4e3a 10\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a -4\u2192-6\u2192-2\u21927\u21920\u21925\u219210\u219218\u219211\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\uff1a\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\uff1b\u7ed3\u70b9\u603b\u4e2a\u6570\uff0c\u5373\u6b63\u6574\u6570N ( \\le 10^5 \\le 10^5 )\uff1b\u4ee5\u53ca\u6b63\u6574\u6570K ( \\le 10^3 \\le 10^3 )\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff1b Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6570\u636e\uff0c\u4e3a [-10^5, 10^5] [-10^5, 10^5] \u533a\u95f4\u5185\u7684\u6574\u6570\uff1b Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u94fe\u8868\u4e0d\u4e3a\u7a7a\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6309\u94fe\u8868\u4ece\u5934\u5230\u5c3e\u7684\u987a\u5e8f\u8f93\u51fa\u91cd\u6392\u540e\u7684\u7ed3\u679c\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 9 10 23333 10 27777 00000 0 99999 00100 18 12309 68237 -6 23333 33218 -4 00000 48652 -2 -1 99999 5 68237 27777 11 48652 12309 7 33218 \u8f93\u51fa\u6837\u4f8b 33218 -4 68237 68237 -6 48652 48652 -2 12309 12309 7 00000 00000 0 99999 99999 5 23333 23333 10 00100 00100 18 27777 27777 11 -1","title":"Statement"},{"location":"PAT-Basic-Level/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define maxn 100000 struct node { int add , data , next , level ; } temp , total [ maxn ]; typedef vector < node > no ; void print ( node x ) { printf ( \"%05d %d %05d \\n \" , x . add , x . data , x . next ); } void print1 ( node x ) { printf ( \"%05d %d -1 \\n \" , x . add , x . data ); } int main () { int first , N , K , len ; cin >> first >> N >> K ; int i , j , k ; map < int , node > vin ; no zero , one , two ; for ( i = 0 ; i < N ; i ++ ) { scanf ( \"%d%d%d\" , & temp . add , & temp . data , & temp . next ); if ( temp . data < 0 ) temp . level = 0 ; else if ( temp . data <= K ) temp . level = 1 ; else temp . level = 2 ; vin [ temp . add ] = temp ; } int addnext = first ; if ( first == -1 ) cout << \"-1 \\n \" ; else { for (; addnext != -1 ; addnext = vin [ addnext ]. next ) { if ( vin [ addnext ]. level == 0 ) zero . push_back ( vin [ addnext ]); else if ( vin [ addnext ]. level == 1 ) one . push_back ( vin [ addnext ]); else two . push_back ( vin [ addnext ]); } for ( len = zero . size (), i = 0 , j = 0 ; i < len ; i ++ ) total [ j ++ ] = zero [ i ]; for ( len = one . size (), i = 0 ; i < len ; i ++ ) total [ j ++ ] = one [ i ]; for ( len = two . size (), i = 0 ; i < len ; i ++ ) total [ j ++ ] = two [ i ]; for ( i = 0 ; i < j - 1 ; i ++ ) { total [ i ]. next = total [ i + 1 ]. add ; print ( total [ i ]); } print1 ( total [ i ]); } }","title":"Solution"},{"location":"PAT-Basic-Level/1076-Wifi%E5%AF%86%E7%A0%81/","text":"1076 Wifi\u5bc6\u7801 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u9762\u662f\u5fae\u535a\u4e0a\u6d41\u4f20\u7684\u4e00\u5f20\u7167\u7247\uff1a\u201c\u5404\u4f4d\u4eb2\u7231\u7684\u540c\u5b66\u4eec\uff0c\u9274\u4e8e\u5927\u5bb6\u6709\u65f6\u9700\u8981\u4f7f\u7528 wifi\uff0c\u53c8\u6015\u803d\u8bef\u4eb2\u4eec\u7684\u5b66\u4e60\uff0c\u73b0\u5c06 wifi \u5bc6\u7801\u8bbe\u7f6e\u4e3a\u4e0b\u5217\u6570\u5b66\u9898\u7b54\u6848\uff1aA-1\uff1bB-2\uff1bC-3\uff1bD-4\uff1b\u8bf7\u540c\u5b66\u4eec\u81ea\u5df1\u4f5c\u7b54\uff0c\u6bcf\u4e24\u65e5\u4e00\u6362\u3002\u8c22\u8c22\u5408\u4f5c\uff01\uff01~\u201d\u2014\u2014 \u8001\u5e08\u4eec\u4e3a\u4e86\u4fc3\u8fdb\u5b66\u751f\u5b66\u4e60\u4e5f\u662f\u62fc\u4e86\u2026\u2026 \u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u7a0b\u5e8f\u628a\u4e00\u7cfb\u5217\u9898\u76ee\u7684\u7b54\u6848\u6309\u7167\u5377\u5b50\u4e0a\u7ed9\u51fa\u7684\u5bf9\u5e94\u5173\u7cfb\u7ffb\u8bd1\u6210 wifi \u7684\u5bc6\u7801\u3002\u8fd9\u91cc\u7b80\u5355\u5047\u8bbe\u6bcf\u9053\u9009\u62e9\u9898\u90fd\u6709 4 \u4e2a\u9009\u9879\uff0c\u6709\u4e14\u53ea\u6709 1 \u4e2a\u6b63\u786e\u7b54\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u7167 \u7f16\u53f7-\u7b54\u6848 \u7684\u683c\u5f0f\u7ed9\u51fa\u4e00\u9053\u9898\u7684 4 \u4e2a\u9009\u9879\uff0c T \u8868\u793a\u6b63\u786e\u9009\u9879\uff0c F \u8868\u793a\u9519\u8bef\u9009\u9879\u3002\u9009\u9879\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa wifi \u5bc6\u7801\u3002 \u8f93\u5165\u6837\u4f8b 8 A-T B-F C-F D-F C-T B-F A-F D-F A-F D-F C-F B-T B-T A-F C-F D-F B-F D-T A-F C-F A-T C-F B-F D-F D-T B-F C-F A-F C-T A-F B-F D-F \u8f93\u51fa\u6837\u4f8b 13224143 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 char c [ 4 ][ 4 ]; int n [ MAXN ]; int main () { int n1 ; cin >> n1 ; int i , j , k = 0 ; for ( i = 0 ; i < n1 ; i ++ ) { cin >> c [ 0 ] >> c [ 1 ] >> c [ 2 ] >> c [ 3 ]; for ( j = 0 ; j < 4 ; j ++ ) { if ( c [ j ][ 2 ] == 'T' ) { n [ k ++ ] = c [ j ][ 0 ] - 64 ; } } } for ( i = 0 ; i < k ; i ++ ) cout << n [ i ]; cout << \" \\n \" ; }","title":"1076-Wifi\u5bc6\u7801"},{"location":"PAT-Basic-Level/1076-Wifi%E5%AF%86%E7%A0%81/#1076-wifi\u5bc6\u7801","text":"","title":"1076 Wifi\u5bc6\u7801"},{"location":"PAT-Basic-Level/1076-Wifi%E5%AF%86%E7%A0%81/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4e0b\u9762\u662f\u5fae\u535a\u4e0a\u6d41\u4f20\u7684\u4e00\u5f20\u7167\u7247\uff1a\u201c\u5404\u4f4d\u4eb2\u7231\u7684\u540c\u5b66\u4eec\uff0c\u9274\u4e8e\u5927\u5bb6\u6709\u65f6\u9700\u8981\u4f7f\u7528 wifi\uff0c\u53c8\u6015\u803d\u8bef\u4eb2\u4eec\u7684\u5b66\u4e60\uff0c\u73b0\u5c06 wifi \u5bc6\u7801\u8bbe\u7f6e\u4e3a\u4e0b\u5217\u6570\u5b66\u9898\u7b54\u6848\uff1aA-1\uff1bB-2\uff1bC-3\uff1bD-4\uff1b\u8bf7\u540c\u5b66\u4eec\u81ea\u5df1\u4f5c\u7b54\uff0c\u6bcf\u4e24\u65e5\u4e00\u6362\u3002\u8c22\u8c22\u5408\u4f5c\uff01\uff01~\u201d\u2014\u2014 \u8001\u5e08\u4eec\u4e3a\u4e86\u4fc3\u8fdb\u5b66\u751f\u5b66\u4e60\u4e5f\u662f\u62fc\u4e86\u2026\u2026 \u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u7a0b\u5e8f\u628a\u4e00\u7cfb\u5217\u9898\u76ee\u7684\u7b54\u6848\u6309\u7167\u5377\u5b50\u4e0a\u7ed9\u51fa\u7684\u5bf9\u5e94\u5173\u7cfb\u7ffb\u8bd1\u6210 wifi \u7684\u5bc6\u7801\u3002\u8fd9\u91cc\u7b80\u5355\u5047\u8bbe\u6bcf\u9053\u9009\u62e9\u9898\u90fd\u6709 4 \u4e2a\u9009\u9879\uff0c\u6709\u4e14\u53ea\u6709 1 \u4e2a\u6b63\u786e\u7b54\u6848\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u7167 \u7f16\u53f7-\u7b54\u6848 \u7684\u683c\u5f0f\u7ed9\u51fa\u4e00\u9053\u9898\u7684 4 \u4e2a\u9009\u9879\uff0c T \u8868\u793a\u6b63\u786e\u9009\u9879\uff0c F \u8868\u793a\u9519\u8bef\u9009\u9879\u3002\u9009\u9879\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa wifi \u5bc6\u7801\u3002 \u8f93\u5165\u6837\u4f8b 8 A-T B-F C-F D-F C-T B-F A-F D-F A-F D-F C-F B-T B-T A-F C-F D-F B-F D-T A-F C-F A-T C-F B-F D-F D-T B-F C-F A-F C-T A-F B-F D-F \u8f93\u51fa\u6837\u4f8b 13224143","title":"Statement"},{"location":"PAT-Basic-Level/1076-Wifi%E5%AF%86%E7%A0%81/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 char c [ 4 ][ 4 ]; int n [ MAXN ]; int main () { int n1 ; cin >> n1 ; int i , j , k = 0 ; for ( i = 0 ; i < n1 ; i ++ ) { cin >> c [ 0 ] >> c [ 1 ] >> c [ 2 ] >> c [ 3 ]; for ( j = 0 ; j < 4 ; j ++ ) { if ( c [ j ][ 2 ] == 'T' ) { n [ k ++ ] = c [ j ][ 0 ] - 64 ; } } } for ( i = 0 ; i < k ; i ++ ) cout << n [ i ]; cout << \" \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1077-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97/","text":"1077 \u4e92\u8bc4\u6210\u7ee9\u8ba1\u7b97 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u6d59\u5927\u7684\u8ba1\u7b97\u673a\u4e13\u4e1a\u8bfe\u4e2d\uff0c\u7ecf\u5e38\u6709\u4e92\u8bc4\u5206\u7ec4\u62a5\u544a\u8fd9\u4e2a\u73af\u8282\u3002\u4e00\u4e2a\u7ec4\u4e0a\u53f0\u4ecb\u7ecd\u81ea\u5df1\u7684\u5de5\u4f5c\uff0c\u5176\u4ed6\u7ec4\u5728\u53f0\u4e0b\u4e3a\u5176\u8868\u73b0\u8bc4\u5206\u3002\u6700\u540e\u8fd9\u4e2a\u7ec4\u7684\u4e92\u8bc4\u6210\u7ee9\u662f\u8fd9\u6837\u8ba1\u7b97\u7684\uff1a\u6240\u6709\u5176\u4ed6\u7ec4\u7684\u8bc4\u5206\u4e2d\uff0c\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u4e00\u4e2a\u6700\u4f4e\u5206\uff0c\u5269\u4e0b\u7684\u5206\u6570\u53d6\u5e73\u5747\u5206\u8bb0\u4e3a G_1 G_1 \uff1b\u8001\u5e08\u7ed9\u8fd9\u4e2a\u7ec4\u7684\u8bc4\u5206\u8bb0\u4e3a G_2 G_2 \u3002\u8be5\u7ec4\u5f97\u5206\u4e3a (G_1+G_2)/2 (G_1+G_2)/2 \uff0c\u6700\u540e\u7ed3\u679c\u56db\u820d\u4e94\u5165\u540e\u4fdd\u7559\u6574\u6570\u5206\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u8ba1\u7b97\u6bcf\u4e2a\u7ec4\u7684\u4e92\u8bc4\u6210\u7ee9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 > > 3\uff09\u548c M M \uff0c\u5206\u522b\u662f\u5206\u7ec4\u6570\u548c\u6ee1\u5206\uff0c\u5747\u4e0d\u8d85\u8fc7 100\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u8be5\u7ec4\u5f97\u5230\u7684 N N \u4e2a\u5206\u6570\uff08\u5747\u4fdd\u8bc1\u4e3a\u6574\u578b\u8303\u56f4\u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u4e2d\u7b2c 1 \u4e2a\u662f\u8001\u5e08\u7ed9\u51fa\u7684\u8bc4\u5206\uff0c\u540e\u9762 N-1 N-1 \u4e2a\u662f\u5176\u4ed6\u7ec4\u7ed9\u7684\u8bc4\u5206\u3002\u5408\u6cd5\u7684\u8f93\u5165\u5e94\u8be5\u662f [0, M] [0, M] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u82e5\u4e0d\u5728\u5408\u6cd5\u533a\u95f4\u5185\uff0c\u5219\u8be5\u5206\u6570\u987b\u88ab\u5ffd\u7565\u3002\u9898\u76ee\u4fdd\u8bc1\u8001\u5e08\u7684\u8bc4\u5206\u90fd\u662f\u5408\u6cd5\u7684\uff0c\u5e76\u4e14\u6bcf\u4e2a\u7ec4\u81f3\u5c11\u4f1a\u6709 3 \u4e2a\u6765\u81ea\u540c\u5b66\u7684\u5408\u6cd5\u8bc4\u5206\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u6bcf\u4e2a\u7ec4\u8f93\u51fa\u5176\u6700\u7ec8\u5f97\u5206\u3002\u6bcf\u4e2a\u5f97\u5206\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 6 50 42 49 49 35 38 41 36 51 50 28 -1 30 40 36 41 33 47 49 30 250 -25 27 45 31 48 0 0 50 50 1234 43 41 36 29 42 29 \u8f93\u51fa\u6837\u4f8b 42 33 41 31 37 39 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int n [ MAXN ][ MAXN ]; int main () { int N , M ; cin >> N >> M ; int i , j , k , l ; int a , b ; for ( i = 0 ; i < N ; i ++ ) { cin >> b ; for ( j = 0 , k = 0 ; j < N - 1 ; j ++ ) { cin >> a ; if ( a >= 0 && a <= M ) n [ i ][ k ++ ] = a ; } sort ( n [ i ], n [ i ] + k ); int total = 0 ; for ( l = 1 ; l < k - 1 ; l ++ ) { total += n [ i ][ l ]; } total /= ( k - 2 ); printf ( \"%d \\n \" , ( int )(( total + b ) * 1.0 / 2.0 + 0.5 )); } }","title":"1077-\u4e92\u8bc4\u6210\u7ee9\u8ba1\u7b97"},{"location":"PAT-Basic-Level/1077-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97/#1077-\u4e92\u8bc4\u6210\u7ee9\u8ba1\u7b97","text":"","title":"1077 \u4e92\u8bc4\u6210\u7ee9\u8ba1\u7b97"},{"location":"PAT-Basic-Level/1077-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5728\u6d59\u5927\u7684\u8ba1\u7b97\u673a\u4e13\u4e1a\u8bfe\u4e2d\uff0c\u7ecf\u5e38\u6709\u4e92\u8bc4\u5206\u7ec4\u62a5\u544a\u8fd9\u4e2a\u73af\u8282\u3002\u4e00\u4e2a\u7ec4\u4e0a\u53f0\u4ecb\u7ecd\u81ea\u5df1\u7684\u5de5\u4f5c\uff0c\u5176\u4ed6\u7ec4\u5728\u53f0\u4e0b\u4e3a\u5176\u8868\u73b0\u8bc4\u5206\u3002\u6700\u540e\u8fd9\u4e2a\u7ec4\u7684\u4e92\u8bc4\u6210\u7ee9\u662f\u8fd9\u6837\u8ba1\u7b97\u7684\uff1a\u6240\u6709\u5176\u4ed6\u7ec4\u7684\u8bc4\u5206\u4e2d\uff0c\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u4e00\u4e2a\u6700\u4f4e\u5206\uff0c\u5269\u4e0b\u7684\u5206\u6570\u53d6\u5e73\u5747\u5206\u8bb0\u4e3a G_1 G_1 \uff1b\u8001\u5e08\u7ed9\u8fd9\u4e2a\u7ec4\u7684\u8bc4\u5206\u8bb0\u4e3a G_2 G_2 \u3002\u8be5\u7ec4\u5f97\u5206\u4e3a (G_1+G_2)/2 (G_1+G_2)/2 \uff0c\u6700\u540e\u7ed3\u679c\u56db\u820d\u4e94\u5165\u540e\u4fdd\u7559\u6574\u6570\u5206\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5199\u4e2a\u7a0b\u5e8f\u5e2e\u52a9\u8001\u5e08\u8ba1\u7b97\u6bcf\u4e2a\u7ec4\u7684\u4e92\u8bc4\u6210\u7ee9\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 > > 3\uff09\u548c M M \uff0c\u5206\u522b\u662f\u5206\u7ec4\u6570\u548c\u6ee1\u5206\uff0c\u5747\u4e0d\u8d85\u8fc7 100\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u8be5\u7ec4\u5f97\u5230\u7684 N N \u4e2a\u5206\u6570\uff08\u5747\u4fdd\u8bc1\u4e3a\u6574\u578b\u8303\u56f4\u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u4e2d\u7b2c 1 \u4e2a\u662f\u8001\u5e08\u7ed9\u51fa\u7684\u8bc4\u5206\uff0c\u540e\u9762 N-1 N-1 \u4e2a\u662f\u5176\u4ed6\u7ec4\u7ed9\u7684\u8bc4\u5206\u3002\u5408\u6cd5\u7684\u8f93\u5165\u5e94\u8be5\u662f [0, M] [0, M] \u533a\u95f4\u5185\u7684\u6574\u6570\uff0c\u82e5\u4e0d\u5728\u5408\u6cd5\u533a\u95f4\u5185\uff0c\u5219\u8be5\u5206\u6570\u987b\u88ab\u5ffd\u7565\u3002\u9898\u76ee\u4fdd\u8bc1\u8001\u5e08\u7684\u8bc4\u5206\u90fd\u662f\u5408\u6cd5\u7684\uff0c\u5e76\u4e14\u6bcf\u4e2a\u7ec4\u81f3\u5c11\u4f1a\u6709 3 \u4e2a\u6765\u81ea\u540c\u5b66\u7684\u5408\u6cd5\u8bc4\u5206\u3002 \u8f93\u51fa\u683c\u5f0f \u4e3a\u6bcf\u4e2a\u7ec4\u8f93\u51fa\u5176\u6700\u7ec8\u5f97\u5206\u3002\u6bcf\u4e2a\u5f97\u5206\u5360\u4e00\u884c\u3002 \u8f93\u5165\u6837\u4f8b 6 50 42 49 49 35 38 41 36 51 50 28 -1 30 40 36 41 33 47 49 30 250 -25 27 45 31 48 0 0 50 50 1234 43 41 36 29 42 29 \u8f93\u51fa\u6837\u4f8b 42 33 41 31 37 39","title":"Statement"},{"location":"PAT-Basic-Level/1077-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 100 int n [ MAXN ][ MAXN ]; int main () { int N , M ; cin >> N >> M ; int i , j , k , l ; int a , b ; for ( i = 0 ; i < N ; i ++ ) { cin >> b ; for ( j = 0 , k = 0 ; j < N - 1 ; j ++ ) { cin >> a ; if ( a >= 0 && a <= M ) n [ i ][ k ++ ] = a ; } sort ( n [ i ], n [ i ] + k ); int total = 0 ; for ( l = 1 ; l < k - 1 ; l ++ ) { total += n [ i ][ l ]; } total /= ( k - 2 ); printf ( \"%d \\n \" , ( int )(( total + b ) * 1.0 / 2.0 + 0.5 )); } }","title":"Solution"},{"location":"PAT-Basic-Level/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/","text":"1078 \u5b57\u7b26\u4e32\u538b\u7f29\u4e0e\u89e3\u538b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6587\u672c\u538b\u7f29\u6709\u5f88\u591a\u79cd\u65b9\u6cd5\uff0c\u8fd9\u91cc\u6211\u4eec\u53ea\u8003\u8651\u6700\u7b80\u5355\u7684\u4e00\u79cd\uff1a\u628a\u7531\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u4e00\u4e2a\u8fde\u7eed\u7684\u7247\u6bb5\u7528\u8fd9\u4e2a\u5b57\u7b26\u548c\u7247\u6bb5\u4e2d\u542b\u6709\u8fd9\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\u6765\u8868\u793a\u3002\u4f8b\u5982 ccccc \u5c31\u7528 5c \u6765\u8868\u793a\u3002\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u91cd\u590d\uff0c\u5c31\u539f\u6837\u8f93\u51fa\u3002\u4f8b\u5982 aba \u538b\u7f29\u540e\u4ecd\u7136\u662f aba \u3002 \u89e3\u538b\u65b9\u6cd5\u5c31\u662f\u53cd\u8fc7\u6765\uff0c\u628a\u5f62\u5982 5c \u8fd9\u6837\u7684\u8868\u793a\u6062\u590d\u4e3a ccccc \u3002 \u672c\u9898\u9700\u8981\u4f60\u6839\u636e\u538b\u7f29\u6216\u89e3\u538b\u7684\u8981\u6c42\uff0c\u5bf9\u7ed9\u5b9a\u5b57\u7b26\u4e32\u8fdb\u884c\u5904\u7406\u3002\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u5730\u5047\u8bbe\u539f\u59cb\u5b57\u7b26\u4e32\u662f\u5b8c\u5168\u7531\u82f1\u6587\u5b57\u6bcd\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\uff0c\u5982\u679c\u662f C \u5c31\u8868\u793a\u4e0b\u9762\u7684\u5b57\u7b26\u4e32\u9700\u8981\u88ab\u538b\u7f29\uff1b\u5982\u679c\u662f D \u5c31\u8868\u793a\u4e0b\u9762\u7684\u5b57\u7b26\u4e32\u9700\u8981\u88ab\u89e3\u538b\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u9700\u8981\u88ab\u538b\u7f29\u6216\u89e3\u538b\u7684\u4e0d\u8d85\u8fc7 1000 \u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u5c3e\u3002\u9898\u76ee\u4fdd\u8bc1\u5b57\u7b26\u91cd\u590d\u4e2a\u6570\u5728\u6574\u578b\u8303\u56f4\u5185\uff0c\u4e14\u8f93\u51fa\u6587\u4ef6\u4e0d\u8d85\u8fc7 1MB\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8981\u6c42\u538b\u7f29\u6216\u89e3\u538b\u5b57\u7b26\u4e32\uff0c\u5e76\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 1 C TTTTThhiiiis isssss a tesssst CAaaa as \u8f93\u51fa\u6837\u4f8b 1 5T2h4is i5s a3 te4st CA3a as \u8f93\u5165\u6837\u4f8b 2 D 5T2h4is i5s a3 te4st CA3a as10Z \u8f93\u51fa\u6837\u4f8b 2 TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ Solution C++ #include <cmath> #include <iostream> using namespace std ; int tran ( string s ) { int i , len = s . size (), j = pow ( 10 , len - 1 ), num = 0 ; for ( i = 0 ; i < len ; i ++ , j /= 10 ) num += ( s [ i ] - '0' ) * j ; return num ; } string tran1 ( int x ) { string s = \"\" , s1 ; if ( x ) { while ( x ) { s1 = x % 10 + '0' ; s += s1 ; x /= 10 ; } } else s = \"0\" ; return s ; } int main () { string s , s1 ; char c ; int len ; cin >> c ; getchar (); getline ( cin , s ); len = s . size (); int i , j = 0 , k , n = 0 , num = 0 , a ; if ( c == 'C' ) { s1 = \"\" ; for ( i = len - 1 ; i >= 0 ; i -= num ) { s1 += s [ i ]; num = 1 ; if ( s [ i - 1 ] == s [ i ] && i ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( s [ j ] == s [ i ]) { num ++ ; } else { break ; } } s1 += tran1 ( num ); } } len = s1 . size (); for ( k = len - 1 ; k >= 0 ; k -- ) { cout << s1 [ k ]; } cout << endl ; } else if ( c == 'D' ) { for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= 48 && s [ i ] <= 57 ) { s1 = \"\" ; for ( k = i ; k < len ; k ++ ) { if ( s [ k ] >= 48 && s [ k ] <= 57 ) s1 += s [ k ]; else break ; } i = k , a = tran ( s1 ); for ( j = 1 ; j < a ; j ++ ) { cout << s [ i ]; } i -- ; } else { cout << s [ i ]; } } cout << endl ; } }","title":"1078-\u5b57\u7b26\u4e32\u538b\u7f29\u4e0e\u89e3\u538b"},{"location":"PAT-Basic-Level/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/#1078-\u5b57\u7b26\u4e32\u538b\u7f29\u4e0e\u89e3\u538b","text":"","title":"1078 \u5b57\u7b26\u4e32\u538b\u7f29\u4e0e\u89e3\u538b"},{"location":"PAT-Basic-Level/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6587\u672c\u538b\u7f29\u6709\u5f88\u591a\u79cd\u65b9\u6cd5\uff0c\u8fd9\u91cc\u6211\u4eec\u53ea\u8003\u8651\u6700\u7b80\u5355\u7684\u4e00\u79cd\uff1a\u628a\u7531\u76f8\u540c\u5b57\u7b26\u7ec4\u6210\u7684\u4e00\u4e2a\u8fde\u7eed\u7684\u7247\u6bb5\u7528\u8fd9\u4e2a\u5b57\u7b26\u548c\u7247\u6bb5\u4e2d\u542b\u6709\u8fd9\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\u6765\u8868\u793a\u3002\u4f8b\u5982 ccccc \u5c31\u7528 5c \u6765\u8868\u793a\u3002\u5982\u679c\u5b57\u7b26\u6ca1\u6709\u91cd\u590d\uff0c\u5c31\u539f\u6837\u8f93\u51fa\u3002\u4f8b\u5982 aba \u538b\u7f29\u540e\u4ecd\u7136\u662f aba \u3002 \u89e3\u538b\u65b9\u6cd5\u5c31\u662f\u53cd\u8fc7\u6765\uff0c\u628a\u5f62\u5982 5c \u8fd9\u6837\u7684\u8868\u793a\u6062\u590d\u4e3a ccccc \u3002 \u672c\u9898\u9700\u8981\u4f60\u6839\u636e\u538b\u7f29\u6216\u89e3\u538b\u7684\u8981\u6c42\uff0c\u5bf9\u7ed9\u5b9a\u5b57\u7b26\u4e32\u8fdb\u884c\u5904\u7406\u3002\u8fd9\u91cc\u6211\u4eec\u7b80\u5355\u5730\u5047\u8bbe\u539f\u59cb\u5b57\u7b26\u4e32\u662f\u5b8c\u5168\u7531\u82f1\u6587\u5b57\u6bcd\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\uff0c\u5982\u679c\u662f C \u5c31\u8868\u793a\u4e0b\u9762\u7684\u5b57\u7b26\u4e32\u9700\u8981\u88ab\u538b\u7f29\uff1b\u5982\u679c\u662f D \u5c31\u8868\u793a\u4e0b\u9762\u7684\u5b57\u7b26\u4e32\u9700\u8981\u88ab\u89e3\u538b\u3002\u7b2c\u4e8c\u884c\u7ed9\u51fa\u9700\u8981\u88ab\u538b\u7f29\u6216\u89e3\u538b\u7684\u4e0d\u8d85\u8fc7 1000 \u4e2a\u5b57\u7b26\u7684\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u5c3e\u3002\u9898\u76ee\u4fdd\u8bc1\u5b57\u7b26\u91cd\u590d\u4e2a\u6570\u5728\u6574\u578b\u8303\u56f4\u5185\uff0c\u4e14\u8f93\u51fa\u6587\u4ef6\u4e0d\u8d85\u8fc7 1MB\u3002 \u8f93\u51fa\u683c\u5f0f \u6839\u636e\u8981\u6c42\u538b\u7f29\u6216\u89e3\u538b\u5b57\u7b26\u4e32\uff0c\u5e76\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 1 C TTTTThhiiiis isssss a tesssst CAaaa as \u8f93\u51fa\u6837\u4f8b 1 5T2h4is i5s a3 te4st CA3a as \u8f93\u5165\u6837\u4f8b 2 D 5T2h4is i5s a3 te4st CA3a as10Z \u8f93\u51fa\u6837\u4f8b 2 TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ","title":"Statement"},{"location":"PAT-Basic-Level/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/#solution","text":"C++ #include <cmath> #include <iostream> using namespace std ; int tran ( string s ) { int i , len = s . size (), j = pow ( 10 , len - 1 ), num = 0 ; for ( i = 0 ; i < len ; i ++ , j /= 10 ) num += ( s [ i ] - '0' ) * j ; return num ; } string tran1 ( int x ) { string s = \"\" , s1 ; if ( x ) { while ( x ) { s1 = x % 10 + '0' ; s += s1 ; x /= 10 ; } } else s = \"0\" ; return s ; } int main () { string s , s1 ; char c ; int len ; cin >> c ; getchar (); getline ( cin , s ); len = s . size (); int i , j = 0 , k , n = 0 , num = 0 , a ; if ( c == 'C' ) { s1 = \"\" ; for ( i = len - 1 ; i >= 0 ; i -= num ) { s1 += s [ i ]; num = 1 ; if ( s [ i - 1 ] == s [ i ] && i ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( s [ j ] == s [ i ]) { num ++ ; } else { break ; } } s1 += tran1 ( num ); } } len = s1 . size (); for ( k = len - 1 ; k >= 0 ; k -- ) { cout << s1 [ k ]; } cout << endl ; } else if ( c == 'D' ) { for ( i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= 48 && s [ i ] <= 57 ) { s1 = \"\" ; for ( k = i ; k < len ; k ++ ) { if ( s [ k ] >= 48 && s [ k ] <= 57 ) s1 += s [ k ]; else break ; } i = k , a = tran ( s1 ); for ( j = 1 ; j < a ; j ++ ) { cout << s [ i ]; } i -- ; } else { cout << s [ i ]; } } cout << endl ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/","text":"1079 \u5ef6\u8fdf\u7684\u56de\u6587\u6570 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k+1 k+1 \u4f4d\u7684\u6b63\u6574\u6570 N N \uff0c\u5199\u6210 a_k \\cdots a_1 a_0 a_k \\cdots a_1 a_0 \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d\u5bf9\u6240\u6709 i i \u6709 0 \\le a_i < 10 0 \\le a_i < 10 \u4e14 a_k > 0 a_k > 0 \u3002 N N \u88ab\u79f0\u4e3a\u4e00\u4e2a \u56de\u6587\u6570 \uff0c\u5f53\u4e14\u4ec5\u5f53\u5bf9\u6240\u6709 i i \u6709 a_i = a_{k-i} a_i = a_{k-i} \u3002\u96f6\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u56de\u6587\u6570\u3002 \u975e\u56de\u6587\u6570\u4e5f\u53ef\u4ee5\u901a\u8fc7\u4e00\u7cfb\u5217\u64cd\u4f5c\u53d8\u51fa\u56de\u6587\u6570\u3002\u9996\u5148\u5c06\u8be5\u6570\u5b57\u9006\u8f6c\uff0c\u518d\u5c06\u9006\u8f6c\u6570\u4e0e\u8be5\u6570\u76f8\u52a0\uff0c\u5982\u679c\u548c\u8fd8\u4e0d\u662f\u4e00\u4e2a\u56de\u6587\u6570\uff0c\u5c31\u91cd\u590d\u8fd9\u4e2a\u9006\u8f6c\u518d\u76f8\u52a0\u7684\u64cd\u4f5c\uff0c\u76f4\u5230\u4e00\u4e2a\u56de\u6587\u6570\u51fa\u73b0\u3002\u5982\u679c\u4e00\u4e2a\u975e\u56de\u6587\u6570\u53ef\u4ee5\u53d8\u51fa\u56de\u6587\u6570\uff0c\u5c31\u79f0\u8fd9\u4e2a\u6570\u4e3a \u5ef6\u8fdf\u7684\u56de\u6587\u6570 \u3002\uff08\u5b9a\u4e49\u7ffb\u8bd1\u81ea https://en.wikipedia.org/wiki/Palindromic_number \uff09 \u7ed9\u5b9a\u4efb\u610f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u672c\u9898\u8981\u6c42\u4f60\u627e\u5230\u5176\u53d8\u51fa\u7684\u90a3\u4e2a\u56de\u6587\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc71000\u4f4d\u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7ed9\u5b9a\u7684\u6574\u6570\uff0c\u4e00\u884c\u4e00\u884c\u8f93\u51fa\u5176\u53d8\u51fa\u56de\u6587\u6570\u7684\u8fc7\u7a0b\u3002\u6bcf\u884c\u683c\u5f0f\u5982\u4e0b A + B = C \u5176\u4e2d A \u662f\u539f\u59cb\u7684\u6570\u5b57\uff0c B \u662f A \u7684\u9006\u8f6c\u6570\uff0c C \u662f\u5b83\u4eec\u7684\u548c\u3002 A \u4ece\u8f93\u5165\u7684\u6574\u6570\u5f00\u59cb\u3002\u91cd\u590d\u64cd\u4f5c\u76f4\u5230 C \u5728 10 \u6b65\u4ee5\u5185\u53d8\u6210\u56de\u6587\u6570\uff0c\u8fd9\u65f6\u5728\u4e00\u884c\u4e2d\u8f93\u51fa C is a palindromic number. \uff1b\u6216\u8005\u5982\u679c 10 \u6b65\u90fd\u6ca1\u80fd\u5f97\u5230\u56de\u6587\u6570\uff0c\u6700\u540e\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Not found in 10 iterations. \u3002 \u8f93\u5165\u6837\u4f8b 1 97152 \u8f93\u51fa\u6837\u4f8b 1 97152 + 25179 = 122331 122331 + 133221 = 255552 255552 is a palindromic number. \u8f93\u5165\u6837\u4f8b 2 196 \u8f93\u51fa\u6837\u4f8b 2 196 + 691 = 887 887 + 788 = 1675 1675 + 5761 = 7436 7436 + 6347 = 13783 13783 + 38731 = 52514 52514 + 41525 = 94039 94039 + 93049 = 187088 187088 + 880781 = 1067869 1067869 + 9687601 = 10755470 10755470 + 07455701 = 18211171 Not found in 10 iterations. Solution C++ #include <bits/stdc++.h> using namespace std ; string add ( string s1 , string s2 ) { if ( s1 == \"\" && s2 == \"\" ) return \"0\" ; if ( s1 == \"\" ) return s2 ; if ( s2 == \"\" ) return s1 ; string maxx = s1 , minn = s2 ; if ( s1 . length () < s2 . length ()) { maxx = s2 ; minn = s1 ; } int a = maxx . length () - 1 , b = minn . length () - 1 ; for ( int i = b ; i >= 0 ; -- i ) { maxx [ a -- ] += minn [ i ] - '0' ; } for ( int i = maxx . length () - 1 ; i > 0 ; -- i ) { if ( maxx [ i ] > '9' ) { maxx [ i ] -= 10 ; maxx [ i - 1 ] ++ ; } } if ( maxx [ 0 ] > '9' ) { maxx [ 0 ] -= 10 ; maxx = '1' + maxx ; } return maxx ; } int f ( string s ) { int i , j , len = s . size (), m ; if ( len % 2 ) m = ( len - 1 ) / 2 ; else m = len / 2 ; for ( i = 0 , j = len - 1 ; i < m ; i ++ , j -- ) { if ( s [ i ] != s [ j ]) return 0 ; } return 1 ; } string tran ( string s ) { int i , len = s . size (); string s1 = \"\" ; for ( i = len - 1 ; i >= 0 ; i -- ) { s1 += s [ i ]; } return s1 ; } int main () { string s , s1 ; cin >> s ; int len = s . size (), i ; if ( f ( s )) { cout << s << \" is a palindromic number. \\n \" ; return 0 ; } for ( i = 0 ; i < 10 ; i ++ ) { s1 = tran ( s ); cout << s << \" + \" << s1 << \" = \" ; s = add ( s , s1 ); cout << s << endl ; if ( f ( s )) { cout << s << \" is a palindromic number. \\n \" ; return 0 ; } } cout << \"Not found in 10 iterations. \\n \" ; }","title":"1079-\u5ef6\u8fdf\u7684\u56de\u6587\u6570"},{"location":"PAT-Basic-Level/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/#1079-\u5ef6\u8fdf\u7684\u56de\u6587\u6570","text":"","title":"1079 \u5ef6\u8fdf\u7684\u56de\u6587\u6570"},{"location":"PAT-Basic-Level/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a k+1 k+1 \u4f4d\u7684\u6b63\u6574\u6570 N N \uff0c\u5199\u6210 a_k \\cdots a_1 a_0 a_k \\cdots a_1 a_0 \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d\u5bf9\u6240\u6709 i i \u6709 0 \\le a_i < 10 0 \\le a_i < 10 \u4e14 a_k > 0 a_k > 0 \u3002 N N \u88ab\u79f0\u4e3a\u4e00\u4e2a \u56de\u6587\u6570 \uff0c\u5f53\u4e14\u4ec5\u5f53\u5bf9\u6240\u6709 i i \u6709 a_i = a_{k-i} a_i = a_{k-i} \u3002\u96f6\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u56de\u6587\u6570\u3002 \u975e\u56de\u6587\u6570\u4e5f\u53ef\u4ee5\u901a\u8fc7\u4e00\u7cfb\u5217\u64cd\u4f5c\u53d8\u51fa\u56de\u6587\u6570\u3002\u9996\u5148\u5c06\u8be5\u6570\u5b57\u9006\u8f6c\uff0c\u518d\u5c06\u9006\u8f6c\u6570\u4e0e\u8be5\u6570\u76f8\u52a0\uff0c\u5982\u679c\u548c\u8fd8\u4e0d\u662f\u4e00\u4e2a\u56de\u6587\u6570\uff0c\u5c31\u91cd\u590d\u8fd9\u4e2a\u9006\u8f6c\u518d\u76f8\u52a0\u7684\u64cd\u4f5c\uff0c\u76f4\u5230\u4e00\u4e2a\u56de\u6587\u6570\u51fa\u73b0\u3002\u5982\u679c\u4e00\u4e2a\u975e\u56de\u6587\u6570\u53ef\u4ee5\u53d8\u51fa\u56de\u6587\u6570\uff0c\u5c31\u79f0\u8fd9\u4e2a\u6570\u4e3a \u5ef6\u8fdf\u7684\u56de\u6587\u6570 \u3002\uff08\u5b9a\u4e49\u7ffb\u8bd1\u81ea https://en.wikipedia.org/wiki/Palindromic_number \uff09 \u7ed9\u5b9a\u4efb\u610f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u672c\u9898\u8981\u6c42\u4f60\u627e\u5230\u5176\u53d8\u51fa\u7684\u90a3\u4e2a\u56de\u6587\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc71000\u4f4d\u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u7ed9\u5b9a\u7684\u6574\u6570\uff0c\u4e00\u884c\u4e00\u884c\u8f93\u51fa\u5176\u53d8\u51fa\u56de\u6587\u6570\u7684\u8fc7\u7a0b\u3002\u6bcf\u884c\u683c\u5f0f\u5982\u4e0b A + B = C \u5176\u4e2d A \u662f\u539f\u59cb\u7684\u6570\u5b57\uff0c B \u662f A \u7684\u9006\u8f6c\u6570\uff0c C \u662f\u5b83\u4eec\u7684\u548c\u3002 A \u4ece\u8f93\u5165\u7684\u6574\u6570\u5f00\u59cb\u3002\u91cd\u590d\u64cd\u4f5c\u76f4\u5230 C \u5728 10 \u6b65\u4ee5\u5185\u53d8\u6210\u56de\u6587\u6570\uff0c\u8fd9\u65f6\u5728\u4e00\u884c\u4e2d\u8f93\u51fa C is a palindromic number. \uff1b\u6216\u8005\u5982\u679c 10 \u6b65\u90fd\u6ca1\u80fd\u5f97\u5230\u56de\u6587\u6570\uff0c\u6700\u540e\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Not found in 10 iterations. \u3002 \u8f93\u5165\u6837\u4f8b 1 97152 \u8f93\u51fa\u6837\u4f8b 1 97152 + 25179 = 122331 122331 + 133221 = 255552 255552 is a palindromic number. \u8f93\u5165\u6837\u4f8b 2 196 \u8f93\u51fa\u6837\u4f8b 2 196 + 691 = 887 887 + 788 = 1675 1675 + 5761 = 7436 7436 + 6347 = 13783 13783 + 38731 = 52514 52514 + 41525 = 94039 94039 + 93049 = 187088 187088 + 880781 = 1067869 1067869 + 9687601 = 10755470 10755470 + 07455701 = 18211171 Not found in 10 iterations.","title":"Statement"},{"location":"PAT-Basic-Level/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; string add ( string s1 , string s2 ) { if ( s1 == \"\" && s2 == \"\" ) return \"0\" ; if ( s1 == \"\" ) return s2 ; if ( s2 == \"\" ) return s1 ; string maxx = s1 , minn = s2 ; if ( s1 . length () < s2 . length ()) { maxx = s2 ; minn = s1 ; } int a = maxx . length () - 1 , b = minn . length () - 1 ; for ( int i = b ; i >= 0 ; -- i ) { maxx [ a -- ] += minn [ i ] - '0' ; } for ( int i = maxx . length () - 1 ; i > 0 ; -- i ) { if ( maxx [ i ] > '9' ) { maxx [ i ] -= 10 ; maxx [ i - 1 ] ++ ; } } if ( maxx [ 0 ] > '9' ) { maxx [ 0 ] -= 10 ; maxx = '1' + maxx ; } return maxx ; } int f ( string s ) { int i , j , len = s . size (), m ; if ( len % 2 ) m = ( len - 1 ) / 2 ; else m = len / 2 ; for ( i = 0 , j = len - 1 ; i < m ; i ++ , j -- ) { if ( s [ i ] != s [ j ]) return 0 ; } return 1 ; } string tran ( string s ) { int i , len = s . size (); string s1 = \"\" ; for ( i = len - 1 ; i >= 0 ; i -- ) { s1 += s [ i ]; } return s1 ; } int main () { string s , s1 ; cin >> s ; int len = s . size (), i ; if ( f ( s )) { cout << s << \" is a palindromic number. \\n \" ; return 0 ; } for ( i = 0 ; i < 10 ; i ++ ) { s1 = tran ( s ); cout << s << \" + \" << s1 << \" = \" ; s = add ( s , s1 ); cout << s << endl ; if ( f ( s )) { cout << s << \" is a palindromic number. \\n \" ; return 0 ; } } cout << \"Not found in 10 iterations. \\n \" ; }","title":"Solution"},{"location":"PAT-Basic-Level/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9/","text":"1080 MOOC\u671f\u7ec8\u6210\u7ee9 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u5728\u4e2d\u56fd\u5927\u5b66MOOC\uff08 http://www.icourse163.org/ \uff09\u5b66\u4e60\u201c\u6570\u636e\u7ed3\u6784\u201d\u8bfe\u7a0b\u7684\u5b66\u751f\uff0c\u60f3\u8981\u83b7\u5f97\u4e00\u5f20\u5408\u683c\u8bc1\u4e66\uff0c\u5fc5\u987b\u9996\u5148\u83b7\u5f97\u4e0d\u5c11\u4e8e200\u5206\u7684\u5728\u7ebf\u7f16\u7a0b\u4f5c\u4e1a\u5206\uff0c\u7136\u540e\u603b\u8bc4\u83b7\u5f97\u4e0d\u5c11\u4e8e60\u5206\uff08\u6ee1\u5206100\uff09\u3002\u603b\u8bc4\u6210\u7ee9\u7684\u8ba1\u7b97\u516c\u5f0f\u4e3a G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) \uff0c\u5982\u679c G_{mid-term} > G_{final} G_{mid-term} > G_{final} \uff1b\u5426\u5219\u603b\u8bc4 G G \u5c31\u662f G_{final} G_{final} \u3002\u8fd9\u91cc G_{mid-term} G_{mid-term} \u548c G_{final} G_{final} \u5206\u522b\u4e3a\u5b66\u751f\u7684\u671f\u4e2d\u548c\u671f\u672b\u6210\u7ee9\u3002 \u73b0\u5728\u7684\u95ee\u9898\u662f\uff0c\u6bcf\u6b21\u8003\u8bd5\u90fd\u4ea7\u751f\u4e00\u5f20\u72ec\u7acb\u7684\u6210\u7ee9\u5355\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u4e0d\u540c\u7684\u6210\u7ee9\u5355\u5408\u4e3a\u4e00\u5f20\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f P\uff08\u505a\u4e86\u5728\u7ebf\u7f16\u7a0b\u4f5c\u4e1a\u7684\u5b66\u751f\u6570\uff09\u3001M\uff08\u53c2\u52a0\u4e86\u671f\u4e2d\u8003\u8bd5\u7684\u5b66\u751f\u6570\uff09\u3001N\uff08\u53c2\u52a0\u4e86\u671f\u672b\u8003\u8bd5\u7684\u5b66\u751f\u6570\uff09\u3002\u6bcf\u4e2a\u6570\u90fd\u4e0d\u8d85\u8fc710000\u3002 \u63a5\u4e0b\u6765\u6709\u4e09\u5757\u8f93\u5165\u3002\u7b2c\u4e00\u5757\u5305\u542b P \u4e2a\u5728\u7ebf\u7f16\u7a0b\u6210\u7ee9 G_p G_p \uff1b\u7b2c\u4e8c\u5757\u5305\u542b M \u4e2a\u671f\u4e2d\u8003\u8bd5\u6210\u7ee9 G_{mid-term} G_{mid-term} \uff1b\u7b2c\u4e09\u5757\u5305\u542b N \u4e2a\u671f\u672b\u8003\u8bd5\u6210\u7ee9 G_{final} G_{final} \u3002\u6bcf\u4e2a\u6210\u7ee9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u5b66\u751f\u5b66\u53f7 \u5206\u6570 \u3002\u5176\u4e2d \u5b66\u751f\u5b66\u53f7 \u4e3a\u4e0d\u8d85\u8fc720\u4e2a\u5b57\u7b26\u7684\u82f1\u6587\u5b57\u6bcd\u548c\u6570\u5b57\uff1b \u5206\u6570 \u662f\u975e\u8d1f\u6574\u6570\uff08\u7f16\u7a0b\u603b\u5206\u6700\u9ad8\u4e3a900\u5206\uff0c\u671f\u4e2d\u548c\u671f\u672b\u7684\u6700\u9ad8\u5206\u4e3a100\u5206\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6253\u5370\u51fa\u83b7\u5f97\u5408\u683c\u8bc1\u4e66\u7684\u5b66\u751f\u540d\u5355\u3002\u6bcf\u4e2a\u5b66\u751f\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u5b66\u751f\u5b66\u53f7 G_p G_p G_{mid-term} G_{mid-term} G_{final} G_{final} G G \u5982\u679c\u6709\u7684\u6210\u7ee9\u4e0d\u5b58\u5728\uff08\u4f8b\u5982\u67d0\u4eba\u6ca1\u53c2\u52a0\u671f\u4e2d\u8003\u8bd5\uff09\uff0c\u5219\u5728\u76f8\u5e94\u7684\u4f4d\u7f6e\u8f93\u51fa\u201c -1 -1 \u201d\u3002\u8f93\u51fa\u987a\u5e8f\u4e3a\u6309\u7167\u603b\u8bc4\u5206\u6570\uff08\u56db\u820d\u4e94\u5165\u7cbe\u786e\u5230\u6574\u6570\uff09\u9012\u51cf\u3002\u82e5\u6709\u5e76\u5217\uff0c\u5219\u6309\u5b66\u53f7\u9012\u589e\u3002\u9898\u76ee\u4fdd\u8bc1\u5b66\u53f7\u6ca1\u6709\u91cd\u590d\uff0c\u4e14\u81f3\u5c11\u5b58\u57281\u4e2a\u5408\u683c\u7684\u5b66\u751f\u3002 \u8f93\u5165\u6837\u4f8b 6 6 7 01234 880 a1903 199 ydjh2 200 wehu8 300 dx86w 220 missing 400 ydhfu77 99 wehu8 55 ydjh2 98 dx86w 88 a1903 86 01234 39 ydhfu77 88 a1903 66 01234 58 wehu8 84 ydjh2 82 missing 99 dx86w 81 \u8f93\u51fa\u6837\u4f8b missing 400 -1 99 99 ydjh2 200 98 82 88 dx86w 220 88 81 84 wehu8 300 55 84 84 Solution C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 struct pp { string s ; int G1 = -1 , G2 = -1 , G3 = -1 , G = -1 ; } q [ MAXN ]; int comp ( pp x , pp y ) { if ( x . G > y . G ) return 1 ; else if ( x . G == y . G ) { if ( x . s < y . s ) return 1 ; } return 0 ; } int main () { map < string , pp > p ; string s ; int n , G , i , j , p1 , m ; cin >> p1 >> m >> n ; for ( i = 0 ; i < p1 ; i ++ ) { cin >> s >> G ; if ( G <= 900 ) p [ s ]. G1 = G ; } for ( i = 0 ; i < m ; i ++ ) { cin >> s >> G ; if ( G <= 100 ) p [ s ]. G2 = G ; } for ( i = 0 ; i < n ; i ++ ) { cin >> s >> G ; if ( G <= 100 ) p [ s ]. G3 = G ; if ( p [ s ]. G2 > p [ s ]. G3 ) p [ s ]. G = ( int )( p [ s ]. G2 * 0.4 + p [ s ]. G3 * 0.6 + 0.5 ); else p [ s ]. G = p [ s ]. G3 ; } map < string , pp >:: iterator it ; for ( it = p . begin (), i = 0 ; it != p . end (); it ++ ) { if ( it -> second . G1 >= 200 && it -> second . G >= 60 ) { q [ i ]. s = it -> first ; q [ i ]. G1 = it -> second . G1 ; q [ i ]. G2 = it -> second . G2 ; q [ i ]. G3 = it -> second . G3 ; q [ i ]. G = it -> second . G ; i ++ ; } } sort ( q , q + i , comp ); for ( j = 0 ; j < i ; j ++ ) { cout << q [ j ]. s ; cout << \" \" << q [ j ]. G1 ; cout << \" \" << q [ j ]. G2 ; cout << \" \" << q [ j ]. G3 ; cout << \" \" << q [ j ]. G ; cout << \" \\n \" ; } }","title":"1080-MOOC\u671f\u7ec8\u6210\u7ee9"},{"location":"PAT-Basic-Level/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9/#1080-mooc\u671f\u7ec8\u6210\u7ee9","text":"","title":"1080 MOOC\u671f\u7ec8\u6210\u7ee9"},{"location":"PAT-Basic-Level/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u5bf9\u4e8e\u5728\u4e2d\u56fd\u5927\u5b66MOOC\uff08 http://www.icourse163.org/ \uff09\u5b66\u4e60\u201c\u6570\u636e\u7ed3\u6784\u201d\u8bfe\u7a0b\u7684\u5b66\u751f\uff0c\u60f3\u8981\u83b7\u5f97\u4e00\u5f20\u5408\u683c\u8bc1\u4e66\uff0c\u5fc5\u987b\u9996\u5148\u83b7\u5f97\u4e0d\u5c11\u4e8e200\u5206\u7684\u5728\u7ebf\u7f16\u7a0b\u4f5c\u4e1a\u5206\uff0c\u7136\u540e\u603b\u8bc4\u83b7\u5f97\u4e0d\u5c11\u4e8e60\u5206\uff08\u6ee1\u5206100\uff09\u3002\u603b\u8bc4\u6210\u7ee9\u7684\u8ba1\u7b97\u516c\u5f0f\u4e3a G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) G = (G_{mid-term}\\times 40\\% + G_{final}\\times 60\\%) \uff0c\u5982\u679c G_{mid-term} > G_{final} G_{mid-term} > G_{final} \uff1b\u5426\u5219\u603b\u8bc4 G G \u5c31\u662f G_{final} G_{final} \u3002\u8fd9\u91cc G_{mid-term} G_{mid-term} \u548c G_{final} G_{final} \u5206\u522b\u4e3a\u5b66\u751f\u7684\u671f\u4e2d\u548c\u671f\u672b\u6210\u7ee9\u3002 \u73b0\u5728\u7684\u95ee\u9898\u662f\uff0c\u6bcf\u6b21\u8003\u8bd5\u90fd\u4ea7\u751f\u4e00\u5f20\u72ec\u7acb\u7684\u6210\u7ee9\u5355\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u628a\u4e0d\u540c\u7684\u6210\u7ee9\u5355\u5408\u4e3a\u4e00\u5f20\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa3\u4e2a\u6574\u6570\uff0c\u5206\u522b\u662f P\uff08\u505a\u4e86\u5728\u7ebf\u7f16\u7a0b\u4f5c\u4e1a\u7684\u5b66\u751f\u6570\uff09\u3001M\uff08\u53c2\u52a0\u4e86\u671f\u4e2d\u8003\u8bd5\u7684\u5b66\u751f\u6570\uff09\u3001N\uff08\u53c2\u52a0\u4e86\u671f\u672b\u8003\u8bd5\u7684\u5b66\u751f\u6570\uff09\u3002\u6bcf\u4e2a\u6570\u90fd\u4e0d\u8d85\u8fc710000\u3002 \u63a5\u4e0b\u6765\u6709\u4e09\u5757\u8f93\u5165\u3002\u7b2c\u4e00\u5757\u5305\u542b P \u4e2a\u5728\u7ebf\u7f16\u7a0b\u6210\u7ee9 G_p G_p \uff1b\u7b2c\u4e8c\u5757\u5305\u542b M \u4e2a\u671f\u4e2d\u8003\u8bd5\u6210\u7ee9 G_{mid-term} G_{mid-term} \uff1b\u7b2c\u4e09\u5757\u5305\u542b N \u4e2a\u671f\u672b\u8003\u8bd5\u6210\u7ee9 G_{final} G_{final} \u3002\u6bcf\u4e2a\u6210\u7ee9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u5b66\u751f\u5b66\u53f7 \u5206\u6570 \u3002\u5176\u4e2d \u5b66\u751f\u5b66\u53f7 \u4e3a\u4e0d\u8d85\u8fc720\u4e2a\u5b57\u7b26\u7684\u82f1\u6587\u5b57\u6bcd\u548c\u6570\u5b57\uff1b \u5206\u6570 \u662f\u975e\u8d1f\u6574\u6570\uff08\u7f16\u7a0b\u603b\u5206\u6700\u9ad8\u4e3a900\u5206\uff0c\u671f\u4e2d\u548c\u671f\u672b\u7684\u6700\u9ad8\u5206\u4e3a100\u5206\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u6253\u5370\u51fa\u83b7\u5f97\u5408\u683c\u8bc1\u4e66\u7684\u5b66\u751f\u540d\u5355\u3002\u6bcf\u4e2a\u5b66\u751f\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e3a\uff1a \u5b66\u751f\u5b66\u53f7 G_p G_p G_{mid-term} G_{mid-term} G_{final} G_{final} G G \u5982\u679c\u6709\u7684\u6210\u7ee9\u4e0d\u5b58\u5728\uff08\u4f8b\u5982\u67d0\u4eba\u6ca1\u53c2\u52a0\u671f\u4e2d\u8003\u8bd5\uff09\uff0c\u5219\u5728\u76f8\u5e94\u7684\u4f4d\u7f6e\u8f93\u51fa\u201c -1 -1 \u201d\u3002\u8f93\u51fa\u987a\u5e8f\u4e3a\u6309\u7167\u603b\u8bc4\u5206\u6570\uff08\u56db\u820d\u4e94\u5165\u7cbe\u786e\u5230\u6574\u6570\uff09\u9012\u51cf\u3002\u82e5\u6709\u5e76\u5217\uff0c\u5219\u6309\u5b66\u53f7\u9012\u589e\u3002\u9898\u76ee\u4fdd\u8bc1\u5b66\u53f7\u6ca1\u6709\u91cd\u590d\uff0c\u4e14\u81f3\u5c11\u5b58\u57281\u4e2a\u5408\u683c\u7684\u5b66\u751f\u3002 \u8f93\u5165\u6837\u4f8b 6 6 7 01234 880 a1903 199 ydjh2 200 wehu8 300 dx86w 220 missing 400 ydhfu77 99 wehu8 55 ydjh2 98 dx86w 88 a1903 86 01234 39 ydhfu77 88 a1903 66 01234 58 wehu8 84 ydjh2 82 missing 99 dx86w 81 \u8f93\u51fa\u6837\u4f8b missing 400 -1 99 99 ydjh2 200 98 82 88 dx86w 220 88 81 84 wehu8 300 55 84 84","title":"Statement"},{"location":"PAT-Basic-Level/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define MAXN 10000 struct pp { string s ; int G1 = -1 , G2 = -1 , G3 = -1 , G = -1 ; } q [ MAXN ]; int comp ( pp x , pp y ) { if ( x . G > y . G ) return 1 ; else if ( x . G == y . G ) { if ( x . s < y . s ) return 1 ; } return 0 ; } int main () { map < string , pp > p ; string s ; int n , G , i , j , p1 , m ; cin >> p1 >> m >> n ; for ( i = 0 ; i < p1 ; i ++ ) { cin >> s >> G ; if ( G <= 900 ) p [ s ]. G1 = G ; } for ( i = 0 ; i < m ; i ++ ) { cin >> s >> G ; if ( G <= 100 ) p [ s ]. G2 = G ; } for ( i = 0 ; i < n ; i ++ ) { cin >> s >> G ; if ( G <= 100 ) p [ s ]. G3 = G ; if ( p [ s ]. G2 > p [ s ]. G3 ) p [ s ]. G = ( int )( p [ s ]. G2 * 0.4 + p [ s ]. G3 * 0.6 + 0.5 ); else p [ s ]. G = p [ s ]. G3 ; } map < string , pp >:: iterator it ; for ( it = p . begin (), i = 0 ; it != p . end (); it ++ ) { if ( it -> second . G1 >= 200 && it -> second . G >= 60 ) { q [ i ]. s = it -> first ; q [ i ]. G1 = it -> second . G1 ; q [ i ]. G2 = it -> second . G2 ; q [ i ]. G3 = it -> second . G3 ; q [ i ]. G = it -> second . G ; i ++ ; } } sort ( q , q + i , comp ); for ( j = 0 ; j < i ; j ++ ) { cout << q [ j ]. s ; cout << \" \" << q [ j ]. G1 ; cout << \" \" << q [ j ]. G2 ; cout << \" \" << q [ j ]. G3 ; cout << \" \" << q [ j ]. G ; cout << \" \\n \" ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/","text":"1081 \u68c0\u67e5\u5bc6\u7801 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5e2e\u52a9\u67d0\u7f51\u7ad9\u7684\u7528\u6237\u6ce8\u518c\u6a21\u5757\u5199\u4e00\u4e2a\u5bc6\u7801\u5408\u6cd5\u6027\u68c0\u67e5\u7684\u5c0f\u529f\u80fd\u3002\u8be5\u7f51\u7ad9\u8981\u6c42\u7528\u6237\u8bbe\u7f6e\u7684\u5bc6\u7801\u5fc5\u987b\u7531\u4e0d\u5c11\u4e8e6\u4e2a\u5b57\u7b26\u7ec4\u6210\uff0c\u5e76\u4e14\u53ea\u80fd\u6709\u82f1\u6587\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u5c0f\u6570\u70b9 . \uff0c\u8fd8\u5fc5\u987b\u65e2\u6709\u5b57\u6bcd\u4e5f\u6709\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\u5bc6\u7801\uff0c\u4e3a\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u6ce8\u610f\uff1a \u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u53ea\u6709\u5c0f\u6570\u70b9\u7684\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u7528\u6237\u7684\u5bc6\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7cfb\u7edf\u53cd\u9988\u4fe1\u606f\uff0c\u5206\u4ee5\u4e0b5\u79cd\uff1a \u5982\u679c\u5bc6\u7801\u5408\u6cd5\uff0c\u8f93\u51fa Your password is wan mei. \uff1b \u5982\u679c\u5bc6\u7801\u592a\u77ed\uff0c\u4e0d\u8bba\u5408\u6cd5\u4e0e\u5426\uff0c\u90fd\u8f93\u51fa Your password is tai duan le. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u5b58\u5728\u4e0d\u5408\u6cd5\u5b57\u7b26\uff0c\u5219\u8f93\u51fa Your password is tai luan le. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u53ea\u6709\u5b57\u6bcd\u6ca1\u6709\u6570\u5b57\uff0c\u5219\u8f93\u51fa Your password needs shu zi. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u53ea\u6709\u6570\u5b57\u6ca1\u6709\u5b57\u6bcd\uff0c\u5219\u8f93\u51fa Your password needs zi mu. \u3002 \u8f93\u5165\u6837\u4f8b 5 123s zheshi.wodepw 1234.5678 WanMei23333 pass*word.6 \u8f93\u51fa\u6837\u4f8b Your password is tai duan le. Your password needs shu zi. Your password needs zi mu. Your password is wan mei. Your password is tai luan le. Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int legal ( string s ) { int len = s . size (); int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { a = 2 ; continue ; } else if (( s [ i ] >= 'a' && s [ i ] <= 'z' ) || ( s [ i ] >= 'A' && s [ i ] <= 'Z' )) { b = 3 ; continue ; } else if ( s [ i ] == '.' ) continue ; else return 0 ; } return a + b ; } int main () { int t ; cin >> t ; getchar (); while ( t -- ) { string s ; getline ( cin , s ); int len = s . size (); if ( len < 6 ) printf ( \"Your password is tai duan le. \\n \" ); else { int ans = legal ( s ); if ( ans == 0 ) printf ( \"Your password is tai luan le. \\n \" ); else if ( ans == 2 ) printf ( \"Your password needs zi mu. \\n \" ); else if ( ans == 3 ) printf ( \"Your password needs shu zi. \\n \" ); else printf ( \"Your password is wan mei. \\n \" ); } } }","title":"1081-\u68c0\u67e5\u5bc6\u7801"},{"location":"PAT-Basic-Level/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/#1081-\u68c0\u67e5\u5bc6\u7801","text":"","title":"1081 \u68c0\u67e5\u5bc6\u7801"},{"location":"PAT-Basic-Level/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u8981\u6c42\u4f60\u5e2e\u52a9\u67d0\u7f51\u7ad9\u7684\u7528\u6237\u6ce8\u518c\u6a21\u5757\u5199\u4e00\u4e2a\u5bc6\u7801\u5408\u6cd5\u6027\u68c0\u67e5\u7684\u5c0f\u529f\u80fd\u3002\u8be5\u7f51\u7ad9\u8981\u6c42\u7528\u6237\u8bbe\u7f6e\u7684\u5bc6\u7801\u5fc5\u987b\u7531\u4e0d\u5c11\u4e8e6\u4e2a\u5b57\u7b26\u7ec4\u6210\uff0c\u5e76\u4e14\u53ea\u80fd\u6709\u82f1\u6587\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u5c0f\u6570\u70b9 . \uff0c\u8fd8\u5fc5\u987b\u65e2\u6709\u5b57\u6bcd\u4e5f\u6709\u6570\u5b57\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 100\uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\u5bc6\u7801\uff0c\u4e3a\u4e0d\u8d85\u8fc7 80 \u4e2a\u5b57\u7b26\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002 \u6ce8\u610f\uff1a \u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u53ea\u6709\u5c0f\u6570\u70b9\u7684\u8f93\u5165\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u7528\u6237\u7684\u5bc6\u7801\uff0c\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u7cfb\u7edf\u53cd\u9988\u4fe1\u606f\uff0c\u5206\u4ee5\u4e0b5\u79cd\uff1a \u5982\u679c\u5bc6\u7801\u5408\u6cd5\uff0c\u8f93\u51fa Your password is wan mei. \uff1b \u5982\u679c\u5bc6\u7801\u592a\u77ed\uff0c\u4e0d\u8bba\u5408\u6cd5\u4e0e\u5426\uff0c\u90fd\u8f93\u51fa Your password is tai duan le. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u5b58\u5728\u4e0d\u5408\u6cd5\u5b57\u7b26\uff0c\u5219\u8f93\u51fa Your password is tai luan le. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u53ea\u6709\u5b57\u6bcd\u6ca1\u6709\u6570\u5b57\uff0c\u5219\u8f93\u51fa Your password needs shu zi. \uff1b \u5982\u679c\u5bc6\u7801\u957f\u5ea6\u5408\u6cd5\uff0c\u4f46\u53ea\u6709\u6570\u5b57\u6ca1\u6709\u5b57\u6bcd\uff0c\u5219\u8f93\u51fa Your password needs zi mu. \u3002 \u8f93\u5165\u6837\u4f8b 5 123s zheshi.wodepw 1234.5678 WanMei23333 pass*word.6 \u8f93\u51fa\u6837\u4f8b Your password is tai duan le. Your password needs shu zi. Your password needs zi mu. Your password is wan mei. Your password is tai luan le.","title":"Statement"},{"location":"PAT-Basic-Level/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int legal ( string s ) { int len = s . size (); int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { a = 2 ; continue ; } else if (( s [ i ] >= 'a' && s [ i ] <= 'z' ) || ( s [ i ] >= 'A' && s [ i ] <= 'Z' )) { b = 3 ; continue ; } else if ( s [ i ] == '.' ) continue ; else return 0 ; } return a + b ; } int main () { int t ; cin >> t ; getchar (); while ( t -- ) { string s ; getline ( cin , s ); int len = s . size (); if ( len < 6 ) printf ( \"Your password is tai duan le. \\n \" ); else { int ans = legal ( s ); if ( ans == 0 ) printf ( \"Your password is tai luan le. \\n \" ); else if ( ans == 2 ) printf ( \"Your password needs zi mu. \\n \" ); else if ( ans == 3 ) printf ( \"Your password needs shu zi. \\n \" ); else printf ( \"Your password is wan mei. \\n \" ); } } }","title":"Solution"},{"location":"PAT-Basic-Level/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/","text":"1082 \u5c04\u51fb\u6bd4\u8d5b Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u76ee\u7ed9\u51fa\u7684\u5c04\u51fb\u6bd4\u8d5b\u7684\u89c4\u5219\u975e\u5e38\u7b80\u5355\uff0c\u8c01\u6253\u7684\u5f39\u6d1e\u8ddd\u79bb\u9776\u5fc3\u6700\u8fd1\uff0c\u8c01\u5c31\u662f\u51a0\u519b\uff1b\u8c01\u5dee\u5f97\u6700\u8fdc\uff0c\u8c01\u5c31\u662f\u83dc\u9e1f\u3002\u672c\u9898\u7ed9\u51fa\u4e00\u7cfb\u5217\u5f39\u6d1e\u7684\u5e73\u9762\u5750\u6807(x,y)\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u627e\u51fa\u51a0\u519b\u548c\u83dc\u9e1f\u3002\u6211\u4eec\u5047\u8bbe\u9776\u5fc3\u5728\u539f\u70b9(0,0)\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 10 000\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\uff1a ID x y \u5176\u4e2d ID \u662f\u8fd0\u52a8\u5458\u7684\u7f16\u53f7\uff08\u7531 4 \u4f4d\u6570\u5b57\u7ec4\u6210\uff09\uff1b x \u548c y \u662f\u5176\u6253\u51fa\u7684\u5f39\u6d1e\u7684\u5e73\u9762\u5750\u6807( x , y )\uff0c\u5747\u4e3a\u6574\u6570\uff0c\u4e14 0 \\le \\le | x |, | y | \\le \\le 100\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u8fd0\u52a8\u5458\u7684\u7f16\u53f7\u4e0d\u91cd\u590d\uff0c\u4e14\u6bcf\u4eba\u53ea\u6253 1 \u67aa\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u51a0\u519b\u548c\u83dc\u9e1f\u7684\u7f16\u53f7\uff0c\u4e2d\u95f4\u7a7a 1 \u683c\u3002\u9898\u76ee\u4fdd\u8bc1\u4ed6\u4eec\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 3 0001 5 7 1020 -1 3 0233 0 -1 \u8f93\u51fa\u6837\u4f8b 0233 0001 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; int id , x , y ; double Max = - INF , Min = INF ; int ans1 , ans2 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & id , & x , & y ); double dis = sqrt ( x * x + y * y ); if ( dis < Min ) { ans2 = id ; Min = dis ; } if ( dis > Max ) { ans1 = id ; Max = dis ; } } printf ( \"%04d %04d \\n \" , ans2 , ans1 ); }","title":"1082-\u5c04\u51fb\u6bd4\u8d5b"},{"location":"PAT-Basic-Level/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/#1082-\u5c04\u51fb\u6bd4\u8d5b","text":"","title":"1082 \u5c04\u51fb\u6bd4\u8d5b"},{"location":"PAT-Basic-Level/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u672c\u9898\u76ee\u7ed9\u51fa\u7684\u5c04\u51fb\u6bd4\u8d5b\u7684\u89c4\u5219\u975e\u5e38\u7b80\u5355\uff0c\u8c01\u6253\u7684\u5f39\u6d1e\u8ddd\u79bb\u9776\u5fc3\u6700\u8fd1\uff0c\u8c01\u5c31\u662f\u51a0\u519b\uff1b\u8c01\u5dee\u5f97\u6700\u8fdc\uff0c\u8c01\u5c31\u662f\u83dc\u9e1f\u3002\u672c\u9898\u7ed9\u51fa\u4e00\u7cfb\u5217\u5f39\u6d1e\u7684\u5e73\u9762\u5750\u6807(x,y)\uff0c\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u627e\u51fa\u51a0\u519b\u548c\u83dc\u9e1f\u3002\u6211\u4eec\u5047\u8bbe\u9776\u5fc3\u5728\u539f\u70b9(0,0)\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 10 000\uff09\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\uff1a ID x y \u5176\u4e2d ID \u662f\u8fd0\u52a8\u5458\u7684\u7f16\u53f7\uff08\u7531 4 \u4f4d\u6570\u5b57\u7ec4\u6210\uff09\uff1b x \u548c y \u662f\u5176\u6253\u51fa\u7684\u5f39\u6d1e\u7684\u5e73\u9762\u5750\u6807( x , y )\uff0c\u5747\u4e3a\u6574\u6570\uff0c\u4e14 0 \\le \\le | x |, | y | \\le \\le 100\u3002\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u8fd0\u52a8\u5458\u7684\u7f16\u53f7\u4e0d\u91cd\u590d\uff0c\u4e14\u6bcf\u4eba\u53ea\u6253 1 \u67aa\u3002 \u8f93\u51fa\u683c\u5f0f \u8f93\u51fa\u51a0\u519b\u548c\u83dc\u9e1f\u7684\u7f16\u53f7\uff0c\u4e2d\u95f4\u7a7a 1 \u683c\u3002\u9898\u76ee\u4fdd\u8bc1\u4ed6\u4eec\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 3 0001 5 7 1020 -1 3 0233 0 -1 \u8f93\u51fa\u6837\u4f8b 0233 0001","title":"Statement"},{"location":"PAT-Basic-Level/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-6 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n ; cin >> n ; int id , x , y ; double Max = - INF , Min = INF ; int ans1 , ans2 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d%d\" , & id , & x , & y ); double dis = sqrt ( x * x + y * y ); if ( dis < Min ) { ans2 = id ; Min = dis ; } if ( dis > Max ) { ans1 = id ; Max = dis ; } } printf ( \"%04d %04d \\n \" , ans2 , ans1 ); }","title":"Solution"},{"location":"PAT-Basic-Level/1083-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE/","text":"1083 \u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u5f20\u5361\u7247\uff0c\u6b63\u9762\u5206\u522b\u5199\u4e0a 1\u30012\u3001\u2026\u2026\u3001N\uff0c\u7136\u540e\u5168\u90e8\u7ffb\u9762\uff0c\u6d17\u724c\uff0c\u5728\u80cc\u9762\u5206\u522b\u5199\u4e0a 1\u30012\u3001\u2026\u2026\u3001N\u3002\u5c06\u6bcf\u5f20\u724c\u7684\u6b63\u53cd\u4e24\u9762\u6570\u5b57\u76f8\u51cf\uff08\u5927\u51cf\u5c0f\uff09\uff0c\u5f97\u5230 N \u4e2a\u975e\u8d1f\u5dee\u503c\uff0c\u5176\u4e2d\u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff082 \\le \\le N \\le \\le 10 000\uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa 1 \u5230 N \u7684\u4e00\u4e2a\u6d17\u724c\u540e\u7684\u6392\u5217\uff0c\u7b2c i \u4e2a\u6570\u8868\u793a\u6b63\u9762\u5199\u4e86 i \u7684\u90a3\u5f20\u5361\u7247\u80cc\u9762\u7684\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u201c\u5dee\u503c \u91cd\u590d\u6b21\u6570\u201d\u7684\u683c\u5f0f\u4ece\u5927\u5230\u5c0f\u8f93\u51fa\u91cd\u590d\u7684\u5dee\u503c\u53ca\u5176\u91cd\u590d\u7684\u6b21\u6570\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u4e2a\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 8 3 5 8 6 2 1 4 7 \u8f93\u51fa\u6837\u4f8b 5 2 3 3 2 2 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n , num ; cin >> n ; map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); m [ abs ( num - i )] ++ ; } map < int , int >:: iterator it ; for ( it = m . end (), it -- ;; it -- ) { if ( it -> second > 1 ) printf ( \"%d %d \\n \" , it -> first , it -> second ); if ( it == m . begin ()) break ; } }","title":"1083-\u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee"},{"location":"PAT-Basic-Level/1083-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE/#1083-\u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee","text":"","title":"1083 \u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee"},{"location":"PAT-Basic-Level/1083-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a N \u5f20\u5361\u7247\uff0c\u6b63\u9762\u5206\u522b\u5199\u4e0a 1\u30012\u3001\u2026\u2026\u3001N\uff0c\u7136\u540e\u5168\u90e8\u7ffb\u9762\uff0c\u6d17\u724c\uff0c\u5728\u80cc\u9762\u5206\u522b\u5199\u4e0a 1\u30012\u3001\u2026\u2026\u3001N\u3002\u5c06\u6bcf\u5f20\u724c\u7684\u6b63\u53cd\u4e24\u9762\u6570\u5b57\u76f8\u51cf\uff08\u5927\u51cf\u5c0f\uff09\uff0c\u5f97\u5230 N \u4e2a\u975e\u8d1f\u5dee\u503c\uff0c\u5176\u4e2d\u662f\u5426\u5b58\u5728\u76f8\u7b49\u7684\u5dee\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff082 \\le \\le N \\le \\le 10 000\uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa 1 \u5230 N \u7684\u4e00\u4e2a\u6d17\u724c\u540e\u7684\u6392\u5217\uff0c\u7b2c i \u4e2a\u6570\u8868\u793a\u6b63\u9762\u5199\u4e86 i \u7684\u90a3\u5f20\u5361\u7247\u80cc\u9762\u7684\u6570\u5b57\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167\u201c\u5dee\u503c \u91cd\u590d\u6b21\u6570\u201d\u7684\u683c\u5f0f\u4ece\u5927\u5230\u5c0f\u8f93\u51fa\u91cd\u590d\u7684\u5dee\u503c\u53ca\u5176\u91cd\u590d\u7684\u6b21\u6570\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u4e2a\u7ed3\u679c\u3002 \u8f93\u5165\u6837\u4f8b 8 3 5 8 6 2 1 4 7 \u8f93\u51fa\u6837\u4f8b 5 2 3 3 2 2","title":"Statement"},{"location":"PAT-Basic-Level/1083-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; int main () { int n , num ; cin >> n ; map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & num ); m [ abs ( num - i )] ++ ; } map < int , int >:: iterator it ; for ( it = m . end (), it -- ;; it -- ) { if ( it -> second > 1 ) printf ( \"%d %d \\n \" , it -> first , it -> second ); if ( it == m . begin ()) break ; } }","title":"Solution"},{"location":"PAT-Basic-Level/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/","text":"1084 \u5916\u89c2\u6570\u5217 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5916\u89c2\u6570\u5217\u662f\u6307\u5177\u6709\u4ee5\u4e0b\u7279\u70b9\u7684\u6574\u6570\u5e8f\u5217\uff1a d, d1, d111, d113, d11231, d112213111, ... \u5b83\u4ece\u4e0d\u7b49\u4e8e 1 \u7684\u6570\u5b57 d \u5f00\u59cb\uff0c\u5e8f\u5217\u7684\u7b2c n+1 \u9879\u662f\u5bf9\u7b2c n \u9879\u7684\u63cf\u8ff0\u3002\u6bd4\u5982\u7b2c 2 \u9879\u8868\u793a\u7b2c 1 \u9879\u6709 1 \u4e2a d \uff0c\u6240\u4ee5\u5c31\u662f d1 \uff1b\u7b2c 2 \u9879\u662f 1 \u4e2a d \uff08\u5bf9\u5e94 d1 \uff09\u548c 1 \u4e2a 1\uff08\u5bf9\u5e94 11\uff09\uff0c\u6240\u4ee5\u7b2c 3 \u9879\u5c31\u662f d111 \u3002\u53c8\u6bd4\u5982\u7b2c 4 \u9879\u662f d113 \uff0c\u5176\u63cf\u8ff0\u5c31\u662f 1 \u4e2a d \uff0c2 \u4e2a 1\uff0c1 \u4e2a 3\uff0c\u6240\u4ee5\u4e0b\u4e00\u9879\u5c31\u662f d11231 \u3002\u5f53\u7136\u8fd9\u4e2a\u5b9a\u4e49\u5bf9 d = 1 \u4e5f\u6210\u7acb\u3002\u672c\u9898\u8981\u6c42\u4f60\u63a8\u7b97\u4efb\u610f\u7ed9\u5b9a\u6570\u5b57 d \u7684\u5916\u89c2\u6570\u5217\u7684\u7b2c N \u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa [0,9] \u8303\u56f4\u5185\u7684\u4e00\u4e2a\u6574\u6570 d \u3001\u4ee5\u53ca\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 40\uff09\uff0c\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6570\u5b57 d \u7684\u5916\u89c2\u6570\u5217\u7684\u7b2c N \u9879\u3002 \u8f93\u5165\u6837\u4f8b 1 8 \u8f93\u51fa\u6837\u4f8b 1123123111 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string tran ( string s ) { int len = s . size (); string ans = \"\" ; char c = s [ 0 ]; int num = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( s [ i ] == c ) num ++ ; else { ans += c ; ans += num + '0' ; c = s [ i ]; num = 1 ; } } ans += c ; ans += num + '0' ; return ans ; } int main () { string ans ; cin >> ans ; int n ; cin >> n ; for ( int i = 1 ; i < n ; i ++ ) ans = tran ( ans ); cout << ans << endl ; }","title":"1084-\u5916\u89c2\u6570\u5217"},{"location":"PAT-Basic-Level/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/#1084-\u5916\u89c2\u6570\u5217","text":"","title":"1084 \u5916\u89c2\u6570\u5217"},{"location":"PAT-Basic-Level/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5916\u89c2\u6570\u5217\u662f\u6307\u5177\u6709\u4ee5\u4e0b\u7279\u70b9\u7684\u6574\u6570\u5e8f\u5217\uff1a d, d1, d111, d113, d11231, d112213111, ... \u5b83\u4ece\u4e0d\u7b49\u4e8e 1 \u7684\u6570\u5b57 d \u5f00\u59cb\uff0c\u5e8f\u5217\u7684\u7b2c n+1 \u9879\u662f\u5bf9\u7b2c n \u9879\u7684\u63cf\u8ff0\u3002\u6bd4\u5982\u7b2c 2 \u9879\u8868\u793a\u7b2c 1 \u9879\u6709 1 \u4e2a d \uff0c\u6240\u4ee5\u5c31\u662f d1 \uff1b\u7b2c 2 \u9879\u662f 1 \u4e2a d \uff08\u5bf9\u5e94 d1 \uff09\u548c 1 \u4e2a 1\uff08\u5bf9\u5e94 11\uff09\uff0c\u6240\u4ee5\u7b2c 3 \u9879\u5c31\u662f d111 \u3002\u53c8\u6bd4\u5982\u7b2c 4 \u9879\u662f d113 \uff0c\u5176\u63cf\u8ff0\u5c31\u662f 1 \u4e2a d \uff0c2 \u4e2a 1\uff0c1 \u4e2a 3\uff0c\u6240\u4ee5\u4e0b\u4e00\u9879\u5c31\u662f d11231 \u3002\u5f53\u7136\u8fd9\u4e2a\u5b9a\u4e49\u5bf9 d = 1 \u4e5f\u6210\u7acb\u3002\u672c\u9898\u8981\u6c42\u4f60\u63a8\u7b97\u4efb\u610f\u7ed9\u5b9a\u6570\u5b57 d \u7684\u5916\u89c2\u6570\u5217\u7684\u7b2c N \u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa [0,9] \u8303\u56f4\u5185\u7684\u4e00\u4e2a\u6574\u6570 d \u3001\u4ee5\u53ca\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le \\le 40\uff09\uff0c\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u6570\u5b57 d \u7684\u5916\u89c2\u6570\u5217\u7684\u7b2c N \u9879\u3002 \u8f93\u5165\u6837\u4f8b 1 8 \u8f93\u51fa\u6837\u4f8b 1123123111","title":"Statement"},{"location":"PAT-Basic-Level/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; string tran ( string s ) { int len = s . size (); string ans = \"\" ; char c = s [ 0 ]; int num = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( s [ i ] == c ) num ++ ; else { ans += c ; ans += num + '0' ; c = s [ i ]; num = 1 ; } } ans += c ; ans += num + '0' ; return ans ; } int main () { string ans ; cin >> ans ; int n ; cin >> n ; for ( int i = 1 ; i < n ; i ++ ) ans = tran ( ans ); cout << ans << endl ; }","title":"Solution"},{"location":"PAT-Basic-Level/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/","text":"1085 PAT\u5355\u4f4d\u6392\u884c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u6b21 PAT \u8003\u8bd5\u7ed3\u675f\u540e\uff0c\u8003\u8bd5\u4e2d\u5fc3\u90fd\u4f1a\u53d1\u5e03\u4e00\u4e2a\u8003\u751f\u5355\u4f4d\u6392\u884c\u699c\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u8003\u751f\u4eba\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u5f97\u5206 \u5b66\u6821 \u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u662f\u7531 6 \u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5176\u9996\u5b57\u6bcd\u8868\u793a\u8003\u8bd5\u7684\u7ea7\u522b\uff1a B \u4ee3\u8868\u4e59\u7ea7\uff0c A \u4ee3\u8868\u7532\u7ea7\uff0c T \u4ee3\u8868\u9876\u7ea7\uff1b \u5f97\u5206 \u662f [0, 100] \u533a\u95f4\u5185\u7684\u6574\u6570\uff1b \u5b66\u6821 \u662f\u7531\u4e0d\u8d85\u8fc7 6 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5355\u4f4d\u7801\uff08\u5927\u5c0f\u5199\u65e0\u5173\uff09\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u662f\u4e0d\u540c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5355\u4f4d\u4e2a\u6570\u3002\u968f\u540e\u6309\u4ee5\u4e0b\u683c\u5f0f\u975e\u964d\u5e8f\u8f93\u51fa\u5355\u4f4d\u7684\u6392\u884c\u699c\uff1a \u6392\u540d \u5b66\u6821 \u52a0\u6743\u603b\u5206 \u8003\u751f\u4eba\u6570 \u5176\u4e2d \u6392\u540d \u662f\u8be5\u5355\u4f4d\u7684\u6392\u540d\uff08\u4ece 1 \u5f00\u59cb\uff09\uff1b \u5b66\u6821 \u662f\u5168\u90e8\u6309\u5c0f\u5199\u5b57\u6bcd\u8f93\u51fa\u7684\u5355\u4f4d\u7801\uff1b \u52a0\u6743\u603b\u5206 \u5b9a\u4e49\u4e3a \u4e59\u7ea7\u603b\u5206/1.5 + \u7532\u7ea7\u603b\u5206 + \u9876\u7ea7\u603b\u5206*1.5 \u7684 \u6574\u6570\u90e8\u5206 \uff1b \u8003\u751f\u4eba\u6570 \u662f\u8be5\u5c5e\u4e8e\u5355\u4f4d\u7684\u8003\u751f\u7684\u603b\u4eba\u6570\u3002 \u5b66\u6821\u9996\u5148\u6309\u52a0\u6743\u603b\u5206\u6392\u884c\u3002\u5982\u6709\u5e76\u5217\uff0c\u5219\u5e94\u5bf9\u5e94\u76f8\u540c\u7684\u6392\u540d\uff0c\u5e76\u6309\u8003\u751f\u4eba\u6570\u5347\u5e8f\u8f93\u51fa\u3002\u5982\u679c\u4ecd\u7136\u5e76\u5217\uff0c\u5219\u6309\u5355\u4f4d\u7801\u7684\u5b57\u5178\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 A57908 85 Au B57908 54 LanX A37487 60 au T28374 67 CMU T32486 24 hypu A66734 92 cmu B76378 71 AU A47780 45 lanx A72809 100 pku A03274 45 hypu \u8f93\u51fa\u6837\u4f8b 5 1 cmu 192 2 1 au 192 3 3 pku 100 1 4 hypu 81 2 4 lanx 81 2 Solution C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { string name ; int tot ; double score ; int s ; }; bool comp ( Node x , Node y ) { if ( x . s == y . s ) { if ( x . tot == y . tot ) return x . name < y . name ; else return x . tot < y . tot ; } return x . s > y . s ; } int main () { int n ; cin >> n ; map < string , Node > m ; string id , school ; int score ; for ( int i = 0 ; i < n ; i ++ ) { cin >> id >> score >> school ; int len = school . size (); for ( int j = 0 ; j < len ; j ++ ) if ( school [ j ] >= 'A' && school [ j ] <= 'Z' ) school [ j ] += 32 ; m [ school ]. tot ++ ; m [ school ]. name = school ; if ( id [ 0 ] == 'A' ) m [ school ]. score += score ; else if ( id [ 0 ] == 'B' ) m [ school ]. score += score * 1.0 / 1.5 ; else m [ school ]. score += score * 1.5 ; } map < string , Node >:: iterator it ; vector < Node > ans ; for ( it = m . begin (); it != m . end (); it ++ ) { it -> second . s = floor ( it -> second . score ); ans . pb ( it -> second ); } sort ( ans . begin (), ans . end (), comp ); int len = ans . size (); cout << len << endl ; printf ( \"1 \" ); cout << ans [ 0 ]. name ; printf ( \" %d %d \\n \" , ans [ 0 ]. s , ans [ 0 ]. tot ); int rank = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( ans [ i ]. s != ans [ i - 1 ]. s ) rank = i + 1 ; printf ( \"%d \" , rank ); cout << ans [ i ]. name ; printf ( \" %d %d \\n \" , ans [ i ]. s , ans [ i ]. tot ); } }","title":"1085-PAT\u5355\u4f4d\u6392\u884c"},{"location":"PAT-Basic-Level/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/#1085-pat\u5355\u4f4d\u6392\u884c","text":"","title":"1085 PAT\u5355\u4f4d\u6392\u884c"},{"location":"PAT-Basic-Level/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB \u6bcf\u6b21 PAT \u8003\u8bd5\u7ed3\u675f\u540e\uff0c\u8003\u8bd5\u4e2d\u5fc3\u90fd\u4f1a\u53d1\u5e03\u4e00\u4e2a\u8003\u751f\u5355\u4f4d\u6392\u884c\u699c\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 10^5 \\le 10^5 \uff09\uff0c\u5373\u8003\u751f\u4eba\u6570\u3002\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u6309\u4e0b\u5217\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u4fe1\u606f\uff1a \u51c6\u8003\u8bc1\u53f7 \u5f97\u5206 \u5b66\u6821 \u5176\u4e2d \u51c6\u8003\u8bc1\u53f7 \u662f\u7531 6 \u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u5176\u9996\u5b57\u6bcd\u8868\u793a\u8003\u8bd5\u7684\u7ea7\u522b\uff1a B \u4ee3\u8868\u4e59\u7ea7\uff0c A \u4ee3\u8868\u7532\u7ea7\uff0c T \u4ee3\u8868\u9876\u7ea7\uff1b \u5f97\u5206 \u662f [0, 100] \u533a\u95f4\u5185\u7684\u6574\u6570\uff1b \u5b66\u6821 \u662f\u7531\u4e0d\u8d85\u8fc7 6 \u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\u7684\u5355\u4f4d\u7801\uff08\u5927\u5c0f\u5199\u65e0\u5173\uff09\u3002\u6ce8\u610f\uff1a\u9898\u76ee\u4fdd\u8bc1\u6bcf\u4e2a\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u662f\u4e0d\u540c\u7684\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5355\u4f4d\u4e2a\u6570\u3002\u968f\u540e\u6309\u4ee5\u4e0b\u683c\u5f0f\u975e\u964d\u5e8f\u8f93\u51fa\u5355\u4f4d\u7684\u6392\u884c\u699c\uff1a \u6392\u540d \u5b66\u6821 \u52a0\u6743\u603b\u5206 \u8003\u751f\u4eba\u6570 \u5176\u4e2d \u6392\u540d \u662f\u8be5\u5355\u4f4d\u7684\u6392\u540d\uff08\u4ece 1 \u5f00\u59cb\uff09\uff1b \u5b66\u6821 \u662f\u5168\u90e8\u6309\u5c0f\u5199\u5b57\u6bcd\u8f93\u51fa\u7684\u5355\u4f4d\u7801\uff1b \u52a0\u6743\u603b\u5206 \u5b9a\u4e49\u4e3a \u4e59\u7ea7\u603b\u5206/1.5 + \u7532\u7ea7\u603b\u5206 + \u9876\u7ea7\u603b\u5206*1.5 \u7684 \u6574\u6570\u90e8\u5206 \uff1b \u8003\u751f\u4eba\u6570 \u662f\u8be5\u5c5e\u4e8e\u5355\u4f4d\u7684\u8003\u751f\u7684\u603b\u4eba\u6570\u3002 \u5b66\u6821\u9996\u5148\u6309\u52a0\u6743\u603b\u5206\u6392\u884c\u3002\u5982\u6709\u5e76\u5217\uff0c\u5219\u5e94\u5bf9\u5e94\u76f8\u540c\u7684\u6392\u540d\uff0c\u5e76\u6309\u8003\u751f\u4eba\u6570\u5347\u5e8f\u8f93\u51fa\u3002\u5982\u679c\u4ecd\u7136\u5e76\u5217\uff0c\u5219\u6309\u5355\u4f4d\u7801\u7684\u5b57\u5178\u5e8f\u8f93\u51fa\u3002 \u8f93\u5165\u6837\u4f8b 10 A57908 85 Au B57908 54 LanX A37487 60 au T28374 67 CMU T32486 24 hypu A66734 92 cmu B76378 71 AU A47780 45 lanx A72809 100 pku A03274 45 hypu \u8f93\u51fa\u6837\u4f8b 5 1 cmu 192 2 1 au 192 3 3 pku 100 1 4 hypu 81 2 4 lanx 81 2","title":"Statement"},{"location":"PAT-Basic-Level/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/#solution","text":"C++ #include <ctype.h> #include <algorithm> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <iomanip> #include <iostream> #include <limits> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #define CLR(a) memset(a, 0, sizeof(a)) #define pb push_back using namespace std ; typedef long long ll ; typedef long double ld ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef pair < string , int > psi ; typedef pair < string , string > pss ; const double PI = 3.14159265358979323846264338327 ; const double E = exp ( 1 ); const double eps = 1e-30 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 5 ; const int MOD = 1e9 + 7 ; struct Node { string name ; int tot ; double score ; int s ; }; bool comp ( Node x , Node y ) { if ( x . s == y . s ) { if ( x . tot == y . tot ) return x . name < y . name ; else return x . tot < y . tot ; } return x . s > y . s ; } int main () { int n ; cin >> n ; map < string , Node > m ; string id , school ; int score ; for ( int i = 0 ; i < n ; i ++ ) { cin >> id >> score >> school ; int len = school . size (); for ( int j = 0 ; j < len ; j ++ ) if ( school [ j ] >= 'A' && school [ j ] <= 'Z' ) school [ j ] += 32 ; m [ school ]. tot ++ ; m [ school ]. name = school ; if ( id [ 0 ] == 'A' ) m [ school ]. score += score ; else if ( id [ 0 ] == 'B' ) m [ school ]. score += score * 1.0 / 1.5 ; else m [ school ]. score += score * 1.5 ; } map < string , Node >:: iterator it ; vector < Node > ans ; for ( it = m . begin (); it != m . end (); it ++ ) { it -> second . s = floor ( it -> second . score ); ans . pb ( it -> second ); } sort ( ans . begin (), ans . end (), comp ); int len = ans . size (); cout << len << endl ; printf ( \"1 \" ); cout << ans [ 0 ]. name ; printf ( \" %d %d \\n \" , ans [ 0 ]. s , ans [ 0 ]. tot ); int rank = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( ans [ i ]. s != ans [ i - 1 ]. s ) rank = i + 1 ; printf ( \"%d \" , rank ); cout << ans [ i ]. name ; printf ( \" %d %d \\n \" , ans [ i ]. s , ans [ i ]. tot ); } }","title":"Solution"},{"location":"PAT-Basic-Level/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/","text":"1086 \u5c31\u4e0d\u544a\u8bc9\u4f60 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u505a\u4f5c\u4e1a\u7684\u65f6\u5019\uff0c\u90bb\u5ea7\u7684\u5c0f\u76c6\u53cb\u95ee\u4f60\uff1a\u201c\u4e94\u4e58\u4ee5\u4e03\u7b49\u4e8e\u591a\u5c11\uff1f\u201d\u4f60\u5e94\u8be5\u4e0d\u5931\u793c\u8c8c\u5730\u56f4\u7b11\u7740\u544a\u8bc9\u4ed6\uff1a\u201c\u4e94\u5341\u4e09\u3002\u201d\u672c\u9898\u5c31\u8981\u6c42\u4f60\uff0c\u5bf9\u4efb\u4f55\u4e00\u5bf9\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\uff0c\u5012\u7740\u8f93\u51fa\u5b83\u4eec\u7684\u4e58\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 A \u548c B\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5012\u7740\u8f93\u51fa A \u548c B \u7684\u4e58\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 5 7 \u8f93\u51fa\u6837\u4f8b 53 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b ; while ( scanf ( \"%d%d\" , & a , & b ) != EOF ) { a *= b ; string s = \"\" ; while ( a ) { s += a % 10 + '0' ; a /= 10 ; } while ( s [ 0 ] == '0' ) s . erase ( 0 , 1 ); cout << s << endl ; } return 0 ; }","title":"1086-\u5c31\u4e0d\u544a\u8bc9\u4f60"},{"location":"PAT-Basic-Level/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/#1086-\u5c31\u4e0d\u544a\u8bc9\u4f60","text":"","title":"1086 \u5c31\u4e0d\u544a\u8bc9\u4f60"},{"location":"PAT-Basic-Level/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u505a\u4f5c\u4e1a\u7684\u65f6\u5019\uff0c\u90bb\u5ea7\u7684\u5c0f\u76c6\u53cb\u95ee\u4f60\uff1a\u201c\u4e94\u4e58\u4ee5\u4e03\u7b49\u4e8e\u591a\u5c11\uff1f\u201d\u4f60\u5e94\u8be5\u4e0d\u5931\u793c\u8c8c\u5730\u56f4\u7b11\u7740\u544a\u8bc9\u4ed6\uff1a\u201c\u4e94\u5341\u4e09\u3002\u201d\u672c\u9898\u5c31\u8981\u6c42\u4f60\uff0c\u5bf9\u4efb\u4f55\u4e00\u5bf9\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\uff0c\u5012\u7740\u8f93\u51fa\u5b83\u4eec\u7684\u4e58\u79ef\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570 A \u548c B\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u5012\u7740\u8f93\u51fa A \u548c B \u7684\u4e58\u79ef\u3002 \u8f93\u5165\u6837\u4f8b 5 7 \u8f93\u51fa\u6837\u4f8b 53","title":"Statement"},{"location":"PAT-Basic-Level/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int a , b ; while ( scanf ( \"%d%d\" , & a , & b ) != EOF ) { a *= b ; string s = \"\" ; while ( a ) { s += a % 10 + '0' ; a /= 10 ; } while ( s [ 0 ] == '0' ) s . erase ( 0 , 1 ); cout << s << endl ; } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/","text":"1087 \u6709\u591a\u5c11\u4e0d\u540c\u7684\u503c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u81ea\u7136\u6570 n n \u4f9d\u6b21\u53d6 1\u30012\u30013\u3001\u2026\u2026\u3001 N N \u65f6\uff0c\u7b97\u5f0f $lfloor n/2rfloor +lfloor n/3rfloor +lfloor n/5rfloor $ \u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u503c\uff1f\uff08\u6ce8\uff1a \\lfloor x\\rfloor \\lfloor x\\rfloor \u4e3a\u53d6\u6574\u51fd\u6570\uff0c\u8868\u793a\u4e0d\u8d85\u8fc7 x x \u7684\u6700\u5927\u81ea\u7136\u6570\uff0c\u5373 x x \u7684\u6574\u6570\u90e8\u5206\u3002\uff09 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 2 \\le N \\le 10^4 2 \\le N \\le 10^4 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u9898\u9762\u4e2d\u7b97\u5f0f\u53d6\u5230\u7684\u4e0d\u540c\u503c\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2017 \u8f93\u51fa\u6837\u4f8b 1480 Solution C++ #include <bits/stdc++.h> using namespace std ; int main () { int n ; int vis [ 20010 ]; while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( vis , 0 , sizeof vis ); for ( int i = 1 ; i <= n ; ++ i ) vis [ i / 2 + i / 3 + i / 5 ] = 1 ; int res = 0 ; for ( int i = 0 ; i <= 2 * n ; ++ i ) res += vis [ i ]; printf ( \"%d \\n \" , res ); } return 0 ; }","title":"1087-\u6709\u591a\u5c11\u4e0d\u540c\u7684\u503c"},{"location":"PAT-Basic-Level/1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/#1087-\u6709\u591a\u5c11\u4e0d\u540c\u7684\u503c","text":"","title":"1087 \u6709\u591a\u5c11\u4e0d\u540c\u7684\u503c"},{"location":"PAT-Basic-Level/1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u81ea\u7136\u6570 n n \u4f9d\u6b21\u53d6 1\u30012\u30013\u3001\u2026\u2026\u3001 N N \u65f6\uff0c\u7b97\u5f0f $lfloor n/2rfloor +lfloor n/3rfloor +lfloor n/5rfloor $ \u6709\u591a\u5c11\u4e2a\u4e0d\u540c\u7684\u503c\uff1f\uff08\u6ce8\uff1a \\lfloor x\\rfloor \\lfloor x\\rfloor \u4e3a\u53d6\u6574\u51fd\u6570\uff0c\u8868\u793a\u4e0d\u8d85\u8fc7 x x \u7684\u6700\u5927\u81ea\u7136\u6570\uff0c\u5373 x x \u7684\u6574\u6570\u90e8\u5206\u3002\uff09 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 2 \\le N \\le 10^4 2 \\le N \\le 10^4 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u9898\u9762\u4e2d\u7b97\u5f0f\u53d6\u5230\u7684\u4e0d\u540c\u503c\u7684\u4e2a\u6570\u3002 \u8f93\u5165\u6837\u4f8b 2017 \u8f93\u51fa\u6837\u4f8b 1480","title":"Statement"},{"location":"PAT-Basic-Level/1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; int main () { int n ; int vis [ 20010 ]; while ( scanf ( \"%d\" , & n ) != EOF ) { memset ( vis , 0 , sizeof vis ); for ( int i = 1 ; i <= n ; ++ i ) vis [ i / 2 + i / 3 + i / 5 ] = 1 ; int res = 0 ; for ( int i = 0 ; i <= 2 * n ; ++ i ) res += vis [ i ]; printf ( \"%d \\n \" , res ); } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C/","text":"1088 \u4e09\u4eba\u884c Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b50\u66f0\uff1a\u201c\u4e09\u4eba\u884c\uff0c\u5fc5\u6709\u6211\u5e08\u7109\u3002\u62e9\u5176\u5584\u8005\u800c\u4ece\u4e4b\uff0c\u5176\u4e0d\u5584\u8005\u800c\u6539\u4e4b\u3002\u201d \u672c\u9898\u7ed9\u5b9a\u7532\u3001\u4e59\u3001\u4e19\u4e09\u4e2a\u4eba\u7684\u80fd\u529b\u503c\u5173\u7cfb\u4e3a\uff1a\u7532\u7684\u80fd\u529b\u503c\u786e\u5b9a\u662f 2 \u4f4d\u6b63\u6574\u6570\uff1b\u628a\u7532\u7684\u80fd\u529b\u503c\u7684 2 \u4e2a\u6570\u5b57\u8c03\u6362\u4f4d\u7f6e\u5c31\u662f\u4e59\u7684\u80fd\u529b\u503c\uff1b\u7532\u4e59\u4e24\u4eba\u80fd\u529b\u5dee\u662f\u4e19\u7684\u80fd\u529b\u503c\u7684 X \u500d\uff1b\u4e59\u7684\u80fd\u529b\u503c\u662f\u4e19\u7684 Y \u500d\u3002\u8bf7\u4f60\u6307\u51fa\u8c01\u6bd4\u4f60\u5f3a\u5e94\u201c\u4ece\u4e4b\u201d\uff0c\u8c01\u6bd4\u4f60\u5f31\u5e94\u201c\u6539\u4e4b\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e09\u4e2a\u6570\uff0c\u4f9d\u6b21\u4e3a\uff1aM\uff08\u4f60\u81ea\u5df1\u7684\u80fd\u529b\u503c\uff09\u3001X \u548c Y\u3002\u4e09\u4e2a\u6570\u5b57\u5747\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u7532\u7684\u80fd\u529b\u503c\uff0c\u968f\u540e\u4f9d\u6b21\u8f93\u51fa\u7532\u3001\u4e59\u3001\u4e19\u4e09\u4eba\u4e0e\u4f60\u7684\u5173\u7cfb\uff1a\u5982\u679c\u5176\u6bd4\u4f60\u5f3a\uff0c\u8f93\u51fa Cong \uff1b\u5e73\u7b49\u5219\u8f93\u51fa Ping \uff1b\u6bd4\u4f60\u5f31\u5219\u8f93\u51fa Gai \u3002\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u4ee5\u7532\u7684\u6700\u5927\u89e3\u4e3a\u51c6\u8fdb\u884c\u5224\u65ad\uff1b\u5982\u679c\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 48 3 7 \u8f93\u51fa\u6837\u4f8b 1 48 Ping Cong Gai \u8f93\u5165\u6837\u4f8b 2 48 11 6 \u8f93\u51fa\u6837\u4f8b 2 No Solution Solution C++ #include <bits/stdc++.h> using namespace std ; const double eps = 1e-6 ; int m , x , y , a , b ; double c ; int f ( int x ) { return ( x % 10 ) * 10 + ( x / 10 ); } int get () { for ( int i = 99 ; i >= 11 ; -- i ) { a = i , b = f ( i ); c = abs ( a - b ) * 1.0 / x ; if ( fabs ( b - c * y ) > eps ) continue ; return 1 ; } return 0 ; } char * comp ( int x , double y ) { if ( x == y ) return ( char * ) \"Ping\" ; else if ( x > y ) return ( char * ) \"Gai\" ; else return ( char * ) \"Cong\" ; } int main () { while ( scanf ( \"%d%d%d\" , & m , & x , & y ) != EOF ) { if ( ! get ()) puts ( \"No Solution\" ); else printf ( \"%d %s %s %s \\n \" , a , comp ( m , a ), comp ( m , b ), comp ( m , c )); } return 0 ; }","title":"1088-\u4e09\u4eba\u884c"},{"location":"PAT-Basic-Level/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C/#1088-\u4e09\u4eba\u884c","text":"","title":"1088 \u4e09\u4eba\u884c"},{"location":"PAT-Basic-Level/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5b50\u66f0\uff1a\u201c\u4e09\u4eba\u884c\uff0c\u5fc5\u6709\u6211\u5e08\u7109\u3002\u62e9\u5176\u5584\u8005\u800c\u4ece\u4e4b\uff0c\u5176\u4e0d\u5584\u8005\u800c\u6539\u4e4b\u3002\u201d \u672c\u9898\u7ed9\u5b9a\u7532\u3001\u4e59\u3001\u4e19\u4e09\u4e2a\u4eba\u7684\u80fd\u529b\u503c\u5173\u7cfb\u4e3a\uff1a\u7532\u7684\u80fd\u529b\u503c\u786e\u5b9a\u662f 2 \u4f4d\u6b63\u6574\u6570\uff1b\u628a\u7532\u7684\u80fd\u529b\u503c\u7684 2 \u4e2a\u6570\u5b57\u8c03\u6362\u4f4d\u7f6e\u5c31\u662f\u4e59\u7684\u80fd\u529b\u503c\uff1b\u7532\u4e59\u4e24\u4eba\u80fd\u529b\u5dee\u662f\u4e19\u7684\u80fd\u529b\u503c\u7684 X \u500d\uff1b\u4e59\u7684\u80fd\u529b\u503c\u662f\u4e19\u7684 Y \u500d\u3002\u8bf7\u4f60\u6307\u51fa\u8c01\u6bd4\u4f60\u5f3a\u5e94\u201c\u4ece\u4e4b\u201d\uff0c\u8c01\u6bd4\u4f60\u5f31\u5e94\u201c\u6539\u4e4b\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e09\u4e2a\u6570\uff0c\u4f9d\u6b21\u4e3a\uff1aM\uff08\u4f60\u81ea\u5df1\u7684\u80fd\u529b\u503c\uff09\u3001X \u548c Y\u3002\u4e09\u4e2a\u6570\u5b57\u5747\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u9996\u5148\u8f93\u51fa\u7532\u7684\u80fd\u529b\u503c\uff0c\u968f\u540e\u4f9d\u6b21\u8f93\u51fa\u7532\u3001\u4e59\u3001\u4e19\u4e09\u4eba\u4e0e\u4f60\u7684\u5173\u7cfb\uff1a\u5982\u679c\u5176\u6bd4\u4f60\u5f3a\uff0c\u8f93\u51fa Cong \uff1b\u5e73\u7b49\u5219\u8f93\u51fa Ping \uff1b\u6bd4\u4f60\u5f31\u5219\u8f93\u51fa Gai \u3002\u5176\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u6ce8\u610f\uff1a\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u4ee5\u7532\u7684\u6700\u5927\u89e3\u4e3a\u51c6\u8fdb\u884c\u5224\u65ad\uff1b\u5982\u679c\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 48 3 7 \u8f93\u51fa\u6837\u4f8b 1 48 Ping Cong Gai \u8f93\u5165\u6837\u4f8b 2 48 11 6 \u8f93\u51fa\u6837\u4f8b 2 No Solution","title":"Statement"},{"location":"PAT-Basic-Level/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const double eps = 1e-6 ; int m , x , y , a , b ; double c ; int f ( int x ) { return ( x % 10 ) * 10 + ( x / 10 ); } int get () { for ( int i = 99 ; i >= 11 ; -- i ) { a = i , b = f ( i ); c = abs ( a - b ) * 1.0 / x ; if ( fabs ( b - c * y ) > eps ) continue ; return 1 ; } return 0 ; } char * comp ( int x , double y ) { if ( x == y ) return ( char * ) \"Ping\" ; else if ( x > y ) return ( char * ) \"Gai\" ; else return ( char * ) \"Cong\" ; } int main () { while ( scanf ( \"%d%d%d\" , & m , & x , & y ) != EOF ) { if ( ! get ()) puts ( \"No Solution\" ); else printf ( \"%d %s %s %s \\n \" , a , comp ( m , a ), comp ( m , b ), comp ( m , c )); } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88/","text":"1089 \u72fc\u4eba\u6740-\u7b80\u5355\u7248 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0b\u6587\u5b57\u6458\u81ea\u300a\u7075\u673a\u4e00\u52a8\u00b7\u597d\u73a9\u7684\u6570\u5b66\u300b\uff1a\u201c\u72fc\u4eba\u6740\u201d\u6e38\u620f\u5206\u4e3a\u72fc\u4eba\u3001\u597d\u4eba\u4e24\u5927\u9635\u8425\u3002\u5728\u4e00\u5c40\u201c\u72fc\u4eba\u6740\u201d\u6e38\u620f\u4e2d\uff0c1 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c2 \u53f7\u662f\u72fc\u4eba\u201d\uff0c2 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c3 \u53f7\u662f\u597d\u4eba\u201d\uff0c3 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c4 \u53f7\u662f\u72fc\u4eba\u201d\uff0c4 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c5 \u53f7\u662f\u597d\u4eba\u201d\uff0c5 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c4 \u53f7\u662f\u597d\u4eba\u201d\u3002\u5df2\u77e5\u8fd9 5 \u540d\u73a9\u5bb6\u4e2d\u6709 2 \u4eba\u626e\u6f14\u72fc\u4eba\u89d2\u8272\uff0c\u6709 2 \u4eba\u8bf4\u7684\u4e0d\u662f\u5b9e\u8bdd\uff0c\u6709\u72fc\u4eba\u6492\u8c0e\u4f46\u5e76\u4e0d\u662f\u6240\u6709\u72fc\u4eba\u90fd\u5728\u6492\u8c0e\u3002\u626e\u6f14\u72fc\u4eba\u89d2\u8272\u7684\u662f\u54ea\u4e24\u53f7\u73a9\u5bb6\uff1f \u672c\u9898\u662f\u8fd9\u4e2a\u95ee\u9898\u7684\u5347\u7ea7\u7248\uff1a\u5df2\u77e5 N N \u540d\u73a9\u5bb6\u4e2d\u6709 2 \u4eba\u626e\u6f14\u72fc\u4eba\u89d2\u8272\uff0c\u6709 2 \u4eba\u8bf4\u7684\u4e0d\u662f\u5b9e\u8bdd\uff0c\u6709\u72fc\u4eba\u6492\u8c0e\u4f46\u5e76\u4e0d\u662f\u6240\u6709\u72fc\u4eba\u90fd\u5728\u6492\u8c0e\u3002\u8981\u6c42\u4f60\u627e\u51fa\u626e\u6f14\u72fc\u4eba\u89d2\u8272\u7684\u662f\u54ea\u51e0\u53f7\u73a9\u5bb6\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 5 \\le N \\le 100 5 \\le N \\le 100 \uff09\u3002\u968f\u540e N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7b2c i i \u53f7\u73a9\u5bb6\u8bf4\u7684\u8bdd\uff08 1 \\le i \\le N 1 \\le i \\le N \uff09\uff0c\u5373\u4e00\u4e2a\u73a9\u5bb6\u7f16\u53f7\uff0c\u7528\u6b63\u53f7\u8868\u793a\u597d\u4eba\uff0c\u8d1f\u53f7\u8868\u793a\u72fc\u4eba\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u6709\u89e3\uff0c\u5728\u4e00\u884c\u4e2d\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa 2 \u4e2a\u72fc\u4eba\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u89e3 \u2014\u2014 \u5373\u5bf9\u4e8e\u4e24\u4e2a\u5e8f\u5217 A = { a[1], ..., a[M] } A = { a[1], ..., a[M] } \u548c B = { b[1], ..., b[M] } B = { b[1], ..., b[M] } \uff0c\u82e5\u5b58\u5728 0 \\le k < M 0 \\le k < M \u4f7f\u5f97 a[i]=b[i] a[i]=b[i] \uff08 i \\le k i \\le k \uff09\uff0c\u4e14 a[k+1]<b[k+1] a[k+1]<b[k+1] \uff0c\u5219\u79f0\u5e8f\u5217 A A \u5c0f\u4e8e\u5e8f\u5217 B B \u3002\u82e5\u65e0\u89e3\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 5 -2 +3 -4 +5 +4 \u8f93\u51fa\u6837\u4f8b 1 1 4 \u8f93\u5165\u6837\u4f8b 2 6 +6 +3 +1 -5 -2 +4 \u8f93\u51fa\u6837\u4f8b 2\uff08\u89e3\u4e0d\u552f\u4e00\uff09 1 5 \u8f93\u5165\u6837\u4f8b 3 5 -2 -3 -4 -5 -1 \u8f93\u51fa\u6837\u4f8b 3 No Solution","title":"1089-\u72fc\u4eba\u6740-\u7b80\u5355\u7248"},{"location":"PAT-Basic-Level/1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88/#1089-\u72fc\u4eba\u6740-\u7b80\u5355\u7248","text":"","title":"1089 \u72fc\u4eba\u6740-\u7b80\u5355\u7248"},{"location":"PAT-Basic-Level/1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u4ee5\u4e0b\u6587\u5b57\u6458\u81ea\u300a\u7075\u673a\u4e00\u52a8\u00b7\u597d\u73a9\u7684\u6570\u5b66\u300b\uff1a\u201c\u72fc\u4eba\u6740\u201d\u6e38\u620f\u5206\u4e3a\u72fc\u4eba\u3001\u597d\u4eba\u4e24\u5927\u9635\u8425\u3002\u5728\u4e00\u5c40\u201c\u72fc\u4eba\u6740\u201d\u6e38\u620f\u4e2d\uff0c1 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c2 \u53f7\u662f\u72fc\u4eba\u201d\uff0c2 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c3 \u53f7\u662f\u597d\u4eba\u201d\uff0c3 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c4 \u53f7\u662f\u72fc\u4eba\u201d\uff0c4 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c5 \u53f7\u662f\u597d\u4eba\u201d\uff0c5 \u53f7\u73a9\u5bb6\u8bf4\uff1a\u201c4 \u53f7\u662f\u597d\u4eba\u201d\u3002\u5df2\u77e5\u8fd9 5 \u540d\u73a9\u5bb6\u4e2d\u6709 2 \u4eba\u626e\u6f14\u72fc\u4eba\u89d2\u8272\uff0c\u6709 2 \u4eba\u8bf4\u7684\u4e0d\u662f\u5b9e\u8bdd\uff0c\u6709\u72fc\u4eba\u6492\u8c0e\u4f46\u5e76\u4e0d\u662f\u6240\u6709\u72fc\u4eba\u90fd\u5728\u6492\u8c0e\u3002\u626e\u6f14\u72fc\u4eba\u89d2\u8272\u7684\u662f\u54ea\u4e24\u53f7\u73a9\u5bb6\uff1f \u672c\u9898\u662f\u8fd9\u4e2a\u95ee\u9898\u7684\u5347\u7ea7\u7248\uff1a\u5df2\u77e5 N N \u540d\u73a9\u5bb6\u4e2d\u6709 2 \u4eba\u626e\u6f14\u72fc\u4eba\u89d2\u8272\uff0c\u6709 2 \u4eba\u8bf4\u7684\u4e0d\u662f\u5b9e\u8bdd\uff0c\u6709\u72fc\u4eba\u6492\u8c0e\u4f46\u5e76\u4e0d\u662f\u6240\u6709\u72fc\u4eba\u90fd\u5728\u6492\u8c0e\u3002\u8981\u6c42\u4f60\u627e\u51fa\u626e\u6f14\u72fc\u4eba\u89d2\u8272\u7684\u662f\u54ea\u51e0\u53f7\u73a9\u5bb6\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N \uff08 5 \\le N \\le 100 5 \\le N \\le 100 \uff09\u3002\u968f\u540e N N \u884c\uff0c\u7b2c i i \u884c\u7ed9\u51fa\u7b2c i i \u53f7\u73a9\u5bb6\u8bf4\u7684\u8bdd\uff08 1 \\le i \\le N 1 \\le i \\le N \uff09\uff0c\u5373\u4e00\u4e2a\u73a9\u5bb6\u7f16\u53f7\uff0c\u7528\u6b63\u53f7\u8868\u793a\u597d\u4eba\uff0c\u8d1f\u53f7\u8868\u793a\u72fc\u4eba\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u6709\u89e3\uff0c\u5728\u4e00\u884c\u4e2d\u6309\u9012\u589e\u987a\u5e8f\u8f93\u51fa 2 \u4e2a\u72fc\u4eba\u7684\u7f16\u53f7\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u8f93\u51fa\u6700\u5c0f\u5e8f\u5217\u89e3 \u2014\u2014 \u5373\u5bf9\u4e8e\u4e24\u4e2a\u5e8f\u5217 A = { a[1], ..., a[M] } A = { a[1], ..., a[M] } \u548c B = { b[1], ..., b[M] } B = { b[1], ..., b[M] } \uff0c\u82e5\u5b58\u5728 0 \\le k < M 0 \\le k < M \u4f7f\u5f97 a[i]=b[i] a[i]=b[i] \uff08 i \\le k i \\le k \uff09\uff0c\u4e14 a[k+1]<b[k+1] a[k+1]<b[k+1] \uff0c\u5219\u79f0\u5e8f\u5217 A A \u5c0f\u4e8e\u5e8f\u5217 B B \u3002\u82e5\u65e0\u89e3\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 5 -2 +3 -4 +5 +4 \u8f93\u51fa\u6837\u4f8b 1 1 4 \u8f93\u5165\u6837\u4f8b 2 6 +6 +3 +1 -5 -2 +4 \u8f93\u51fa\u6837\u4f8b 2\uff08\u89e3\u4e0d\u552f\u4e00\uff09 1 5 \u8f93\u5165\u6837\u4f8b 3 5 -2 -3 -4 -5 -1 \u8f93\u51fa\u6837\u4f8b 3 No Solution","title":"Statement"},{"location":"PAT-Basic-Level/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1/","text":"1090 \u5371\u9669\u54c1\u88c5\u7bb1 Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u96c6\u88c5\u7bb1\u8fd0\u8f93\u8d27\u7269\u65f6\uff0c\u6211\u4eec\u5fc5\u987b\u7279\u522b\u5c0f\u5fc3\uff0c\u4e0d\u80fd\u628a\u4e0d\u76f8\u5bb9\u7684\u8d27\u7269\u88c5\u5728\u4e00\u53ea\u7bb1\u5b50\u91cc\u3002\u6bd4\u5982\u6c27\u5316\u5242\u7edd\u5bf9\u4e0d\u80fd\u8ddf\u6613\u71c3\u6db2\u4f53\u540c\u7bb1\uff0c\u5426\u5219\u5f88\u5bb9\u6613\u9020\u6210\u7206\u70b8\u3002 \u672c\u9898\u7ed9\u5b9a\u4e00\u5f20\u4e0d\u76f8\u5bb9\u7269\u54c1\u7684\u6e05\u5355\uff0c\u9700\u8981\u4f60\u68c0\u67e5\u6bcf\u4e00\u5f20\u96c6\u88c5\u7bb1\u8d27\u54c1\u6e05\u5355\uff0c\u5224\u65ad\u5b83\u4eec\u662f\u5426\u80fd\u88c5\u5728\u540c\u4e00\u53ea\u7bb1\u5b50\u91cc\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N ( \\le 10^4 \\le 10^4 ) \u662f\u6210\u5bf9\u7684\u4e0d\u76f8\u5bb9\u7269\u54c1\u7684\u5bf9\u6570\uff1b M M ( \\le 100 \\le 100 ) \u662f\u96c6\u88c5\u7bb1\u8d27\u54c1\u6e05\u5355\u7684\u5355\u6570\u3002 \u968f\u540e\u6570\u636e\u5206\u4e24\u5927\u5757\u7ed9\u51fa\u3002\u7b2c\u4e00\u5757\u6709 N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u4e0d\u76f8\u5bb9\u7684\u7269\u54c1\u3002\u7b2c\u4e8c\u5757\u6709 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7bb1\u8d27\u7269\u7684\u6e05\u5355\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K G[1] G[2] ... G[K] \u5176\u4e2d K ( \\le 1000 \\le 1000 ) \u662f\u7269\u54c1\u4ef6\u6570\uff0c G[i] \u662f\u7269\u54c1\u7684\u7f16\u53f7\u3002\u7b80\u5355\u8d77\u89c1\uff0c\u6bcf\u4ef6\u7269\u54c1\u7528\u4e00\u4e2a 5 \u4f4d\u6570\u7684\u7f16\u53f7\u4ee3\u8868\u3002\u4e24\u4e2a\u6570\u5b57\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7bb1\u8d27\u7269\u6e05\u5355\uff0c\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5b89\u5168\u8fd0\u8f93\u3002\u5982\u679c\u6ca1\u6709\u4e0d\u76f8\u5bb9\u7269\u54c1\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 6 3 20001 20002 20003 20004 20005 20006 20003 20001 20005 20004 20004 20006 4 00001 20004 00002 20003 5 98823 20002 20003 20006 10010 3 12345 67890 23333 \u8f93\u51fa\u6837\u4f8b No Yes Yes Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 #define M 1000010 int vis [ M ]; int n , q , a [ N ]; pii e [ N ]; bool ok () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ e [ i ]. fi ] && vis [ e [ i ]. se ]) return 0 ; return 1 ; } int main () { scanf ( \"%d%d\" , & n , & q ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d%d\" , & e [ i ]. fi , & e [ i ]. se ); while ( q -- ) { int k ; cin >> k ; for ( int i = 1 ; i <= k ; ++ i ) { scanf ( \"%d\" , a + i ); vis [ a [ i ]] = 1 ; } puts ( ok () ? \"Yes\" : \"No\" ); for ( int i = 1 ; i <= k ; ++ i ) vis [ a [ i ]] = 0 ; } return 0 ; }","title":"1090-\u5371\u9669\u54c1\u88c5\u7bb1"},{"location":"PAT-Basic-Level/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1/#1090-\u5371\u9669\u54c1\u88c5\u7bb1","text":"","title":"1090 \u5371\u9669\u54c1\u88c5\u7bb1"},{"location":"PAT-Basic-Level/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u96c6\u88c5\u7bb1\u8fd0\u8f93\u8d27\u7269\u65f6\uff0c\u6211\u4eec\u5fc5\u987b\u7279\u522b\u5c0f\u5fc3\uff0c\u4e0d\u80fd\u628a\u4e0d\u76f8\u5bb9\u7684\u8d27\u7269\u88c5\u5728\u4e00\u53ea\u7bb1\u5b50\u91cc\u3002\u6bd4\u5982\u6c27\u5316\u5242\u7edd\u5bf9\u4e0d\u80fd\u8ddf\u6613\u71c3\u6db2\u4f53\u540c\u7bb1\uff0c\u5426\u5219\u5f88\u5bb9\u6613\u9020\u6210\u7206\u70b8\u3002 \u672c\u9898\u7ed9\u5b9a\u4e00\u5f20\u4e0d\u76f8\u5bb9\u7269\u54c1\u7684\u6e05\u5355\uff0c\u9700\u8981\u4f60\u68c0\u67e5\u6bcf\u4e00\u5f20\u96c6\u88c5\u7bb1\u8d27\u54c1\u6e05\u5355\uff0c\u5224\u65ad\u5b83\u4eec\u662f\u5426\u80fd\u88c5\u5728\u540c\u4e00\u53ea\u7bb1\u5b50\u91cc\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570\uff1a N N ( \\le 10^4 \\le 10^4 ) \u662f\u6210\u5bf9\u7684\u4e0d\u76f8\u5bb9\u7269\u54c1\u7684\u5bf9\u6570\uff1b M M ( \\le 100 \\le 100 ) \u662f\u96c6\u88c5\u7bb1\u8d27\u54c1\u6e05\u5355\u7684\u5355\u6570\u3002 \u968f\u540e\u6570\u636e\u5206\u4e24\u5927\u5757\u7ed9\u51fa\u3002\u7b2c\u4e00\u5757\u6709 N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9\u4e0d\u76f8\u5bb9\u7684\u7269\u54c1\u3002\u7b2c\u4e8c\u5757\u6709 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7bb1\u8d27\u7269\u7684\u6e05\u5355\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a K G[1] G[2] ... G[K] \u5176\u4e2d K ( \\le 1000 \\le 1000 ) \u662f\u7269\u54c1\u4ef6\u6570\uff0c G[i] \u662f\u7269\u54c1\u7684\u7f16\u53f7\u3002\u7b80\u5355\u8d77\u89c1\uff0c\u6bcf\u4ef6\u7269\u54c1\u7528\u4e00\u4e2a 5 \u4f4d\u6570\u7684\u7f16\u53f7\u4ee3\u8868\u3002\u4e24\u4e2a\u6570\u5b57\u4e4b\u95f4\u7528\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u7bb1\u8d27\u7269\u6e05\u5355\uff0c\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5b89\u5168\u8fd0\u8f93\u3002\u5982\u679c\u6ca1\u6709\u4e0d\u76f8\u5bb9\u7269\u54c1\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 6 3 20001 20002 20003 20004 20005 20006 20003 20001 20005 20004 20004 20006 4 00001 20004 00002 20003 5 98823 20002 20003 20006 10010 3 12345 67890 23333 \u8f93\u51fa\u6837\u4f8b No Yes Yes","title":"Statement"},{"location":"PAT-Basic-Level/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 #define M 1000010 int vis [ M ]; int n , q , a [ N ]; pii e [ N ]; bool ok () { for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ e [ i ]. fi ] && vis [ e [ i ]. se ]) return 0 ; return 1 ; } int main () { scanf ( \"%d%d\" , & n , & q ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d%d\" , & e [ i ]. fi , & e [ i ]. se ); while ( q -- ) { int k ; cin >> k ; for ( int i = 1 ; i <= k ; ++ i ) { scanf ( \"%d\" , a + i ); vis [ a [ i ]] = 1 ; } puts ( ok () ? \"Yes\" : \"No\" ); for ( int i = 1 ; i <= k ; ++ i ) vis [ a [ i ]] = 0 ; } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0/","text":"1091 N-\u81ea\u5b88\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u67d0\u4e2a\u6570 K K \u7684\u5e73\u65b9\u4e58\u4ee5 N N \u4ee5\u540e\uff0c\u7ed3\u679c\u7684\u672b\u5c3e\u51e0\u4f4d\u6570\u7b49\u4e8e K K \uff0c\u90a3\u4e48\u5c31\u79f0\u8fd9\u4e2a\u6570\u4e3a\u201c N N -\u81ea\u5b88\u6570\u201d\u3002\u4f8b\u5982 3\\times 92^2 = 25 392 3\\times 92^2 = 25 392 \uff0c\u800c 25 392 25 392 \u7684\u672b\u5c3e\u4e24\u4f4d\u6b63\u597d\u662f 92 92 \uff0c\u6240\u4ee5 92 92 \u662f\u4e00\u4e2a 3 3 -\u81ea\u5b88\u6570\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5224\u65ad\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6570\u5b57\u662f\u5426\u5173\u4e8e\u67d0\u4e2a N N \u662f N N -\u81ea\u5b88\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 M M \uff08 \\le 20 \\le 20 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa M M \u4e2a\u5f85\u68c0\u6d4b\u7684\u3001\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u68c0\u6d4b\u7684\u6570\u5b57\uff0c\u5982\u679c\u5b83\u662f N N -\u81ea\u5b88\u6570\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5c0f\u7684 N N \u548c NK^2 NK^2 \u7684\u503c\uff0c\u4ee5\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\uff1b\u5426\u5219\u8f93\u51fa No \u3002\u6ce8\u610f\u9898\u76ee\u4fdd\u8bc1 N < 10 N < 10 \u3002 \u8f93\u5165\u6837\u4f8b 3 92 5 233 \u8f93\u51fa\u6837\u4f8b 3 25392 1 25 No Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n ; bool ok ( int x , int n ) { while ( n ) { if ( x % 10 != n % 10 ) return 0 ; x /= 10 ; n /= 10 ; } return 1 ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n ); bool flag = 0 ; for ( int i = 1 ; i < 10 ; ++ i ) if ( ok ( n * n * i , n )) { flag = 1 ; printf ( \"%d %d \\n \" , i , n * n * i ); break ; } if ( flag == 0 ) puts ( \"No\" ); } return 0 ; }","title":"1091-N-\u81ea\u5b88\u6570"},{"location":"PAT-Basic-Level/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0/#1091-n-\u81ea\u5b88\u6570","text":"","title":"1091 N-\u81ea\u5b88\u6570"},{"location":"PAT-Basic-Level/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5982\u679c\u67d0\u4e2a\u6570 K K \u7684\u5e73\u65b9\u4e58\u4ee5 N N \u4ee5\u540e\uff0c\u7ed3\u679c\u7684\u672b\u5c3e\u51e0\u4f4d\u6570\u7b49\u4e8e K K \uff0c\u90a3\u4e48\u5c31\u79f0\u8fd9\u4e2a\u6570\u4e3a\u201c N N -\u81ea\u5b88\u6570\u201d\u3002\u4f8b\u5982 3\\times 92^2 = 25 392 3\\times 92^2 = 25 392 \uff0c\u800c 25 392 25 392 \u7684\u672b\u5c3e\u4e24\u4f4d\u6b63\u597d\u662f 92 92 \uff0c\u6240\u4ee5 92 92 \u662f\u4e00\u4e2a 3 3 -\u81ea\u5b88\u6570\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\u5224\u65ad\u4e00\u4e2a\u7ed9\u5b9a\u7684\u6570\u5b57\u662f\u5426\u5173\u4e8e\u67d0\u4e2a N N \u662f N N -\u81ea\u5b88\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 M M \uff08 \\le 20 \\le 20 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa M M \u4e2a\u5f85\u68c0\u6d4b\u7684\u3001\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u68c0\u6d4b\u7684\u6570\u5b57\uff0c\u5982\u679c\u5b83\u662f N N -\u81ea\u5b88\u6570\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5c0f\u7684 N N \u548c NK^2 NK^2 \u7684\u503c\uff0c\u4ee5\u4e00\u4e2a\u7a7a\u683c\u9694\u5f00\uff1b\u5426\u5219\u8f93\u51fa No \u3002\u6ce8\u610f\u9898\u76ee\u4fdd\u8bc1 N < 10 N < 10 \u3002 \u8f93\u5165\u6837\u4f8b 3 92 5 233 \u8f93\u51fa\u6837\u4f8b 3 25392 1 25 No","title":"Statement"},{"location":"PAT-Basic-Level/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n ; bool ok ( int x , int n ) { while ( n ) { if ( x % 10 != n % 10 ) return 0 ; x /= 10 ; n /= 10 ; } return 1 ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n ); bool flag = 0 ; for ( int i = 1 ; i < 10 ; ++ i ) if ( ok ( n * n * i , n )) { flag = 1 ; printf ( \"%d %d \\n \" , i , n * n * i ); break ; } if ( flag == 0 ) puts ( \"No\" ); } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC/","text":"1092 \u6700\u597d\u5403\u7684\u6708\u997c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e45\u8d1f\u76db\u540d\u7684\u4e2d\u56fd\u4f20\u7edf\u7cd5\u70b9\u4e4b\u4e00\uff0c\u81ea\u5510\u671d\u4ee5\u6765\uff0c\u5df2\u7ecf\u53d1\u5c55\u51fa\u51e0\u767e\u54c1\u79cd\u3002 \u82e5\u60f3\u8bc4\u6bd4\u51fa\u4e00\u79cd\u201c\u6700\u597d\u5403\u201d\u7684\u6708\u997c\uff0c\u90a3\u52bf\u5fc5\u5728\u5403\u8d27\u754c\u5f15\u53d1\u4e00\u573a\u8165\u98ce\u8840\u96e8\u2026\u2026 \u5728\u8fd9\u91cc\u6211\u4eec\u7528\u6570\u5b57\u8bf4\u8bdd\uff0c\u7ed9\u51fa\u5168\u56fd\u5404\u5730\u5404\u79cd\u6708\u997c\u7684\u9500\u91cf\uff0c\u8981\u6c42\u4f60\u4ece\u4e2d\u627e\u51fa\u9500\u91cf\u51a0\u519b\uff0c\u8ba4\u5b9a\u4e3a\u6700\u597d\u5403\u7684\u6708\u997c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\u548c M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u6708\u997c\u7684\u79cd\u7c7b\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u6708\u997c\u79cd\u7c7b\u4ece 1 \u5230 N N \u7f16\u53f7\uff09\u548c\u53c2\u4e0e\u7edf\u8ba1\u7684\u57ce\u5e02\u6570\u91cf\u3002 \u63a5\u4e0b\u6765 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u975e\u8d1f\u6574\u6570\uff08\u5747\u4e0d\u8d85\u8fc7 1 \u767e\u4e07\uff09\uff0c\u5176\u4e2d\u7b2c i i \u4e2a\u6574\u6570\u4e3a\u7b2c i i \u79cd\u6708\u997c\u7684\u9500\u91cf\uff08\u5757\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u9500\u91cf\uff0c\u7b2c\u4e8c\u884c\u8f93\u51fa\u9500\u91cf\u6700\u5927\u7684\u6708\u997c\u7684\u79cd\u7c7b\u7f16\u53f7\u3002\u5982\u679c\u51a0\u519b\u4e0d\u552f\u4e00\uff0c\u5219\u6309\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u5e76\u5217\u51a0\u519b\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 \u8f93\u51fa\u6837\u4f8b 2018 3 5 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n , m , a [ N ]; int main () { memset ( a , 0 , sizeof a ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) { int x ; for ( int j = 1 ; j <= n ; ++ j ) scanf ( \"%d\" , & x ), a [ j ] += x ; } int Max = * max_element ( a + 1 , a + 1 + n ); printf ( \"%d \\n \" , Max ); bool flag = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( a [ i ] == Max ) { if ( flag ) printf ( \" \" ); else flag = 1 ; printf ( \"%d\" , i ); } puts ( \"\" ); return 0 ; }","title":"1092-\u6700\u597d\u5403\u7684\u6708\u997c"},{"location":"PAT-Basic-Level/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC/#1092-\u6700\u597d\u5403\u7684\u6708\u997c","text":"","title":"1092 \u6700\u597d\u5403\u7684\u6708\u997c"},{"location":"PAT-Basic-Level/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB \u6708\u997c\u662f\u4e45\u8d1f\u76db\u540d\u7684\u4e2d\u56fd\u4f20\u7edf\u7cd5\u70b9\u4e4b\u4e00\uff0c\u81ea\u5510\u671d\u4ee5\u6765\uff0c\u5df2\u7ecf\u53d1\u5c55\u51fa\u51e0\u767e\u54c1\u79cd\u3002 \u82e5\u60f3\u8bc4\u6bd4\u51fa\u4e00\u79cd\u201c\u6700\u597d\u5403\u201d\u7684\u6708\u997c\uff0c\u90a3\u52bf\u5fc5\u5728\u5403\u8d27\u754c\u5f15\u53d1\u4e00\u573a\u8165\u98ce\u8840\u96e8\u2026\u2026 \u5728\u8fd9\u91cc\u6211\u4eec\u7528\u6570\u5b57\u8bf4\u8bdd\uff0c\u7ed9\u51fa\u5168\u56fd\u5404\u5730\u5404\u79cd\u6708\u997c\u7684\u9500\u91cf\uff0c\u8981\u6c42\u4f60\u4ece\u4e2d\u627e\u51fa\u9500\u91cf\u51a0\u519b\uff0c\u8ba4\u5b9a\u4e3a\u6700\u597d\u5403\u7684\u6708\u997c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 1000 \\le 1000 \uff09\u548c M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u6708\u997c\u7684\u79cd\u7c7b\u6570\uff08\u4e8e\u662f\u9ed8\u8ba4\u6708\u997c\u79cd\u7c7b\u4ece 1 \u5230 N N \u7f16\u53f7\uff09\u548c\u53c2\u4e0e\u7edf\u8ba1\u7684\u57ce\u5e02\u6570\u91cf\u3002 \u63a5\u4e0b\u6765 M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa N N \u4e2a\u975e\u8d1f\u6574\u6570\uff08\u5747\u4e0d\u8d85\u8fc7 1 \u767e\u4e07\uff09\uff0c\u5176\u4e2d\u7b2c i i \u4e2a\u6574\u6570\u4e3a\u7b2c i i \u79cd\u6708\u997c\u7684\u9500\u91cf\uff08\u5757\uff09\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u6700\u5927\u9500\u91cf\uff0c\u7b2c\u4e8c\u884c\u8f93\u51fa\u9500\u91cf\u6700\u5927\u7684\u6708\u997c\u7684\u79cd\u7c7b\u7f16\u53f7\u3002\u5982\u679c\u51a0\u519b\u4e0d\u552f\u4e00\uff0c\u5219\u6309\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u5e76\u5217\u51a0\u519b\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 \u8f93\u51fa\u6837\u4f8b 2018 3 5","title":"Statement"},{"location":"PAT-Basic-Level/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n , m , a [ N ]; int main () { memset ( a , 0 , sizeof a ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) { int x ; for ( int j = 1 ; j <= n ; ++ j ) scanf ( \"%d\" , & x ), a [ j ] += x ; } int Max = * max_element ( a + 1 , a + 1 + n ); printf ( \"%d \\n \" , Max ); bool flag = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( a [ i ] == Max ) { if ( flag ) printf ( \" \" ); else flag = 1 ; printf ( \"%d\" , i ); } puts ( \"\" ); return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A%2BB/","text":"1093 \u5b57\u7b26\u4e32A+B Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32 A A \u548c B B \uff0c\u672c\u9898\u8981\u6c42\u4f60\u8f93\u51fa A+B A+B \uff0c\u5373\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u5e76\u96c6\u3002\u8981\u6c42\u5148\u8f93\u51fa A A \uff0c\u518d\u8f93\u51fa B B \uff0c\u4f46 \u91cd\u590d\u7684\u5b57\u7b26\u5fc5\u987b\u88ab\u5254\u9664 \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e24\u884c\u4e2d\u5206\u522b\u7ed9\u51fa A A \u548c B B \uff0c\u5747\u4e3a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u3001\u7531\u53ef\u89c1 ASCII \u5b57\u7b26 (\u5373\u7801\u503c\u4e3a32~126)\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u3001\u7531\u56de\u8f66\u6807\u8bc6\u7ed3\u675f\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u9898\u9762\u8981\u6c42\u7684 A A \u548c B B \u7684\u548c\u3002 \u8f93\u5165\u6837\u4f8b This is a sample test to show you_How it works \u8f93\u51fa\u6837\u4f8b This ampletowyu_Hrk Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define fi first #define se second #define pii pair<int, int> string a , b ; int mp [ 1100 ]; int main () { getline ( cin , a ); getline ( cin , b ); memset ( mp , 0 , sizeof mp ); a += b ; for ( int i = 0 , len = a . size (); i < len ; ++ i ) { if ( mp [ a [ i ]]) continue ; mp [ a [ i ]] = 1 ; putchar ( a [ i ]); } puts ( \"\" ); return 0 ; }","title":"1093-\u5b57\u7b26\u4e32A+B"},{"location":"PAT-Basic-Level/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A%2BB/#1093-\u5b57\u7b26\u4e32ab","text":"","title":"1093 \u5b57\u7b26\u4e32A+B"},{"location":"PAT-Basic-Level/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A%2BB/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32 A A \u548c B B \uff0c\u672c\u9898\u8981\u6c42\u4f60\u8f93\u51fa A+B A+B \uff0c\u5373\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u5e76\u96c6\u3002\u8981\u6c42\u5148\u8f93\u51fa A A \uff0c\u518d\u8f93\u51fa B B \uff0c\u4f46 \u91cd\u590d\u7684\u5b57\u7b26\u5fc5\u987b\u88ab\u5254\u9664 \u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e24\u884c\u4e2d\u5206\u522b\u7ed9\u51fa A A \u548c B B \uff0c\u5747\u4e3a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u3001\u7531\u53ef\u89c1 ASCII \u5b57\u7b26 (\u5373\u7801\u503c\u4e3a32~126)\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u3001\u7531\u56de\u8f66\u6807\u8bc6\u7ed3\u675f\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u9898\u9762\u8981\u6c42\u7684 A A \u548c B B \u7684\u548c\u3002 \u8f93\u5165\u6837\u4f8b This is a sample test to show you_How it works \u8f93\u51fa\u6837\u4f8b This ampletowyu_Hrk","title":"Statement"},{"location":"PAT-Basic-Level/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A%2BB/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define N 100010 #define fi first #define se second #define pii pair<int, int> string a , b ; int mp [ 1100 ]; int main () { getline ( cin , a ); getline ( cin , b ); memset ( mp , 0 , sizeof mp ); a += b ; for ( int i = 0 , len = a . size (); i < len ; ++ i ) { if ( mp [ a [ i ]]) continue ; mp [ a [ i ]] = 1 ; putchar ( a [ i ]); } puts ( \"\" ); return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98/","text":"1094 \u8c37\u6b4c\u7684\u62db\u8058 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB 2004 \u5e74 7 \u6708\uff0c\u8c37\u6b4c\u5728\u7845\u8c37\u7684 101 \u53f7\u516c\u8def\u8fb9\u7ad6\u7acb\u4e86\u4e00\u5757\u5de8\u5927\u7684\u5e7f\u544a\u724c\uff08\u5982\u4e0b\u56fe\uff09\u7528\u4e8e\u62db\u8058\u3002\u5185\u5bb9\u8d85\u7ea7\u7b80\u5355\uff0c\u5c31\u662f\u4e00\u4e2a\u4ee5 .com \u7ed3\u5c3e\u7684\u7f51\u5740\uff0c\u800c\u524d\u9762\u7684\u7f51\u5740\u662f\u4e00\u4e2a 10 \u4f4d\u7d20\u6570\uff0c\u8fd9\u4e2a\u7d20\u6570\u662f\u81ea\u7136\u5e38\u6570 e \u4e2d\u6700\u65e9\u51fa\u73b0\u7684 10 \u4f4d\u8fde\u7eed\u6570\u5b57\u3002\u80fd\u627e\u51fa\u8fd9\u4e2a\u7d20\u6570\u7684\u4eba\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8bbf\u95ee\u8c37\u6b4c\u7684\u8fd9\u4e2a\u7f51\u7ad9\u8fdb\u5165\u62db\u8058\u6d41\u7a0b\u7684\u4e0b\u4e00\u6b65\u3002 \u81ea\u7136\u5e38\u6570 e \u662f\u4e00\u4e2a\u8457\u540d\u7684\u8d85\u8d8a\u6570\uff0c\u524d\u9762\u82e5\u5e72\u4f4d\u5199\u51fa\u6765\u662f\u8fd9\u6837\u7684\uff1ae = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642 7427466391 932003059921\u2026 \u5176\u4e2d\u7c97\u4f53\u6807\u51fa\u7684 10 \u4f4d\u6570\u5c31\u662f\u7b54\u6848\u3002 \u672c\u9898\u8981\u6c42\u4f60\u7f16\u7a0b\u89e3\u51b3\u4e00\u4e2a\u66f4\u901a\u7528\u7684\u95ee\u9898\uff1a\u4ece\u4efb\u4e00\u7ed9\u5b9a\u7684\u957f\u5ea6\u4e3a L \u7684\u6570\u5b57\u4e2d\uff0c\u627e\u51fa\u6700\u65e9\u51fa\u73b0\u7684 K \u4f4d\u8fde\u7eed\u6570\u5b57\u6240\u7ec4\u6210\u7684\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f L\uff08\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u6570\u5b57\u957f\u5ea6\uff09\u548c K\uff08\u5c0f\u4e8e 10 \u7684\u6b63\u6574\u6570\uff09\u3002\u63a5\u4e0b\u6765\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a L \u7684\u6b63\u6574\u6570 N\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa N \u4e2d\u6700\u65e9\u51fa\u73b0\u7684 K \u4f4d\u8fde\u7eed\u6570\u5b57\u6240\u7ec4\u6210\u7684\u7d20\u6570\u3002\u5982\u679c\u8fd9\u6837\u7684\u7d20\u6570\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa 404 \u3002\u6ce8\u610f\uff0c\u539f\u59cb\u6570\u5b57\u4e2d\u7684\u524d\u5bfc\u96f6\u4e5f\u8ba1\u7b97\u5728\u4f4d\u6570\u4e4b\u5185\u3002\u4f8b\u5982\u5728 200236 \u4e2d\u627e 4 \u4f4d\u7d20\u6570\uff0c0023 \u7b97\u662f\u89e3\uff1b\u4f46\u7b2c\u4e00\u4f4d 2 \u4e0d\u80fd\u88ab\u5f53\u6210 0002 \u8f93\u51fa\uff0c\u56e0\u4e3a\u5728\u539f\u59cb\u6570\u5b57\u4e2d\u4e0d\u5b58\u5728\u8fd9\u4e2a 2 \u7684\u524d\u5bfc\u96f6\u3002 \u8f93\u5165\u6837\u4f8b 1 20 5 23654987725541023819 \u8f93\u51fa\u6837\u4f8b 1 49877 \u8f93\u5165\u6837\u4f8b 2 10 3 2468001680 \u8f93\u51fa\u6837\u4f8b 2 404 \u9e23\u8c22\u7528\u6237 \u5927\u51b0 \u8865\u5145\u6570\u636e\uff01 Solution C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n , k ; char s [ N ]; bool isprime ( ll x ) { for ( int i = 2 ; 1l l * i * i <= x ; ++ i ) if ( x % i == 0 ) return 0 ; return 1 ; } ll getf ( int l , int r ) { ll res = 0 ; for ( int i = l ; i <= r ; ++ i ) res = res * 10 + s [ i ] - '0' ; return res ; } void work () { for ( int i = k ; i <= n ; ++ i ) { ll x = getf ( i - k + 1 , i ); if ( isprime ( x )) { printf ( \"%0*lld \\n \" , k , x ); return ; } } puts ( \"404\" ); } int main () { while ( scanf ( \"%d%d\" , & n , & k ) != EOF ) { scanf ( \"%s\" , s + 1 ); work (); } return 0 ; }","title":"1094-\u8c37\u6b4c\u7684\u62db\u8058"},{"location":"PAT-Basic-Level/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98/#1094-\u8c37\u6b4c\u7684\u62db\u8058","text":"","title":"1094 \u8c37\u6b4c\u7684\u62db\u8058"},{"location":"PAT-Basic-Level/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB 2004 \u5e74 7 \u6708\uff0c\u8c37\u6b4c\u5728\u7845\u8c37\u7684 101 \u53f7\u516c\u8def\u8fb9\u7ad6\u7acb\u4e86\u4e00\u5757\u5de8\u5927\u7684\u5e7f\u544a\u724c\uff08\u5982\u4e0b\u56fe\uff09\u7528\u4e8e\u62db\u8058\u3002\u5185\u5bb9\u8d85\u7ea7\u7b80\u5355\uff0c\u5c31\u662f\u4e00\u4e2a\u4ee5 .com \u7ed3\u5c3e\u7684\u7f51\u5740\uff0c\u800c\u524d\u9762\u7684\u7f51\u5740\u662f\u4e00\u4e2a 10 \u4f4d\u7d20\u6570\uff0c\u8fd9\u4e2a\u7d20\u6570\u662f\u81ea\u7136\u5e38\u6570 e \u4e2d\u6700\u65e9\u51fa\u73b0\u7684 10 \u4f4d\u8fde\u7eed\u6570\u5b57\u3002\u80fd\u627e\u51fa\u8fd9\u4e2a\u7d20\u6570\u7684\u4eba\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8bbf\u95ee\u8c37\u6b4c\u7684\u8fd9\u4e2a\u7f51\u7ad9\u8fdb\u5165\u62db\u8058\u6d41\u7a0b\u7684\u4e0b\u4e00\u6b65\u3002 \u81ea\u7136\u5e38\u6570 e \u662f\u4e00\u4e2a\u8457\u540d\u7684\u8d85\u8d8a\u6570\uff0c\u524d\u9762\u82e5\u5e72\u4f4d\u5199\u51fa\u6765\u662f\u8fd9\u6837\u7684\uff1ae = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642 7427466391 932003059921\u2026 \u5176\u4e2d\u7c97\u4f53\u6807\u51fa\u7684 10 \u4f4d\u6570\u5c31\u662f\u7b54\u6848\u3002 \u672c\u9898\u8981\u6c42\u4f60\u7f16\u7a0b\u89e3\u51b3\u4e00\u4e2a\u66f4\u901a\u7528\u7684\u95ee\u9898\uff1a\u4ece\u4efb\u4e00\u7ed9\u5b9a\u7684\u957f\u5ea6\u4e3a L \u7684\u6570\u5b57\u4e2d\uff0c\u627e\u51fa\u6700\u65e9\u51fa\u73b0\u7684 K \u4f4d\u8fde\u7eed\u6570\u5b57\u6240\u7ec4\u6210\u7684\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff0c\u5206\u522b\u662f L\uff08\u4e0d\u8d85\u8fc7 1000 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u6570\u5b57\u957f\u5ea6\uff09\u548c K\uff08\u5c0f\u4e8e 10 \u7684\u6b63\u6574\u6570\uff09\u3002\u63a5\u4e0b\u6765\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a L \u7684\u6b63\u6574\u6570 N\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa N \u4e2d\u6700\u65e9\u51fa\u73b0\u7684 K \u4f4d\u8fde\u7eed\u6570\u5b57\u6240\u7ec4\u6210\u7684\u7d20\u6570\u3002\u5982\u679c\u8fd9\u6837\u7684\u7d20\u6570\u4e0d\u5b58\u5728\uff0c\u5219\u8f93\u51fa 404 \u3002\u6ce8\u610f\uff0c\u539f\u59cb\u6570\u5b57\u4e2d\u7684\u524d\u5bfc\u96f6\u4e5f\u8ba1\u7b97\u5728\u4f4d\u6570\u4e4b\u5185\u3002\u4f8b\u5982\u5728 200236 \u4e2d\u627e 4 \u4f4d\u7d20\u6570\uff0c0023 \u7b97\u662f\u89e3\uff1b\u4f46\u7b2c\u4e00\u4f4d 2 \u4e0d\u80fd\u88ab\u5f53\u6210 0002 \u8f93\u51fa\uff0c\u56e0\u4e3a\u5728\u539f\u59cb\u6570\u5b57\u4e2d\u4e0d\u5b58\u5728\u8fd9\u4e2a 2 \u7684\u524d\u5bfc\u96f6\u3002 \u8f93\u5165\u6837\u4f8b 1 20 5 23654987725541023819 \u8f93\u51fa\u6837\u4f8b 1 49877 \u8f93\u5165\u6837\u4f8b 2 10 3 2468001680 \u8f93\u51fa\u6837\u4f8b 2 404 \u9e23\u8c22\u7528\u6237 \u5927\u51b0 \u8865\u5145\u6570\u636e\uff01","title":"Statement"},{"location":"PAT-Basic-Level/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define db double #define ll long long #define INF 0x3f3f3f3f #define fi first #define se second #define pii pair<int, int> #define N 10010 int n , k ; char s [ N ]; bool isprime ( ll x ) { for ( int i = 2 ; 1l l * i * i <= x ; ++ i ) if ( x % i == 0 ) return 0 ; return 1 ; } ll getf ( int l , int r ) { ll res = 0 ; for ( int i = l ; i <= r ; ++ i ) res = res * 10 + s [ i ] - '0' ; return res ; } void work () { for ( int i = k ; i <= n ; ++ i ) { ll x = getf ( i - k + 1 , i ); if ( isprime ( x )) { printf ( \"%0*lld \\n \" , k , x ); return ; } } puts ( \"404\" ); } int main () { while ( scanf ( \"%d%d\" , & n , & k ) != EOF ) { scanf ( \"%s\" , s + 1 ); work (); } return 0 ; }","title":"Solution"},{"location":"PAT-Basic-Level/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/","text":"1095 \u89e3\u7801PAT\u51c6\u8003\u8bc1 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB PAT \u51c6\u8003\u8bc1\u53f7\u7531 4 \u90e8\u5206\u7ec4\u6210\uff1a \u7b2c 1 \u4f4d\u662f\u7ea7\u522b\uff0c\u5373 T \u4ee3\u8868\u9876\u7ea7\uff1b A \u4ee3\u8868\u7532\u7ea7\uff1b B \u4ee3\u8868\u4e59\u7ea7\uff1b \u7b2c 2~4 \u4f4d\u662f\u8003\u573a\u7f16\u53f7\uff0c\u8303\u56f4\u4ece 101 \u5230 999\uff1b \u7b2c 5~10 \u4f4d\u662f\u8003\u8bd5\u65e5\u671f\uff0c\u683c\u5f0f\u4e3a\u5e74\u3001\u6708\u3001\u65e5\u987a\u6b21\u5404\u5360 2 \u4f4d\uff1b \u6700\u540e 11~13 \u4f4d\u662f\u8003\u751f\u7f16\u53f7\uff0c\u8303\u56f4\u4ece 000 \u5230 999\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7cfb\u5217\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u4ed6\u4eec\u7684\u6210\u7ee9\uff0c\u8bf7\u4f60\u6309\u7167\u8981\u6c42\u8f93\u51fa\u5404\u79cd\u7edf\u8ba1\u4fe1\u606f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u8003\u751f\u4eba\u6570\u548c\u7edf\u8ba1\u8981\u6c42\u7684\u4e2a\u6570\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u5176\u5206\u6570\uff08\u5728\u533a\u95f4 [0, 100] [0, 100] \u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u518d\u7ed9\u51fa M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7edf\u8ba1\u8981\u6c42\uff0c\u683c\u5f0f\u4e3a\uff1a \u7c7b\u578b \u6307\u4ee4 \uff0c\u5176\u4e2d \u7c7b\u578b \u4e3a 1 \u8868\u793a\u8981\u6c42\u6309\u5206\u6570\u975e\u5347\u5e8f\u8f93\u51fa\u67d0\u4e2a\u6307\u5b9a\u7ea7\u522b\u7684\u8003\u751f\u7684\u6210\u7ee9\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u4ee3\u8868\u6307\u5b9a\u7ea7\u522b\u7684\u5b57\u6bcd\uff1b \u7c7b\u578b \u4e3a 2 \u8868\u793a\u8981\u6c42\u5c06\u67d0\u6307\u5b9a\u8003\u573a\u7684\u8003\u751f\u4eba\u6570\u548c\u603b\u5206\u7edf\u8ba1\u8f93\u51fa\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u6307\u5b9a\u8003\u573a\u7684\u7f16\u53f7\uff1b \u7c7b\u578b \u4e3a 3 \u8868\u793a\u8981\u6c42\u5c06\u67d0\u6307\u5b9a\u65e5\u671f\u7684\u8003\u751f\u4eba\u6570\u5206\u8003\u573a\u7edf\u8ba1\u8f93\u51fa\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u6307\u5b9a\u65e5\u671f\uff0c\u683c\u5f0f\u4e0e\u51c6\u8003\u8bc1\u4e0a\u65e5\u671f\u76f8\u540c\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u9879\u7edf\u8ba1\u8981\u6c42\uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case #: \u8981\u6c42 \uff0c\u5176\u4e2d # \u662f\u8be5\u9879\u8981\u6c42\u7684\u7f16\u53f7\uff0c\u4ece 1 \u5f00\u59cb\uff1b \u8981\u6c42 \u5373\u590d\u5236\u8f93\u5165\u7ed9\u51fa\u7684\u8981\u6c42\u3002\u968f\u540e\u8f93\u51fa\u76f8\u5e94\u7684\u7edf\u8ba1\u7ed3\u679c\uff1a \u7c7b\u578b \u4e3a 1 \u7684\u6307\u4ee4\uff0c\u8f93\u51fa\u683c\u5f0f\u4e0e\u8f93\u5165\u7684\u8003\u751f\u4fe1\u606f\u683c\u5f0f\u76f8\u540c\uff0c\u5373 \u51c6\u8003\u8bc1\u53f7 \u6210\u7ee9 \u3002\u5bf9\u4e8e\u5206\u6570\u5e76\u5217\u7684\u8003\u751f\uff0c\u6309\u5176\u51c6\u8003\u8bc1\u53f7\u7684\u5b57\u5178\u5e8f\u9012\u589e\u8f93\u51fa\uff08\u9898\u76ee\u4fdd\u8bc1\u65e0\u91cd\u590d\u51c6\u8003\u8bc1\u53f7\uff09\uff1b \u7c7b\u578b \u4e3a 2 \u7684\u6307\u4ee4\uff0c\u6309 \u4eba\u6570 \u603b\u5206 \u7684\u683c\u5f0f\u8f93\u51fa\uff1b \u7c7b\u578b \u4e3a 3 \u7684\u6307\u4ee4\uff0c\u8f93\u51fa\u6309\u4eba\u6570\u975e\u9012\u589e\u987a\u5e8f\uff0c\u683c\u5f0f\u4e3a \u8003\u573a\u7f16\u53f7 \u603b\u4eba\u6570 \u3002\u82e5\u4eba\u6570\u5e76\u5217\u5219\u6309\u8003\u573a\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002 \u5982\u679c\u67e5\u8be2\u7ed3\u679c\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa NA \u3002 \u8f93\u5165\u6837\u4f8b 8 4 B123180908127 99 B102180908003 86 A112180318002 98 T107150310127 62 A107180908108 100 T123180908010 78 B112160918035 88 A107180908021 98 1 A 2 107 3 180908 2 999 \u8f93\u51fa\u6837\u4f8b Case 1: 1 A A107180908108 100 A107180908021 98 A112180318002 98 Case 2: 2 107 3 260 Case 3: 3 180908 107 2 123 2 102 1 Case 4: 2 999 NA","title":"1095-\u89e3\u7801PAT\u51c6\u8003\u8bc1"},{"location":"PAT-Basic-Level/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/#1095-\u89e3\u7801pat\u51c6\u8003\u8bc1","text":"","title":"1095 \u89e3\u7801PAT\u51c6\u8003\u8bc1"},{"location":"PAT-Basic-Level/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB PAT \u51c6\u8003\u8bc1\u53f7\u7531 4 \u90e8\u5206\u7ec4\u6210\uff1a \u7b2c 1 \u4f4d\u662f\u7ea7\u522b\uff0c\u5373 T \u4ee3\u8868\u9876\u7ea7\uff1b A \u4ee3\u8868\u7532\u7ea7\uff1b B \u4ee3\u8868\u4e59\u7ea7\uff1b \u7b2c 2~4 \u4f4d\u662f\u8003\u573a\u7f16\u53f7\uff0c\u8303\u56f4\u4ece 101 \u5230 999\uff1b \u7b2c 5~10 \u4f4d\u662f\u8003\u8bd5\u65e5\u671f\uff0c\u683c\u5f0f\u4e3a\u5e74\u3001\u6708\u3001\u65e5\u987a\u6b21\u5404\u5360 2 \u4f4d\uff1b \u6700\u540e 11~13 \u4f4d\u662f\u8003\u751f\u7f16\u53f7\uff0c\u8303\u56f4\u4ece 000 \u5230 999\u3002 \u73b0\u7ed9\u5b9a\u4e00\u7cfb\u5217\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u4ed6\u4eec\u7684\u6210\u7ee9\uff0c\u8bf7\u4f60\u6309\u7167\u8981\u6c42\u8f93\u51fa\u5404\u79cd\u7edf\u8ba1\u4fe1\u606f\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u6b63\u6574\u6570 N N \uff08 \\le 10^4 \\le 10^4 \uff09\u548c M M \uff08 \\le 100 \\le 100 \uff09\uff0c\u5206\u522b\u4e3a\u8003\u751f\u4eba\u6570\u548c\u7edf\u8ba1\u8981\u6c42\u7684\u4e2a\u6570\u3002 \u63a5\u4e0b\u6765 N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u8003\u751f\u7684\u51c6\u8003\u8bc1\u53f7\u548c\u5176\u5206\u6570\uff08\u5728\u533a\u95f4 [0, 100] [0, 100] \u5185\u7684\u6574\u6570\uff09\uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8003\u751f\u4fe1\u606f\u4e4b\u540e\uff0c\u518d\u7ed9\u51fa M M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4e2a\u7edf\u8ba1\u8981\u6c42\uff0c\u683c\u5f0f\u4e3a\uff1a \u7c7b\u578b \u6307\u4ee4 \uff0c\u5176\u4e2d \u7c7b\u578b \u4e3a 1 \u8868\u793a\u8981\u6c42\u6309\u5206\u6570\u975e\u5347\u5e8f\u8f93\u51fa\u67d0\u4e2a\u6307\u5b9a\u7ea7\u522b\u7684\u8003\u751f\u7684\u6210\u7ee9\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u4ee3\u8868\u6307\u5b9a\u7ea7\u522b\u7684\u5b57\u6bcd\uff1b \u7c7b\u578b \u4e3a 2 \u8868\u793a\u8981\u6c42\u5c06\u67d0\u6307\u5b9a\u8003\u573a\u7684\u8003\u751f\u4eba\u6570\u548c\u603b\u5206\u7edf\u8ba1\u8f93\u51fa\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u6307\u5b9a\u8003\u573a\u7684\u7f16\u53f7\uff1b \u7c7b\u578b \u4e3a 3 \u8868\u793a\u8981\u6c42\u5c06\u67d0\u6307\u5b9a\u65e5\u671f\u7684\u8003\u751f\u4eba\u6570\u5206\u8003\u573a\u7edf\u8ba1\u8f93\u51fa\uff0c\u5bf9\u5e94\u7684 \u6307\u4ee4 \u5219\u7ed9\u51fa\u6307\u5b9a\u65e5\u671f\uff0c\u683c\u5f0f\u4e0e\u51c6\u8003\u8bc1\u4e0a\u65e5\u671f\u76f8\u540c\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u9879\u7edf\u8ba1\u8981\u6c42\uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case #: \u8981\u6c42 \uff0c\u5176\u4e2d # \u662f\u8be5\u9879\u8981\u6c42\u7684\u7f16\u53f7\uff0c\u4ece 1 \u5f00\u59cb\uff1b \u8981\u6c42 \u5373\u590d\u5236\u8f93\u5165\u7ed9\u51fa\u7684\u8981\u6c42\u3002\u968f\u540e\u8f93\u51fa\u76f8\u5e94\u7684\u7edf\u8ba1\u7ed3\u679c\uff1a \u7c7b\u578b \u4e3a 1 \u7684\u6307\u4ee4\uff0c\u8f93\u51fa\u683c\u5f0f\u4e0e\u8f93\u5165\u7684\u8003\u751f\u4fe1\u606f\u683c\u5f0f\u76f8\u540c\uff0c\u5373 \u51c6\u8003\u8bc1\u53f7 \u6210\u7ee9 \u3002\u5bf9\u4e8e\u5206\u6570\u5e76\u5217\u7684\u8003\u751f\uff0c\u6309\u5176\u51c6\u8003\u8bc1\u53f7\u7684\u5b57\u5178\u5e8f\u9012\u589e\u8f93\u51fa\uff08\u9898\u76ee\u4fdd\u8bc1\u65e0\u91cd\u590d\u51c6\u8003\u8bc1\u53f7\uff09\uff1b \u7c7b\u578b \u4e3a 2 \u7684\u6307\u4ee4\uff0c\u6309 \u4eba\u6570 \u603b\u5206 \u7684\u683c\u5f0f\u8f93\u51fa\uff1b \u7c7b\u578b \u4e3a 3 \u7684\u6307\u4ee4\uff0c\u8f93\u51fa\u6309\u4eba\u6570\u975e\u9012\u589e\u987a\u5e8f\uff0c\u683c\u5f0f\u4e3a \u8003\u573a\u7f16\u53f7 \u603b\u4eba\u6570 \u3002\u82e5\u4eba\u6570\u5e76\u5217\u5219\u6309\u8003\u573a\u7f16\u53f7\u9012\u589e\u987a\u5e8f\u8f93\u51fa\u3002 \u5982\u679c\u67e5\u8be2\u7ed3\u679c\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa NA \u3002 \u8f93\u5165\u6837\u4f8b 8 4 B123180908127 99 B102180908003 86 A112180318002 98 T107150310127 62 A107180908108 100 T123180908010 78 B112160918035 88 A107180908021 98 1 A 2 107 3 180908 2 999 \u8f93\u51fa\u6837\u4f8b Case 1: 1 A A107180908108 100 A107180908021 98 A112180318002 98 Case 2: 2 107 3 260 Case 3: 3 180908 107 2 123 2 102 1 Case 4: 2 999 NA","title":"Statement"},{"location":"PAT-Basic-Level/1096-%E5%A4%A7%E7%BE%8E%E6%95%B0/","text":"1096 \u5927\u7f8e\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u82e5\u6b63\u6574\u6570 N N \u53ef\u4ee5\u6574\u9664\u5b83\u7684 4 \u4e2a\u4e0d\u540c\u6b63\u56e0\u6570\u4e4b\u548c\uff0c\u5219\u79f0\u8fd9\u6837\u7684\u6b63\u6574\u6570\u4e3a\u201c\u5927\u7f8e\u6570\u201d\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5224\u65ad\u4efb\u4e00\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\u662f\u5426\u662f\u201c\u5927\u7f8e\u6570\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa K K \u4e2a\u5f85\u68c0\u6d4b\u7684\u3001\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u68c0\u6d4b\u7684\u6570\u5b57\uff0c\u5982\u679c\u5b83\u662f\u5927\u7f8e\u6570\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 3 18 29 40 \u8f93\u51fa\u6837\u4f8b Yes No Yes","title":"1096-\u5927\u7f8e\u6570"},{"location":"PAT-Basic-Level/1096-%E5%A4%A7%E7%BE%8E%E6%95%B0/#1096-\u5927\u7f8e\u6570","text":"","title":"1096 \u5927\u7f8e\u6570"},{"location":"PAT-Basic-Level/1096-%E5%A4%A7%E7%BE%8E%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u82e5\u6b63\u6574\u6570 N N \u53ef\u4ee5\u6574\u9664\u5b83\u7684 4 \u4e2a\u4e0d\u540c\u6b63\u56e0\u6570\u4e4b\u548c\uff0c\u5219\u79f0\u8fd9\u6837\u7684\u6b63\u6574\u6570\u4e3a\u201c\u5927\u7f8e\u6570\u201d\u3002\u672c\u9898\u5c31\u8981\u6c42\u4f60\u5224\u65ad\u4efb\u4e00\u7ed9\u5b9a\u7684\u6b63\u6574\u6570\u662f\u5426\u662f\u201c\u5927\u7f8e\u6570\u201d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u6b63\u6574\u6570 K K \uff08 \\le 10 \\le 10 \uff09\uff0c\u968f\u540e\u4e00\u884c\u7ed9\u51fa K K \u4e2a\u5f85\u68c0\u6d4b\u7684\u3001\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u6b63\u6574\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u9700\u8981\u68c0\u6d4b\u7684\u6570\u5b57\uff0c\u5982\u679c\u5b83\u662f\u5927\u7f8e\u6570\u5c31\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5426\u5219\u8f93\u51fa No \u3002 \u8f93\u5165\u6837\u4f8b 3 18 29 40 \u8f93\u51fa\u6837\u4f8b Yes No Yes","title":"Statement"},{"location":"PAT-Basic-Level/1097-%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%B9%B3%E7%A7%BB/","text":"1097 \u77e9\u9635\u884c\u5e73\u79fb Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a n\\times n n\\times n \u7684\u6574\u6570\u77e9\u9635\u3002\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u7684\u6b63\u6574\u6570 k<n k<n \uff0c\u6211\u4eec\u5c06\u77e9\u9635\u7684\u5947\u6570\u884c\u7684\u5143\u7d20\u6574\u4f53\u5411\u53f3\u4f9d\u6b21\u5e73\u79fb 1\u3001\u2026\u2026\u3001 k k \u30011\u3001\u2026\u2026\u3001 k k \u3001\u2026\u2026 \u4e2a\u4f4d\u7f6e\uff0c\u5e73\u79fb\u7a7a\u51fa\u7684\u4f4d\u7f6e\u7528\u6574\u6570 x x \u8865\u3002\u4f60\u9700\u8981\u8ba1\u7b97\u51fa\u7ed3\u679c\u77e9\u9635\u7684\u6bcf\u4e00\u5217\u5143\u7d20\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff1a n n \uff08 <100 <100 \uff09\u3001 k k \uff08 <n <n \uff09\u3001 x x \uff08 <100 <100 \uff09\uff0c\u5206\u522b\u5982\u9898\u9762\u6240\u8ff0\u3002 \u63a5\u4e0b\u6765 n n \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa n n \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u77e9\u9635\u5143\u7d20\u7684\u503c\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5e73\u79fb\u540e\u7b2c 1 \u5230 n n \u5217\u5143\u7d20\u7684\u548c\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 2 99 11 87 23 67 20 75 89 37 94 27 91 63 50 11 44 38 50 26 40 26 24 73 85 63 28 62 18 68 15 83 27 97 88 25 43 23 78 98 20 30 81 99 77 36 48 59 25 34 22 \u8f93\u51fa\u6837\u4f8b 529 481 479 263 417 342 343 \u6837\u4f8b\u89e3\u8bfb \u9700\u8981\u5e73\u79fb\u7684\u662f\u7b2c 1\u30013\u30015\u30017 \u884c\u3002\u7ed9\u5b9a k=2 k=2 \uff0c\u5e94\u8be5\u5c06\u8fd9\u4e09\u5217\u987a\u6b21\u6574\u4f53\u5411\u53f3\u5e73\u79fb 1\u30012\u30011\u30012 \u4f4d\uff08\u5982\u679c\u6709\u66f4\u591a\u884c\uff0c\u5c31\u5e94\u8be5\u6309\u7167 1\u30012\u30011\u30012\u30011\u30012 \u2026\u2026 \u8fd9\u4e2a\u89c4\u5f8b\u987a\u6b21\u5411\u53f3\u5e73\u79fb\uff09\uff0c\u5de6\u7aef\u7684\u7a7a\u4f4d\u7528 99 \u6765\u586b\u5145\u3002\u5e73\u79fb\u540e\u7684\u77e9\u9635\u53d8\u6210\uff1a 99 11 87 23 67 20 75 37 94 27 91 63 50 11 99 99 44 38 50 26 40 73 85 63 28 62 18 68 99 15 83 27 97 88 25 23 78 98 20 30 81 99 99 99 77 36 48 59 25","title":"1097-\u77e9\u9635\u884c\u5e73\u79fb"},{"location":"PAT-Basic-Level/1097-%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%B9%B3%E7%A7%BB/#1097-\u77e9\u9635\u884c\u5e73\u79fb","text":"","title":"1097 \u77e9\u9635\u884c\u5e73\u79fb"},{"location":"PAT-Basic-Level/1097-%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%B9%B3%E7%A7%BB/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a n\\times n n\\times n \u7684\u6574\u6570\u77e9\u9635\u3002\u5bf9\u4efb\u4e00\u7ed9\u5b9a\u7684\u6b63\u6574\u6570 k<n k<n \uff0c\u6211\u4eec\u5c06\u77e9\u9635\u7684\u5947\u6570\u884c\u7684\u5143\u7d20\u6574\u4f53\u5411\u53f3\u4f9d\u6b21\u5e73\u79fb 1\u3001\u2026\u2026\u3001 k k \u30011\u3001\u2026\u2026\u3001 k k \u3001\u2026\u2026 \u4e2a\u4f4d\u7f6e\uff0c\u5e73\u79fb\u7a7a\u51fa\u7684\u4f4d\u7f6e\u7528\u6574\u6570 x x \u8865\u3002\u4f60\u9700\u8981\u8ba1\u7b97\u51fa\u7ed3\u679c\u77e9\u9635\u7684\u6bcf\u4e00\u5217\u5143\u7d20\u7684\u548c\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7b2c\u4e00\u884c\u7ed9\u51fa 3 \u4e2a\u6b63\u6574\u6570\uff1a n n \uff08 <100 <100 \uff09\u3001 k k \uff08 <n <n \uff09\u3001 x x \uff08 <100 <100 \uff09\uff0c\u5206\u522b\u5982\u9898\u9762\u6240\u8ff0\u3002 \u63a5\u4e0b\u6765 n n \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa n n \u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570\uff0c\u4e3a\u77e9\u9635\u5143\u7d20\u7684\u503c\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u5e73\u79fb\u540e\u7b2c 1 \u5230 n n \u5217\u5143\u7d20\u7684\u548c\u3002\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 7 2 99 11 87 23 67 20 75 89 37 94 27 91 63 50 11 44 38 50 26 40 26 24 73 85 63 28 62 18 68 15 83 27 97 88 25 43 23 78 98 20 30 81 99 77 36 48 59 25 34 22 \u8f93\u51fa\u6837\u4f8b 529 481 479 263 417 342 343 \u6837\u4f8b\u89e3\u8bfb \u9700\u8981\u5e73\u79fb\u7684\u662f\u7b2c 1\u30013\u30015\u30017 \u884c\u3002\u7ed9\u5b9a k=2 k=2 \uff0c\u5e94\u8be5\u5c06\u8fd9\u4e09\u5217\u987a\u6b21\u6574\u4f53\u5411\u53f3\u5e73\u79fb 1\u30012\u30011\u30012 \u4f4d\uff08\u5982\u679c\u6709\u66f4\u591a\u884c\uff0c\u5c31\u5e94\u8be5\u6309\u7167 1\u30012\u30011\u30012\u30011\u30012 \u2026\u2026 \u8fd9\u4e2a\u89c4\u5f8b\u987a\u6b21\u5411\u53f3\u5e73\u79fb\uff09\uff0c\u5de6\u7aef\u7684\u7a7a\u4f4d\u7528 99 \u6765\u586b\u5145\u3002\u5e73\u79fb\u540e\u7684\u77e9\u9635\u53d8\u6210\uff1a 99 11 87 23 67 20 75 37 94 27 91 63 50 11 99 99 44 38 50 26 40 73 85 63 28 62 18 68 99 15 83 27 97 88 25 23 78 98 20 30 81 99 99 99 77 36 48 59 25","title":"Statement"},{"location":"PAT-Basic-Level/1098-%E5%B2%A9%E6%B4%9E%E6%96%BD%E5%B7%A5/","text":"1098 \u5ca9\u6d1e\u65bd\u5de5 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8981\u5c06\u4e00\u6761\u76f4\u5f84\u81f3\u5c11\u4e3a 1 \u4e2a\u5355\u4f4d\u7684\u957f\u7ba1\u9053\u6c34\u5e73\u9001\u5165\u5730\u5f62\u590d\u6742\u7684\u5ca9\u6d1e\u4e2d\uff0c\u7a76\u7adf\u662f\u5426\u53ef\u80fd\uff1f\u4e0b\u9762\u7684\u4e24\u5e45\u56fe\u5206\u522b\u7ed9\u51fa\u4e86\u5ca9\u6d1e\u7684\u5256\u9762\u56fe\uff0c\u6df1\u84dd\u8272\u7684\u6298\u7ebf\u52fe\u52d2\u51fa\u5ca9\u6d1e\u9876\u90e8\u548c\u5e95\u90e8\u7684\u8f6e\u5ed3\u3002\u56fe 1 \u662f\u6709\u53ef\u80fd\u7684\uff0c\u7eff\u8272\u90e8\u5206\u663e\u793a\u76f4\u5f84\u4e3a 1 \u7684\u7ba1\u9053\u53ef\u4ee5\u9001\u5165\u3002\u56fe 2 \u5c31\u4e0d\u53ef\u80fd\uff0c\u9664\u975e\u628a\u9876\u90e8\u6216\u5e95\u90e8\u7684\u7a81\u51fa\u90e8\u5206\u524a\u6389 1 \u4e2a\u5355\u4f4d\u7684\u9ad8\u5ea6\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u7ed9\u5b9a\u7684\u5ca9\u6d1e\u4e2d\u662f\u5426\u53ef\u4ee5\u65bd\u5de5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u6a2a\u5411\u91c7\u6837\u7684\u70b9\u6570\u3002\u968f\u540e\u4e24\u884c\u6570\u636e\uff0c\u4ece\u5de6\u5230\u53f3\u987a\u6b21\u7ed9\u51fa\u91c7\u6837\u70b9\u7684\u7eb5\u5750\u6807\uff1a\u7b2c 1 \u884c\u662f\u5ca9\u6d1e\u9876\u90e8\u7684\u91c7\u6837\u70b9\uff0c\u7b2c 2 \u884c\u662f\u5ca9\u6d1e\u5e95\u90e8\u7684\u91c7\u6837\u70b9\u3002\u8fd9\u91cc\u5047\u8bbe\u5750\u6807\u539f\u70b9\u5728\u5de6\u4e0b\u89d2\uff0c\u6bcf\u4e2a\u7eb5\u5750\u6807\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u975e\u8d1f\u6574\u6570\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u6570\u636e\u662f\u5408\u7406\u7684\uff0c\u5373\u5ca9\u6d1e\u5e95\u90e8\u7684\u8f6e\u5ed3\u7ebf\u4e0d\u4f1a\u4e0e\u9876\u90e8\u8f6e\u5ed3\u7ebf\u4ea4\u53c9\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u53ef\u4ee5\u76f4\u63a5\u65bd\u5de5\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \u548c\u53ef\u4ee5\u9001\u5165\u7684\u7ba1\u9053\u7684\u6700\u5927\u76f4\u5f84\uff1b\u5982\u679c\u4e0d\u884c\uff0c\u5219\u8f93\u51fa No \u548c\u81f3\u5c11\u9700\u8981\u524a\u6389\u7684\u9ad8\u5ea6\u3002\u7b54\u6848\u548c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 1 11 7 6 5 5 6 5 4 5 5 4 4 3 2 2 2 2 3 3 2 1 2 3 \u8f93\u51fa\u6837\u4f8b 1 Yes 1 \u8f93\u5165\u6837\u4f8b 2 11 7 6 5 5 6 5 4 5 5 4 4 3 2 2 2 3 4 3 2 1 2 3 \u8f93\u51fa\u6837\u4f8b 2 No 1","title":"1098-\u5ca9\u6d1e\u65bd\u5de5"},{"location":"PAT-Basic-Level/1098-%E5%B2%A9%E6%B4%9E%E6%96%BD%E5%B7%A5/#1098-\u5ca9\u6d1e\u65bd\u5de5","text":"","title":"1098 \u5ca9\u6d1e\u65bd\u5de5"},{"location":"PAT-Basic-Level/1098-%E5%B2%A9%E6%B4%9E%E6%96%BD%E5%B7%A5/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8981\u5c06\u4e00\u6761\u76f4\u5f84\u81f3\u5c11\u4e3a 1 \u4e2a\u5355\u4f4d\u7684\u957f\u7ba1\u9053\u6c34\u5e73\u9001\u5165\u5730\u5f62\u590d\u6742\u7684\u5ca9\u6d1e\u4e2d\uff0c\u7a76\u7adf\u662f\u5426\u53ef\u80fd\uff1f\u4e0b\u9762\u7684\u4e24\u5e45\u56fe\u5206\u522b\u7ed9\u51fa\u4e86\u5ca9\u6d1e\u7684\u5256\u9762\u56fe\uff0c\u6df1\u84dd\u8272\u7684\u6298\u7ebf\u52fe\u52d2\u51fa\u5ca9\u6d1e\u9876\u90e8\u548c\u5e95\u90e8\u7684\u8f6e\u5ed3\u3002\u56fe 1 \u662f\u6709\u53ef\u80fd\u7684\uff0c\u7eff\u8272\u90e8\u5206\u663e\u793a\u76f4\u5f84\u4e3a 1 \u7684\u7ba1\u9053\u53ef\u4ee5\u9001\u5165\u3002\u56fe 2 \u5c31\u4e0d\u53ef\u80fd\uff0c\u9664\u975e\u628a\u9876\u90e8\u6216\u5e95\u90e8\u7684\u7a81\u51fa\u90e8\u5206\u524a\u6389 1 \u4e2a\u5355\u4f4d\u7684\u9ad8\u5ea6\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5224\u65ad\u7ed9\u5b9a\u7684\u5ca9\u6d1e\u4e2d\u662f\u5426\u53ef\u4ee5\u65bd\u5de5\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e00\u4e2a\u4e0d\u8d85\u8fc7 100 \u7684\u6b63\u6574\u6570 N N \uff0c\u5373\u6a2a\u5411\u91c7\u6837\u7684\u70b9\u6570\u3002\u968f\u540e\u4e24\u884c\u6570\u636e\uff0c\u4ece\u5de6\u5230\u53f3\u987a\u6b21\u7ed9\u51fa\u91c7\u6837\u70b9\u7684\u7eb5\u5750\u6807\uff1a\u7b2c 1 \u884c\u662f\u5ca9\u6d1e\u9876\u90e8\u7684\u91c7\u6837\u70b9\uff0c\u7b2c 2 \u884c\u662f\u5ca9\u6d1e\u5e95\u90e8\u7684\u91c7\u6837\u70b9\u3002\u8fd9\u91cc\u5047\u8bbe\u5750\u6807\u539f\u70b9\u5728\u5de6\u4e0b\u89d2\uff0c\u6bcf\u4e2a\u7eb5\u5750\u6807\u4e3a\u4e0d\u8d85\u8fc7 1000 \u7684\u975e\u8d1f\u6574\u6570\u3002\u540c\u884c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u9898\u76ee\u4fdd\u8bc1\u8f93\u5165\u6570\u636e\u662f\u5408\u7406\u7684\uff0c\u5373\u5ca9\u6d1e\u5e95\u90e8\u7684\u8f6e\u5ed3\u7ebf\u4e0d\u4f1a\u4e0e\u9876\u90e8\u8f6e\u5ed3\u7ebf\u4ea4\u53c9\u3002 \u8f93\u51fa\u683c\u5f0f \u5982\u679c\u53ef\u4ee5\u76f4\u63a5\u65bd\u5de5\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \u548c\u53ef\u4ee5\u9001\u5165\u7684\u7ba1\u9053\u7684\u6700\u5927\u76f4\u5f84\uff1b\u5982\u679c\u4e0d\u884c\uff0c\u5219\u8f93\u51fa No \u548c\u81f3\u5c11\u9700\u8981\u524a\u6389\u7684\u9ad8\u5ea6\u3002\u7b54\u6848\u548c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u5165\u6837\u4f8b 1 11 7 6 5 5 6 5 4 5 5 4 4 3 2 2 2 2 3 3 2 1 2 3 \u8f93\u51fa\u6837\u4f8b 1 Yes 1 \u8f93\u5165\u6837\u4f8b 2 11 7 6 5 5 6 5 4 5 5 4 4 3 2 2 2 3 4 3 2 1 2 3 \u8f93\u51fa\u6837\u4f8b 2 No 1","title":"Statement"},{"location":"PAT-Basic-Level/1099-%E6%80%A7%E6%84%9F%E7%B4%A0%E6%95%B0/","text":"1099 \u6027\u611f\u7d20\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u6027\u611f\u7d20\u6570\u201d\u662f\u6307\u5f62\u5982 ( p p , p+6 p+6 ) \u8fd9\u6837\u7684\u4e00\u5bf9\u7d20\u6570\u3002\u4e4b\u6240\u4ee5\u53eb\u8fd9\u4e2a\u540d\u5b57\uff0c\u662f\u56e0\u4e3a\u62c9\u4e01\u8bed\u7ba1\u201c\u516d\u201d\u53eb\u201csex\u201d\uff08\u5373\u82f1\u8bed\u7684\u201c\u6027\u611f\u201d\uff09\u3002\uff08\u539f\u6587\u6458\u81ea http://mathworld.wolfram.com/SexyPrimes.html \uff09 \u73b0\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u8bf7\u4f60\u5224\u65ad\u5176\u662f\u5426\u4e3a\u4e00\u4e2a\u6027\u611f\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N ( \\le 10^8 \\le 10^8 )\u3002 \u8f93\u51fa\u683c\u5f0f \u82e5 N N \u662f\u4e00\u4e2a\u6027\u611f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5e76\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u4e0e N N \u914d\u5bf9\u7684\u53e6\u4e00\u4e2a\u6027\u611f\u7d20\u6570\uff08\u82e5\u8fd9\u6837\u7684\u6570\u4e0d\u552f\u4e00\uff0c\u8f93\u51fa\u8f83\u5c0f\u7684\u90a3\u4e2a\uff09\u3002\u82e5 N N \u4e0d\u662f\u6027\u611f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No \uff0c\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u5927\u4e8e N N \u7684\u6700\u5c0f\u6027\u611f\u7d20\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 47 \u8f93\u51fa\u6837\u4f8b 1 Yes 41 \u8f93\u5165\u6837\u4f8b 2 21 \u8f93\u51fa\u6837\u4f8b 2 No 23","title":"1099-\u6027\u611f\u7d20\u6570"},{"location":"PAT-Basic-Level/1099-%E6%80%A7%E6%84%9F%E7%B4%A0%E6%95%B0/#1099-\u6027\u611f\u7d20\u6570","text":"","title":"1099 \u6027\u611f\u7d20\u6570"},{"location":"PAT-Basic-Level/1099-%E6%80%A7%E6%84%9F%E7%B4%A0%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u6027\u611f\u7d20\u6570\u201d\u662f\u6307\u5f62\u5982 ( p p , p+6 p+6 ) \u8fd9\u6837\u7684\u4e00\u5bf9\u7d20\u6570\u3002\u4e4b\u6240\u4ee5\u53eb\u8fd9\u4e2a\u540d\u5b57\uff0c\u662f\u56e0\u4e3a\u62c9\u4e01\u8bed\u7ba1\u201c\u516d\u201d\u53eb\u201csex\u201d\uff08\u5373\u82f1\u8bed\u7684\u201c\u6027\u611f\u201d\uff09\u3002\uff08\u539f\u6587\u6458\u81ea http://mathworld.wolfram.com/SexyPrimes.html \uff09 \u73b0\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u8bf7\u4f60\u5224\u65ad\u5176\u662f\u5426\u4e3a\u4e00\u4e2a\u6027\u611f\u7d20\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N N ( \\le 10^8 \\le 10^8 )\u3002 \u8f93\u51fa\u683c\u5f0f \u82e5 N N \u662f\u4e00\u4e2a\u6027\u611f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Yes \uff0c\u5e76\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u4e0e N N \u914d\u5bf9\u7684\u53e6\u4e00\u4e2a\u6027\u611f\u7d20\u6570\uff08\u82e5\u8fd9\u6837\u7684\u6570\u4e0d\u552f\u4e00\uff0c\u8f93\u51fa\u8f83\u5c0f\u7684\u90a3\u4e2a\uff09\u3002\u82e5 N N \u4e0d\u662f\u6027\u611f\u7d20\u6570\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No \uff0c\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u5927\u4e8e N N \u7684\u6700\u5c0f\u6027\u611f\u7d20\u6570\u3002 \u8f93\u5165\u6837\u4f8b 1 47 \u8f93\u51fa\u6837\u4f8b 1 Yes 41 \u8f93\u5165\u6837\u4f8b 2 21 \u8f93\u51fa\u6837\u4f8b 2 No 23","title":"Statement"},{"location":"PAT-Basic-Level/1100-%E6%A0%A1%E5%BA%86/","text":"1100 \u6821\u5e86 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB 2019 \u5e74\u6d59\u6c5f\u5927\u5b66\u5c06\u8981\u5e86\u795d\u6210\u7acb 122 \u5468\u5e74\u3002\u4e3a\u4e86\u51c6\u5907\u6821\u5e86\uff0c\u6821\u53cb\u4f1a\u6536\u96c6\u4e86\u6240\u6709\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u73b0\u5728\u9700\u8981\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u6839\u636e\u6765\u53c2\u52a0\u6821\u5e86\u7684\u6240\u6709\u4eba\u58eb\u7684\u8eab\u4efd\u8bc1\u53f7\uff0c\u7edf\u8ba1\u6765\u4e86\u591a\u5c11\u6821\u53cb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7\uff0818 \u4f4d\u7531\u6570\u5b57\u548c\u5927\u5199\u5b57\u6bcdX\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u8eab\u4efd\u8bc1\u53f7\u4e0d\u91cd\u590d\u3002 \u968f\u540e\u7ed9\u51fa\u524d\u6765\u53c2\u52a0\u6821\u5e86\u7684\u6240\u6709\u4eba\u58eb\u7684\u4fe1\u606f\uff1a\u9996\u5148\u662f\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 M\uff0c\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u4eba\u58eb\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8eab\u4efd\u8bc1\u53f7\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u53c2\u52a0\u6821\u5e86\u7684\u6821\u53cb\u7684\u4eba\u6570\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u6700\u5e74\u957f\u7684\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7 \u2014\u2014 \u6ce8\u610f\u8eab\u4efd\u8bc1\u7b2c 7-14 \u4f4d\u7ed9\u51fa\u7684\u662f yyyymmdd \u683c\u5f0f\u7684\u751f\u65e5\u3002\u5982\u679c\u6ca1\u6709\u6821\u53cb\u6765\uff0c\u5219\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u6700\u5e74\u957f\u7684\u6765\u5bbe\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u6821\u53cb\u6216\u6765\u5bbe\u5fc5\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 5 372928196906118710 610481197806202213 440684198612150417 13072819571002001X 150702193604190912 6 530125197901260019 150702193604190912 220221196701020034 610481197806202213 440684198612150417 370205198709275042 \u8f93\u51fa\u6837\u4f8b 3 150702193604190912","title":"1100-\u6821\u5e86"},{"location":"PAT-Basic-Level/1100-%E6%A0%A1%E5%BA%86/#1100-\u6821\u5e86","text":"","title":"1100 \u6821\u5e86"},{"location":"PAT-Basic-Level/1100-%E6%A0%A1%E5%BA%86/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB 2019 \u5e74\u6d59\u6c5f\u5927\u5b66\u5c06\u8981\u5e86\u795d\u6210\u7acb 122 \u5468\u5e74\u3002\u4e3a\u4e86\u51c6\u5907\u6821\u5e86\uff0c\u6821\u53cb\u4f1a\u6536\u96c6\u4e86\u6240\u6709\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u73b0\u5728\u9700\u8981\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u6839\u636e\u6765\u53c2\u52a0\u6821\u5e86\u7684\u6240\u6709\u4eba\u58eb\u7684\u8eab\u4efd\u8bc1\u53f7\uff0c\u7edf\u8ba1\u6765\u4e86\u591a\u5c11\u6821\u53cb\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 N\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7\uff0818 \u4f4d\u7531\u6570\u5b57\u548c\u5927\u5199\u5b57\u6bcdX\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\uff09\u3002\u9898\u76ee\u4fdd\u8bc1\u8eab\u4efd\u8bc1\u53f7\u4e0d\u91cd\u590d\u3002 \u968f\u540e\u7ed9\u51fa\u524d\u6765\u53c2\u52a0\u6821\u5e86\u7684\u6240\u6709\u4eba\u58eb\u7684\u4fe1\u606f\uff1a\u9996\u5148\u662f\u4e00\u4e2a\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570 M\uff0c\u968f\u540e M \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4f4d\u4eba\u58eb\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8eab\u4efd\u8bc1\u53f7\u4e0d\u91cd\u590d\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u8f93\u51fa\u53c2\u52a0\u6821\u5e86\u7684\u6821\u53cb\u7684\u4eba\u6570\u3002\u7136\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u6700\u5e74\u957f\u7684\u6821\u53cb\u7684\u8eab\u4efd\u8bc1\u53f7 \u2014\u2014 \u6ce8\u610f\u8eab\u4efd\u8bc1\u7b2c 7-14 \u4f4d\u7ed9\u51fa\u7684\u662f yyyymmdd \u683c\u5f0f\u7684\u751f\u65e5\u3002\u5982\u679c\u6ca1\u6709\u6821\u53cb\u6765\uff0c\u5219\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u6700\u5e74\u957f\u7684\u6765\u5bbe\u7684\u8eab\u4efd\u8bc1\u53f7\u3002\u9898\u76ee\u4fdd\u8bc1\u8fd9\u6837\u7684\u6821\u53cb\u6216\u6765\u5bbe\u5fc5\u662f\u552f\u4e00\u7684\u3002 \u8f93\u5165\u6837\u4f8b 5 372928196906118710 610481197806202213 440684198612150417 13072819571002001X 150702193604190912 6 530125197901260019 150702193604190912 220221196701020034 610481197806202213 440684198612150417 370205198709275042 \u8f93\u51fa\u6837\u4f8b 3 150702193604190912","title":"Statement"},{"location":"PAT-Basic-Level/1101-B%E6%98%AFA%E7%9A%84%E5%A4%9A%E5%B0%91%E5%80%8D/","text":"1101 B\u662fA\u7684\u591a\u5c11\u500d Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bbe\u4e00\u4e2a\u6570 A A \u7684\u6700\u4f4e D D \u4f4d\u5f62\u6210\u7684\u6570\u662f a_d a_d \u3002\u5982\u679c\u628a a_d a_d \u622a\u4e0b\u6765\u79fb\u5230 A A \u7684\u6700\u9ad8\u4f4d\u524d\u9762\uff0c\u5c31\u5f62\u6210\u4e86\u4e00\u4e2a\u65b0\u7684\u6570 B B \u3002 B B \u662f A A \u7684\u591a\u5c11\u500d\uff1f\u4f8b\u5982\u5c06 12345 \u7684\u6700\u4f4e 2 \u4f4d 45 \u622a\u4e0b\u6765\u653e\u5230 123 \u7684\u524d\u9762\uff0c\u5c31\u5f97\u5230 45123\uff0c\u5b83\u7ea6\u662f 12345 \u7684 3.66 \u500d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 A A \uff08 \\le 10^9 \\le 10^9 \uff09\u548c\u8981\u622a\u53d6\u7684\u4f4d\u6570 D D \u3002\u9898\u76ee\u4fdd\u8bc1 D D \u4e0d\u8d85\u8fc7 A A \u7684\u603b\u4f4d\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u8ba1\u7b97 B B \u662f A A \u7684\u591a\u5c11\u500d\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 1 12345 2 \u8f93\u51fa\u6837\u4f8b 1 3.66 \u8f93\u5165\u6837\u4f8b 2 12345 5 \u8f93\u51fa\u6837\u4f8b 2 1.00","title":"1101-B\u662fA\u7684\u591a\u5c11\u500d"},{"location":"PAT-Basic-Level/1101-B%E6%98%AFA%E7%9A%84%E5%A4%9A%E5%B0%91%E5%80%8D/#1101-b\u662fa\u7684\u591a\u5c11\u500d","text":"","title":"1101 B\u662fA\u7684\u591a\u5c11\u500d"},{"location":"PAT-Basic-Level/1101-B%E6%98%AFA%E7%9A%84%E5%A4%9A%E5%B0%91%E5%80%8D/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u8bbe\u4e00\u4e2a\u6570 A A \u7684\u6700\u4f4e D D \u4f4d\u5f62\u6210\u7684\u6570\u662f a_d a_d \u3002\u5982\u679c\u628a a_d a_d \u622a\u4e0b\u6765\u79fb\u5230 A A \u7684\u6700\u9ad8\u4f4d\u524d\u9762\uff0c\u5c31\u5f62\u6210\u4e86\u4e00\u4e2a\u65b0\u7684\u6570 B B \u3002 B B \u662f A A \u7684\u591a\u5c11\u500d\uff1f\u4f8b\u5982\u5c06 12345 \u7684\u6700\u4f4e 2 \u4f4d 45 \u622a\u4e0b\u6765\u653e\u5230 123 \u7684\u524d\u9762\uff0c\u5c31\u5f97\u5230 45123\uff0c\u5b83\u7ea6\u662f 12345 \u7684 3.66 \u500d\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 A A \uff08 \\le 10^9 \\le 10^9 \uff09\u548c\u8981\u622a\u53d6\u7684\u4f4d\u6570 D D \u3002\u9898\u76ee\u4fdd\u8bc1 D D \u4e0d\u8d85\u8fc7 A A \u7684\u603b\u4f4d\u6570\u3002 \u8f93\u51fa\u683c\u5f0f \u8ba1\u7b97 B B \u662f A A \u7684\u591a\u5c11\u500d\uff0c\u8f93\u51fa\u5c0f\u6570\u70b9\u540e 2 \u4f4d\u3002 \u8f93\u5165\u6837\u4f8b 1 12345 2 \u8f93\u51fa\u6837\u4f8b 1 3.66 \u8f93\u5165\u6837\u4f8b 2 12345 5 \u8f93\u51fa\u6837\u4f8b 2 1.00","title":"Statement"},{"location":"PAT-Basic-Level/1102-%E6%95%99%E8%B6%85%E5%86%A0%E5%86%9B%E5%8D%B7/","text":"1102 \u6559\u8d85\u51a0\u519b\u5377 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u6559\u80b2\u8d85\u5e02\u201d\u662f\u62fc\u9898 A \u7cfb\u7edf\u7684\u4e00\u4e2a\u884d\u751f\u4ea7\u54c1\uff0c\u53d1\u5e03\u4e86\u5404\u79cd\u8bd5\u5377\u548c\u7ec3\u4e60\u4f9b\u7528\u6237\u9009\u8d2d\u3002\u5728\u8bd5\u5377\u5217\u8868\u4e2d\uff0c\u7cfb\u7edf\u4e0d\u4ec5\u5217\u51fa\u4e86\u6bcf\u4efd\u8bd5\u5377\u7684\u5355\u4ef7\uff0c\u8fd8\u663e\u793a\u4e86\u5f53\u524d\u7684\u8d2d\u4e70\u4eba\u6b21\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u6839\u636e\u8fd9\u4e9b\u4fe1\u606f\u627e\u51fa\u6559\u80b2\u8d85\u5e02\u6240\u6709\u8bd5\u5377\u4e2d\u7684\u9500\u91cf\uff08\u5373\u8d2d\u4e70\u4eba\u6b21\uff09\u51a0\u519b\u548c\u9500\u552e\u989d\u51a0\u519b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4efd\u5377\u5b50\u7684\u72ec\u7279 ID \uff08\u7531\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc78\u4f4d\u7684\u5b57\u7b26\u4e32\uff09\u3001\u5355\u4ef7\uff08\u4e3a\u4e0d\u8d85\u8fc7 100 100 \u7684\u6b63\u6574\u6570\uff09\u548c\u8d2d\u4e70\u4eba\u6b21\uff08\u4e3a\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u975e\u8d1f\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u9500\u91cf\u51a0\u519b\u7684 ID \u53ca\u5176\u9500\u91cf\uff0c\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u9500\u552e\u989d\u51a0\u519b\u7684 ID \u53ca\u5176\u9500\u552e\u989d\u3002\u540c\u884c\u8f93\u51fa\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u51a0\u519b\u662f\u552f\u4e00\u7684\uff0c\u4e0d\u5b58\u5728\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 4 zju007 39 10 pku2019 9 332 pat2018 95 79 qdu106 19 38 \u8f93\u51fa\u6837\u4f8b pku2019 332 pat2018 7505","title":"1102-\u6559\u8d85\u51a0\u519b\u5377"},{"location":"PAT-Basic-Level/1102-%E6%95%99%E8%B6%85%E5%86%A0%E5%86%9B%E5%8D%B7/#1102-\u6559\u8d85\u51a0\u519b\u5377","text":"","title":"1102 \u6559\u8d85\u51a0\u519b\u5377"},{"location":"PAT-Basic-Level/1102-%E6%95%99%E8%B6%85%E5%86%A0%E5%86%9B%E5%8D%B7/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u6559\u80b2\u8d85\u5e02\u201d\u662f\u62fc\u9898 A \u7cfb\u7edf\u7684\u4e00\u4e2a\u884d\u751f\u4ea7\u54c1\uff0c\u53d1\u5e03\u4e86\u5404\u79cd\u8bd5\u5377\u548c\u7ec3\u4e60\u4f9b\u7528\u6237\u9009\u8d2d\u3002\u5728\u8bd5\u5377\u5217\u8868\u4e2d\uff0c\u7cfb\u7edf\u4e0d\u4ec5\u5217\u51fa\u4e86\u6bcf\u4efd\u8bd5\u5377\u7684\u5355\u4ef7\uff0c\u8fd8\u663e\u793a\u4e86\u5f53\u524d\u7684\u8d2d\u4e70\u4eba\u6b21\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u6839\u636e\u8fd9\u4e9b\u4fe1\u606f\u627e\u51fa\u6559\u80b2\u8d85\u5e02\u6240\u6709\u8bd5\u5377\u4e2d\u7684\u9500\u91cf\uff08\u5373\u8d2d\u4e70\u4eba\u6b21\uff09\u51a0\u519b\u548c\u9500\u552e\u989d\u51a0\u519b\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u6b63\u6574\u6570 N\uff08 \\le 10^4 \\le 10^4 \uff09\uff0c\u968f\u540e N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u4efd\u5377\u5b50\u7684\u72ec\u7279 ID \uff08\u7531\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7ec4\u6210\u7684\u3001\u957f\u5ea6\u4e0d\u8d85\u8fc78\u4f4d\u7684\u5b57\u7b26\u4e32\uff09\u3001\u5355\u4ef7\uff08\u4e3a\u4e0d\u8d85\u8fc7 100 100 \u7684\u6b63\u6574\u6570\uff09\u548c\u8d2d\u4e70\u4eba\u6b21\uff08\u4e3a\u4e0d\u8d85\u8fc7 10^6 10^6 \u7684\u975e\u8d1f\u6574\u6570\uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u7b2c\u4e00\u884c\u4e2d\u8f93\u51fa\u9500\u91cf\u51a0\u519b\u7684 ID \u53ca\u5176\u9500\u91cf\uff0c\u7b2c\u4e8c\u884c\u4e2d\u8f93\u51fa\u9500\u552e\u989d\u51a0\u519b\u7684 ID \u53ca\u5176\u9500\u552e\u989d\u3002\u540c\u884c\u8f93\u51fa\u95f4\u4ee5\u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u3002\u9898\u76ee\u4fdd\u8bc1\u51a0\u519b\u662f\u552f\u4e00\u7684\uff0c\u4e0d\u5b58\u5728\u5e76\u5217\u3002 \u8f93\u5165\u6837\u4f8b 4 zju007 39 10 pku2019 9 332 pat2018 95 79 qdu106 19 38 \u8f93\u51fa\u6837\u4f8b pku2019 332 pat2018 7505","title":"Statement"},{"location":"PAT-Basic-Level/1103-%E7%BC%98%E5%88%86%E6%95%B0/","text":"1103 \u7f18\u5206\u6570 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6240\u8c13 \u7f18\u5206\u6570 \u662f\u6307\u8fd9\u6837\u4e00\u5bf9\u6b63\u6574\u6570 a a \u548c b b \uff0c\u5176\u4e2d a a \u548c\u5b83\u7684\u5c0f\u5f1f a-1 a-1 \u7684\u7acb\u65b9\u5dee\u6b63\u597d\u662f\u53e6\u4e00\u4e2a\u6574\u6570 c c \u7684\u5e73\u65b9\uff0c\u800c c c \u6b63\u597d\u662f b b \u548c\u5b83\u7684\u5c0f\u5f1f b-1 b-1 \u7684\u5e73\u65b9\u548c\u3002\u4f8b\u5982 8^3 - 7^3 = 169 = 13^2 8^3 - 7^3 = 169 = 13^2 \uff0c\u800c 13 = 3^2 + 2^2 13 = 3^2 + 2^2 \uff0c\u4e8e\u662f 8 \u548c 3 \u5c31\u662f\u4e00\u5bf9\u7f18\u5206\u6570\u3002 \u7ed9\u5b9a a a \u6240\u5728\u7684\u533a\u95f4 [m,n] [m,n] \uff0c\u662f\u5426\u5b58\u5728\u7f18\u5206\u6570\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9 0<m<n\\le 25000 0<m<n\\le 25000 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167 a a \u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u5bf9\u7f18\u5206\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u65e0\u89e3\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 8 200 \u8f93\u51fa\u6837\u4f8b 1 8 3 105 10 \u8f93\u5165\u6837\u4f8b 2 9 100 \u8f93\u51fa\u6837\u4f8b 2 No Solution","title":"1103-\u7f18\u5206\u6570"},{"location":"PAT-Basic-Level/1103-%E7%BC%98%E5%88%86%E6%95%B0/#1103-\u7f18\u5206\u6570","text":"","title":"1103 \u7f18\u5206\u6570"},{"location":"PAT-Basic-Level/1103-%E7%BC%98%E5%88%86%E6%95%B0/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u6240\u8c13 \u7f18\u5206\u6570 \u662f\u6307\u8fd9\u6837\u4e00\u5bf9\u6b63\u6574\u6570 a a \u548c b b \uff0c\u5176\u4e2d a a \u548c\u5b83\u7684\u5c0f\u5f1f a-1 a-1 \u7684\u7acb\u65b9\u5dee\u6b63\u597d\u662f\u53e6\u4e00\u4e2a\u6574\u6570 c c \u7684\u5e73\u65b9\uff0c\u800c c c \u6b63\u597d\u662f b b \u548c\u5b83\u7684\u5c0f\u5f1f b-1 b-1 \u7684\u5e73\u65b9\u548c\u3002\u4f8b\u5982 8^3 - 7^3 = 169 = 13^2 8^3 - 7^3 = 169 = 13^2 \uff0c\u800c 13 = 3^2 + 2^2 13 = 3^2 + 2^2 \uff0c\u4e8e\u662f 8 \u548c 3 \u5c31\u662f\u4e00\u5bf9\u7f18\u5206\u6570\u3002 \u7ed9\u5b9a a a \u6240\u5728\u7684\u533a\u95f4 [m,n] [m,n] \uff0c\u662f\u5426\u5b58\u5728\u7f18\u5206\u6570\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u533a\u95f4\u7684\u4e24\u4e2a\u7aef\u70b9 0<m<n\\le 25000 0<m<n\\le 25000 \uff0c\u5176\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u7167 a a \u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u6bcf\u884c\u8f93\u51fa\u4e00\u5bf9\u7f18\u5206\u6570\uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u65e0\u89e3\uff0c\u5219\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 1 8 200 \u8f93\u51fa\u6837\u4f8b 1 8 3 105 10 \u8f93\u5165\u6837\u4f8b 2 9 100 \u8f93\u51fa\u6837\u4f8b 2 No Solution","title":"Statement"},{"location":"PAT-Basic-Level/1104-%E5%A4%A9%E9%95%BF%E5%9C%B0%E4%B9%85/","text":"1104 \u5929\u957f\u5730\u4e45 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u5929\u957f\u5730\u4e45\u6570\u201d\u662f\u6307\u4e00\u4e2a K K \u4f4d\u6b63\u6574\u6570 A A \uff0c\u5176\u6ee1\u8db3\u6761\u4ef6\u4e3a\uff1a A A \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u4e3a m m \uff0c A+1 A+1 \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u4e3a n n \uff0c\u4e14 m m \u4e0e n n \u7684\u6700\u5927\u516c\u7ea6\u6570\u662f\u4e00\u4e2a\u5927\u4e8e 2 \u7684\u7d20\u6570\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u627e\u51fa\u8fd9\u4e9b\u5929\u957f\u5730\u4e45\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 5 \\le 5 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9 K K \uff08 3<K<10 3<K<10 \uff09\u548c m m \uff08 1<m<90 1<m<90 \uff09\uff0c\u5176\u542b\u4e49\u5982\u9898\u9762\u6240\u8ff0\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u8f93\u5165\u7684 K K \u548c m m \uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case X \uff0c\u5176\u4e2d X \u662f\u8f93\u51fa\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff1b\u7136\u540e\u4e00\u884c\u8f93\u51fa\u5bf9\u5e94\u7684 n n \u548c A A \uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u6bcf\u7ec4\u89e3\u5360\u4e00\u884c\uff0c\u6309 n n \u7684\u9012\u589e\u5e8f\u8f93\u51fa\uff1b\u82e5\u4ecd\u4e0d\u552f\u4e00\uff0c\u5219\u6309 A A \u7684\u9012\u589e\u5e8f\u8f93\u51fa\u3002\u82e5\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 2 6 45 7 80 \u8f93\u51fa\u6837\u4f8b Case 1 10 189999 10 279999 10 369999 10 459999 10 549999 10 639999 10 729999 10 819999 10 909999 Case 2 No Solution","title":"1104-\u5929\u957f\u5730\u4e45"},{"location":"PAT-Basic-Level/1104-%E5%A4%A9%E9%95%BF%E5%9C%B0%E4%B9%85/#1104-\u5929\u957f\u5730\u4e45","text":"","title":"1104 \u5929\u957f\u5730\u4e45"},{"location":"PAT-Basic-Level/1104-%E5%A4%A9%E9%95%BF%E5%9C%B0%E4%B9%85/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 3000 ms \u5185\u5b58\u9650\u5236: 64 MB \u201c\u5929\u957f\u5730\u4e45\u6570\u201d\u662f\u6307\u4e00\u4e2a K K \u4f4d\u6b63\u6574\u6570 A A \uff0c\u5176\u6ee1\u8db3\u6761\u4ef6\u4e3a\uff1a A A \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u4e3a m m \uff0c A+1 A+1 \u7684\u5404\u4f4d\u6570\u5b57\u4e4b\u548c\u4e3a n n \uff0c\u4e14 m m \u4e0e n n \u7684\u6700\u5927\u516c\u7ea6\u6570\u662f\u4e00\u4e2a\u5927\u4e8e 2 \u7684\u7d20\u6570\u3002\u672c\u9898\u5c31\u8bf7\u4f60\u627e\u51fa\u8fd9\u4e9b\u5929\u957f\u5730\u4e45\u6570\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u7ed9\u51fa\u6b63\u6574\u6570 N N \uff08 \\le 5 \\le 5 \uff09\uff0c\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u5bf9 K K \uff08 3<K<10 3<K<10 \uff09\u548c m m \uff08 1<m<90 1<m<90 \uff09\uff0c\u5176\u542b\u4e49\u5982\u9898\u9762\u6240\u8ff0\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e00\u5bf9\u8f93\u5165\u7684 K K \u548c m m \uff0c\u9996\u5148\u5728\u4e00\u884c\u4e2d\u8f93\u51fa Case X \uff0c\u5176\u4e2d X \u662f\u8f93\u51fa\u7684\u7f16\u53f7\uff08\u4ece 1 \u5f00\u59cb\uff09\uff1b\u7136\u540e\u4e00\u884c\u8f93\u51fa\u5bf9\u5e94\u7684 n n \u548c A A \uff0c\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002\u5982\u679c\u89e3\u4e0d\u552f\u4e00\uff0c\u5219\u6bcf\u7ec4\u89e3\u5360\u4e00\u884c\uff0c\u6309 n n \u7684\u9012\u589e\u5e8f\u8f93\u51fa\uff1b\u82e5\u4ecd\u4e0d\u552f\u4e00\uff0c\u5219\u6309 A A \u7684\u9012\u589e\u5e8f\u8f93\u51fa\u3002\u82e5\u89e3\u4e0d\u5b58\u5728\uff0c\u5219\u5728\u4e00\u884c\u4e2d\u8f93\u51fa No Solution \u3002 \u8f93\u5165\u6837\u4f8b 2 6 45 7 80 \u8f93\u51fa\u6837\u4f8b Case 1 10 189999 10 279999 10 369999 10 459999 10 549999 10 639999 10 729999 10 819999 10 909999 Case 2 No Solution","title":"Statement"},{"location":"PAT-Basic-Level/1105-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/","text":"1105 \u94fe\u8868\u5408\u5e76 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u5355\u94fe\u8868 L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n \u548c L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m \u3002\u5982\u679c n\\ge 2m n\\ge 2m \uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5c06\u6bd4\u8f83\u77ed\u7684\u90a3\u4e2a\u94fe\u8868\u9006\u5e8f\uff0c\u7136\u540e\u5c06\u4e4b\u5e76\u5165\u6bd4\u8f83\u957f\u7684\u90a3\u4e2a\u94fe\u8868\uff0c\u5f97\u5230\u4e00\u4e2a\u5f62\u5982 $a_1 to a_2 to b_{m} to a_3 to a_4 to b_{m-1}cdots $ \u7684\u7ed3\u679c\u3002\u4f8b\u5982\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868\u5206\u522b\u4e3a 6\u21927 \u548c 1\u21922\u21923\u21924\u21925\uff0c\u4f60\u5e94\u8be5\u8f93\u51fa 1\u21922\u21927\u21923\u21924\u21926\u21925\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u94fe\u8868 L_1 L_1 \u548c L_2 L_2 \u7684\u5934\u7ed3\u70b9\u7684\u5730\u5740\uff0c\u4ee5\u53ca\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\uff0c\u5373\u7ed9\u5b9a\u7684\u7ed3\u70b9\u603b\u6570\u3002\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u662f\u4e00\u4e2a 5 \u4f4d\u6570\u7684\u975e\u8d1f\u6574\u6570\uff0c\u7a7a\u5730\u5740 NULL \u7528 -1 \u8868\u793a\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u7ed3\u70b9\u7684\u4fe1\u606f\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u7684\u5730\u5740\uff0c Data \u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff0c Next \u662f\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u7a7a\u94fe\u8868\uff0c\u5e76\u4e14\u8f83\u957f\u7684\u94fe\u8868\u81f3\u5c11\u662f\u8f83\u77ed\u94fe\u8868\u7684\u4e24\u500d\u957f\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u987a\u5e8f\u8f93\u51fa\u7ed3\u679c\u94fe\u8868\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 01000 7 02233 2 34891 00100 6 00001 34891 3 10086 01000 1 02233 00033 5 -1 10086 4 00033 00001 7 -1 \u8f93\u51fa\u6837\u4f8b 01000 1 02233 02233 2 00001 00001 7 34891 34891 3 10086 10086 4 00100 00100 6 00033 00033 5 -1","title":"1105-\u94fe\u8868\u5408\u5e76"},{"location":"PAT-Basic-Level/1105-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/#1105-\u94fe\u8868\u5408\u5e76","text":"","title":"1105 \u94fe\u8868\u5408\u5e76"},{"location":"PAT-Basic-Level/1105-%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e24\u4e2a\u5355\u94fe\u8868 L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n L_1 = a_1 \\to a_2\\to \\cdots \\to a_{n-1}\\to a_n \u548c L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m L_2 = b_1 \\to b_2\\to \\cdots \\to b_{m-1}\\to b_m \u3002\u5982\u679c n\\ge 2m n\\ge 2m \uff0c\u4f60\u7684\u4efb\u52a1\u662f\u5c06\u6bd4\u8f83\u77ed\u7684\u90a3\u4e2a\u94fe\u8868\u9006\u5e8f\uff0c\u7136\u540e\u5c06\u4e4b\u5e76\u5165\u6bd4\u8f83\u957f\u7684\u90a3\u4e2a\u94fe\u8868\uff0c\u5f97\u5230\u4e00\u4e2a\u5f62\u5982 $a_1 to a_2 to b_{m} to a_3 to a_4 to b_{m-1}cdots $ \u7684\u7ed3\u679c\u3002\u4f8b\u5982\u7ed9\u5b9a\u4e24\u4e2a\u94fe\u8868\u5206\u522b\u4e3a 6\u21927 \u548c 1\u21922\u21923\u21924\u21925\uff0c\u4f60\u5e94\u8be5\u8f93\u51fa 1\u21922\u21927\u21923\u21924\u21926\u21925\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e24\u4e2a\u94fe\u8868 L_1 L_1 \u548c L_2 L_2 \u7684\u5934\u7ed3\u70b9\u7684\u5730\u5740\uff0c\u4ee5\u53ca\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\uff0c\u5373\u7ed9\u5b9a\u7684\u7ed3\u70b9\u603b\u6570\u3002\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u662f\u4e00\u4e2a 5 \u4f4d\u6570\u7684\u975e\u8d1f\u6574\u6570\uff0c\u7a7a\u5730\u5740 NULL \u7528 -1 \u8868\u793a\u3002 \u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u6309\u4ee5\u4e0b\u683c\u5f0f\u7ed9\u51fa\u4e00\u4e2a\u7ed3\u70b9\u7684\u4fe1\u606f\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u7684\u5730\u5740\uff0c Data \u662f\u4e0d\u8d85\u8fc7 10^5 10^5 \u7684\u6b63\u6574\u6570\uff0c Next \u662f\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3002\u9898\u76ee\u4fdd\u8bc1\u6ca1\u6709\u7a7a\u94fe\u8868\uff0c\u5e76\u4e14\u8f83\u957f\u7684\u94fe\u8868\u81f3\u5c11\u662f\u8f83\u77ed\u94fe\u8868\u7684\u4e24\u500d\u957f\u3002 \u8f93\u51fa\u683c\u5f0f \u6309\u987a\u5e8f\u8f93\u51fa\u7ed3\u679c\u94fe\u8868\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 01000 7 02233 2 34891 00100 6 00001 34891 3 10086 01000 1 02233 00033 5 -1 10086 4 00033 00001 7 -1 \u8f93\u51fa\u6837\u4f8b 01000 1 02233 02233 2 00001 00001 7 34891 34891 3 10086 10086 4 00100 00100 6 00033 00033 5 -1","title":"Statement"},{"location":"PAT-Basic-Level/1106-2019%E6%95%B0%E5%88%97/","text":"1106 2019\u6570\u5217 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u628a 2019 \u5404\u4e2a\u6570\u4f4d\u4e0a\u7684\u6570\u5b57 2\u30010\u30011\u30019 \u4f5c\u4e3a\u4e00\u4e2a\u6570\u5217\u7684\u524d 4 \u9879\uff0c\u7528\u5b83\u4eec\u53bb\u6784\u9020\u4e00\u4e2a\u65e0\u7a77\u6570\u5217\uff0c\u5176\u4e2d\u7b2c n n \uff08 >4 >4 \uff09\u9879\u662f\u5b83\u524d 4 \u9879\u4e4b\u548c\u7684\u4e2a\u4f4d\u6570\u5b57\u3002\u4f8b\u5982\u7b2c 5 \u9879\u4e3a 2\uff0c \u56e0\u4e3a 2+0+1+9=12 2+0+1+9=12 \uff0c\u4e2a\u4f4d\u6570\u662f 2\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5217\u51fa\u8fd9\u4e2a\u5e8f\u5217\u7684\u524d n n \u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u6b63\u6574\u6570 n n \uff08 \\le 1000 \\le 1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6570\u5217\u7684\u524d n n \u9879\uff0c\u6570\u5b57\u95f4\u4e0d\u8981\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 \u8f93\u51fa\u6837\u4f8b 2019224758 \u9898\u5916\u8bdd\uff1a \u8fd9\u4e2a\u6570\u5217\u4e2d\u6c38\u8fdc\u4e0d\u4f1a\u51fa\u73b0 2018 \uff0c\u4f60\u80fd\u8bc1\u660e\u5417\uff1f","title":"1106-2019\u6570\u5217"},{"location":"PAT-Basic-Level/1106-2019%E6%95%B0%E5%88%97/#1106-2019\u6570\u5217","text":"","title":"1106 2019\u6570\u5217"},{"location":"PAT-Basic-Level/1106-2019%E6%95%B0%E5%88%97/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u628a 2019 \u5404\u4e2a\u6570\u4f4d\u4e0a\u7684\u6570\u5b57 2\u30010\u30011\u30019 \u4f5c\u4e3a\u4e00\u4e2a\u6570\u5217\u7684\u524d 4 \u9879\uff0c\u7528\u5b83\u4eec\u53bb\u6784\u9020\u4e00\u4e2a\u65e0\u7a77\u6570\u5217\uff0c\u5176\u4e2d\u7b2c n n \uff08 >4 >4 \uff09\u9879\u662f\u5b83\u524d 4 \u9879\u4e4b\u548c\u7684\u4e2a\u4f4d\u6570\u5b57\u3002\u4f8b\u5982\u7b2c 5 \u9879\u4e3a 2\uff0c \u56e0\u4e3a 2+0+1+9=12 2+0+1+9=12 \uff0c\u4e2a\u4f4d\u6570\u662f 2\u3002 \u672c\u9898\u5c31\u8bf7\u4f60\u7f16\u5199\u7a0b\u5e8f\uff0c\u5217\u51fa\u8fd9\u4e2a\u5e8f\u5217\u7684\u524d n n \u9879\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u7ed9\u51fa\u6b63\u6574\u6570 n n \uff08 \\le 1000 \\le 1000 \uff09\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u8f93\u51fa\u6570\u5217\u7684\u524d n n \u9879\uff0c\u6570\u5b57\u95f4\u4e0d\u8981\u6709\u7a7a\u683c\u3002 \u8f93\u5165\u6837\u4f8b 10 \u8f93\u51fa\u6837\u4f8b 2019224758 \u9898\u5916\u8bdd\uff1a \u8fd9\u4e2a\u6570\u5217\u4e2d\u6c38\u8fdc\u4e0d\u4f1a\u51fa\u73b0 2018 \uff0c\u4f60\u80fd\u8bc1\u660e\u5417\uff1f","title":"Statement"},{"location":"PAT-Basic-Level/1107-%E8%80%81%E9%BC%A0%E7%88%B1%E5%A4%A7%E7%B1%B3/","text":"1107 \u8001\u9f20\u7231\u5927\u7c73 Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7fc1\u607a\u8001\u5e08\u66fe\u7ecf\u8bbe\u8ba1\u8fc7\u4e00\u6b3e Java \u6311\u6218\u6e38\u620f\uff0c\u53eb\u201c\u8001\u9f20\u7231\u5927\u7c73\u201d\uff08\u6216\u8bb8\u56e0\u4e3a\u4ed6\u7684\u5916\u53f7\u53eb\u201c\u80d6\u80d6\u9f20\u201d\uff09\u3002\u6bcf\u4e2a\u73a9\u5bb6\u7528 Java \u4ee3\u7801\u63a7\u5236\u4e00\u53ea\u9f20\uff0c\u76ee\u6807\u662f\u62a2\u5403\u5c3d\u53ef\u80fd\u591a\u7684\u5927\u7c73\u8ba9\u81ea\u5df1\u53d8\u6210\u80d6\u80d6\u9f20\uff0c\u6700\u80d6\u7684\u90a3\u53ea\u5c31\u662f\u51a0\u519b\u3002 \u56e0\u4e3a\u6e38\u620f\u65f6\u95f4\u4e0d\u80fd\u592a\u957f\uff0c\u6211\u4eec\u628a\u73a9\u5bb6\u5206\u6210 N N \u7ec4\uff0c\u6bcf\u7ec4 M M \u53ea\u8001\u9f20\u540c\u573a\u7ade\u6280\uff0c\u7136\u540e\u4ece N N \u4e2a\u5206\u7ec4\u51a0\u519b\u4e2d\u76f4\u63a5\u9009\u51fa\u6700\u80d6\u7684\u51a0\u519b\u80d6\u80d6\u9f20\u3002\u73b0\u5728\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u6765\u5f97\u5230\u51a0\u519b\u7684\u4f53\u91cd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 100 \\le 100 \uff09\u4e3a\u7ec4\u6570\uff0c M M \uff08 \\le 10 \\le 10 \uff09\u4e3a\u6bcf\u7ec4\u73a9\u5bb6\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7ec4\u73a9\u5bb6\u63a7\u5236\u7684 M M \u53ea\u8001\u9f20\u6700\u540e\u7684\u4f53\u91cd\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u975e\u8d1f\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u987a\u6b21\u8f93\u51fa\u5404\u7ec4\u51a0\u519b\u7684\u4f53\u91cd\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u968f\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u51a0\u519b\u80d6\u80d6\u9f20\u7684\u4f53\u91cd\u3002 \u8f93\u5165\u6837\u4f8b 3 5 62 53 88 72 81 12 31 9 0 2 91 42 39 6 48 \u8f93\u51fa\u6837\u4f8b 88 31 91 91","title":"1107-\u8001\u9f20\u7231\u5927\u7c73"},{"location":"PAT-Basic-Level/1107-%E8%80%81%E9%BC%A0%E7%88%B1%E5%A4%A7%E7%B1%B3/#1107-\u8001\u9f20\u7231\u5927\u7c73","text":"","title":"1107 \u8001\u9f20\u7231\u5927\u7c73"},{"location":"PAT-Basic-Level/1107-%E8%80%81%E9%BC%A0%E7%88%B1%E5%A4%A7%E7%B1%B3/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7fc1\u607a\u8001\u5e08\u66fe\u7ecf\u8bbe\u8ba1\u8fc7\u4e00\u6b3e Java \u6311\u6218\u6e38\u620f\uff0c\u53eb\u201c\u8001\u9f20\u7231\u5927\u7c73\u201d\uff08\u6216\u8bb8\u56e0\u4e3a\u4ed6\u7684\u5916\u53f7\u53eb\u201c\u80d6\u80d6\u9f20\u201d\uff09\u3002\u6bcf\u4e2a\u73a9\u5bb6\u7528 Java \u4ee3\u7801\u63a7\u5236\u4e00\u53ea\u9f20\uff0c\u76ee\u6807\u662f\u62a2\u5403\u5c3d\u53ef\u80fd\u591a\u7684\u5927\u7c73\u8ba9\u81ea\u5df1\u53d8\u6210\u80d6\u80d6\u9f20\uff0c\u6700\u80d6\u7684\u90a3\u53ea\u5c31\u662f\u51a0\u519b\u3002 \u56e0\u4e3a\u6e38\u620f\u65f6\u95f4\u4e0d\u80fd\u592a\u957f\uff0c\u6211\u4eec\u628a\u73a9\u5bb6\u5206\u6210 N N \u7ec4\uff0c\u6bcf\u7ec4 M M \u53ea\u8001\u9f20\u540c\u573a\u7ade\u6280\uff0c\u7136\u540e\u4ece N N \u4e2a\u5206\u7ec4\u51a0\u519b\u4e2d\u76f4\u63a5\u9009\u51fa\u6700\u80d6\u7684\u51a0\u519b\u80d6\u80d6\u9f20\u3002\u73b0\u5728\u5c31\u8bf7\u4f60\u5199\u4e2a\u7a0b\u5e8f\u6765\u5f97\u5230\u51a0\u519b\u7684\u4f53\u91cd\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u7b2c\u4e00\u884c\u4e2d\u7ed9\u51fa 2 \u4e2a\u6b63\u6574\u6570\uff1a N N \uff08 \\le 100 \\le 100 \uff09\u4e3a\u7ec4\u6570\uff0c M M \uff08 \\le 10 \\le 10 \uff09\u4e3a\u6bcf\u7ec4\u73a9\u5bb6\u4e2a\u6570\u3002\u968f\u540e N N \u884c\uff0c\u6bcf\u884c\u7ed9\u51fa\u4e00\u7ec4\u73a9\u5bb6\u63a7\u5236\u7684 M M \u53ea\u8001\u9f20\u6700\u540e\u7684\u4f53\u91cd\uff0c\u5747\u4e3a\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u975e\u8d1f\u6574\u6570\u3002\u6570\u5b57\u95f4\u4ee5\u7a7a\u683c\u5206\u9694\u3002 \u8f93\u51fa\u683c\u5f0f \u9996\u5148\u5728\u7b2c\u4e00\u884c\u987a\u6b21\u8f93\u51fa\u5404\u7ec4\u51a0\u519b\u7684\u4f53\u91cd\uff0c\u6570\u5b57\u95f4\u4ee5 1 \u4e2a\u7a7a\u683c\u5206\u9694\uff0c\u884c\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002\u968f\u540e\u5728\u7b2c\u4e8c\u884c\u8f93\u51fa\u51a0\u519b\u80d6\u80d6\u9f20\u7684\u4f53\u91cd\u3002 \u8f93\u5165\u6837\u4f8b 3 5 62 53 88 72 81 12 31 9 0 2 91 42 39 6 48 \u8f93\u51fa\u6837\u4f8b 88 31 91 91","title":"Statement"},{"location":"PAT-Basic-Level/1108-String%E5%A4%8D%E8%AF%BB%E6%9C%BA/","text":"1108 String\u590d\u8bfb\u673a Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 StringString.... \uff08\u6ce8\u610f\u533a\u5206\u5927\u5c0f\u5199\uff09\u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u516d\u79cd\u5b57\u7b26\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 String \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002\u4f8b\u5982 gnirtSSs \u8981\u8c03\u6574\u6210 StringS \u8f93\u51fa\uff0c\u5176\u4e2d s \u662f\u591a\u4f59\u5b57\u7b26\u88ab\u5ffd\u7565\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b sTRidlinSayBingStrropriiSHSiRiagIgtSSr \u8f93\u51fa\u6837\u4f8b StringStringSrigSriSiSii","title":"1108-String\u590d\u8bfb\u673a"},{"location":"PAT-Basic-Level/1108-String%E5%A4%8D%E8%AF%BB%E6%9C%BA/#1108-string\u590d\u8bfb\u673a","text":"","title":"1108 String\u590d\u8bfb\u673a"},{"location":"PAT-Basic-Level/1108-String%E5%A4%8D%E8%AF%BB%E6%9C%BA/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u5b57\u7b26\u4e32\u3002\u8bf7\u5c06\u5b57\u7b26\u91cd\u65b0\u8c03\u6574\u987a\u5e8f\uff0c\u6309 StringString.... \uff08\u6ce8\u610f\u533a\u5206\u5927\u5c0f\u5199\uff09\u8fd9\u6837\u7684\u987a\u5e8f\u8f93\u51fa\uff0c\u5e76\u5ffd\u7565\u5176\u5b83\u5b57\u7b26\u3002\u5f53\u7136\uff0c\u516d\u79cd\u5b57\u7b26\u7684\u4e2a\u6570\u4e0d\u4e00\u5b9a\u662f\u4e00\u6837\u591a\u7684\uff0c\u82e5\u67d0\u79cd\u5b57\u7b26\u5df2\u7ecf\u8f93\u51fa\u5b8c\uff0c\u5219\u4f59\u4e0b\u7684\u5b57\u7b26\u4ecd\u6309 String \u7684\u987a\u5e8f\u6253\u5370\uff0c\u76f4\u5230\u6240\u6709\u5b57\u7b26\u90fd\u88ab\u8f93\u51fa\u3002\u4f8b\u5982 gnirtSSs \u8981\u8c03\u6574\u6210 StringS \u8f93\u51fa\uff0c\u5176\u4e2d s \u662f\u591a\u4f59\u5b57\u7b26\u88ab\u5ffd\u7565\u3002 \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e0d\u8d85\u8fc7 10^4 10^4 \u7684\u3001\u4ec5\u7531\u82f1\u6587\u5b57\u6bcd\u6784\u6210\u7684\u975e\u7a7a\u5b57\u7b26\u4e32\u3002 \u8f93\u51fa\u683c\u5f0f \u5728\u4e00\u884c\u4e2d\u6309\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u5b57\u7b26\u4e32\u3002\u9898\u76ee\u4fdd\u8bc1\u8f93\u51fa\u975e\u7a7a\u3002 \u8f93\u5165\u6837\u4f8b sTRidlinSayBingStrropriiSHSiRiagIgtSSr \u8f93\u51fa\u6837\u4f8b StringStringSrigSriSiSii","title":"Statement"},{"location":"PAT-Basic-Level/1109-%E6%93%85%E9%95%BFC/","text":"1109 \u64c5\u957fC Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u88ab\u9762\u8bd5\u5b98\u8981\u6c42\u7528 C \u5199\u4e00\u4e2a\u201cHello World\u201d\u65f6\uff0c\u6709\u672c\u4e8b\u50cf\u4e0b\u56fe\u663e\u793a\u7684\u90a3\u6837\u5199\u4e00\u4e2a\u51fa\u6765\u5417\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u7ed9\u51fa 26 \u4e2a\u82f1\u6587\u5927\u5199\u5b57\u6bcd A-Z\uff0c\u6bcf\u4e2a\u5b57\u6bcd\u7528\u4e00\u4e2a 7\\times 5 7\\times 5 \u7684\u3001\u7531 C \u548c . \u7ec4\u6210\u7684\u77e9\u9635\u6784\u6210\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u53e5\u5b50\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u53e5\u5b50\u662f\u7531\u82e5\u5e72\u4e2a\u5355\u8bcd\uff08\u6bcf\u4e2a\u5305\u542b\u4e0d\u8d85\u8fc7 10 \u4e2a\u8fde\u7eed\u7684\u5927\u5199\u82f1\u6587\u5b57\u6bcd\uff09\u7ec4\u6210\u7684\uff0c\u5355\u8bcd\u95f4\u4ee5\u4efb\u4f55\u975e\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u5206\u9694\u3002 \u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u7ed9\u51fa\u4e00\u4e2a\u5355\u8bcd\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u5355\u8bcd\uff0c\u5c06\u5176\u6bcf\u4e2a\u5b57\u6bcd\u7528\u77e9\u9635\u5f62\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\uff0c\u5b57\u6bcd\u95f4\u6709\u4e00\u5217\u7a7a\u683c\u5206\u9694\u3002\u5355\u8bcd\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u76f8\u90bb\u7684\u4e24\u4e2a\u5355\u8bcd\u95f4\u5fc5\u987b\u6709\u4e00\u7a7a\u884c\u5206\u9694\u3002\u8f93\u51fa\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u884c\u3002 \u8f93\u5165\u6837\u4f8b ..C.. .C.C. C...C CCCCC C...C C...C C...C CCCC. C...C C...C CCCC. C...C C...C CCCC. .CCC. C...C C.... C.... C.... C...C .CCC. CCCC. C...C C...C C...C C...C C...C CCCC. CCCCC C.... C.... CCCC. C.... C.... CCCCC CCCCC C.... C.... CCCC. C.... C.... C.... CCCC. C...C C.... C.CCC C...C C...C CCCC. C...C C...C C...C CCCCC C...C C...C C...C CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. CCCCC CCCCC ....C ....C ....C ....C C...C .CCC. C...C C..C. C.C.. CC... C.C.. C..C. C...C C.... C.... C.... C.... C.... C.... CCCCC C...C C...C CC.CC C.C.C C...C C...C C...C C...C C...C CC..C C.C.C C..CC C...C C...C .CCC. C...C C...C C...C C...C C...C .CCC. CCCC. C...C C...C CCCC. C.... C.... C.... .CCC. C...C C...C C...C C.C.C C..CC .CCC. CCCC. C...C CCCC. CC... C.C.. C..C. C...C .CCC. C...C C.... .CCC. ....C C...C .CCC. CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. ..C.. C...C C...C C...C C...C C...C C...C .CCC. C...C C...C C...C C...C C...C .C.C. ..C.. C...C C...C C...C C.C.C CC.CC C...C C...C C...C C...C .C.C. ..C.. .C.C. C...C C...C C...C C...C .C.C. ..C.. ..C.. ..C.. ..C.. CCCCC ....C ...C. ..C.. .C... C.... CCCCC HELLO~WORLD! \u8f93\u51fa\u6837\u4f8b C...C CCCCC C.... C.... .CCC. C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C CCCCC CCCC. C.... C.... C...C C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C C...C CCCCC CCCCC CCCCC .CCC. C...C .CCC. CCCC. C.... CCCC. C...C C...C C...C C.... C...C C...C C...C CCCC. C.... C...C C.C.C C...C CC... C.... C...C CC.CC C...C C.C.. C.... C...C C...C C...C C..C. C.... C...C C...C .CCC. C...C CCCCC CCCC.","title":"1109-\u64c5\u957fC"},{"location":"PAT-Basic-Level/1109-%E6%93%85%E9%95%BFC/#1109-\u64c5\u957fc","text":"","title":"1109 \u64c5\u957fC"},{"location":"PAT-Basic-Level/1109-%E6%93%85%E9%95%BFC/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u5f53\u4f60\u88ab\u9762\u8bd5\u5b98\u8981\u6c42\u7528 C \u5199\u4e00\u4e2a\u201cHello World\u201d\u65f6\uff0c\u6709\u672c\u4e8b\u50cf\u4e0b\u56fe\u663e\u793a\u7684\u90a3\u6837\u5199\u4e00\u4e2a\u51fa\u6765\u5417\uff1f \u8f93\u5165\u683c\u5f0f \u8f93\u5165\u9996\u5148\u7ed9\u51fa 26 \u4e2a\u82f1\u6587\u5927\u5199\u5b57\u6bcd A-Z\uff0c\u6bcf\u4e2a\u5b57\u6bcd\u7528\u4e00\u4e2a 7\\times 5 7\\times 5 \u7684\u3001\u7531 C \u548c . \u7ec4\u6210\u7684\u77e9\u9635\u6784\u6210\u3002\u6700\u540e\u5728\u4e00\u884c\u4e2d\u7ed9\u51fa\u4e00\u4e2a\u53e5\u5b50\uff0c\u4ee5\u56de\u8f66\u7ed3\u675f\u3002\u53e5\u5b50\u662f\u7531\u82e5\u5e72\u4e2a\u5355\u8bcd\uff08\u6bcf\u4e2a\u5305\u542b\u4e0d\u8d85\u8fc7 10 \u4e2a\u8fde\u7eed\u7684\u5927\u5199\u82f1\u6587\u5b57\u6bcd\uff09\u7ec4\u6210\u7684\uff0c\u5355\u8bcd\u95f4\u4ee5\u4efb\u4f55\u975e\u5927\u5199\u82f1\u6587\u5b57\u6bcd\u5206\u9694\u3002 \u9898\u76ee\u4fdd\u8bc1\u81f3\u5c11\u7ed9\u51fa\u4e00\u4e2a\u5355\u8bcd\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u5355\u8bcd\uff0c\u5c06\u5176\u6bcf\u4e2a\u5b57\u6bcd\u7528\u77e9\u9635\u5f62\u5f0f\u5728\u4e00\u884c\u4e2d\u8f93\u51fa\uff0c\u5b57\u6bcd\u95f4\u6709\u4e00\u5217\u7a7a\u683c\u5206\u9694\u3002\u5355\u8bcd\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u683c\u3002 \u76f8\u90bb\u7684\u4e24\u4e2a\u5355\u8bcd\u95f4\u5fc5\u987b\u6709\u4e00\u7a7a\u884c\u5206\u9694\u3002\u8f93\u51fa\u7684\u9996\u5c3e\u4e0d\u5f97\u6709\u591a\u4f59\u7a7a\u884c\u3002 \u8f93\u5165\u6837\u4f8b ..C.. .C.C. C...C CCCCC C...C C...C C...C CCCC. C...C C...C CCCC. C...C C...C CCCC. .CCC. C...C C.... C.... C.... C...C .CCC. CCCC. C...C C...C C...C C...C C...C CCCC. CCCCC C.... C.... CCCC. C.... C.... CCCCC CCCCC C.... C.... CCCC. C.... C.... C.... CCCC. C...C C.... C.CCC C...C C...C CCCC. C...C C...C C...C CCCCC C...C C...C C...C CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. CCCCC CCCCC ....C ....C ....C ....C C...C .CCC. C...C C..C. C.C.. CC... C.C.. C..C. C...C C.... C.... C.... C.... C.... C.... CCCCC C...C C...C CC.CC C.C.C C...C C...C C...C C...C C...C CC..C C.C.C C..CC C...C C...C .CCC. C...C C...C C...C C...C C...C .CCC. CCCC. C...C C...C CCCC. C.... C.... C.... .CCC. C...C C...C C...C C.C.C C..CC .CCC. CCCC. C...C CCCC. CC... C.C.. C..C. C...C .CCC. C...C C.... .CCC. ....C C...C .CCC. CCCCC ..C.. ..C.. ..C.. ..C.. ..C.. ..C.. C...C C...C C...C C...C C...C C...C .CCC. C...C C...C C...C C...C C...C .C.C. ..C.. C...C C...C C...C C.C.C CC.CC C...C C...C C...C C...C .C.C. ..C.. .C.C. C...C C...C C...C C...C .C.C. ..C.. ..C.. ..C.. ..C.. CCCCC ....C ...C. ..C.. .C... C.... CCCCC HELLO~WORLD! \u8f93\u51fa\u6837\u4f8b C...C CCCCC C.... C.... .CCC. C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C CCCCC CCCC. C.... C.... C...C C...C C.... C.... C.... C...C C...C C.... C.... C.... C...C C...C CCCCC CCCCC CCCCC .CCC. C...C .CCC. CCCC. C.... CCCC. C...C C...C C...C C.... C...C C...C C...C CCCC. C.... C...C C.C.C C...C CC... C.... C...C CC.CC C...C C.C.. C.... C...C C...C C...C C..C. C.... C...C C...C .CCC. C...C CCCCC CCCC.","title":"Statement"},{"location":"PAT-Basic-Level/1110-%E5%8C%BA%E5%9D%97%E5%8F%8D%E8%BD%AC/","text":"1110 \u533a\u5757\u53cd\u8f6c Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868 L L \uff0c\u6211\u4eec\u5c06\u6bcf K K \u4e2a\u7ed3\u70b9\u770b\u6210\u4e00\u4e2a \u533a\u5757 \uff08\u94fe\u8868\u6700\u540e\u82e5\u4e0d\u8db3 K K \u4e2a\u7ed3\u70b9\uff0c\u4e5f\u770b\u6210\u4e00\u4e2a\u533a\u5757\uff09\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06 L L \u4e2d\u6240\u6709\u533a\u5757\u7684\u94fe\u63a5\u53cd\u8f6c\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a 1\u21922\u21923\u21924\u21925\u21926\u21927\u21928\uff0c K K \u4e3a 3\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 7\u21928\u21924\u21925\u21926\u21921\u21922\u21923\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3001\u7ed3\u70b9\u603b\u4e2a\u6570\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3001\u4ee5\u53ca\u6b63\u6574\u6570 K K ( \\le N \\le N )\uff0c\u5373\u533a\u5757\u7684\u5927\u5c0f\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff0c Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6574\u6570\u6570\u636e\uff0c Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 8 3 71120 7 88666 00000 4 99999 00100 1 12309 68237 6 71120 33218 3 00000 99999 5 68237 88666 8 -1 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 71120 7 88666 88666 8 00000 00000 4 99999 99999 5 68237 68237 6 00100 00100 1 12309 12309 2 33218 33218 3 -1","title":"1110-\u533a\u5757\u53cd\u8f6c"},{"location":"PAT-Basic-Level/1110-%E5%8C%BA%E5%9D%97%E5%8F%8D%E8%BD%AC/#1110-\u533a\u5757\u53cd\u8f6c","text":"","title":"1110 \u533a\u5757\u53cd\u8f6c"},{"location":"PAT-Basic-Level/1110-%E5%8C%BA%E5%9D%97%E5%8F%8D%E8%BD%AC/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB \u7ed9\u5b9a\u4e00\u4e2a\u5355\u94fe\u8868 L L \uff0c\u6211\u4eec\u5c06\u6bcf K K \u4e2a\u7ed3\u70b9\u770b\u6210\u4e00\u4e2a \u533a\u5757 \uff08\u94fe\u8868\u6700\u540e\u82e5\u4e0d\u8db3 K K \u4e2a\u7ed3\u70b9\uff0c\u4e5f\u770b\u6210\u4e00\u4e2a\u533a\u5757\uff09\uff0c\u8bf7\u7f16\u5199\u7a0b\u5e8f\u5c06 L L \u4e2d\u6240\u6709\u533a\u5757\u7684\u94fe\u63a5\u53cd\u8f6c\u3002\u4f8b\u5982\uff1a\u7ed9\u5b9a L L \u4e3a 1\u21922\u21923\u21924\u21925\u21926\u21927\u21928\uff0c K K \u4e3a 3\uff0c\u5219\u8f93\u51fa\u5e94\u8be5\u4e3a 7\u21928\u21924\u21925\u21926\u21921\u21922\u21923\u3002 \u8f93\u5165\u683c\u5f0f \u6bcf\u4e2a\u8f93\u5165\u5305\u542b 1 \u4e2a\u6d4b\u8bd5\u7528\u4f8b\u3002\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7b2c 1 \u884c\u7ed9\u51fa\u7b2c 1 \u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u3001\u7ed3\u70b9\u603b\u4e2a\u6570\u6b63\u6574\u6570 N N ( \\le 10^5 \\le 10^5 )\u3001\u4ee5\u53ca\u6b63\u6574\u6570 K K ( \\le N \\le N )\uff0c\u5373\u533a\u5757\u7684\u5927\u5c0f\u3002\u7ed3\u70b9\u7684\u5730\u5740\u662f 5 \u4f4d\u975e\u8d1f\u6574\u6570\uff0cNULL \u5730\u5740\u7528 -1 -1 \u8868\u793a\u3002 \u63a5\u4e0b\u6765\u6709 N N \u884c\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3a\uff1a Address Data Next \u5176\u4e2d Address \u662f\u7ed3\u70b9\u5730\u5740\uff0c Data \u662f\u8be5\u7ed3\u70b9\u4fdd\u5b58\u7684\u6574\u6570\u6570\u636e\uff0c Next \u662f\u4e0b\u4e00\u7ed3\u70b9\u7684\u5730\u5740\u3002 \u8f93\u51fa\u683c\u5f0f \u5bf9\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\uff0c\u987a\u5e8f\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u94fe\u8868\uff0c\u5176\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u5360\u4e00\u884c\uff0c\u683c\u5f0f\u4e0e\u8f93\u5165\u76f8\u540c\u3002 \u8f93\u5165\u6837\u4f8b 00100 8 3 71120 7 88666 00000 4 99999 00100 1 12309 68237 6 71120 33218 3 00000 99999 5 68237 88666 8 -1 12309 2 33218 \u8f93\u51fa\u6837\u4f8b 71120 7 88666 88666 8 00000 00000 4 99999 99999 5 68237 68237 6 00100 00100 1 12309 12309 2 33218 33218 3 -1","title":"Statement"},{"location":"PAT-Top-Level/1001-Battle%20Over%20Cities%20-%20Hard%20Version/","text":"1001 Battle Over Cities - Hard Version Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB It is vitally important to have all the cities connected by highways in a war. If a city is conquered by the enemy, all the highways from/toward that city will be closed. To keep the rest of the cities connected, we must repair some highways with the minimum cost. On the other hand, if losing a city will cost us too much to rebuild the connection, we must pay more attention to that city. Given the map of cities which have all the destroyed and remaining highways marked, you are supposed to point out the city to which we must pay the most attention. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M , which are the total number of cities, and the number of highways, respectively. Then M lines follow, each describes a highway by 4 integers: City1 City2 Cost Status where City1 and City2 are the numbers of the cities the highway connects (the cities are numbered from 1 to N ), Cost is the effort taken to repair that highway if necessary, and Status is either 0, meaning that highway is destroyed, or 1, meaning that highway is in use. Note: It is guaranteed that the whole country was connected before the war. Output Specification For each test case, just print in a line the city we must protest the most, that is, it will take us the maximum effort to rebuild the connection if that city is conquered by the enemy. In case there is more than one city to be printed, output them in increasing order of the city numbers, separated by one space, but no extra space at the end of the line. In case there is no need to repair any highway at all, simply output 0. Sample Input 1 4 5 1 2 1 1 1 3 1 1 2 3 1 0 2 4 1 1 3 4 1 0 Sample Output 1 1 2 Sample Input 2 4 5 1 2 1 1 1 3 1 1 2 3 1 0 2 4 1 1 3 4 2 1 Sample Output 2 0 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define pLI pair<ll, int> #define fi first #define se second #define SZ(x) (int((x).size())) const int N = 3e5 + 10 ; const ll INF = 1e18 ; int n , m ; struct E { int u , v ; ll w ; bool operator < ( const E & other ) const { return w < other . w ; } }; vector < E > e [ 2 ]; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; ll gao ( int x ) { ufs . init ( n ); for ( int i = 0 ; i < SZ ( e [ 1 ]); ++ i ) { int u = e [ 1 ][ i ]. u , v = e [ 1 ][ i ]. v ; if ( u != x && v != x ) ufs . merge ( u , v ); } ll res = 0 ; for ( int i = 0 ; i < SZ ( e [ 0 ]); ++ i ) { int u = e [ 0 ][ i ]. u , v = e [ 0 ][ i ]. v ; ll w = e [ 0 ][ i ]. w ; if ( u != x && v != x && ufs . merge ( u , v )) res += w ; } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( i != x ) { if ( ufs . fa [ i ] == 0 ) ++ cnt ; } if ( cnt > 1 ) return INF ; return res ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , sta ; i <= m ; ++ i ) { E tmp ; scanf ( \"%d%d%lld%d\" , & tmp . u , & tmp . v , & tmp . w , & sta ); e [ sta ]. push_back ( tmp ); } sort ( e [ 0 ]. begin (), e [ 0 ]. end ()); sort ( e [ 1 ]. begin (), e [ 1 ]. end ()); vector < pLI > vec ; for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( pLI ( gao ( i ), i )); } sort ( vec . begin (), vec . end (), [ & ]( pLI x , pLI y ) { return x . fi > y . fi ; }); if ( vec [ 0 ]. fi == 0 ) printf ( \"0 \\n \" ); else { vector < int > res ; for ( int i = 0 ; i < n ; ++ i ) { if ( i && vec [ i ]. fi < vec [ i - 1 ]. fi ) break ; res . push_back ( vec [ i ]. se ); } sort ( res . begin (), res . end ()); for ( int i = 0 ; i < SZ ( res ); ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == SZ ( res ) - 1 ]); } return 0 ; }","title":"1001-Battle Over Cities - Hard Version"},{"location":"PAT-Top-Level/1001-Battle%20Over%20Cities%20-%20Hard%20Version/#1001-battle-over-cities---hard-version","text":"","title":"1001 Battle Over Cities - Hard Version"},{"location":"PAT-Top-Level/1001-Battle%20Over%20Cities%20-%20Hard%20Version/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB It is vitally important to have all the cities connected by highways in a war. If a city is conquered by the enemy, all the highways from/toward that city will be closed. To keep the rest of the cities connected, we must repair some highways with the minimum cost. On the other hand, if losing a city will cost us too much to rebuild the connection, we must pay more attention to that city. Given the map of cities which have all the destroyed and remaining highways marked, you are supposed to point out the city to which we must pay the most attention. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M , which are the total number of cities, and the number of highways, respectively. Then M lines follow, each describes a highway by 4 integers: City1 City2 Cost Status where City1 and City2 are the numbers of the cities the highway connects (the cities are numbered from 1 to N ), Cost is the effort taken to repair that highway if necessary, and Status is either 0, meaning that highway is destroyed, or 1, meaning that highway is in use. Note: It is guaranteed that the whole country was connected before the war. Output Specification For each test case, just print in a line the city we must protest the most, that is, it will take us the maximum effort to rebuild the connection if that city is conquered by the enemy. In case there is more than one city to be printed, output them in increasing order of the city numbers, separated by one space, but no extra space at the end of the line. In case there is no need to repair any highway at all, simply output 0. Sample Input 1 4 5 1 2 1 1 1 3 1 1 2 3 1 0 2 4 1 1 3 4 1 0 Sample Output 1 1 2 Sample Input 2 4 5 1 2 1 1 1 3 1 1 2 3 1 0 2 4 1 1 3 4 2 1 Sample Output 2 0","title":"Statement"},{"location":"PAT-Top-Level/1001-Battle%20Over%20Cities%20-%20Hard%20Version/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define pLI pair<ll, int> #define fi first #define se second #define SZ(x) (int((x).size())) const int N = 3e5 + 10 ; const ll INF = 1e18 ; int n , m ; struct E { int u , v ; ll w ; bool operator < ( const E & other ) const { return w < other . w ; } }; vector < E > e [ 2 ]; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; ll gao ( int x ) { ufs . init ( n ); for ( int i = 0 ; i < SZ ( e [ 1 ]); ++ i ) { int u = e [ 1 ][ i ]. u , v = e [ 1 ][ i ]. v ; if ( u != x && v != x ) ufs . merge ( u , v ); } ll res = 0 ; for ( int i = 0 ; i < SZ ( e [ 0 ]); ++ i ) { int u = e [ 0 ][ i ]. u , v = e [ 0 ][ i ]. v ; ll w = e [ 0 ][ i ]. w ; if ( u != x && v != x && ufs . merge ( u , v )) res += w ; } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( i != x ) { if ( ufs . fa [ i ] == 0 ) ++ cnt ; } if ( cnt > 1 ) return INF ; return res ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , sta ; i <= m ; ++ i ) { E tmp ; scanf ( \"%d%d%lld%d\" , & tmp . u , & tmp . v , & tmp . w , & sta ); e [ sta ]. push_back ( tmp ); } sort ( e [ 0 ]. begin (), e [ 0 ]. end ()); sort ( e [ 1 ]. begin (), e [ 1 ]. end ()); vector < pLI > vec ; for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( pLI ( gao ( i ), i )); } sort ( vec . begin (), vec . end (), [ & ]( pLI x , pLI y ) { return x . fi > y . fi ; }); if ( vec [ 0 ]. fi == 0 ) printf ( \"0 \\n \" ); else { vector < int > res ; for ( int i = 0 ; i < n ; ++ i ) { if ( i && vec [ i ]. fi < vec [ i - 1 ]. fi ) break ; res . push_back ( vec [ i ]. se ); } sort ( res . begin (), res . end ()); for ( int i = 0 ; i < SZ ( res ); ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == SZ ( res ) - 1 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1002-Business/","text":"1002 Business Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB As the manager of your company, you have to carefully consider, for each project, the time taken to finish it, the deadline, and the profit you can gain, in order to decide if your group should take this project. For example, given 3 projects as the following: Project[1] takes 3 days, it must be finished in 3 days in order to gain 6 units of profit. Project[2] takes 2 days, it must be finished in 2 days in order to gain 3 units of profit. Project[3] takes 1 day only, it must be finished in 3 days in order to gain 4 units of profit. You may take Project[1] to gain 6 units of profit. But if you take Project[2] first, then you will have 1 day left to complete Project[3] just in time, and hence gain 7 units of profit in total. Notice that once you decide to work on a project, you have to do it from beginning to the end without any interruption. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 50 \\le 50 ), and then followed by N N lines of projects, each contains three numbers P P , L L , and D D where P P is the profit, L L the lasting days of the project, and D D the deadline. It is guaranteed that L L is never more than D D , and all the numbers are non-negative integers. Output Specification For each test case, output in a line the maximum profit you can gain. Sample Input 4 7 1 3 10 2 3 6 1 2 5 1 1 Sample Output 18 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; int n , f [ N ]; struct E { int P , L , D ; bool operator < ( const E & other ) const { return D < other . D ; } } e [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. P , & e [ i ]. L , & e [ i ]. D ); } sort ( e + 1 , e + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = e [ i ]. D - e [ i ]. L ; j >= 0 ; -- j ) { f [ j + e [ i ]. L ] = max ( f [ j + e [ i ]. L ], f [ j ] + e [ i ]. P ); } } int res = 0 ; for ( int i = 0 ; i <= 1000 ; ++ i ) res = max ( res , f [ i ]); printf ( \"%d \\n \" , res ); return 0 ; }","title":"1002-Business"},{"location":"PAT-Top-Level/1002-Business/#1002-business","text":"","title":"1002 Business"},{"location":"PAT-Top-Level/1002-Business/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB As the manager of your company, you have to carefully consider, for each project, the time taken to finish it, the deadline, and the profit you can gain, in order to decide if your group should take this project. For example, given 3 projects as the following: Project[1] takes 3 days, it must be finished in 3 days in order to gain 6 units of profit. Project[2] takes 2 days, it must be finished in 2 days in order to gain 3 units of profit. Project[3] takes 1 day only, it must be finished in 3 days in order to gain 4 units of profit. You may take Project[1] to gain 6 units of profit. But if you take Project[2] first, then you will have 1 day left to complete Project[3] just in time, and hence gain 7 units of profit in total. Notice that once you decide to work on a project, you have to do it from beginning to the end without any interruption. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 50 \\le 50 ), and then followed by N N lines of projects, each contains three numbers P P , L L , and D D where P P is the profit, L L the lasting days of the project, and D D the deadline. It is guaranteed that L L is never more than D D , and all the numbers are non-negative integers. Output Specification For each test case, output in a line the maximum profit you can gain. Sample Input 4 7 1 3 10 2 3 6 1 2 5 1 1 Sample Output 18","title":"Statement"},{"location":"PAT-Top-Level/1002-Business/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1100 ; int n , f [ N ]; struct E { int P , L , D ; bool operator < ( const E & other ) const { return D < other . D ; } } e [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. P , & e [ i ]. L , & e [ i ]. D ); } sort ( e + 1 , e + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = e [ i ]. D - e [ i ]. L ; j >= 0 ; -- j ) { f [ j + e [ i ]. L ] = max ( f [ j + e [ i ]. L ], f [ j ] + e [ i ]. P ); } } int res = 0 ; for ( int i = 0 ; i <= 1000 ; ++ i ) res = max ( res , f [ i ]); printf ( \"%d \\n \" , res ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1003-Universal%20Travel%20Sites/","text":"1003 Universal Travel Sites Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N ( \\le \\le 500). Then N lines follow, each in the format: source[i] destination[i] capacity[i] where source[i] and destination[i] are the names of the satellites and the two involved planets, and capacity[i] > > 0 is the maximum number of passengers that can be transported at one pass from source[i] to destination[i] . Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU. Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet. Output Specification For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Sample Input EAR MAR 11 EAR AAA 300 EAR BBB 400 AAA BBB 100 AAA CCC 400 AAA MAR 300 BBB DDD 400 AAA DDD 400 DDD AAA 100 CCC MAR 400 DDD CCC 200 DDD MAR 300 Sample Output 700 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const ll INF = 1e18 ; template < class Type > struct Dinic { static const int M = 2e6 + 10 ; static const int N = 1e5 + 10 ; struct Edge { int to , nxt ; Type flow ; Edge () {} Edge ( int to , int nxt , Type flow ) : to ( to ), nxt ( nxt ), flow ( flow ) {} } edge [ M ]; int S , T ; int head [ N ], tot ; int dep [ N ]; void init () { memset ( head , -1 , sizeof head ); tot = 0 ; } void set ( int S , int T ) { this -> S = S ; this -> T = T ; } void addedge ( int u , int v , Type w , Type rw = 0 ) { edge [ tot ] = Edge ( v , head [ u ], w ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], rw ); head [ v ] = tot ++ ; } bool BFS () { memset ( dep , -1 , sizeof dep ); queue < int > q ; q . push ( S ); dep [ S ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == -1 ) { dep [ edge [ i ]. to ] = dep [ u ] + 1 ; q . push ( edge [ i ]. to ); } } } return dep [ T ] >= 0 ; } Type DFS ( int u , Type f ) { if ( u == T || f == 0 ) return f ; Type w , used = 0 ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == dep [ u ] + 1 ) { w = DFS ( edge [ i ]. to , min ( f - used , edge [ i ]. flow )); edge [ i ]. flow -= w ; edge [ i ^ 1 ]. flow += w ; used += w ; if ( used == f ) return f ; } } if ( ! used ) dep [ u ] = -1 ; return used ; } Type solve () { Type ans = 0 ; while ( BFS ()) { ans += DFS ( S , INF ); } return ans ; } }; Dinic < ll > dinic ; map < string , int > mp ; int cnt , n ; string S , T ; inline int getID ( const string & s ) { if ( mp . count ( s )) return mp [ s ]; mp [ s ] = ++ cnt ; return cnt ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cnt = 0 ; cin >> S >> T >> n ; mp . clear (); dinic . init (); for ( int i = 1 ; i <= n ; ++ i ) { string _S , _T ; int w ; cin >> _S >> _T >> w ; int u = getID ( _S ), v = getID ( _T ); dinic . addedge ( u , v , w ); } dinic . set ( getID ( S ), getID ( T )); cout << dinic . solve () << endl ; return 0 ; }","title":"1003-Universal Travel Sites"},{"location":"PAT-Top-Level/1003-Universal%20Travel%20Sites/#1003-universal-travel-sites","text":"","title":"1003 Universal Travel Sites"},{"location":"PAT-Top-Level/1003-Universal%20Travel%20Sites/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB After finishing her tour around the Earth, CYLL is now planning a universal travel sites development project. After a careful investigation, she has a list of capacities of all the satellite transportation stations in hand. To estimate a budget, she must know the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Input Specification Each input file contains one test case. For each case, the first line contains the names of the source and the destination planets, and a positive integer N ( \\le \\le 500). Then N lines follow, each in the format: source[i] destination[i] capacity[i] where source[i] and destination[i] are the names of the satellites and the two involved planets, and capacity[i] > > 0 is the maximum number of passengers that can be transported at one pass from source[i] to destination[i] . Each name is a string of 3 uppercase characters chosen from {A-Z}, e.g., ZJU. Note that the satellite transportation stations have no accommodation facilities for the passengers. Therefore none of the passengers can stay. Such a station will not allow arrivals of space vessels that contain more than its own capacity. It is guaranteed that the list contains neither the routes to the source planet nor that from the destination planet. Output Specification For each test case, just print in one line the minimum capacity that a planet station must have to guarantee that every space vessel can dock and download its passengers on arrival. Sample Input EAR MAR 11 EAR AAA 300 EAR BBB 400 AAA BBB 100 AAA CCC 400 AAA MAR 300 BBB DDD 400 AAA DDD 400 DDD AAA 100 CCC MAR 400 DDD CCC 200 DDD MAR 300 Sample Output 700","title":"Statement"},{"location":"PAT-Top-Level/1003-Universal%20Travel%20Sites/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const ll INF = 1e18 ; template < class Type > struct Dinic { static const int M = 2e6 + 10 ; static const int N = 1e5 + 10 ; struct Edge { int to , nxt ; Type flow ; Edge () {} Edge ( int to , int nxt , Type flow ) : to ( to ), nxt ( nxt ), flow ( flow ) {} } edge [ M ]; int S , T ; int head [ N ], tot ; int dep [ N ]; void init () { memset ( head , -1 , sizeof head ); tot = 0 ; } void set ( int S , int T ) { this -> S = S ; this -> T = T ; } void addedge ( int u , int v , Type w , Type rw = 0 ) { edge [ tot ] = Edge ( v , head [ u ], w ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], rw ); head [ v ] = tot ++ ; } bool BFS () { memset ( dep , -1 , sizeof dep ); queue < int > q ; q . push ( S ); dep [ S ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == -1 ) { dep [ edge [ i ]. to ] = dep [ u ] + 1 ; q . push ( edge [ i ]. to ); } } } return dep [ T ] >= 0 ; } Type DFS ( int u , Type f ) { if ( u == T || f == 0 ) return f ; Type w , used = 0 ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == dep [ u ] + 1 ) { w = DFS ( edge [ i ]. to , min ( f - used , edge [ i ]. flow )); edge [ i ]. flow -= w ; edge [ i ^ 1 ]. flow += w ; used += w ; if ( used == f ) return f ; } } if ( ! used ) dep [ u ] = -1 ; return used ; } Type solve () { Type ans = 0 ; while ( BFS ()) { ans += DFS ( S , INF ); } return ans ; } }; Dinic < ll > dinic ; map < string , int > mp ; int cnt , n ; string S , T ; inline int getID ( const string & s ) { if ( mp . count ( s )) return mp [ s ]; mp [ s ] = ++ cnt ; return cnt ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cnt = 0 ; cin >> S >> T >> n ; mp . clear (); dinic . init (); for ( int i = 1 ; i <= n ; ++ i ) { string _S , _T ; int w ; cin >> _S >> _T >> w ; int u = getID ( _S ), v = getID ( _T ); dinic . addedge ( u , v , w ); } dinic . set ( getID ( S ), getID ( T )); cout << dinic . solve () << endl ; return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1004-To%20Buy%20or%20Not%20to%20Buy%20-%20Hard%20Version/","text":"1004 To Buy or Not to Buy - Hard Version Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence in some cases Eva might have to buy several strings to get all the beads she needs. With a hundred strings in the shop, Eva needs your help to tell her whether or not she can get all the beads she needs with the least number of extra beads she has to pay for. For the sake of simplicity, let's use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. In sample 1, buying the 2 nd and the last two strings is the best way since there are only 3 extra beads. In sample 2, buying all the three strings won't help since there are three R beads missing. Input Specification Each input file contains one test case. Each case first gives in a line the string that Eva wants. Then a positive integer N N ( \\le 100 \\le 100 ) is given in the next line, followed by N N lines of strings that belong to the shop. All the strings contain no more than 1000 beads. Output Specification For each test case, print your answer in one line. If the answer is Yes , then also output the least number of extra beads Eva has to buy; or if the answer is No , then also output the number of beads missing from all the strings. There must be exactly 1 space between the answer and the number. Sample Input 1 RYg5 8 gY5Ybf 8R5 12346789 gRg8h 5Y37 pRgYgbR52 8Y 8g Sample Output 1 Yes 3 Sample Input 2 YrRR8RRrY 3 ppRGrrYB225 8ppGrrB25 Zd6KrY Sample Output 2 No 3 Solution C++ #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e3 + 10 ; int n , cnt [ 110 ][ 220 ], S [ 110 ][ 220 ], tot [ 220 ], need [ 220 ], has [ 220 ]; char s [ N ], t [ 110 ][ N ]; int id [ 220 ], cntID , res , loop ; void dfs ( int cur , int fee , int gap ) { if ( fee >= res ) return ; if ( gap == 0 ) { res = fee ; return ; } if ( cur > n ) return ; ++ loop ; if ( loop > 500 ) return ; for ( int i = 1 ; i <= cntID ; ++ i ) { if ( S [ cur ][ i ] < need [ i ] - has [ i ]) return ; } int preGap = gap ; int preFee = fee ; for ( int i = 1 ; i <= cntID ; ++ i ) { if ( cnt [ cur ][ i ]) { fee -= max ( 0 , has [ i ] - need [ i ]); gap -= max ( 0 , need [ i ] - has [ i ]); has [ i ] += cnt [ cur ][ i ]; fee += max ( 0 , has [ i ] - need [ i ]); gap += max ( 0 , need [ i ] - has [ i ]); } } if ( gap < preGap ) dfs ( cur + 1 , fee , gap ); for ( int i = 1 ; i <= cntID ; ++ i ) { if ( cnt [ cur ][ i ]) { has [ i ] -= cnt [ cur ][ i ]; } } dfs ( cur + 1 , preFee , preGap ); } int main () { cntID = 0 ; for ( int i = '0' ; i <= '9' ; ++ i ) id [ i ] = ++ cntID ; for ( int i = 'a' ; i <= 'z' ; ++ i ) id [ i ] = ++ cntID ; for ( int i = 'A' ; i <= 'Z' ; ++ i ) id [ i ] = ++ cntID ; scanf ( \"%s\" , s + 1 ); scanf ( \"%d\" , & n ); for ( int i = 1 ; s [ i ]; ++ i ) ++ need [ id [ s [ i ]]]; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , t [ i ] + 1 ); for ( int j = 1 ; t [ i ][ j ]; ++ j ) { ++ cnt [ i ][ id [ t [ i ][ j ]]]; ++ tot [ id [ t [ i ][ j ]]]; } } for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j <= cntID ; ++ j ) S [ i ][ j ] = S [ i + 1 ][ j ] + cnt [ i ][ j ]; } int gap = 0 ; for ( int i = 1 ; i <= cntID ; ++ i ) { gap += max ( 0 , need [ i ] - tot [ i ]); } if ( gap > 0 ) { printf ( \"No %d \\n \" , gap ); return 0 ; } res = 1e9 ; int Slen = strlen ( s + 1 ); dfs ( 1 , 0 , Slen ); printf ( \"Yes %d \\n \" , res ); return 0 ; }","title":"1004-To Buy or Not to Buy - Hard Version"},{"location":"PAT-Top-Level/1004-To%20Buy%20or%20Not%20to%20Buy%20-%20Hard%20Version/#1004-to-buy-or-not-to-buy---hard-version","text":"","title":"1004 To Buy or Not to Buy - Hard Version"},{"location":"PAT-Top-Level/1004-To%20Buy%20or%20Not%20to%20Buy%20-%20Hard%20Version/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence in some cases Eva might have to buy several strings to get all the beads she needs. With a hundred strings in the shop, Eva needs your help to tell her whether or not she can get all the beads she needs with the least number of extra beads she has to pay for. For the sake of simplicity, let's use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. In sample 1, buying the 2 nd and the last two strings is the best way since there are only 3 extra beads. In sample 2, buying all the three strings won't help since there are three R beads missing. Input Specification Each input file contains one test case. Each case first gives in a line the string that Eva wants. Then a positive integer N N ( \\le 100 \\le 100 ) is given in the next line, followed by N N lines of strings that belong to the shop. All the strings contain no more than 1000 beads. Output Specification For each test case, print your answer in one line. If the answer is Yes , then also output the least number of extra beads Eva has to buy; or if the answer is No , then also output the number of beads missing from all the strings. There must be exactly 1 space between the answer and the number. Sample Input 1 RYg5 8 gY5Ybf 8R5 12346789 gRg8h 5Y37 pRgYgbR52 8Y 8g Sample Output 1 Yes 3 Sample Input 2 YrRR8RRrY 3 ppRGrrYB225 8ppGrrB25 Zd6KrY Sample Output 2 No 3","title":"Statement"},{"location":"PAT-Top-Level/1004-To%20Buy%20or%20Not%20to%20Buy%20-%20Hard%20Version/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e3 + 10 ; int n , cnt [ 110 ][ 220 ], S [ 110 ][ 220 ], tot [ 220 ], need [ 220 ], has [ 220 ]; char s [ N ], t [ 110 ][ N ]; int id [ 220 ], cntID , res , loop ; void dfs ( int cur , int fee , int gap ) { if ( fee >= res ) return ; if ( gap == 0 ) { res = fee ; return ; } if ( cur > n ) return ; ++ loop ; if ( loop > 500 ) return ; for ( int i = 1 ; i <= cntID ; ++ i ) { if ( S [ cur ][ i ] < need [ i ] - has [ i ]) return ; } int preGap = gap ; int preFee = fee ; for ( int i = 1 ; i <= cntID ; ++ i ) { if ( cnt [ cur ][ i ]) { fee -= max ( 0 , has [ i ] - need [ i ]); gap -= max ( 0 , need [ i ] - has [ i ]); has [ i ] += cnt [ cur ][ i ]; fee += max ( 0 , has [ i ] - need [ i ]); gap += max ( 0 , need [ i ] - has [ i ]); } } if ( gap < preGap ) dfs ( cur + 1 , fee , gap ); for ( int i = 1 ; i <= cntID ; ++ i ) { if ( cnt [ cur ][ i ]) { has [ i ] -= cnt [ cur ][ i ]; } } dfs ( cur + 1 , preFee , preGap ); } int main () { cntID = 0 ; for ( int i = '0' ; i <= '9' ; ++ i ) id [ i ] = ++ cntID ; for ( int i = 'a' ; i <= 'z' ; ++ i ) id [ i ] = ++ cntID ; for ( int i = 'A' ; i <= 'Z' ; ++ i ) id [ i ] = ++ cntID ; scanf ( \"%s\" , s + 1 ); scanf ( \"%d\" , & n ); for ( int i = 1 ; s [ i ]; ++ i ) ++ need [ id [ s [ i ]]]; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , t [ i ] + 1 ); for ( int j = 1 ; t [ i ][ j ]; ++ j ) { ++ cnt [ i ][ id [ t [ i ][ j ]]]; ++ tot [ id [ t [ i ][ j ]]]; } } for ( int i = n ; i >= 1 ; -- i ) { for ( int j = 1 ; j <= cntID ; ++ j ) S [ i ][ j ] = S [ i + 1 ][ j ] + cnt [ i ][ j ]; } int gap = 0 ; for ( int i = 1 ; i <= cntID ; ++ i ) { gap += max ( 0 , need [ i ] - tot [ i ]); } if ( gap > 0 ) { printf ( \"No %d \\n \" , gap ); return 0 ; } res = 1e9 ; int Slen = strlen ( s + 1 ); dfs ( 1 , 0 , Slen ); printf ( \"Yes %d \\n \" , res ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/","text":"1005 Programming Pattern Statement Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB Programmers often have a preference among program constructs. For example, some may prefer if(0==a) , while others may prefer if(!a) . Analyzing such patterns can help to narrow down a programmer's identity, which is useful for detecting plagiarism. Now given some text sampled from someone's program, can you find the person's most commonly used pattern of a specific length? Input Specification Each input file contains one test case. For each case, there is one line consisting of the pattern length N N ( 1\\le N\\le 1048576 1\\le N\\le 1048576 ), followed by one line no less than N N and no more than 1048576 characters in length, terminated by a carriage return \\n . The entire input is case sensitive. Output Specification For each test case, print in one line the length- N N substring that occurs most frequently in the input, followed by a space and the number of times it has occurred in the input. If there are multiple such substrings, print the lexicographically smallest one. Whitespace characters in the input should be printed as they are. Also note that there may be multiple occurrences of the same substring overlapping each other. Sample Input 1 4 //A can can can a can. Sample Output 1 can 4 Sample Input 2 3 int a=~~~~~~~~~~~~~~~~~~~~~0; Sample Output 2 ~~~ 19 Tutorial \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u5728\u6240\u6709\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2d\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\uff0c\u5982\u679c\u6709\u591a\u4e2a\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u3002 \u5e76\u4e14\u8fd8\u8981\u8f93\u51fa\u51fa\u73b0\u6b21\u6570\u3002 \u601d\u8def\uff1a \u8003\u8651\u8dd1\u4e00\u4e2a SA \uff0c\u7136\u540e\u53d1\u73b0\u957f\u5ea6\u4e3a n n \u7684\u5e76\u4e14\u76f8\u540c\u7684\u5b50\u4e32\uff0c\u4ed6\u4eec\u7684\u540e\u7f00\u6392\u540d\u80af\u5b9a\u662f\u76f8\u540c\u7684\u3002 \u5e76\u4e14\u5b57\u5178\u5e8f\u8d8a\u5c0f\u7684\uff0c\u540e\u7f00\u6392\u540d\u80af\u5b9a\u8d8a\u5c0f\uff0c\u6240\u4ee5\u626b\u4e00\u904d sa[\\;] sa[\\;] \u6570\u7ec4\u5373\u53ef\u6c42\u51fa\u7b54\u6848\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1048576 * 3 + 10 ; int n ; char s [ N ]; struct DA { //\u6c42SA\u6570\u7ec4\u9700\u8981\u7528\u5230\u7684\u4e2d\u95f4\u53d8\u91cf\uff0c\u4e0d\u9700\u8981\u8d4b\u503c // c\u6570\u7ec4\u7684\u8303\u56f4\u4e3am + 1 int t1 [ N ], t2 [ N ], c [ N ]; int sa [ N ]; int Rank [ N ]; int height [ N ]; //\u5f85\u6392\u5e8f\u7684\u5b57\u7b26\u4e32\u653e\u5728str\u6570\u7ec4\u4e2d\uff0c\u4ecestr[0] - s[n - 1]\u957f\u5ea6\u4e3an, \u6700\u5927\u503c\u5c0f\u4e8em int str [ N ]; int n , m ; void init ( char * s , int m , int n ) { this -> m = m ; this -> n = n ; for ( int i = 0 ; i < n ; ++ i ) str [ i ] = s [ i ]; str [ n ] = 0 ; } bool cmp ( int * r , int a , int b , int l ) { return r [ a ] == r [ b ] && r [ a + l ] == r [ b + l ]; } void work () { ++ n ; int i , j , p , * x = t1 , * y = t2 ; //\u7b2c\u4e00\u8f6e\u57fa\u6570\u6392\u5e8f\uff0c\u5982\u679cs\u7684\u6700\u5927\u503c\u5f88\u5927\uff0c\u53ef\u6539\u4e3a\u5feb\u901f\u6392\u5e8f for ( i = 0 ; i < m ; ++ i ) c [ i ] = 0 ; for ( i = 0 ; i < n ; ++ i ) c [ x [ i ] = str [ i ]] ++ ; for ( i = 1 ; i < m ; ++ i ) c [ i ] += c [ i - 1 ]; for ( i = n - 1 ; i >= 0 ; -- i ) sa [ -- c [ x [ i ]]] = i ; for ( j = 1 ; j <= n ; j <<= 1 ) { p = 0 ; //\u76f4\u63a5\u5229\u7528sa\u6570\u7ec4\u6392\u5e8f\u7b2c\u4e8c\u5173\u952e\u5b57 //\u540e\u9762\u7684j\u4e2a\u6570\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7a7a\u7684\u6700\u5c0f for ( i = n - j ; i < n ; ++ i ) { y [ p ++ ] = i ; } for ( i = 0 ; i < n ; ++ i ) if ( sa [ i ] >= j ) y [ p ++ ] = sa [ i ] - j ; //\u8fd9\u6837\u6570\u7ec4y\u4fdd\u5b58\u7684\u5c31\u662f\u6309\u7167\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\u7684\u7ed3\u679c //\u57fa\u6570\u6392\u5e8f\u7b2c\u4e00\u5173\u952e\u5b57 for ( i = 0 ; i < m ; ++ i ) c [ i ] = 0 ; for ( i = 0 ; i < n ; ++ i ) c [ x [ y [ i ]]] ++ ; for ( i = 1 ; i < m ; ++ i ) c [ i ] += c [ i - 1 ]; for ( i = n - 1 ; i >= 0 ; -- i ) sa [ -- c [ x [ y [ i ]]]] = y [ i ]; //\u6839\u636esa\u548cx\u6570\u7ec4\u8ba1\u7b97\u65b0\u7684x\u6570\u7ec4 swap ( x , y ); p = 1 ; x [ sa [ 0 ]] = 0 ; for ( i = 1 ; i < n ; ++ i ) { x [ sa [ i ]] = cmp ( y , sa [ i - 1 ], sa [ i ], j ) ? p - 1 : p ++ ; } if ( p >= n ) break ; //\u4e0b\u6b21\u57fa\u6570\u6392\u5e8f\u7684\u6700\u5927\u503c m = p ; } int k = 0 ; -- n ; for ( i = 0 ; i <= n ; ++ i ) Rank [ sa [ i ]] = i ; // build height for ( i = 0 ; i < n ; ++ i ) { if ( k ) -- k ; j = sa [ Rank [ i ] - 1 ]; while ( str [ i + k ] == str [ j + k ]) ++ k ; height [ Rank [ i ]] = k ; } } } da ; int main () { scanf ( \"%d \\n %[^ \\n ]\" , & n , s ); int len = strlen ( s ); da . init ( s , 128 , len ); da . work (); // da.work(s, len, 128); int pre = 1 , Max = 1 , pos = da . sa [ 1 ]; for ( int i = 2 ; i <= len ; ++ i ) { if ( da . height [ i ] >= n ) { ++ pre ; if ( pre > Max ) { Max = pre ; pos = da . sa [ i ]; } } else { pre = 1 ; } } s [ pos + n ] = 0 ; printf ( \"%s %d \\n \" , s + pos , Max ); return 0 ; } Tutorial1 \u8003\u8651 Hash \uff0c\u6c42\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570\u3002 \u6bd4\u8f83\u5b57\u5178\u5e8f\uff0c\u76f4\u63a5\u4e8c\u5206 lcp \u8fdb\u884c\u6bd4\u8f83\u5373\u53ef\uff0c\u6bd4\u8f83\u7684\u6b21\u6570\u4e0d\u4f1a\u8d85\u8fc7 |len| - n |len| - n \u6b21\u3002 \u672c\u6765\u7528 map \u505a\uff0c\u6709\u4e2a\u70b9\u4e00\u76f4 TLE \uff0c\u7528 unordered_map \u4e5f\u65e0\u6d4e\u4e8e\u4e8b\u3002 \u540e\u6765\u53d1\u73b0\u53ef\u4ee5\u76f4\u63a5 sort \uff0c\u7136\u540e\u626b\u4e00\u904d\u5c31 WIN \u4e86\u3002 Solution1 C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1.1e6 + 10 , INF = 0x3f3f3f3f ; int n ; string s ; struct Hash { int seed , mod ; int base [ N ], a [ N ]; void init ( int _seed , int _mod , const string & s ) { seed = _seed ; mod = _mod ; base [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { base [ i ] = 1l l * base [ i - 1 ] * seed % mod ; } a [ 0 ] = 0 ; for ( int i = 1 ; i < SZ ( s ); ++ i ) { a [ i ] = ( 1l l * a [ i - 1 ] * seed % mod + s [ i ]) % mod ; } } inline int get ( int l , int r ) { return ( a [ r ] - 1l l * a [ l - 1 ] * base [ r - l + 1 ] % mod + mod ) % mod ; } } hs ; inline bool ok ( int x , int y ) { if ( hs . get ( x , x + n - 1 ) == hs . get ( y , y + n - 1 )) return false ; int l = 1 , r = n , res = 0 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( hs . get ( x , x + mid - 1 ) == hs . get ( y , y + mid - 1 )) { res = mid ; l = mid + 1 ; } else { r = mid - 1 ; } } if ( res < n && s [ x + res ] > s [ y + res ]) return true ; return false ; } struct node { int ix , val , num ; node () {} node ( int ix , int val , int num ) : ix ( ix ), val ( val ), num ( num ) {} }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; getline ( cin , s ); getline ( cin , s ); s . insert ( 0 , \"0\" ); hs . init ( 233 , 998244353 , s ); vector < node > vec , _vec ; for ( int i = 1 ; i + n <= SZ ( s ); ++ i ) { vec . emplace_back ( i , hs . get ( i , i + n - 1 ), 1 ); } sort ( vec . begin (), vec . end (), [ & ]( node a , node b ) { return a . val < b . val ; }); _vec . push_back ( vec . back ()); vec . pop_back (); while ( ! vec . empty ()) { node tmp = vec . back (); vec . pop_back (); if ( tmp . val == _vec . back (). val ) ++ _vec . back (). num ; else _vec . push_back ( tmp ); } sort ( _vec . begin (), _vec . end (), [ & ]( node a , node b ) { return a . num > b . num ; }); node res = _vec [ 0 ]; for ( int i = 1 ; i < SZ ( _vec ); ++ i ) { node now = _vec [ i ]; if ( res . num > now . num ) break ; else if ( ok ( res . ix , now . ix )) res = now ; } cout << s . substr ( res . ix , n ) << \" \" << res . num << \" \\n \" ; return 0 ; } Tutorial2 \u60f3\u4e0d\u901a\u4e3a\u4ec0\u4e48\u8fd9\u4e9b\u300c\u66b4\u529b\u300d\u53ef\u4ee5\u8fc7\u3002 Solution2 C++ #include <bits/extc++.h> #include <bits/stdc++.h> using namespace std ; using namespace __gnu_pbds ; #define fi first #define se second const int N = 1048576 + 10 ; int n ; string s ; typedef unsigned int ull ; // map<ull, int> mp, id; struct Hash { static ull base [ N ]; static void init () { base [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) base [ i ] = base [ i - 1 ] * 131 ; } ull a [ N ]; //\u6700\u597d\u6539\u6210\u4ece1\u5f00\u59cb\uff0c\u56e0\u4e3a\u67e5\u8be2\u533a\u95f4Hash\u503c\u662f\u524d\u7f00\u548c\u5f62\u5f0f inline void gao ( string & s ) { a [ 0 ] = 0 ; int len = s . size (); for ( int i = 1 ; i <= len ; ++ i ) { a [ i ] = a [ i - 1 ] * 131 + ( s [ i - 1 ] + 1 ); } } inline ull get ( int l , int r ) { ++ l , ++ r ; return a [ r ] - a [ l - 1 ] * base [ r - l + 1 ]; } } hs ; ull Hash :: base [ N ] = { 0 }; unordered_map < ull , int > mp ; int main () { Hash :: init (); ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; getline ( cin , s ); getline ( cin , s ); hs . gao ( s ); int Max = 0 , pos = -1 ; int len = s . size (); for ( int i = 0 ; i + n - 1 < len ; ++ i ) { ull val = hs . get ( i , i + n - 1 ); ++ mp [ val ]; if ( mp [ val ] > Max ) { Max = mp [ val ]; pos = i ; } else if ( mp [ val ] == Max ) { for ( int j = 0 ; j < n ; ++ j ) if ( s [ pos + j ] != s [ i + j ]) { if ( s [ pos + j ] > s [ i + j ]) pos = i ; break ; } } } cout << s . substr ( pos , n ) << \" \" << Max << \" \\n \" ; return 0 ; }","title":"1005-Programming Pattern"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#1005-programming-pattern","text":"","title":"1005 Programming Pattern"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#statement","text":"Metadata \u4f5c\u8005: HOU, Qiming \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 800 ms \u5185\u5b58\u9650\u5236: 64 MB Programmers often have a preference among program constructs. For example, some may prefer if(0==a) , while others may prefer if(!a) . Analyzing such patterns can help to narrow down a programmer's identity, which is useful for detecting plagiarism. Now given some text sampled from someone's program, can you find the person's most commonly used pattern of a specific length? Input Specification Each input file contains one test case. For each case, there is one line consisting of the pattern length N N ( 1\\le N\\le 1048576 1\\le N\\le 1048576 ), followed by one line no less than N N and no more than 1048576 characters in length, terminated by a carriage return \\n . The entire input is case sensitive. Output Specification For each test case, print in one line the length- N N substring that occurs most frequently in the input, followed by a space and the number of times it has occurred in the input. If there are multiple such substrings, print the lexicographically smallest one. Whitespace characters in the input should be printed as they are. Also note that there may be multiple occurrences of the same substring overlapping each other. Sample Input 1 4 //A can can can a can. Sample Output 1 can 4 Sample Input 2 3 int a=~~~~~~~~~~~~~~~~~~~~~0; Sample Output 2 ~~~ 19","title":"Statement"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#tutorial","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u5728\u6240\u6709\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2d\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\uff0c\u5982\u679c\u6709\u591a\u4e2a\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u3002 \u5e76\u4e14\u8fd8\u8981\u8f93\u51fa\u51fa\u73b0\u6b21\u6570\u3002 \u601d\u8def\uff1a \u8003\u8651\u8dd1\u4e00\u4e2a SA \uff0c\u7136\u540e\u53d1\u73b0\u957f\u5ea6\u4e3a n n \u7684\u5e76\u4e14\u76f8\u540c\u7684\u5b50\u4e32\uff0c\u4ed6\u4eec\u7684\u540e\u7f00\u6392\u540d\u80af\u5b9a\u662f\u76f8\u540c\u7684\u3002 \u5e76\u4e14\u5b57\u5178\u5e8f\u8d8a\u5c0f\u7684\uff0c\u540e\u7f00\u6392\u540d\u80af\u5b9a\u8d8a\u5c0f\uff0c\u6240\u4ee5\u626b\u4e00\u904d sa[\\;] sa[\\;] \u6570\u7ec4\u5373\u53ef\u6c42\u51fa\u7b54\u6848\u3002","title":"Tutorial"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1048576 * 3 + 10 ; int n ; char s [ N ]; struct DA { //\u6c42SA\u6570\u7ec4\u9700\u8981\u7528\u5230\u7684\u4e2d\u95f4\u53d8\u91cf\uff0c\u4e0d\u9700\u8981\u8d4b\u503c // c\u6570\u7ec4\u7684\u8303\u56f4\u4e3am + 1 int t1 [ N ], t2 [ N ], c [ N ]; int sa [ N ]; int Rank [ N ]; int height [ N ]; //\u5f85\u6392\u5e8f\u7684\u5b57\u7b26\u4e32\u653e\u5728str\u6570\u7ec4\u4e2d\uff0c\u4ecestr[0] - s[n - 1]\u957f\u5ea6\u4e3an, \u6700\u5927\u503c\u5c0f\u4e8em int str [ N ]; int n , m ; void init ( char * s , int m , int n ) { this -> m = m ; this -> n = n ; for ( int i = 0 ; i < n ; ++ i ) str [ i ] = s [ i ]; str [ n ] = 0 ; } bool cmp ( int * r , int a , int b , int l ) { return r [ a ] == r [ b ] && r [ a + l ] == r [ b + l ]; } void work () { ++ n ; int i , j , p , * x = t1 , * y = t2 ; //\u7b2c\u4e00\u8f6e\u57fa\u6570\u6392\u5e8f\uff0c\u5982\u679cs\u7684\u6700\u5927\u503c\u5f88\u5927\uff0c\u53ef\u6539\u4e3a\u5feb\u901f\u6392\u5e8f for ( i = 0 ; i < m ; ++ i ) c [ i ] = 0 ; for ( i = 0 ; i < n ; ++ i ) c [ x [ i ] = str [ i ]] ++ ; for ( i = 1 ; i < m ; ++ i ) c [ i ] += c [ i - 1 ]; for ( i = n - 1 ; i >= 0 ; -- i ) sa [ -- c [ x [ i ]]] = i ; for ( j = 1 ; j <= n ; j <<= 1 ) { p = 0 ; //\u76f4\u63a5\u5229\u7528sa\u6570\u7ec4\u6392\u5e8f\u7b2c\u4e8c\u5173\u952e\u5b57 //\u540e\u9762\u7684j\u4e2a\u6570\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7a7a\u7684\u6700\u5c0f for ( i = n - j ; i < n ; ++ i ) { y [ p ++ ] = i ; } for ( i = 0 ; i < n ; ++ i ) if ( sa [ i ] >= j ) y [ p ++ ] = sa [ i ] - j ; //\u8fd9\u6837\u6570\u7ec4y\u4fdd\u5b58\u7684\u5c31\u662f\u6309\u7167\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\u7684\u7ed3\u679c //\u57fa\u6570\u6392\u5e8f\u7b2c\u4e00\u5173\u952e\u5b57 for ( i = 0 ; i < m ; ++ i ) c [ i ] = 0 ; for ( i = 0 ; i < n ; ++ i ) c [ x [ y [ i ]]] ++ ; for ( i = 1 ; i < m ; ++ i ) c [ i ] += c [ i - 1 ]; for ( i = n - 1 ; i >= 0 ; -- i ) sa [ -- c [ x [ y [ i ]]]] = y [ i ]; //\u6839\u636esa\u548cx\u6570\u7ec4\u8ba1\u7b97\u65b0\u7684x\u6570\u7ec4 swap ( x , y ); p = 1 ; x [ sa [ 0 ]] = 0 ; for ( i = 1 ; i < n ; ++ i ) { x [ sa [ i ]] = cmp ( y , sa [ i - 1 ], sa [ i ], j ) ? p - 1 : p ++ ; } if ( p >= n ) break ; //\u4e0b\u6b21\u57fa\u6570\u6392\u5e8f\u7684\u6700\u5927\u503c m = p ; } int k = 0 ; -- n ; for ( i = 0 ; i <= n ; ++ i ) Rank [ sa [ i ]] = i ; // build height for ( i = 0 ; i < n ; ++ i ) { if ( k ) -- k ; j = sa [ Rank [ i ] - 1 ]; while ( str [ i + k ] == str [ j + k ]) ++ k ; height [ Rank [ i ]] = k ; } } } da ; int main () { scanf ( \"%d \\n %[^ \\n ]\" , & n , s ); int len = strlen ( s ); da . init ( s , 128 , len ); da . work (); // da.work(s, len, 128); int pre = 1 , Max = 1 , pos = da . sa [ 1 ]; for ( int i = 2 ; i <= len ; ++ i ) { if ( da . height [ i ] >= n ) { ++ pre ; if ( pre > Max ) { Max = pre ; pos = da . sa [ i ]; } } else { pre = 1 ; } } s [ pos + n ] = 0 ; printf ( \"%s %d \\n \" , s + pos , Max ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#tutorial1","text":"\u8003\u8651 Hash \uff0c\u6c42\u51fa\u73b0\u7684\u6700\u5927\u6b21\u6570\u3002 \u6bd4\u8f83\u5b57\u5178\u5e8f\uff0c\u76f4\u63a5\u4e8c\u5206 lcp \u8fdb\u884c\u6bd4\u8f83\u5373\u53ef\uff0c\u6bd4\u8f83\u7684\u6b21\u6570\u4e0d\u4f1a\u8d85\u8fc7 |len| - n |len| - n \u6b21\u3002 \u672c\u6765\u7528 map \u505a\uff0c\u6709\u4e2a\u70b9\u4e00\u76f4 TLE \uff0c\u7528 unordered_map \u4e5f\u65e0\u6d4e\u4e8e\u4e8b\u3002 \u540e\u6765\u53d1\u73b0\u53ef\u4ee5\u76f4\u63a5 sort \uff0c\u7136\u540e\u626b\u4e00\u904d\u5c31 WIN \u4e86\u3002","title":"Tutorial1"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#solution1","text":"C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1.1e6 + 10 , INF = 0x3f3f3f3f ; int n ; string s ; struct Hash { int seed , mod ; int base [ N ], a [ N ]; void init ( int _seed , int _mod , const string & s ) { seed = _seed ; mod = _mod ; base [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { base [ i ] = 1l l * base [ i - 1 ] * seed % mod ; } a [ 0 ] = 0 ; for ( int i = 1 ; i < SZ ( s ); ++ i ) { a [ i ] = ( 1l l * a [ i - 1 ] * seed % mod + s [ i ]) % mod ; } } inline int get ( int l , int r ) { return ( a [ r ] - 1l l * a [ l - 1 ] * base [ r - l + 1 ] % mod + mod ) % mod ; } } hs ; inline bool ok ( int x , int y ) { if ( hs . get ( x , x + n - 1 ) == hs . get ( y , y + n - 1 )) return false ; int l = 1 , r = n , res = 0 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( hs . get ( x , x + mid - 1 ) == hs . get ( y , y + mid - 1 )) { res = mid ; l = mid + 1 ; } else { r = mid - 1 ; } } if ( res < n && s [ x + res ] > s [ y + res ]) return true ; return false ; } struct node { int ix , val , num ; node () {} node ( int ix , int val , int num ) : ix ( ix ), val ( val ), num ( num ) {} }; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; getline ( cin , s ); getline ( cin , s ); s . insert ( 0 , \"0\" ); hs . init ( 233 , 998244353 , s ); vector < node > vec , _vec ; for ( int i = 1 ; i + n <= SZ ( s ); ++ i ) { vec . emplace_back ( i , hs . get ( i , i + n - 1 ), 1 ); } sort ( vec . begin (), vec . end (), [ & ]( node a , node b ) { return a . val < b . val ; }); _vec . push_back ( vec . back ()); vec . pop_back (); while ( ! vec . empty ()) { node tmp = vec . back (); vec . pop_back (); if ( tmp . val == _vec . back (). val ) ++ _vec . back (). num ; else _vec . push_back ( tmp ); } sort ( _vec . begin (), _vec . end (), [ & ]( node a , node b ) { return a . num > b . num ; }); node res = _vec [ 0 ]; for ( int i = 1 ; i < SZ ( _vec ); ++ i ) { node now = _vec [ i ]; if ( res . num > now . num ) break ; else if ( ok ( res . ix , now . ix )) res = now ; } cout << s . substr ( res . ix , n ) << \" \" << res . num << \" \\n \" ; return 0 ; }","title":"Solution1"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#tutorial2","text":"\u60f3\u4e0d\u901a\u4e3a\u4ec0\u4e48\u8fd9\u4e9b\u300c\u66b4\u529b\u300d\u53ef\u4ee5\u8fc7\u3002","title":"Tutorial2"},{"location":"PAT-Top-Level/1005-Programming%20Pattern/#solution2","text":"C++ #include <bits/extc++.h> #include <bits/stdc++.h> using namespace std ; using namespace __gnu_pbds ; #define fi first #define se second const int N = 1048576 + 10 ; int n ; string s ; typedef unsigned int ull ; // map<ull, int> mp, id; struct Hash { static ull base [ N ]; static void init () { base [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) base [ i ] = base [ i - 1 ] * 131 ; } ull a [ N ]; //\u6700\u597d\u6539\u6210\u4ece1\u5f00\u59cb\uff0c\u56e0\u4e3a\u67e5\u8be2\u533a\u95f4Hash\u503c\u662f\u524d\u7f00\u548c\u5f62\u5f0f inline void gao ( string & s ) { a [ 0 ] = 0 ; int len = s . size (); for ( int i = 1 ; i <= len ; ++ i ) { a [ i ] = a [ i - 1 ] * 131 + ( s [ i - 1 ] + 1 ); } } inline ull get ( int l , int r ) { ++ l , ++ r ; return a [ r ] - a [ l - 1 ] * base [ r - l + 1 ]; } } hs ; ull Hash :: base [ N ] = { 0 }; unordered_map < ull , int > mp ; int main () { Hash :: init (); ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; getline ( cin , s ); getline ( cin , s ); hs . gao ( s ); int Max = 0 , pos = -1 ; int len = s . size (); for ( int i = 0 ; i + n - 1 < len ; ++ i ) { ull val = hs . get ( i , i + n - 1 ); ++ mp [ val ]; if ( mp [ val ] > Max ) { Max = mp [ val ]; pos = i ; } else if ( mp [ val ] == Max ) { for ( int j = 0 ; j < n ; ++ j ) if ( s [ pos + j ] != s [ i + j ]) { if ( s [ pos + j ] > s [ i + j ]) pos = i ; break ; } } } cout << s . substr ( pos , n ) << \" \" << Max << \" \\n \" ; return 0 ; }","title":"Solution2"},{"location":"PAT-Top-Level/1006-Tree%20Traversals%20-%20Hard%20Version/","text":"1006 Tree Traversals - Hard Version Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given the partial results of a binary tree's traversals in in-order, pre-order, and post-order. You are supposed to output the complete results and the level order traversal sequence of the corresponding tree. Input Specification Each input file contains one test case. For each case, a positive integer N N ( \\le 100 \\le 100 ) is given in the first line. Then three lines follow, containing the incomplete in-order, pre-order and post-order traversal sequences, respectively. It is assumed that the tree nodes are numbered from 1 to N N and no number is given out of the range. A - represents a missing number. Output Specification For each case, print in four lines the complete in-order, pre-order and post-order traversal sequences, together with the level order traversal sequence of the corresponding tree. The numbers must be separated by a space, and there must be no extra space at the beginning or the end of each line. If it is impossible to reconstruct the unique tree from the given information, simply print Impossible . Sample Input 1 9 3 - 2 1 7 9 - 4 6 9 - 5 3 2 1 - 6 4 3 1 - - 7 - 6 8 - Sample Output 1 3 5 2 1 7 9 8 4 6 9 7 5 3 2 1 8 6 4 3 1 2 5 7 4 6 8 9 9 7 8 5 6 3 2 4 1 Sample Input 2 3 - - - - 1 - 1 - - Sample Output 2 Impossible Tutorial \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u3001\u524d\u5e8f\u3001\u540e\u5e8f\u904d\u5386\u7684\u6b8b\u7f3a\u5e8f\u5217\uff0c\u95ee\u80fd\u5426\u552f\u4e00\u7684\u8fd8\u539f\u51fa\u8fd9\u68f5\u6811\uff0c\u5982\u679c\u80fd\uff0c\u8f93\u51fa\u4e2d\u5e8f\u3001\u524d\u5e8f\u3001\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u4ee5\u53ca\u5c42\u6b21\u904d\u5386\u7ed3\u679c\u3002 \u7ed3\u70b9\u4e2a\u6570 n (1 \\leq n \\leq 10^2) n (1 \\leq n \\leq 10^2) \u3002 \u601d\u8def\uff1a \u5224\u65ad\u5728\u4e09\u4e2a\u904d\u5386\u5e8f\u5217\u4e2d\u5747\u4e3a\u51fa\u73b0\u7684\u70b9\u7684\u4e2a\u6570\u662f\u5426\u5927\u4e8e 1 1 \uff0c\u5982\u679c\u5927\u4e8e 1 1 , \u90a3\u4e48\u80af\u5b9a Impossible \uff0c\u56e0\u4e3a\u8fd9\u4e9b\u70b9\u7684\u4f4d\u7f6e\u80af\u5b9a\u53ef\u4ee5\u4e92\u6362\u3002 \u6211\u4eec\u8003\u8651\u4ece\u4e2d\u5e8f\u904d\u5386\u5165\u624b\uff0c\u901a\u8fc7\u679a\u4e3e\u5f53\u524d\u5b50\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u533a\u95f4\u4e2d\u7684\u6839\uff0c\u7136\u540e\u4ee5\u6b64\u5206\u6210\u5de6\u53f3\u4e24\u4e2a\u5b50\u6811\u5f80\u4e0b\u904d\u5386\u5224\u65ad\u5408\u6cd5\u6027\u3002 \u4f46\u662f\u5728\u4e0b\u9762\u4ee3\u7801\u4e2d\uff0c\u6211\u8ba4\u4e3a\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u5728\u679a\u4e3e\u6839\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u4e00\u65e6\u53d1\u73b0\u4e00\u4e2a\u5408\u6cd5\u7684\u6839\u5c31\u8fd4\u56de True \uff0c\u8fd9\u6837\u662f\u6709\u95ee\u9898\u7684\u3002 \u56e0\u4e3a\u53ef\u80fd\u5f80\u4e0b\u53bb\u679a\u4e3e\u5b58\u5728\u53e6\u4e00\u4e2a\u5408\u6cd5\u7684\u6839\uff0c\u90a3\u4e48\u5f53\u524d\u5b50\u6811\u7684\u904d\u5386\u5e8f\u5217\u5c31\u5b58\u5728\u591a\u79cd\u5408\u6cd5\u72b6\u6001\uff0c\u6700\u540e\u6784\u6210\u7684\u6811\u5c31\u4e0d\u662f\u552f\u4e00\u7684\u3002 \u56e0\u4e3a\u591a\u52a0\u4e00\u4e2a\u5224\u65ad\uff0c\u5224\u65ad\u5f53\u524d\u5b50\u5e8f\u5217\u7684\u5408\u6cd5\u7684\u6839\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5927\u4e8e 1 1 \u4e2a\uff0c\u5e94\u8be5\u4e5f\u662f Impossible \u3002 \u4f46\u662f\u52a0\u4e0a\u540e WA \u4e86\u4e00\u4e2a\u70b9\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff1a 3 - - - 1 2 3 3 2 1 \u5b83\u663e\u7136\u5b58\u5728\u81f3\u5c11\u4e24\u79cd\u72b6\u6001\uff1a \u4f46\u662f\u4e0b\u9762\u8fd9\u4efd AC \u4ee3\u7801\uff0c\u8f93\u51fa\u7684\u662f\u6709\u7ed3\u679c\u7684\u3002 \u66ff\u6362\u6210\u6ce8\u91ca\u91cc\u7684\u5185\u5bb9\u540e\u7684\u90a3\u4efd WA \u7684\u4ee3\u7801\uff0c\u8f93\u51fa\u662f Impossible \u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1e2 + 10 , INF = 0x3f3f3f3f ; int n , a [ N ], b [ N ], c [ N ], _a [ N ], _b [ N ], _c [ N ], cnt [ N ]; pII son [ N ]; int rd () { string s ; cin >> s ; if ( s == \"-\" ) return 0 ; int num = 0 ; for ( auto & ch : s ) num = num * 10 + ( ch - '0' ); return num ; } bool dfs ( int al , int ar , int bl , int br , int cl , int cr , int & rt ) { if ( al > ar || bl > br || cl > cr ) return true ; if ( b [ bl ] != 0 && c [ cr ] != 0 && b [ bl ] != c [ cr ]) return false ; for ( int i = al ; i <= ar ; ++ i ) { if ( a [ i ] != 0 && b [ bl ] != 0 && a [ i ] != b [ bl ]) continue ; if ( a [ i ] != 0 && c [ cr ] != 0 && a [ i ] != c [ cr ]) continue ; int now = max ({ a [ i ], b [ bl ], c [ cr ]}); son [ i ] = pII ( 0 , 0 ); int len = i - al ; if ( dfs ( al , i - 1 , bl + 1 , bl + len , cl , cl + len - 1 , son [ i ]. fi ) && dfs ( i + 1 , ar , bl + len + 1 , br , cl + len , cr - 1 , son [ i ]. se )) { _a [ i ] = _b [ bl ] = _c [ cr ] = now ; rt = i ; return true ; } } return false ; } void bfs ( int st ) { vector < int > res ; queue < int > que ; que . push ( st ); while ( ! que . empty ()) { int u = que . front (); que . pop (); res . push_back ( _a [ u ]); if ( son [ u ]. fi ) que . push ( son [ u ]. fi ); if ( son [ u ]. se ) que . push ( son [ u ]. se ); } for ( int i = 0 ; i < SZ ( res ); ++ i ) { cout << res [ i ] << \" \\n \" [ i == SZ ( res ) - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; memset ( cnt , 0 , sizeof cnt ); int num = n ; for ( auto & arr : { a , b , c }) { for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ] = rd (); if ( arr [ i ] && ++ cnt [ arr [ i ]] == 1 ) -- num ; } } for ( int i = 1 ; i <= n ; ++ i ) { _a [ i ] = a [ i ]; _b [ i ] = b [ i ]; _c [ i ] = c [ i ]; } int rt = 0 ; if ( num > 1 || ! dfs ( 1 , n , 1 , n , 1 , n , rt )) { cout << \"Impossible \\n \" ; return 0 ; } num = -1 ; memset ( cnt , 0 , sizeof cnt ); for ( int i = 1 ; i <= n ; ++ i ) ++ cnt [ _a [ i ]]; for ( int i = 1 ; i <= n ; ++ i ) if ( cnt [ i ] == 0 ) num = i ; for ( auto & arr : { _a , _b , _c }) { for ( int i = 1 ; i <= n ; ++ i ) if ( arr [ i ] == 0 ) arr [ i ] = num ; for ( int i = 1 ; i <= n ; ++ i ) { cout << arr [ i ] << \" \\n \" [ i == n ]; } } bfs ( rt ); return 0 ; }","title":"1006-Tree Traversals - Hard Version"},{"location":"PAT-Top-Level/1006-Tree%20Traversals%20-%20Hard%20Version/#1006-tree-traversals---hard-version","text":"","title":"1006 Tree Traversals - Hard Version"},{"location":"PAT-Top-Level/1006-Tree%20Traversals%20-%20Hard%20Version/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given the partial results of a binary tree's traversals in in-order, pre-order, and post-order. You are supposed to output the complete results and the level order traversal sequence of the corresponding tree. Input Specification Each input file contains one test case. For each case, a positive integer N N ( \\le 100 \\le 100 ) is given in the first line. Then three lines follow, containing the incomplete in-order, pre-order and post-order traversal sequences, respectively. It is assumed that the tree nodes are numbered from 1 to N N and no number is given out of the range. A - represents a missing number. Output Specification For each case, print in four lines the complete in-order, pre-order and post-order traversal sequences, together with the level order traversal sequence of the corresponding tree. The numbers must be separated by a space, and there must be no extra space at the beginning or the end of each line. If it is impossible to reconstruct the unique tree from the given information, simply print Impossible . Sample Input 1 9 3 - 2 1 7 9 - 4 6 9 - 5 3 2 1 - 6 4 3 1 - - 7 - 6 8 - Sample Output 1 3 5 2 1 7 9 8 4 6 9 7 5 3 2 1 8 6 4 3 1 2 5 7 4 6 8 9 9 7 8 5 6 3 2 4 1 Sample Input 2 3 - - - - 1 - 1 - - Sample Output 2 Impossible","title":"Statement"},{"location":"PAT-Top-Level/1006-Tree%20Traversals%20-%20Hard%20Version/#tutorial","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u3001\u524d\u5e8f\u3001\u540e\u5e8f\u904d\u5386\u7684\u6b8b\u7f3a\u5e8f\u5217\uff0c\u95ee\u80fd\u5426\u552f\u4e00\u7684\u8fd8\u539f\u51fa\u8fd9\u68f5\u6811\uff0c\u5982\u679c\u80fd\uff0c\u8f93\u51fa\u4e2d\u5e8f\u3001\u524d\u5e8f\u3001\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u4ee5\u53ca\u5c42\u6b21\u904d\u5386\u7ed3\u679c\u3002 \u7ed3\u70b9\u4e2a\u6570 n (1 \\leq n \\leq 10^2) n (1 \\leq n \\leq 10^2) \u3002 \u601d\u8def\uff1a \u5224\u65ad\u5728\u4e09\u4e2a\u904d\u5386\u5e8f\u5217\u4e2d\u5747\u4e3a\u51fa\u73b0\u7684\u70b9\u7684\u4e2a\u6570\u662f\u5426\u5927\u4e8e 1 1 \uff0c\u5982\u679c\u5927\u4e8e 1 1 , \u90a3\u4e48\u80af\u5b9a Impossible \uff0c\u56e0\u4e3a\u8fd9\u4e9b\u70b9\u7684\u4f4d\u7f6e\u80af\u5b9a\u53ef\u4ee5\u4e92\u6362\u3002 \u6211\u4eec\u8003\u8651\u4ece\u4e2d\u5e8f\u904d\u5386\u5165\u624b\uff0c\u901a\u8fc7\u679a\u4e3e\u5f53\u524d\u5b50\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u533a\u95f4\u4e2d\u7684\u6839\uff0c\u7136\u540e\u4ee5\u6b64\u5206\u6210\u5de6\u53f3\u4e24\u4e2a\u5b50\u6811\u5f80\u4e0b\u904d\u5386\u5224\u65ad\u5408\u6cd5\u6027\u3002 \u4f46\u662f\u5728\u4e0b\u9762\u4ee3\u7801\u4e2d\uff0c\u6211\u8ba4\u4e3a\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u5728\u679a\u4e3e\u6839\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6211\u4eec\u4e00\u65e6\u53d1\u73b0\u4e00\u4e2a\u5408\u6cd5\u7684\u6839\u5c31\u8fd4\u56de True \uff0c\u8fd9\u6837\u662f\u6709\u95ee\u9898\u7684\u3002 \u56e0\u4e3a\u53ef\u80fd\u5f80\u4e0b\u53bb\u679a\u4e3e\u5b58\u5728\u53e6\u4e00\u4e2a\u5408\u6cd5\u7684\u6839\uff0c\u90a3\u4e48\u5f53\u524d\u5b50\u6811\u7684\u904d\u5386\u5e8f\u5217\u5c31\u5b58\u5728\u591a\u79cd\u5408\u6cd5\u72b6\u6001\uff0c\u6700\u540e\u6784\u6210\u7684\u6811\u5c31\u4e0d\u662f\u552f\u4e00\u7684\u3002 \u56e0\u4e3a\u591a\u52a0\u4e00\u4e2a\u5224\u65ad\uff0c\u5224\u65ad\u5f53\u524d\u5b50\u5e8f\u5217\u7684\u5408\u6cd5\u7684\u6839\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5927\u4e8e 1 1 \u4e2a\uff0c\u5e94\u8be5\u4e5f\u662f Impossible \u3002 \u4f46\u662f\u52a0\u4e0a\u540e WA \u4e86\u4e00\u4e2a\u70b9\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff1a 3 - - - 1 2 3 3 2 1 \u5b83\u663e\u7136\u5b58\u5728\u81f3\u5c11\u4e24\u79cd\u72b6\u6001\uff1a \u4f46\u662f\u4e0b\u9762\u8fd9\u4efd AC \u4ee3\u7801\uff0c\u8f93\u51fa\u7684\u662f\u6709\u7ed3\u679c\u7684\u3002 \u66ff\u6362\u6210\u6ce8\u91ca\u91cc\u7684\u5185\u5bb9\u540e\u7684\u90a3\u4efd WA \u7684\u4ee3\u7801\uff0c\u8f93\u51fa\u662f Impossible \u3002","title":"Tutorial"},{"location":"PAT-Top-Level/1006-Tree%20Traversals%20-%20Hard%20Version/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define SZ(x) (int(x.size())) using pII = pair < int , int > ; const int N = 1e2 + 10 , INF = 0x3f3f3f3f ; int n , a [ N ], b [ N ], c [ N ], _a [ N ], _b [ N ], _c [ N ], cnt [ N ]; pII son [ N ]; int rd () { string s ; cin >> s ; if ( s == \"-\" ) return 0 ; int num = 0 ; for ( auto & ch : s ) num = num * 10 + ( ch - '0' ); return num ; } bool dfs ( int al , int ar , int bl , int br , int cl , int cr , int & rt ) { if ( al > ar || bl > br || cl > cr ) return true ; if ( b [ bl ] != 0 && c [ cr ] != 0 && b [ bl ] != c [ cr ]) return false ; for ( int i = al ; i <= ar ; ++ i ) { if ( a [ i ] != 0 && b [ bl ] != 0 && a [ i ] != b [ bl ]) continue ; if ( a [ i ] != 0 && c [ cr ] != 0 && a [ i ] != c [ cr ]) continue ; int now = max ({ a [ i ], b [ bl ], c [ cr ]}); son [ i ] = pII ( 0 , 0 ); int len = i - al ; if ( dfs ( al , i - 1 , bl + 1 , bl + len , cl , cl + len - 1 , son [ i ]. fi ) && dfs ( i + 1 , ar , bl + len + 1 , br , cl + len , cr - 1 , son [ i ]. se )) { _a [ i ] = _b [ bl ] = _c [ cr ] = now ; rt = i ; return true ; } } return false ; } void bfs ( int st ) { vector < int > res ; queue < int > que ; que . push ( st ); while ( ! que . empty ()) { int u = que . front (); que . pop (); res . push_back ( _a [ u ]); if ( son [ u ]. fi ) que . push ( son [ u ]. fi ); if ( son [ u ]. se ) que . push ( son [ u ]. se ); } for ( int i = 0 ; i < SZ ( res ); ++ i ) { cout << res [ i ] << \" \\n \" [ i == SZ ( res ) - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n ; memset ( cnt , 0 , sizeof cnt ); int num = n ; for ( auto & arr : { a , b , c }) { for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ] = rd (); if ( arr [ i ] && ++ cnt [ arr [ i ]] == 1 ) -- num ; } } for ( int i = 1 ; i <= n ; ++ i ) { _a [ i ] = a [ i ]; _b [ i ] = b [ i ]; _c [ i ] = c [ i ]; } int rt = 0 ; if ( num > 1 || ! dfs ( 1 , n , 1 , n , 1 , n , rt )) { cout << \"Impossible \\n \" ; return 0 ; } num = -1 ; memset ( cnt , 0 , sizeof cnt ); for ( int i = 1 ; i <= n ; ++ i ) ++ cnt [ _a [ i ]]; for ( int i = 1 ; i <= n ; ++ i ) if ( cnt [ i ] == 0 ) num = i ; for ( auto & arr : { _a , _b , _c }) { for ( int i = 1 ; i <= n ; ++ i ) if ( arr [ i ] == 0 ) arr [ i ] = num ; for ( int i = 1 ; i <= n ; ++ i ) { cout << arr [ i ] << \" \\n \" [ i == n ]; } } bfs ( rt ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1007-Red-black%20Tree/","text":"1007 Red-black Tree Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB There is a kind of binary tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) All the leaves are NULL nodes and are colored black. (4) Each red node must have 2 black descends (may be NULL). (5) All simple paths from any node x to a descendant leaf have the same number of black nodes. We call a non-NULL node an internal node . From property (5) we can define the black-height of a red-black tree as the number of nodes on the simple path from the root (excluding the root itself) to any NULL leaf (including the NULL leaf). And we can derive that a red-black tree with black height H has at least 2^H-1 2^H-1 internal nodes. Here comes the question: given a positive N N , how many distinct red-black trees are there that consist of exactly N N internal nodes? Input Specification Each input file contains one test case which gives a positive integer N N ( \\le 500 \\le 500 ). Output Specification For each case, print in a line the number of distinct red-black tees with N N internal nodes. Since the answer may be very large, output the remainder of it divided by 1000000007 please. Sample Input 5 Sample Output 8 Tutorial \u9898\u610f\uff1a \u7ea2\u9ed1\u6811\u7684\u5c5e\u6027\u5982\u4e0b\uff1a \u6bcf\u4e2a\u7ed3\u70b9\u4e3a\u9ed1\u8272\u6216\u8005\u7ea2\u8272\u3002 \u6839\u662f\u9ed1\u8272\u3002 \u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u90fd\u662f NULL \uff0c\u5e76\u4e14\u90fd\u662f\u9ed1\u8272\u7ed3\u70b9\u3002 \u6bcf\u4e2a\u7ea2\u8272\u7ed3\u70b9\u90fd\u5fc5\u6709\u4e24\u4e2a\u9ed1\u5b69\u5b50\uff0c\u8fd9\u4e24\u4e2a\u9ed1\u5b69\u5b50\u53ef\u4ee5\u662f NULL \u3002 \u4ece\u4efb\u4e00\u7ed3\u70b9\u51fa\u53d1\uff0c\u5230\u5176\u5b50\u6811\u7684\u4efb\u4e00\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u9ed1\u8272\u7ed3\u70b9\u7684\u6570\u91cf\u5fc5\u987b\u76f8\u540c\u3002 \u5b9a\u4e49\u975e NULL \u7ed3\u70b9\u4e3a internal node \uff0c black-height \u4e3a\u6839\u5230\u4efb\u4e00\u53f6\u5b50\u7ed3\u70b9\u7684\u7b80\u5355\u8def\u5f84\u4e2d\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf(\u4e0d\u5305\u62ec\u6839\u8282\u70b9\uff0c\u4f46\u662f\u5305\u62ec\u53f6\u5b50\u7ed3\u70b9)\u3002 \u7136\u540e\u5c31\u80fd\u5f97\u51fa black-height \u4e3a H H \u7684\u7ea2\u9ed1\u6811\uff0c\u81f3\u5c11\u6709 2^H - 1 2^H - 1 \u4e2a internal node \u3002 \u4e3a\u4ec0\u4e48\uff1f \u56e0\u4e3a\u6bcf\u4e2a\u975e NULL \u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\uff0c\u800c\u4e14\u4e00\u4e2a\u7ea2\u8272\u7ed3\u70b9\u5bf9\u9ad8\u5ea6\u6ca1\u6709\u8d21\u732e\uff0c\u4f46\u662f\u5bf9 internal node \u6709\u8d21\u732e\u3002 \u76f4\u63a5\u8003\u8651\u5168\u9ed1\u7684\u4e00\u68f5\u7ea2\u9ed1\u6811\u5c31\u662f\u9ad8\u5ea6\u4e3a H H \u7684\u6ee1\u4e8c\u53c9\u6811\uff0c\u6b64\u65f6\u7ed3\u70b9\u6570\u91cf\u4e3a 2^H - 1 2^H - 1 \uff0c\u4e5f\u5c31\u662f\u4e0b\u754c\u3002 \u7ed9\u51fa n(1 \\leq n \\leq 500) n(1 \\leq n \\leq 500) \uff0c\u6c42\u6709\u591a\u5c11\u68f5\u7ea2\u9ed1\u6811\uff0c\u4f7f\u5f97\u5176 internal node \u6570\u91cf\u6070\u597d\u4e3a n n \u3002 \u601d\u8def\uff1a \u8003\u8651\uff1a r_{i, j} r_{i, j} \u8868\u793a\u4ee5\u7ea2\u8272\u7ed3\u70b9\u4e3a\u6839\uff0c black-height \u4e3a i i \uff0c internal node \u4e3a j j \u7684\u65b9\u6848\u6570\u3002 b_{i, j} b_{i, j} \u8868\u793a\u4ee5\u7ea2\u8272\u7ed3\u70b9\u4e3a\u6839\uff0c black-height \u4e3a i i \uff0c internal node \u4e3a j j \u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u663e\u7136\u6709\uff1a r_{1, 1} = 1, b_{1, 1} = 1, b_{1, 2} = 2 r_{1, 1} = 1, b_{1, 1} = 1, b_{1, 2} = 2 \uff0c\u8f6c\u79fb\u6709\uff1a \\begin{eqnarray*} r_{x, y} &=& b_{x - 1, i} \\cdot b_{x - 1, y - i - 1} \\\\ b_{x, y} &=& (b_{x - 1, i} + r_{x, i}) \\cdot (b_{x - 1, y - i - 1} + r_{x, y - i - 1}) \\end{eqnarray*} \\begin{eqnarray*} r_{x, y} &=& b_{x - 1, i} \\cdot b_{x - 1, y - i - 1} \\\\ b_{x, y} &=& (b_{x - 1, i} + r_{x, i}) \\cdot (b_{x - 1, y - i - 1} + r_{x, y - i - 1}) \\end{eqnarray*} \u56e0\u4e3a\u5bf9\u4e8e\u7ea2\u8272\u7ed3\u70b9\u6765\u8bf4\uff0c\u5b83\u7684\u4e24\u4e2a\u5b69\u5b50\u5fc5\u5b9a\u662f\u9ed1\u5b69\u5b50\uff0c\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u662f\u4ece b_{x - 1, *} b_{x - 1, *} \u8f6c\u79fb\u8fc7\u6765\uff0c\u56de\u987e\u5b9a\u4e49\uff0c\u6211\u4eec\u77e5\u9053\u4ee5\u9ed1\u7ed3\u70b9\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\uff0c\u5b83\u7684\u8fd9\u4e2a\u9ed1\u8272\u7684\u6839\u8282\u70b9\uff0c\u662f\u4e0d\u4f1a\u5bf9 black-height \u4f5c\u51fa\u8d21\u732e\u7684\uff0c\u4f46\u662f\u5f53\u5b83\u63a5\u5728\u4e00\u4e2a\u7ea2\u8272\u7ed3\u70b9\u4e0b\u4e4b\u540e\uff0c\u8fd9\u4e2a\u539f\u672c\u662f\u6839\u7684\u9ed1\u8272\u7ed3\u70b9\u5c31\u4f1a\u4f5c\u51fa\u8d21\u732e\u3002 \u90a3\u4e48\u5bf9\u9ed1\u8272\u7ed3\u70b9\u6765\u8bf4\uff0c\u81ea\u7136\u5b83\u7684\u4e24\u4e2a\u5b69\u5b50\u662f\u7ea2\u662f\u9ed1\u65e0\u6240\u8c13\uff0c\u53ea\u8981 black-height \u6ee1\u8db3\u5373\u53ef\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 5e2 + 10 ; const int mod = 1e9 + 7 ; int n , r [ N ][ N ], b [ N ][ N ]; void chadd ( int & x , int y ) { x += y ; if ( x >= mod ) x -= mod ; } int gaoR ( int x , int y ); int gaoB ( int x , int y ); // height x internal node y int gaoR ( int x , int y ) { if ( r [ x ][ y ] != -1 ) return r [ x ][ y ]; if ( x < 0 ) return 0 ; r [ x ][ y ] = 0 ; for ( int i = 1 ; i < y - 1 ; ++ i ) { chadd ( r [ x ][ y ], 1l l * gaoB ( x - 1 , i ) * gaoB ( x - 1 , y - i - 1 ) % mod ); } // if (x == 0 && r[x][y]) cout << x << \" \" << y << \" \" << r[x][y] << endl; return r [ x ][ y ]; } int gaoB ( int x , int y ) { if ( b [ x ][ y ] != -1 ) return b [ x ][ y ]; if ( x <= 0 ) return 0 ; b [ x ][ y ] = 0 ; for ( int i = 1 ; i < y - 1 ; ++ i ) { chadd ( b [ x ][ y ], 1l l * ( gaoB ( x - 1 , i ) + gaoR ( x , i )) * ( gaoB ( x - 1 , y - i - 1 ) + gaoR ( x , y - i - 1 )) % mod ); } return b [ x ][ y ]; } int main () { scanf ( \"%d\" , & n ); memset ( r , -1 , sizeof r ); memset ( b , -1 , sizeof b ); b [ 1 ][ 1 ] = 1 ; b [ 1 ][ 2 ] = 2 ; r [ 1 ][ 1 ] = 1 ; int res = 0 ; for ( int i = 10 ; i >= 0 ; -- i ) { chadd ( res , gaoB ( i , n )); } printf ( \"%d \\n \" , res ); return 0 ; }","title":"1007-Red-black Tree"},{"location":"PAT-Top-Level/1007-Red-black%20Tree/#1007-red-black-tree","text":"","title":"1007 Red-black Tree"},{"location":"PAT-Top-Level/1007-Red-black%20Tree/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB There is a kind of binary tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black. (2) The root is black. (3) All the leaves are NULL nodes and are colored black. (4) Each red node must have 2 black descends (may be NULL). (5) All simple paths from any node x to a descendant leaf have the same number of black nodes. We call a non-NULL node an internal node . From property (5) we can define the black-height of a red-black tree as the number of nodes on the simple path from the root (excluding the root itself) to any NULL leaf (including the NULL leaf). And we can derive that a red-black tree with black height H has at least 2^H-1 2^H-1 internal nodes. Here comes the question: given a positive N N , how many distinct red-black trees are there that consist of exactly N N internal nodes? Input Specification Each input file contains one test case which gives a positive integer N N ( \\le 500 \\le 500 ). Output Specification For each case, print in a line the number of distinct red-black tees with N N internal nodes. Since the answer may be very large, output the remainder of it divided by 1000000007 please. Sample Input 5 Sample Output 8","title":"Statement"},{"location":"PAT-Top-Level/1007-Red-black%20Tree/#tutorial","text":"\u9898\u610f\uff1a \u7ea2\u9ed1\u6811\u7684\u5c5e\u6027\u5982\u4e0b\uff1a \u6bcf\u4e2a\u7ed3\u70b9\u4e3a\u9ed1\u8272\u6216\u8005\u7ea2\u8272\u3002 \u6839\u662f\u9ed1\u8272\u3002 \u6240\u6709\u7684\u53f6\u5b50\u7ed3\u70b9\u90fd\u662f NULL \uff0c\u5e76\u4e14\u90fd\u662f\u9ed1\u8272\u7ed3\u70b9\u3002 \u6bcf\u4e2a\u7ea2\u8272\u7ed3\u70b9\u90fd\u5fc5\u6709\u4e24\u4e2a\u9ed1\u5b69\u5b50\uff0c\u8fd9\u4e24\u4e2a\u9ed1\u5b69\u5b50\u53ef\u4ee5\u662f NULL \u3002 \u4ece\u4efb\u4e00\u7ed3\u70b9\u51fa\u53d1\uff0c\u5230\u5176\u5b50\u6811\u7684\u4efb\u4e00\u53f6\u5b50\u7ed3\u70b9\u4e0a\uff0c\u9ed1\u8272\u7ed3\u70b9\u7684\u6570\u91cf\u5fc5\u987b\u76f8\u540c\u3002 \u5b9a\u4e49\u975e NULL \u7ed3\u70b9\u4e3a internal node \uff0c black-height \u4e3a\u6839\u5230\u4efb\u4e00\u53f6\u5b50\u7ed3\u70b9\u7684\u7b80\u5355\u8def\u5f84\u4e2d\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf(\u4e0d\u5305\u62ec\u6839\u8282\u70b9\uff0c\u4f46\u662f\u5305\u62ec\u53f6\u5b50\u7ed3\u70b9)\u3002 \u7136\u540e\u5c31\u80fd\u5f97\u51fa black-height \u4e3a H H \u7684\u7ea2\u9ed1\u6811\uff0c\u81f3\u5c11\u6709 2^H - 1 2^H - 1 \u4e2a internal node \u3002 \u4e3a\u4ec0\u4e48\uff1f \u56e0\u4e3a\u6bcf\u4e2a\u975e NULL \u7ed3\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\uff0c\u800c\u4e14\u4e00\u4e2a\u7ea2\u8272\u7ed3\u70b9\u5bf9\u9ad8\u5ea6\u6ca1\u6709\u8d21\u732e\uff0c\u4f46\u662f\u5bf9 internal node \u6709\u8d21\u732e\u3002 \u76f4\u63a5\u8003\u8651\u5168\u9ed1\u7684\u4e00\u68f5\u7ea2\u9ed1\u6811\u5c31\u662f\u9ad8\u5ea6\u4e3a H H \u7684\u6ee1\u4e8c\u53c9\u6811\uff0c\u6b64\u65f6\u7ed3\u70b9\u6570\u91cf\u4e3a 2^H - 1 2^H - 1 \uff0c\u4e5f\u5c31\u662f\u4e0b\u754c\u3002 \u7ed9\u51fa n(1 \\leq n \\leq 500) n(1 \\leq n \\leq 500) \uff0c\u6c42\u6709\u591a\u5c11\u68f5\u7ea2\u9ed1\u6811\uff0c\u4f7f\u5f97\u5176 internal node \u6570\u91cf\u6070\u597d\u4e3a n n \u3002 \u601d\u8def\uff1a \u8003\u8651\uff1a r_{i, j} r_{i, j} \u8868\u793a\u4ee5\u7ea2\u8272\u7ed3\u70b9\u4e3a\u6839\uff0c black-height \u4e3a i i \uff0c internal node \u4e3a j j \u7684\u65b9\u6848\u6570\u3002 b_{i, j} b_{i, j} \u8868\u793a\u4ee5\u7ea2\u8272\u7ed3\u70b9\u4e3a\u6839\uff0c black-height \u4e3a i i \uff0c internal node \u4e3a j j \u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u663e\u7136\u6709\uff1a r_{1, 1} = 1, b_{1, 1} = 1, b_{1, 2} = 2 r_{1, 1} = 1, b_{1, 1} = 1, b_{1, 2} = 2 \uff0c\u8f6c\u79fb\u6709\uff1a \\begin{eqnarray*} r_{x, y} &=& b_{x - 1, i} \\cdot b_{x - 1, y - i - 1} \\\\ b_{x, y} &=& (b_{x - 1, i} + r_{x, i}) \\cdot (b_{x - 1, y - i - 1} + r_{x, y - i - 1}) \\end{eqnarray*} \\begin{eqnarray*} r_{x, y} &=& b_{x - 1, i} \\cdot b_{x - 1, y - i - 1} \\\\ b_{x, y} &=& (b_{x - 1, i} + r_{x, i}) \\cdot (b_{x - 1, y - i - 1} + r_{x, y - i - 1}) \\end{eqnarray*} \u56e0\u4e3a\u5bf9\u4e8e\u7ea2\u8272\u7ed3\u70b9\u6765\u8bf4\uff0c\u5b83\u7684\u4e24\u4e2a\u5b69\u5b50\u5fc5\u5b9a\u662f\u9ed1\u5b69\u5b50\uff0c\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u662f\u4ece b_{x - 1, *} b_{x - 1, *} \u8f6c\u79fb\u8fc7\u6765\uff0c\u56de\u987e\u5b9a\u4e49\uff0c\u6211\u4eec\u77e5\u9053\u4ee5\u9ed1\u7ed3\u70b9\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\uff0c\u5b83\u7684\u8fd9\u4e2a\u9ed1\u8272\u7684\u6839\u8282\u70b9\uff0c\u662f\u4e0d\u4f1a\u5bf9 black-height \u4f5c\u51fa\u8d21\u732e\u7684\uff0c\u4f46\u662f\u5f53\u5b83\u63a5\u5728\u4e00\u4e2a\u7ea2\u8272\u7ed3\u70b9\u4e0b\u4e4b\u540e\uff0c\u8fd9\u4e2a\u539f\u672c\u662f\u6839\u7684\u9ed1\u8272\u7ed3\u70b9\u5c31\u4f1a\u4f5c\u51fa\u8d21\u732e\u3002 \u90a3\u4e48\u5bf9\u9ed1\u8272\u7ed3\u70b9\u6765\u8bf4\uff0c\u81ea\u7136\u5b83\u7684\u4e24\u4e2a\u5b69\u5b50\u662f\u7ea2\u662f\u9ed1\u65e0\u6240\u8c13\uff0c\u53ea\u8981 black-height \u6ee1\u8db3\u5373\u53ef\u3002","title":"Tutorial"},{"location":"PAT-Top-Level/1007-Red-black%20Tree/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 5e2 + 10 ; const int mod = 1e9 + 7 ; int n , r [ N ][ N ], b [ N ][ N ]; void chadd ( int & x , int y ) { x += y ; if ( x >= mod ) x -= mod ; } int gaoR ( int x , int y ); int gaoB ( int x , int y ); // height x internal node y int gaoR ( int x , int y ) { if ( r [ x ][ y ] != -1 ) return r [ x ][ y ]; if ( x < 0 ) return 0 ; r [ x ][ y ] = 0 ; for ( int i = 1 ; i < y - 1 ; ++ i ) { chadd ( r [ x ][ y ], 1l l * gaoB ( x - 1 , i ) * gaoB ( x - 1 , y - i - 1 ) % mod ); } // if (x == 0 && r[x][y]) cout << x << \" \" << y << \" \" << r[x][y] << endl; return r [ x ][ y ]; } int gaoB ( int x , int y ) { if ( b [ x ][ y ] != -1 ) return b [ x ][ y ]; if ( x <= 0 ) return 0 ; b [ x ][ y ] = 0 ; for ( int i = 1 ; i < y - 1 ; ++ i ) { chadd ( b [ x ][ y ], 1l l * ( gaoB ( x - 1 , i ) + gaoR ( x , i )) * ( gaoB ( x - 1 , y - i - 1 ) + gaoR ( x , y - i - 1 )) % mod ); } return b [ x ][ y ]; } int main () { scanf ( \"%d\" , & n ); memset ( r , -1 , sizeof r ); memset ( b , -1 , sizeof b ); b [ 1 ][ 1 ] = 1 ; b [ 1 ][ 2 ] = 2 ; r [ 1 ][ 1 ] = 1 ; int res = 0 ; for ( int i = 10 ; i >= 0 ; -- i ) { chadd ( res , gaoB ( i , n )); } printf ( \"%d \\n \" , res ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1008-Airline%20Routes/","text":"1008 Airline Routes Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a map of airline routes, you are supposed to check if a round trip can be planned between any pair of cities. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 2\\le N \\le 10^4 2\\le N \\le 10^4 ) and M M ( \\le 6N \\le 6N ), which are the total number of cities (hence the cities are numbered from 1 to N N ) and the number of airline routes, respectively. Then M M lines follow, each gives the information of a route in the format of the source city index first, and then the destination city index, separated by a space. It is guaranteed that the source is never the same as the destination. After the map information, another positive integer K K is given, which is the number of queries. Then K K lines of queries follow, each contains a pair of distinct cities' indices. Output Specification For each query, output in a line Yes if a round trip is possible, or No if not. Sample Input 12 19 3 4 1 3 12 11 5 9 6 2 3 2 10 7 9 1 7 12 2 4 9 5 2 6 12 4 11 10 4 8 8 12 11 8 12 7 1 5 20 11 4 12 7 3 6 2 3 5 3 3 9 4 3 8 3 8 10 10 11 7 8 7 1 9 5 1 9 2 6 3 1 3 12 7 3 6 9 6 8 Sample Output Yes Yes No No No No No No Yes Yes Yes No Yes Yes Yes No No No No No Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , m , q ; // G \u539f\u56fe T \u9006\u56fe struct Graph { struct E { int to , nx , w ; } e [ N << 1 ]; int h [ N ], cntSCC ; void init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) h [ i ] = -1 ; cntSCC = -1 ; } void addedge ( int u , int v , int w = 0 ) { e [ ++ cntSCC ] = { v , h [ u ], w }; h [ u ] = cntSCC ; } } G , T ; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; struct Kosaraju { bool mark [ 2 ][ N ]; int sta [ N ], setNum [ N ], Belong [ N ], cntSCC , dOut [ N ]; // setNum[i] \u7b2ci\u4e2aSCC\u7684\u70b9\u6570 // Belong[i] \u70b9i\u5c5e\u4e8e\u54ea\u4e2aSCC void dfs ( int u ) { mark [ 0 ][ u ] = 1 ; for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to ; if ( ! mark [ 0 ][ v ]) dfs ( v ); } sta [ ++* sta ] = u ; } void dfs1 ( int u ) { mark [ 1 ][ u ] = 1 ; ++ setNum [ cntSCC ]; Belong [ u ] = cntSCC ; for ( int i = T . h [ u ]; ~ i ; i = T . e [ i ]. nx ) { int v = T . e [ i ]. to ; if ( ! mark [ 1 ][ v ]) dfs1 ( v ); } } void work ( int n ) { memset ( mark [ 0 ], 0 , sizeof ( mark [ 0 ][ 0 ]) * ( n + 5 )); memset ( mark [ 1 ], 0 , sizeof ( mark [ 1 ][ 0 ]) * ( n + 5 )); memset ( setNum , 0 , sizeof ( setNum [ 0 ]) * ( n + 5 )); * sta = 0 ; cntSCC = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! mark [ 0 ][ i ]) dfs ( i ); for ( int i = * sta ; i >= 1 ; -- i ) { if ( ! mark [ 1 ][ sta [ i ]]) { ++ cntSCC ; dfs1 ( sta [ i ]); } } } void gao ( int n ) { work ( n ); scanf ( \"%d\" , & q ); for ( int i = 1 , u , v ; i <= q ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); puts ( Belong [ u ] == Belong [ v ] ? \"Yes\" : \"No\" ); } } } kosaraju ; int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { G . init ( n ); T . init ( n ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G . addedge ( u , v ); T . addedge ( v , u ); } kosaraju . gao ( n ); } return 0 ; }","title":"1008-Airline Routes"},{"location":"PAT-Top-Level/1008-Airline%20Routes/#1008-airline-routes","text":"","title":"1008 Airline Routes"},{"location":"PAT-Top-Level/1008-Airline%20Routes/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given a map of airline routes, you are supposed to check if a round trip can be planned between any pair of cities. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 2\\le N \\le 10^4 2\\le N \\le 10^4 ) and M M ( \\le 6N \\le 6N ), which are the total number of cities (hence the cities are numbered from 1 to N N ) and the number of airline routes, respectively. Then M M lines follow, each gives the information of a route in the format of the source city index first, and then the destination city index, separated by a space. It is guaranteed that the source is never the same as the destination. After the map information, another positive integer K K is given, which is the number of queries. Then K K lines of queries follow, each contains a pair of distinct cities' indices. Output Specification For each query, output in a line Yes if a round trip is possible, or No if not. Sample Input 12 19 3 4 1 3 12 11 5 9 6 2 3 2 10 7 9 1 7 12 2 4 9 5 2 6 12 4 11 10 4 8 8 12 11 8 12 7 1 5 20 11 4 12 7 3 6 2 3 5 3 3 9 4 3 8 3 8 10 10 11 7 8 7 1 9 5 1 9 2 6 3 1 3 12 7 3 6 9 6 8 Sample Output Yes Yes No No No No No No Yes Yes Yes No Yes Yes Yes No No No No No","title":"Statement"},{"location":"PAT-Top-Level/1008-Airline%20Routes/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , m , q ; // G \u539f\u56fe T \u9006\u56fe struct Graph { struct E { int to , nx , w ; } e [ N << 1 ]; int h [ N ], cntSCC ; void init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) h [ i ] = -1 ; cntSCC = -1 ; } void addedge ( int u , int v , int w = 0 ) { e [ ++ cntSCC ] = { v , h [ u ], w }; h [ u ] = cntSCC ; } } G , T ; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; struct Kosaraju { bool mark [ 2 ][ N ]; int sta [ N ], setNum [ N ], Belong [ N ], cntSCC , dOut [ N ]; // setNum[i] \u7b2ci\u4e2aSCC\u7684\u70b9\u6570 // Belong[i] \u70b9i\u5c5e\u4e8e\u54ea\u4e2aSCC void dfs ( int u ) { mark [ 0 ][ u ] = 1 ; for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to ; if ( ! mark [ 0 ][ v ]) dfs ( v ); } sta [ ++* sta ] = u ; } void dfs1 ( int u ) { mark [ 1 ][ u ] = 1 ; ++ setNum [ cntSCC ]; Belong [ u ] = cntSCC ; for ( int i = T . h [ u ]; ~ i ; i = T . e [ i ]. nx ) { int v = T . e [ i ]. to ; if ( ! mark [ 1 ][ v ]) dfs1 ( v ); } } void work ( int n ) { memset ( mark [ 0 ], 0 , sizeof ( mark [ 0 ][ 0 ]) * ( n + 5 )); memset ( mark [ 1 ], 0 , sizeof ( mark [ 1 ][ 0 ]) * ( n + 5 )); memset ( setNum , 0 , sizeof ( setNum [ 0 ]) * ( n + 5 )); * sta = 0 ; cntSCC = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! mark [ 0 ][ i ]) dfs ( i ); for ( int i = * sta ; i >= 1 ; -- i ) { if ( ! mark [ 1 ][ sta [ i ]]) { ++ cntSCC ; dfs1 ( sta [ i ]); } } } void gao ( int n ) { work ( n ); scanf ( \"%d\" , & q ); for ( int i = 1 , u , v ; i <= q ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); puts ( Belong [ u ] == Belong [ v ] ? \"Yes\" : \"No\" ); } } } kosaraju ; int main () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { G . init ( n ); T . init ( n ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G . addedge ( u , v ); T . addedge ( v , u ); } kosaraju . gao ( n ); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1009-Triple%20Inversions/","text":"1009 Triple Inversions Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Given a list of N N integers A_1 A_1 , A_2 A_2 , A_3 A_3 ,\u2026 A_N A_N , there's a famous problem to count the number of inversions in it. An inversion is defined as a piar of indices i < j i < j such that A_i > A_j A_i > A_j . Now we have a new challenging problem. You are supposed to count the number of triple inversions in it. As you may guess, a triple inversion is defined as a triple of indices i < j < k i < j < k such that A_i > A_j > A_k A_i > A_j > A_k . For example, in the list { 5, 1, 4, 3, 2 } there are 4 triple inversions, namely (5,4,3), (5,4,2), (5,3,2) and (4,3,2). To simplify the problem, the list A A is given as a permutation of integers from 1 to N N . Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N in [ 3, 10^5 3, 10^5 ]. The second line contains a permutation of integers from 1 to N N and each of the integer is separated by a single space. Output Specification For each case, print in a line the number of triple inversions in the list. Sample Input 22 1 2 3 4 5 16 6 7 8 9 10 19 11 12 14 15 17 18 21 22 20 13 Sample Output 8 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 ; int n , a [ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } ll query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } bit [ 2 ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { bit [ 0 ]. update ( a [ i ], 1 ); bit [ 1 ]. update ( a [ i ], bit [ 0 ]. query ( a [ i ] + 1 , n )); res += bit [ 1 ]. query ( a [ i ] + 1 , n ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"1009-Triple Inversions"},{"location":"PAT-Top-Level/1009-Triple%20Inversions/#1009-triple-inversions","text":"","title":"1009 Triple Inversions"},{"location":"PAT-Top-Level/1009-Triple%20Inversions/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 300 ms \u5185\u5b58\u9650\u5236: 64 MB Given a list of N N integers A_1 A_1 , A_2 A_2 , A_3 A_3 ,\u2026 A_N A_N , there's a famous problem to count the number of inversions in it. An inversion is defined as a piar of indices i < j i < j such that A_i > A_j A_i > A_j . Now we have a new challenging problem. You are supposed to count the number of triple inversions in it. As you may guess, a triple inversion is defined as a triple of indices i < j < k i < j < k such that A_i > A_j > A_k A_i > A_j > A_k . For example, in the list { 5, 1, 4, 3, 2 } there are 4 triple inversions, namely (5,4,3), (5,4,2), (5,3,2) and (4,3,2). To simplify the problem, the list A A is given as a permutation of integers from 1 to N N . Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N in [ 3, 10^5 3, 10^5 ]. The second line contains a permutation of integers from 1 to N N and each of the integer is separated by a single space. Output Specification For each case, print in a line the number of triple inversions in the list. Sample Input 22 1 2 3 4 5 16 6 7 8 9 10 19 11 12 14 15 17 18 21 22 20 13 Sample Output 8","title":"Statement"},{"location":"PAT-Top-Level/1009-Triple%20Inversions/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 ; int n , a [ N ]; struct BIT { ll a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , ll v ) { for (; x < N ; x += x & - x ) a [ x ] += v ; } ll query ( int x ) { ll res = 0 ; for (; x > 0 ; x -= x & - x ) res += a [ x ]; return res ; } ll query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } bit [ 2 ]; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { bit [ 0 ]. update ( a [ i ], 1 ); bit [ 1 ]. update ( a [ i ], bit [ 0 ]. query ( a [ i ] + 1 , n )); res += bit [ 1 ]. query ( a [ i ] + 1 , n ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1010-Lehmer%20Code/","text":"1010 Lehmer Code Statement Metadata \u4f5c\u8005: LIU, Yaoting \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: \"In mathematics and in particular in combinatorics, the Lehmer code is a particular way to encode each possible permutation of a sequence of n n numbers.\" To be more specific, for a given permutation of items { A_1 A_1 , A_2 A_2 , \\cdots \\cdots , A_n A_n }, Lehmer code is a sequence of numbers { L_1 L_1 , L_2 L_2 , \\cdots \\cdots , L_n L_n } such that L_i L_i is the total number of items from A_i A_i to A_n A_n which are less than A_i A_i . For example, given { 24, 35, 12, 1, 56, 23 }, the second Lehmer code L_2 L_2 is 3 since from 35 to 23 there are three items, { 12, 1, 23 }, less than the second item, 35. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N distinct numbers are given in the next line. Output Specification For each test case, output in a line the corresponding Lehmer code. The numbers must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. Sample Input 6 24 35 12 1 56 23 Sample Output 3 3 1 0 1 0 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ], b [ N ]; struct SEG { int t [ N << 2 ]; void init () { memset ( t , 0 , sizeof t ); } void update ( int id , int l , int r , int pos , int v ) { if ( l <= pos && r >= pos ) t [ id ] += v ; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); } int query ( int id , int l , int r , int ql , int qr ) { if ( ql > qr ) return 0 ; if ( l >= ql && r <= qr ) return t [ id ]; int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res += query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) res += query ( id << 1 | 1 , mid + 1 , r , ql , qr ); return res ; } } seg ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); b [ i ] = a [ i ]; } seg . init (); sort ( b + 1 , b + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( b + 1 , b + 1 + n , a [ i ]) - b ; seg . update ( 1 , 1 , 100000 , a [ i ], 1 ); } for ( int i = 1 ; i <= n ; ++ i ) { seg . update ( 1 , 1 , 100000 , a [ i ], -1 ); printf ( \"%d%c\" , seg . query ( 1 , 1 , 100000 , 1 , a [ i ] - 1 ), \" \\n \" [ i == n ]); } } return 0 ; }","title":"1010-Lehmer Code"},{"location":"PAT-Top-Level/1010-Lehmer%20Code/#1010-lehmer-code","text":"","title":"1010 Lehmer Code"},{"location":"PAT-Top-Level/1010-Lehmer%20Code/#statement","text":"Metadata \u4f5c\u8005: LIU, Yaoting \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB According to Wikipedia: \"In mathematics and in particular in combinatorics, the Lehmer code is a particular way to encode each possible permutation of a sequence of n n numbers.\" To be more specific, for a given permutation of items { A_1 A_1 , A_2 A_2 , \\cdots \\cdots , A_n A_n }, Lehmer code is a sequence of numbers { L_1 L_1 , L_2 L_2 , \\cdots \\cdots , L_n L_n } such that L_i L_i is the total number of items from A_i A_i to A_n A_n which are less than A_i A_i . For example, given { 24, 35, 12, 1, 56, 23 }, the second Lehmer code L_2 L_2 is 3 since from 35 to 23 there are three items, { 12, 1, 23 }, less than the second item, 35. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 10^5 \\le 10^5 ). Then N N distinct numbers are given in the next line. Output Specification For each test case, output in a line the corresponding Lehmer code. The numbers must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. Sample Input 6 24 35 12 1 56 23 Sample Output 3 3 1 0 1 0","title":"Statement"},{"location":"PAT-Top-Level/1010-Lehmer%20Code/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , a [ N ], b [ N ]; struct SEG { int t [ N << 2 ]; void init () { memset ( t , 0 , sizeof t ); } void update ( int id , int l , int r , int pos , int v ) { if ( l <= pos && r >= pos ) t [ id ] += v ; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); } int query ( int id , int l , int r , int ql , int qr ) { if ( ql > qr ) return 0 ; if ( l >= ql && r <= qr ) return t [ id ]; int mid = ( l + r ) >> 1 ; int res = 0 ; if ( ql <= mid ) res += query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) res += query ( id << 1 | 1 , mid + 1 , r , ql , qr ); return res ; } } seg ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); b [ i ] = a [ i ]; } seg . init (); sort ( b + 1 , b + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = lower_bound ( b + 1 , b + 1 + n , a [ i ]) - b ; seg . update ( 1 , 1 , 100000 , a [ i ], 1 ); } for ( int i = 1 ; i <= n ; ++ i ) { seg . update ( 1 , 1 , 100000 , a [ i ], -1 ); printf ( \"%d%c\" , seg . query ( 1 , 1 , 100000 , 1 , a [ i ] - 1 ), \" \\n \" [ i == n ]); } } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1011-Cut%20Rectangles/","text":"1011 Cut Rectangles Statement Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB When a rectangle is cut by a straight line, we can easily obtain two polygons as the result. But the reversed problem is harder: given two polygons, your task is to check whether or not they could be obtained by cutting a rectangle. To give you more trouble, the input polygons are possibly moved, rotated (90 degrees, 180 degrees, or 270 degrees counter-clockwise), or even flipped (mirrored). It is assumed that the original rectangle's edges are parallel to the axis. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 20 \\le 20 ), and then N N pairs of polygons are given. Each polygon is described in the format: k k x_1 x_1 y_1 y_1 \\cdots \\cdots x_k x_k y_k y_k where k k ( 2 < k \\le 10 2 < k \\le 10 ) is the number of vertices on the polygon, and ( x_i x_i , y_i y_i ) ( 0 \\le x_i, y_i \\le 10^8 0 \\le x_i, y_i \\le 10^8 ) are the coordinates of the vertices, given in either clockwise or counter-clockwise order. Note: there is no redundant vertex. That is, it is guaranteed that all the vertices are distinct for each polygon, and that no three consecutive vertices are on the same line. Output Specification For each pair of polygons, print in a line either YES or NO as the answer. Sample Input 8 3 0 0 1 0 1 1 3 0 0 1 1 0 1 3 0 0 1 0 1 1 3 0 0 1 1 0 2 4 0 4 1 4 1 0 0 0 4 4 0 4 1 0 1 0 0 3 0 0 1 1 0 1 4 2 3 1 4 1 7 2 7 5 10 10 10 12 12 12 14 11 14 10 3 28 35 29 35 29 37 3 7 9 8 11 8 9 5 87 26 92 26 92 23 90 22 87 22 5 0 0 2 0 1 1 1 2 0 2 4 0 0 1 1 2 1 2 0 4 0 0 0 1 1 1 2 0 4 0 0 0 1 1 1 2 0 Sample Output YES NO YES YES YES YES NO YES","title":"1011-Cut Rectangles"},{"location":"PAT-Top-Level/1011-Cut%20Rectangles/#1011-cut-rectangles","text":"","title":"1011 Cut Rectangles"},{"location":"PAT-Top-Level/1011-Cut%20Rectangles/#statement","text":"Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB When a rectangle is cut by a straight line, we can easily obtain two polygons as the result. But the reversed problem is harder: given two polygons, your task is to check whether or not they could be obtained by cutting a rectangle. To give you more trouble, the input polygons are possibly moved, rotated (90 degrees, 180 degrees, or 270 degrees counter-clockwise), or even flipped (mirrored). It is assumed that the original rectangle's edges are parallel to the axis. Input Specification Each input file contains one test case. For each case, the first line gives a positive integer N N ( \\le 20 \\le 20 ), and then N N pairs of polygons are given. Each polygon is described in the format: k k x_1 x_1 y_1 y_1 \\cdots \\cdots x_k x_k y_k y_k where k k ( 2 < k \\le 10 2 < k \\le 10 ) is the number of vertices on the polygon, and ( x_i x_i , y_i y_i ) ( 0 \\le x_i, y_i \\le 10^8 0 \\le x_i, y_i \\le 10^8 ) are the coordinates of the vertices, given in either clockwise or counter-clockwise order. Note: there is no redundant vertex. That is, it is guaranteed that all the vertices are distinct for each polygon, and that no three consecutive vertices are on the same line. Output Specification For each pair of polygons, print in a line either YES or NO as the answer. Sample Input 8 3 0 0 1 0 1 1 3 0 0 1 1 0 1 3 0 0 1 0 1 1 3 0 0 1 1 0 2 4 0 4 1 4 1 0 0 0 4 4 0 4 1 0 1 0 0 3 0 0 1 1 0 1 4 2 3 1 4 1 7 2 7 5 10 10 10 12 12 12 14 11 14 10 3 28 35 29 35 29 37 3 7 9 8 11 8 9 5 87 26 92 26 92 23 90 22 87 22 5 0 0 2 0 1 1 1 2 0 2 4 0 0 1 1 2 1 2 0 4 0 0 0 1 1 1 2 0 4 0 0 0 1 1 1 2 0 Sample Output YES NO YES YES YES YES NO YES","title":"Statement"},{"location":"PAT-Top-Level/1012-Greedy%20Snake/","text":"1012 Greedy Snake Statement Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Have you ever played the game \"Greedy Snake\"? In the game, we control the movements of the snake to eat the fruits scattered in the game field, while the snake's body gets longer whenever it eats a fruit. The goal of the game is to make the snake eat as many fruits as possible, before its head has no where to go. It would be a real challenge to let you program this game, right now. But hey! Relax! This time you are only asked to program a simplified version of the game. In this simple version, the fruits are all over the place except at some extra obstacle cells. The snake's body will extend all the way along the path while it eats the fruits. You may take any fruit cell as the starting position of the snake. Then you have four directions to choose from: UP, DOWN, LEFT or RIGHT. Once you pick up a direction for the snake, it must keep going until it hits an obstacle or its own body. This procedure repeats until the head of the snake has no where to go \u2013 that is, every adjacent cell of its head is either an obstacle or its own body. Your task is to minimize the number of fruits left. For example, let's define the game field to be a 6 by 6 maze, surrounded by obstacle cells # , with one extra obstacle @ . S is the starting position of the snake. All the fruits are represented by dots. ###### #..S@# #....# #....# #....# ###### Then if you decide to move DOWN, RIGHT, and UP, the results are shown below. ###### #..*@# #..*.# #..*.# #..S.# ###### ###### #..*@# #..*.# #..*.# #..*S# ###### ###### #..*@# #..*S# #..**# #..**# ###### Now the snake is stucked, the game is over, and there are 8 fruits left. However, by carefully changing your moves or choosing another starting position, you can actually control the snake to eat up all the fruits. Try it out! Task 1: minimize the number of fruits left, and count the number of starting positions that can lead to the optimal solution. Task 2: To make things more interesting, you may replace one fruit cell by an obstacle, to obtain a better result, and count the number of ways to add an obstacle that leads to the better result. In case there is no way to improve the result by adding one obstacle, you should point out this situation. Input Specification Each input file contains one test case. For each case, the first line contains two integers N N ( 4 \\le N \\le 15 4 \\le N \\le 15 ), the size of the game field, and K K ( 0 \\le K \\le 2 0 \\le K \\le 2 ), the number of extra obstacles. Then K K lines follow, each gives the coordinates of an obstacle in the format \" x_i x_i y_i y_i \" where 2 \\le x_i, y_i \\le N-1 2 \\le x_i, y_i \\le N-1 . Output Specification For each case, print the results in two lines. In the first line print the minimal number of fruits left, and the number of different optimal starting positions. Then in the second line, either print -1 -1 if there is no way to improve the result, or two integers: the better result and the number of optimal ways to add an obstacle. Sample Input 1 6 1 2 5 Sample Output 1 0 4 -1 Sample Input 2 6 2 2 2 3 3 Sample Output 2 2 1 0 2","title":"1012-Greedy Snake"},{"location":"PAT-Top-Level/1012-Greedy%20Snake/#1012-greedy-snake","text":"","title":"1012 Greedy Snake"},{"location":"PAT-Top-Level/1012-Greedy%20Snake/#statement","text":"Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Have you ever played the game \"Greedy Snake\"? In the game, we control the movements of the snake to eat the fruits scattered in the game field, while the snake's body gets longer whenever it eats a fruit. The goal of the game is to make the snake eat as many fruits as possible, before its head has no where to go. It would be a real challenge to let you program this game, right now. But hey! Relax! This time you are only asked to program a simplified version of the game. In this simple version, the fruits are all over the place except at some extra obstacle cells. The snake's body will extend all the way along the path while it eats the fruits. You may take any fruit cell as the starting position of the snake. Then you have four directions to choose from: UP, DOWN, LEFT or RIGHT. Once you pick up a direction for the snake, it must keep going until it hits an obstacle or its own body. This procedure repeats until the head of the snake has no where to go \u2013 that is, every adjacent cell of its head is either an obstacle or its own body. Your task is to minimize the number of fruits left. For example, let's define the game field to be a 6 by 6 maze, surrounded by obstacle cells # , with one extra obstacle @ . S is the starting position of the snake. All the fruits are represented by dots. ###### #..S@# #....# #....# #....# ###### Then if you decide to move DOWN, RIGHT, and UP, the results are shown below. ###### #..*@# #..*.# #..*.# #..S.# ###### ###### #..*@# #..*.# #..*.# #..*S# ###### ###### #..*@# #..*S# #..**# #..**# ###### Now the snake is stucked, the game is over, and there are 8 fruits left. However, by carefully changing your moves or choosing another starting position, you can actually control the snake to eat up all the fruits. Try it out! Task 1: minimize the number of fruits left, and count the number of starting positions that can lead to the optimal solution. Task 2: To make things more interesting, you may replace one fruit cell by an obstacle, to obtain a better result, and count the number of ways to add an obstacle that leads to the better result. In case there is no way to improve the result by adding one obstacle, you should point out this situation. Input Specification Each input file contains one test case. For each case, the first line contains two integers N N ( 4 \\le N \\le 15 4 \\le N \\le 15 ), the size of the game field, and K K ( 0 \\le K \\le 2 0 \\le K \\le 2 ), the number of extra obstacles. Then K K lines follow, each gives the coordinates of an obstacle in the format \" x_i x_i y_i y_i \" where 2 \\le x_i, y_i \\le N-1 2 \\le x_i, y_i \\le N-1 . Output Specification For each case, print the results in two lines. In the first line print the minimal number of fruits left, and the number of different optimal starting positions. Then in the second line, either print -1 -1 if there is no way to improve the result, or two integers: the better result and the number of optimal ways to add an obstacle. Sample Input 1 6 1 2 5 Sample Output 1 0 4 -1 Sample Input 2 6 2 2 2 3 3 Sample Output 2 2 1 0 2","title":"Statement"},{"location":"PAT-Top-Level/1013-Image%20Segmentation/","text":"1013 Image Segmentation Statement Metadata \u4f5c\u8005: ZHU, Jianke \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Image segmentation is usually formulated as a graph partition problem, where each segment corresponds to a connected component. Moreover, each pixel is the vertex of the graph. Each edge has a weight, which is a non-negative dissimilarity between neighboring pixels. So, the goal of image segmentation is to decompose the image graph into several disconnected components, where the elements in a component are similar and the elements in the different components are dissimilar. The components are defined as follows: A component is made of a set of connected vertices; Any two components have no shared vertices; The dissimilarity D(C1, C2) D(C1, C2) of any two components C1 C1 and C2 C2 is larger than the confidence H H of any of C1 C1 and C2 C2 . The dissimilarity D(C1, C2) D(C1, C2) is defined to be the minimum edge weight of all the edges connecting C1 C1 and C2 C2 , or infinity if no such edge exists; The confidence of a component C C , H(C) H(C) , is defined to be the maximum edge weight of the minimum spanning tree of C C , plus a function f(C) = c/|C| f(C) = c/|C| where c c is a positive constant and |C| |C| is the size of the component C C ; A set of vertices must not be treated as a component if they can be partitioned into two or more components. Your job is to write a program to list all the components. Input Specification Each input file contains one test case. For each case, the first line contains three integers: N_v N_v ( 0 < N_v \\le 1000 0 < N_v \\le 1000 ), the total number of vertices (and hence the vertices are numbered from 0 to N_v -1 N_v -1 ); N_e N_e , the total number of edges; and c c , the constant in the function f(C) f(C) . Then N_e N_e lines follow, each gives an adge in the format: V1 V2 Weight Note: it is guaranteed that each pixel has no more than 8 neighboring pixels. The constant and all the weights are positive and are no more than 1000. Output Specification For each case, list each component in a line. The vertices in a component must be printed in increasing order, separated by one space with no extra space at the beginning or the end of the line. The components must be listed in increasing order of their first vertex. Sample Input 1 10 21 100 0 1 10 0 3 60 0 4 90 1 2 90 1 3 50 1 4 200 1 5 86 2 4 95 2 5 5 3 4 95 3 6 15 3 7 101 4 5 500 4 6 100 4 7 101 4 8 101 5 7 300 5 8 50 6 7 90 7 8 84 7 9 34 Sample Output 1 0 1 3 6 2 5 8 4 7 9 Sample Input 2 7 7 100 0 1 10 1 2 61 2 3 50 3 4 200 4 5 82 5 0 200 3 6 90 Sample Output 2 0 1 2 3 6 4 5 Solution C++ #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 1e3 + 10 ; int n , m , c ; struct E { int u , v , w ; bool operator < ( const E & other ) const { return w < other . w ; } } e [ N * N ]; inline int ceil ( int x , int y ) { if ( x % y == 0 ) return x / y + 1 ; return ( x + y - 1 ) / y ; } struct UFS { int fa [ N ], sze [ N ], Max [ N ], MinID [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; Max [ i ] = 0 ; MinID [ i ] = i ; } } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y , int _Max ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; sze [ y ] += sze [ x ]; Max [ y ] = _Max ; MinID [ y ] = min ( MinID [ y ], MinID [ x ]); } } bool same ( int u , int v ) { return find ( u ) == find ( v ); } int H ( int u ) { u = find ( u ); return Max [ u ] + c / sze [ u ]; // ceil(c, sze[u]); } } ufs ; void gao () { sort ( e + 1 , e + 1 + m ); ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( ufs . same ( u , v )) continue ; if ( w <= ufs . H ( u ) && w <= ufs . H ( v )) { ufs . merge ( u , v , w ); } } vector < vector < int >> vec ( n + 5 ); for ( int i = 1 ; i <= n ; ++ i ) { vec [ ufs . MinID [ ufs . find ( i )]]. push_back ( i ); } for ( auto & it : vec ) if ( ! it . empty ()) { sort ( it . begin (), it . end ()); for ( int i = 0 ; i < SZ ( it ); ++ i ) printf ( \"%d%c\" , it [ i ] - 1 , \" \\n \" [ i == SZ ( it ) - 1 ]); } } int main () { scanf ( \"%d%d%d\" , & n , & m , & c ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. u , & e [ i ]. v , & e [ i ]. w ); ++ e [ i ]. u , ++ e [ i ]. v ; } gao (); return 0 ; }","title":"1013-Image Segmentation"},{"location":"PAT-Top-Level/1013-Image%20Segmentation/#1013-image-segmentation","text":"","title":"1013 Image Segmentation"},{"location":"PAT-Top-Level/1013-Image%20Segmentation/#statement","text":"Metadata \u4f5c\u8005: ZHU, Jianke \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Image segmentation is usually formulated as a graph partition problem, where each segment corresponds to a connected component. Moreover, each pixel is the vertex of the graph. Each edge has a weight, which is a non-negative dissimilarity between neighboring pixels. So, the goal of image segmentation is to decompose the image graph into several disconnected components, where the elements in a component are similar and the elements in the different components are dissimilar. The components are defined as follows: A component is made of a set of connected vertices; Any two components have no shared vertices; The dissimilarity D(C1, C2) D(C1, C2) of any two components C1 C1 and C2 C2 is larger than the confidence H H of any of C1 C1 and C2 C2 . The dissimilarity D(C1, C2) D(C1, C2) is defined to be the minimum edge weight of all the edges connecting C1 C1 and C2 C2 , or infinity if no such edge exists; The confidence of a component C C , H(C) H(C) , is defined to be the maximum edge weight of the minimum spanning tree of C C , plus a function f(C) = c/|C| f(C) = c/|C| where c c is a positive constant and |C| |C| is the size of the component C C ; A set of vertices must not be treated as a component if they can be partitioned into two or more components. Your job is to write a program to list all the components. Input Specification Each input file contains one test case. For each case, the first line contains three integers: N_v N_v ( 0 < N_v \\le 1000 0 < N_v \\le 1000 ), the total number of vertices (and hence the vertices are numbered from 0 to N_v -1 N_v -1 ); N_e N_e , the total number of edges; and c c , the constant in the function f(C) f(C) . Then N_e N_e lines follow, each gives an adge in the format: V1 V2 Weight Note: it is guaranteed that each pixel has no more than 8 neighboring pixels. The constant and all the weights are positive and are no more than 1000. Output Specification For each case, list each component in a line. The vertices in a component must be printed in increasing order, separated by one space with no extra space at the beginning or the end of the line. The components must be listed in increasing order of their first vertex. Sample Input 1 10 21 100 0 1 10 0 3 60 0 4 90 1 2 90 1 3 50 1 4 200 1 5 86 2 4 95 2 5 5 3 4 95 3 6 15 3 7 101 4 5 500 4 6 100 4 7 101 4 8 101 5 7 300 5 8 50 6 7 90 7 8 84 7 9 34 Sample Output 1 0 1 3 6 2 5 8 4 7 9 Sample Input 2 7 7 100 0 1 10 1 2 61 2 3 50 3 4 200 4 5 82 5 0 200 3 6 90 Sample Output 2 0 1 2 3 6 4 5","title":"Statement"},{"location":"PAT-Top-Level/1013-Image%20Segmentation/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 1e3 + 10 ; int n , m , c ; struct E { int u , v , w ; bool operator < ( const E & other ) const { return w < other . w ; } } e [ N * N ]; inline int ceil ( int x , int y ) { if ( x % y == 0 ) return x / y + 1 ; return ( x + y - 1 ) / y ; } struct UFS { int fa [ N ], sze [ N ], Max [ N ], MinID [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; Max [ i ] = 0 ; MinID [ i ] = i ; } } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y , int _Max ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; sze [ y ] += sze [ x ]; Max [ y ] = _Max ; MinID [ y ] = min ( MinID [ y ], MinID [ x ]); } } bool same ( int u , int v ) { return find ( u ) == find ( v ); } int H ( int u ) { u = find ( u ); return Max [ u ] + c / sze [ u ]; // ceil(c, sze[u]); } } ufs ; void gao () { sort ( e + 1 , e + 1 + m ); ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( ufs . same ( u , v )) continue ; if ( w <= ufs . H ( u ) && w <= ufs . H ( v )) { ufs . merge ( u , v , w ); } } vector < vector < int >> vec ( n + 5 ); for ( int i = 1 ; i <= n ; ++ i ) { vec [ ufs . MinID [ ufs . find ( i )]]. push_back ( i ); } for ( auto & it : vec ) if ( ! it . empty ()) { sort ( it . begin (), it . end ()); for ( int i = 0 ; i < SZ ( it ); ++ i ) printf ( \"%d%c\" , it [ i ] - 1 , \" \\n \" [ i == SZ ( it ) - 1 ]); } } int main () { scanf ( \"%d%d%d\" , & n , & m , & c ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. u , & e [ i ]. v , & e [ i ]. w ); ++ e [ i ]. u , ++ e [ i ]. v ; } gao (); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1014-Circles%20of%20Friends/","text":"1014 Circles of Friends Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB A circle of friends is a network of friend relationships. If A is a friend of B, then B is considered a friend of A no matter B admits or not, and they are said to belong to the same circle. Here we assume that friendship is transitive, that is, if A is a friend of B, and B is a friend of C, then A is a friend of C and the three of them all belong to the same circle. On the other hand, A is not so close to C as B is. We define the distance D(X, Y) between two friends X and Y as the minimum number of friends between them. For example, D(A, B) = 0, and D(C, A) = 1. The diameter of a friends circle is the maximum distance between any pair of friends in the circle. Now given some people's relationships, you are supposed to find the number of friends circles and the circle with the largest diameter. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 2 \\le N \\le 1000 2 \\le N \\le 1000 ), which is the total number of people involved, and hence they are numbered from 1 to N N . Then N N lines follow, each in the format: k k p_1 p_1 \u2026 p_k p_k where k k ( 0 \\le k < min(10, N) 0 \\le k < min(10, N) ) is the number of friends and p_1 p_1 to p_k p_k (if k>0 k>0 ) are the friends' indices. The i i -th line corresponds to the i i -th person. All the numbers in a line are separated by spaces. It is guaranteed that no one is given as a friend of oneself. Output Specification For each case, print in a line the number of friends circles, and the largest diameter, separated by exactly one space. Sample Input 17 2 15 12 1 17 2 16 9 1 8 4 10 13 15 14 0 2 11 14 1 4 2 2 3 2 13 11 2 15 7 2 1 14 2 5 15 0 0 1 3 1 2 Sample Output 4 3 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 , INF = 0x3f3f3f3f ; int n , use [ N ]; vector < vector < int >> G ; struct BFS { int dis [ N ]; void gao ( int s ) { memset ( dis , 0x3f , sizeof dis ); dis [ s ] = 0 ; queue < int > que ; que . push ( s ); while ( ! que . empty ()) { int u = que . front (); que . pop (); use [ u ] = 1 ; for ( auto & v : G [ u ]) { if ( dis [ v ] > dis [ u ] + 1 ) { dis [ v ] = dis [ u ] + 1 ; que . push ( v ); } } } } } bfs [ N ]; int main () { scanf ( \"%d\" , & n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int sze ; scanf ( \"%d\" , & sze ); for ( int j = 1 , x ; j <= sze ; ++ j ) { scanf ( \"%d\" , & x ); G [ i ]. push_back ( x ); G [ x ]. push_back ( i ); } } memset ( use , 0 , sizeof use ); int cnt = 0 ; int Max = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! use [ i ]) { ++ cnt ; } bfs [ i ]. gao ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( bfs [ i ]. dis [ j ] != INF ) { Max = max ( Max , bfs [ i ]. dis [ j ]); } } printf ( \"%d %d \\n \" , cnt , Max - 1 ); return 0 ; }","title":"1014-Circles of Friends"},{"location":"PAT-Top-Level/1014-Circles%20of%20Friends/#1014-circles-of-friends","text":"","title":"1014 Circles of Friends"},{"location":"PAT-Top-Level/1014-Circles%20of%20Friends/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB A circle of friends is a network of friend relationships. If A is a friend of B, then B is considered a friend of A no matter B admits or not, and they are said to belong to the same circle. Here we assume that friendship is transitive, that is, if A is a friend of B, and B is a friend of C, then A is a friend of C and the three of them all belong to the same circle. On the other hand, A is not so close to C as B is. We define the distance D(X, Y) between two friends X and Y as the minimum number of friends between them. For example, D(A, B) = 0, and D(C, A) = 1. The diameter of a friends circle is the maximum distance between any pair of friends in the circle. Now given some people's relationships, you are supposed to find the number of friends circles and the circle with the largest diameter. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 2 \\le N \\le 1000 2 \\le N \\le 1000 ), which is the total number of people involved, and hence they are numbered from 1 to N N . Then N N lines follow, each in the format: k k p_1 p_1 \u2026 p_k p_k where k k ( 0 \\le k < min(10, N) 0 \\le k < min(10, N) ) is the number of friends and p_1 p_1 to p_k p_k (if k>0 k>0 ) are the friends' indices. The i i -th line corresponds to the i i -th person. All the numbers in a line are separated by spaces. It is guaranteed that no one is given as a friend of oneself. Output Specification For each case, print in a line the number of friends circles, and the largest diameter, separated by exactly one space. Sample Input 17 2 15 12 1 17 2 16 9 1 8 4 10 13 15 14 0 2 11 14 1 4 2 2 3 2 13 11 2 15 7 2 1 14 2 5 15 0 0 1 3 1 2 Sample Output 4 3","title":"Statement"},{"location":"PAT-Top-Level/1014-Circles%20of%20Friends/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 , INF = 0x3f3f3f3f ; int n , use [ N ]; vector < vector < int >> G ; struct BFS { int dis [ N ]; void gao ( int s ) { memset ( dis , 0x3f , sizeof dis ); dis [ s ] = 0 ; queue < int > que ; que . push ( s ); while ( ! que . empty ()) { int u = que . front (); que . pop (); use [ u ] = 1 ; for ( auto & v : G [ u ]) { if ( dis [ v ] > dis [ u ] + 1 ) { dis [ v ] = dis [ u ] + 1 ; que . push ( v ); } } } } } bfs [ N ]; int main () { scanf ( \"%d\" , & n ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int sze ; scanf ( \"%d\" , & sze ); for ( int j = 1 , x ; j <= sze ; ++ j ) { scanf ( \"%d\" , & x ); G [ i ]. push_back ( x ); G [ x ]. push_back ( i ); } } memset ( use , 0 , sizeof use ); int cnt = 0 ; int Max = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ! use [ i ]) { ++ cnt ; } bfs [ i ]. gao ( i ); for ( int j = 1 ; j <= n ; ++ j ) if ( bfs [ i ]. dis [ j ] != INF ) { Max = max ( Max , bfs [ i ]. dis [ j ]); } } printf ( \"%d %d \\n \" , cnt , Max - 1 ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1015-Letter-moving%20Game/","text":"1015 Letter-moving Game Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Here is a simple intersting letter-moving game. The game starts with 2 strings S and T consist of lower case English letters. S and T contain the same letters but the orders might be different. In other words S can be obtained by shuffling letters in String T. At each step, you can move one arbitrary letter in S either to the beginning or to the end of it. How many steps at least to change S into T? Input Specification Each input file contains one test case. For each case, the first line contains the string S, and the second line contains the string T. They consist of only the lower case English letters and S can be obtained by shuffling T's letters. The length of S is no larger than 1000. Output Specification For each case, print in a line the least number of steps to change S into T in the game. Sample Input iononmrogdg goodmorning Sample Output 8 Sample Solution (0) starts from iononmrogdg (1) Move the last g to the beginning: giononmrogd (2) Move m to the end: giononrogdm (3) Move the first o to the end: ginonrogdmo (4) Move r to the end: ginonogdmor (5) Move the first n to the end: gionogdmorn (6) Move i to the end: gonogdmorni (7) Move the first n to the end: googdmornin (8) Move the second g to the end: goodmorning Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 , ALP = 26 ; char s [ N ], t [ N ]; int n , f [ N ][ ALP ], nx [ ALP ]; int main () { while ( scanf ( \"%s%s\" , s + 1 , t + 1 ) != EOF ) { n = strlen ( s + 1 ); for ( int i = 0 ; i < ALP ; ++ i ) nx [ i ] = n + 1 ; for ( int i = n ; i >= 0 ; -- i ) { int ch = s [ i ] - 'a' ; for ( int j = 0 ; j < ALP ; ++ j ) { f [ i ][ j ] = nx [ j ]; } if ( i ) nx [ ch ] = i ; } int res = 0 ; for ( int i = 1 , j ; i <= n ; ++ i ) { int p = 0 ; for ( j = i ; j <= n ; ++ j ) { int ch = t [ j ] - 'a' ; if ( f [ p ][ ch ] > n ) break ; p = f [ p ][ ch ]; } res = max ( res , j - i ); } printf ( \"%d \\n \" , n - res ); } return 0 ; }","title":"1015-Letter-moving Game"},{"location":"PAT-Top-Level/1015-Letter-moving%20Game/#1015-letter-moving-game","text":"","title":"1015 Letter-moving Game"},{"location":"PAT-Top-Level/1015-Letter-moving%20Game/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Here is a simple intersting letter-moving game. The game starts with 2 strings S and T consist of lower case English letters. S and T contain the same letters but the orders might be different. In other words S can be obtained by shuffling letters in String T. At each step, you can move one arbitrary letter in S either to the beginning or to the end of it. How many steps at least to change S into T? Input Specification Each input file contains one test case. For each case, the first line contains the string S, and the second line contains the string T. They consist of only the lower case English letters and S can be obtained by shuffling T's letters. The length of S is no larger than 1000. Output Specification For each case, print in a line the least number of steps to change S into T in the game. Sample Input iononmrogdg goodmorning Sample Output 8 Sample Solution (0) starts from iononmrogdg (1) Move the last g to the beginning: giononmrogd (2) Move m to the end: giononrogdm (3) Move the first o to the end: ginonrogdmo (4) Move r to the end: ginonogdmor (5) Move the first n to the end: gionogdmorn (6) Move i to the end: gonogdmorni (7) Move the first n to the end: googdmornin (8) Move the second g to the end: goodmorning","title":"Statement"},{"location":"PAT-Top-Level/1015-Letter-moving%20Game/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 , ALP = 26 ; char s [ N ], t [ N ]; int n , f [ N ][ ALP ], nx [ ALP ]; int main () { while ( scanf ( \"%s%s\" , s + 1 , t + 1 ) != EOF ) { n = strlen ( s + 1 ); for ( int i = 0 ; i < ALP ; ++ i ) nx [ i ] = n + 1 ; for ( int i = n ; i >= 0 ; -- i ) { int ch = s [ i ] - 'a' ; for ( int j = 0 ; j < ALP ; ++ j ) { f [ i ][ j ] = nx [ j ]; } if ( i ) nx [ ch ] = i ; } int res = 0 ; for ( int i = 1 , j ; i <= n ; ++ i ) { int p = 0 ; for ( j = i ; j <= n ; ++ j ) { int ch = t [ j ] - 'a' ; if ( f [ p ][ ch ] > n ) break ; p = f [ p ][ ch ]; } res = max ( res , j - i ); } printf ( \"%d \\n \" , n - res ); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1016-Uniqueness%20of%20MST/","text":"1016 Uniqueness of MST Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers: V1 V2 Weight where V1 and V2 are the two ends of the edge (the vertices are numbered from 1 to N), and Weight is the positive weight on that edge. It is guaranteed that the total weight of the graph will not exceed 2^{30} 2^{30} . Output Specification For each test case, first print in a line the total weight of the minimum spanning tree if there exists one, or else print No MST instead. Then if the MST exists, print in the next line Yes if the tree is unique, or No otherwise. There there is no MST, print the number of connected components instead. Sample Input 1 5 7 1 2 6 5 1 1 2 3 4 3 4 3 4 1 7 2 4 2 4 5 5 Sample Output 1 11 Yes Sample Input 2 4 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 2 4 No Sample Input 3 5 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 3 No MST 2 Solution C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second const int N = 500 * 500 + 10 ; int n , m ; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; struct E { int u , v , w , use ; bool operator < ( const E & other ) const { return w < other . w ; } } e [ N ]; void Kruskal () { sort ( e + 1 , e + 1 + m ); int tot = 0 ; ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( ufs . merge ( u , v )) { e [ i ]. use = 1 ; tot += w ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ufs . fa [ i ] == 0 ) { ++ cnt ; } } if ( cnt > 1 ) { printf ( \"No MST \\n %d \\n \" , cnt ); return ; } ufs . init ( n ); int unique = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { int j = i ; for (; j <= m ; ++ j ) { if ( e [ j ]. w > e [ i ]. w ) break ; } -- j ; for ( int k = i ; k <= j ; ++ k ) if ( e [ k ]. use == 0 ) { int u = e [ k ]. u , v = e [ k ]. v ; if ( ! ufs . same ( u , v )) { unique = 0 ; break ; } } if ( ! unique ) break ; for ( int k = i ; k <= j ; ++ k ) if ( e [ k ]. use ) { int u = e [ k ]. u , v = e [ k ]. v ; ufs . merge ( u , v ); } i = j ; } printf ( \"%d \\n %s \\n \" , tot , unique ? \"Yes\" : \"No\" ); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. u , & e [ i ]. v , & e [ i ]. w ); e [ i ]. use = 0 ; } Kruskal (); return 0 ; }","title":"1016-Uniqueness of MST"},{"location":"PAT-Top-Level/1016-Uniqueness%20of%20MST/#1016-uniqueness-of-mst","text":"","title":"1016 Uniqueness of MST"},{"location":"PAT-Top-Level/1016-Uniqueness%20of%20MST/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given any weighted undirected graph, there exists at least one minimum spanning tree (MST) if the graph is connected. Sometimes the MST may not be unique though. Here you are supposed to calculate the minimum total weight of the MST, and also tell if it is unique or not. Input Specification Each input file contains one test case. Each case starts with a line containing 2 numbers N ( \\le \\le 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by 3 integers: V1 V2 Weight where V1 and V2 are the two ends of the edge (the vertices are numbered from 1 to N), and Weight is the positive weight on that edge. It is guaranteed that the total weight of the graph will not exceed 2^{30} 2^{30} . Output Specification For each test case, first print in a line the total weight of the minimum spanning tree if there exists one, or else print No MST instead. Then if the MST exists, print in the next line Yes if the tree is unique, or No otherwise. There there is no MST, print the number of connected components instead. Sample Input 1 5 7 1 2 6 5 1 1 2 3 4 3 4 3 4 1 7 2 4 2 4 5 5 Sample Output 1 11 Yes Sample Input 2 4 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 2 4 No Sample Input 3 5 5 1 2 1 2 3 1 3 4 2 4 1 2 3 1 3 Sample Output 3 No MST 2","title":"Statement"},{"location":"PAT-Top-Level/1016-Uniqueness%20of%20MST/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second const int N = 500 * 500 + 10 ; int n , m ; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; struct E { int u , v , w , use ; bool operator < ( const E & other ) const { return w < other . w ; } } e [ N ]; void Kruskal () { sort ( e + 1 , e + 1 + m ); int tot = 0 ; ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = e [ i ]. u , v = e [ i ]. v , w = e [ i ]. w ; if ( ufs . merge ( u , v )) { e [ i ]. use = 1 ; tot += w ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( ufs . fa [ i ] == 0 ) { ++ cnt ; } } if ( cnt > 1 ) { printf ( \"No MST \\n %d \\n \" , cnt ); return ; } ufs . init ( n ); int unique = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { int j = i ; for (; j <= m ; ++ j ) { if ( e [ j ]. w > e [ i ]. w ) break ; } -- j ; for ( int k = i ; k <= j ; ++ k ) if ( e [ k ]. use == 0 ) { int u = e [ k ]. u , v = e [ k ]. v ; if ( ! ufs . same ( u , v )) { unique = 0 ; break ; } } if ( ! unique ) break ; for ( int k = i ; k <= j ; ++ k ) if ( e [ k ]. use ) { int u = e [ k ]. u , v = e [ k ]. v ; ufs . merge ( u , v ); } i = j ; } printf ( \"%d \\n %s \\n \" , tot , unique ? \"Yes\" : \"No\" ); } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & e [ i ]. u , & e [ i ]. v , & e [ i ]. w ); e [ i ]. use = 0 ; } Kruskal (); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1017-The%20Best%20Peak%20Shape/","text":"1017 The Best Peak Shape Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB In many research areas, one important target of analyzing data is to find the best \"peak shape\" out of a huge amount of raw data full of noises. A \"peak shape\" of length L L is an ordered sequence of L L numbers { D_1 D_1 , \\cdots \\cdots , D_L D_L } satisfying that there exists an index i i ( 1 < i < L 1 < i < L ) such that D_1 < \\cdots < D_{i-1} < D_i > D_{i+1} > \\cdots > D_L D_1 < \\cdots < D_{i-1} < D_i > D_{i+1} > \\cdots > D_L . Now given N N input numbers ordered by their indices, you may remove some of them to keep the rest of the numbers in a peak shape. The best peak shape is the longest sub-sequence that forms a peak shape. If there is a tie, then the most symmetric (meaning that the difference of the lengths of the increasing and the decreasing sub-sequences is minimized) one will be chosen. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 3 \\le N \\le 10^4 3 \\le N \\le 10^4 ). Then N N integers are given in the next line, separated by spaces. All the integers are in [-10000, 10000] [-10000, 10000] . Output Specification For each case, print in a line the length of the best peak shape, the index (starts from 1) and the value of the peak number. If the solution does not exist, simply print \"No peak shape\" in a line. The judge's input guarantees the uniqueness of the output. Sample Input1 20 1 3 0 8 5 -2 29 20 20 4 10 4 7 25 18 6 17 16 2 -1 Sample Output1 10 14 25 Sample Input2 5 -1 3 8 10 20 Sample Output2 No peak shape Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ], f [ N ], g [ N ]; struct Hash { vector < int > a ; int & operator []( int x ) { return a [ x - 1 ]; } int size () { return a . size (); } void init () { a . clear (); } void add ( int x ) { a . push_back ( x ); } void gao () { sort ( a . begin (), a . end ()); a . erase ( unique ( a . begin (), a . end ()), a . end ()); } int get ( int x ) { return lower_bound ( a . begin (), a . end (), x ) - a . begin () + 1 ; } } hs ; struct BIT { int a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , int v ) { for (; x < N ; x += x & - x ) a [ x ] = max ( a [ x ], v ); } int query ( int x ) { if ( x < 0 ) return 0 ; int res = 0 ; for (; x ; x -= x & - x ) res = max ( res , a [ x ]); return res ; } } bit ; void gao ( int * f ) { bit . init (); for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = 1 + bit . query ( a [ i ] - 1 ); bit . update ( a [ i ], f [ i ]); } } int main () { scanf ( \"%d\" , & n ); hs . init (); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), hs . add ( a [ i ]); hs . gao (); for ( int i = 1 ; i <= n ; ++ i ) a [ i ] = hs . get ( a [ i ]); gao ( f ); reverse ( a + 1 , a + 1 + n ); gao ( g ); reverse ( a + 1 , a + 1 + n ); reverse ( g + 1 , g + 1 + n ); int maxLen = -1 , pos = -1 , dif = 0 ; for ( int i = 2 ; i < n ; ++ i ) { if ( f [ i ] > 1 && g [ i ] > 1 ) { if (( f [ i ] + g [ i ] - 1 > maxLen ) || ( f [ i ] + g [ i ] - 1 == maxLen && abs ( f [ i ] - g [ i ]) < dif )) { maxLen = f [ i ] + g [ i ] - 1 ; dif = abs ( f [ i ] - g [ i ]); pos = i ; } } } if ( maxLen == -1 ) puts ( \"No peak shape\" ); else printf ( \"%d %d %d \\n \" , maxLen , pos , hs [ a [ pos ]]); return 0 ; }","title":"1017-The Best Peak Shape"},{"location":"PAT-Top-Level/1017-The%20Best%20Peak%20Shape/#1017-the-best-peak-shape","text":"","title":"1017 The Best Peak Shape"},{"location":"PAT-Top-Level/1017-The%20Best%20Peak%20Shape/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB In many research areas, one important target of analyzing data is to find the best \"peak shape\" out of a huge amount of raw data full of noises. A \"peak shape\" of length L L is an ordered sequence of L L numbers { D_1 D_1 , \\cdots \\cdots , D_L D_L } satisfying that there exists an index i i ( 1 < i < L 1 < i < L ) such that D_1 < \\cdots < D_{i-1} < D_i > D_{i+1} > \\cdots > D_L D_1 < \\cdots < D_{i-1} < D_i > D_{i+1} > \\cdots > D_L . Now given N N input numbers ordered by their indices, you may remove some of them to keep the rest of the numbers in a peak shape. The best peak shape is the longest sub-sequence that forms a peak shape. If there is a tie, then the most symmetric (meaning that the difference of the lengths of the increasing and the decreasing sub-sequences is minimized) one will be chosen. Input Specification Each input file contains one test case. For each case, the first line gives an integer N N ( 3 \\le N \\le 10^4 3 \\le N \\le 10^4 ). Then N N integers are given in the next line, separated by spaces. All the integers are in [-10000, 10000] [-10000, 10000] . Output Specification For each case, print in a line the length of the best peak shape, the index (starts from 1) and the value of the peak number. If the solution does not exist, simply print \"No peak shape\" in a line. The judge's input guarantees the uniqueness of the output. Sample Input1 20 1 3 0 8 5 -2 29 20 20 4 10 4 7 25 18 6 17 16 2 -1 Sample Output1 10 14 25 Sample Input2 5 -1 3 8 10 20 Sample Output2 No peak shape","title":"Statement"},{"location":"PAT-Top-Level/1017-The%20Best%20Peak%20Shape/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ], f [ N ], g [ N ]; struct Hash { vector < int > a ; int & operator []( int x ) { return a [ x - 1 ]; } int size () { return a . size (); } void init () { a . clear (); } void add ( int x ) { a . push_back ( x ); } void gao () { sort ( a . begin (), a . end ()); a . erase ( unique ( a . begin (), a . end ()), a . end ()); } int get ( int x ) { return lower_bound ( a . begin (), a . end (), x ) - a . begin () + 1 ; } } hs ; struct BIT { int a [ N ]; void init () { memset ( a , 0 , sizeof a ); } void update ( int x , int v ) { for (; x < N ; x += x & - x ) a [ x ] = max ( a [ x ], v ); } int query ( int x ) { if ( x < 0 ) return 0 ; int res = 0 ; for (; x ; x -= x & - x ) res = max ( res , a [ x ]); return res ; } } bit ; void gao ( int * f ) { bit . init (); for ( int i = 1 ; i <= n ; ++ i ) { f [ i ] = 1 + bit . query ( a [ i ] - 1 ); bit . update ( a [ i ], f [ i ]); } } int main () { scanf ( \"%d\" , & n ); hs . init (); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), hs . add ( a [ i ]); hs . gao (); for ( int i = 1 ; i <= n ; ++ i ) a [ i ] = hs . get ( a [ i ]); gao ( f ); reverse ( a + 1 , a + 1 + n ); gao ( g ); reverse ( a + 1 , a + 1 + n ); reverse ( g + 1 , g + 1 + n ); int maxLen = -1 , pos = -1 , dif = 0 ; for ( int i = 2 ; i < n ; ++ i ) { if ( f [ i ] > 1 && g [ i ] > 1 ) { if (( f [ i ] + g [ i ] - 1 > maxLen ) || ( f [ i ] + g [ i ] - 1 == maxLen && abs ( f [ i ] - g [ i ]) < dif )) { maxLen = f [ i ] + g [ i ] - 1 ; dif = abs ( f [ i ] - g [ i ]); pos = i ; } } } if ( maxLen == -1 ) puts ( \"No peak shape\" ); else printf ( \"%d %d %d \\n \" , maxLen , pos , hs [ a [ pos ]]); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1018-Subnumbers/","text":"1018 Subnumbers Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a positive integer N N , let us define a subnumber of N N as a consecutive number of digits NOT starting with 0 . For example if N = 1021 N = 1021 , it has 7 subnumbers, namely, 1, 10, 102, 1021, 2, 21 and 1 (again). Here is your task: please calculate the sum of all the subnumbers of N N . For 1021, the sum is 1+10+102+1021+2+21+1 = 1158. Since the result may be very large, output the answer modulo 1000000007 ( 10^9 + 7 10^9 + 7 ) please. Input Specification Each input file contains one test case, which gives the integer N N ( 0 < N < 10^{100000} 0 < N < 10^{100000} ) in a line. Output Specification Print in a line the sum of all N N 's subnumbers (modulo 1000000007). Sample Input 1234567890123456789 Sample Output 332876913 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 , mod = 1e9 + 7 ; char s [ N ]; void chadd ( ll & x , ll y ) { x += y ; while ( x >= mod ) x -= mod ; while ( x < 0 ) x += mod ; } int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { ll res = 0 , pre = 0 , cnt = 0 ; for ( int i = 1 ; s [ i ]; ++ i ) { int num = s [ i ] - '0' ; pre = pre * 10 % mod ; if ( num ) ++ cnt ; chadd ( pre , cnt * num ); chadd ( res , pre ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"1018-Subnumbers"},{"location":"PAT-Top-Level/1018-Subnumbers/#1018-subnumbers","text":"","title":"1018 Subnumbers"},{"location":"PAT-Top-Level/1018-Subnumbers/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a positive integer N N , let us define a subnumber of N N as a consecutive number of digits NOT starting with 0 . For example if N = 1021 N = 1021 , it has 7 subnumbers, namely, 1, 10, 102, 1021, 2, 21 and 1 (again). Here is your task: please calculate the sum of all the subnumbers of N N . For 1021, the sum is 1+10+102+1021+2+21+1 = 1158. Since the result may be very large, output the answer modulo 1000000007 ( 10^9 + 7 10^9 + 7 ) please. Input Specification Each input file contains one test case, which gives the integer N N ( 0 < N < 10^{100000} 0 < N < 10^{100000} ) in a line. Output Specification Print in a line the sum of all N N 's subnumbers (modulo 1000000007). Sample Input 1234567890123456789 Sample Output 332876913","title":"Statement"},{"location":"PAT-Top-Level/1018-Subnumbers/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 , mod = 1e9 + 7 ; char s [ N ]; void chadd ( ll & x , ll y ) { x += y ; while ( x >= mod ) x -= mod ; while ( x < 0 ) x += mod ; } int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { ll res = 0 , pre = 0 , cnt = 0 ; for ( int i = 1 ; s [ i ]; ++ i ) { int num = s [ i ] - '0' ; pre = pre * 10 % mod ; if ( num ) ++ cnt ; chadd ( pre , cnt * num ); chadd ( res , pre ); } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1019-Separate%20the%20Animals/","text":"1019 Separate the Animals Statement Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1500 ms \u5185\u5b58\u9650\u5236: 64 MB There are some animals in a zoo which can be described as a grid with N rows and M columns. Your task is to place some obstacles so that no pairs of animals can reach each other. Two animals can reach each other if and only if their cells are 4-connected . For example, in Figure 1, the central blue cell can be reached by the four red cells, and cannot be reached by the other four white cells. Figure 1 What is more, you must put obstacles in exactly K cells, which are 4-connected and form exactly H holes. Here a hole is defined as a 4-connected part with finitely many open cells while the zoo is placed in an infinite open grid. For example, there are 2 holes (the green and the yellow areas) in Figure 2. Figure 2 For the following grid with two animals: Figure 3 If K = 8 and H = 1, one way to separate them is the following: Figure 4 Figure 5 is illegal because it contains no hole. Figure 5 Figure 6 is also illegal because the obstacles are not 4-connected. Figure 6 Given some animals, you are supposed to count the number of different solutions. Input Specification Each input file contains one test case. For each case, the first line gives four integers: N, M, K, H (2 \\le \\le N, M \\le \\le 6; 1 \\le \\le K \\le \\le 12; 0 \\le \\le H \\le \\le 2). All the numbers are separated by spaces. Then N lines follow, each contains M characters, which are either . or O , representing an open cell or an animal, respectively. There will be at least 2 animals. Output Specification For each case, print a single line containing a single integer: the number of solutions. Sample Input 3 5 8 1 ...O. .O... ..... Sample Output 8 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n , m , K , h ; const int N = 15 ; char g [ N ][ N ]; int a [ N ][ N ], vis [ N * N ]; inline int id ( int x , int y ) { return ( x - 1 ) * m + y ; } unordered_map < ll , int > mp ; int fa [ N * N ], sze [ N * N ]; int find ( int x ) { return fa [ x ] == -1 ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; sze [ y ] += sze [ x ]; } } int Move [][ 2 ] = { -1 , 0 , 0 , -1 , 1 , 0 , 0 , 1 , }; inline bool valid ( int x , int y ) { if ( x < 1 || x > n || y < 1 || y > m ) return 0 ; return 1 ; } inline bool ok ( ll sta ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { int ID = id ( i , j ); fa [ ID ] = -1 ; sze [ ID ] = ( g [ i ][ j ] != '.' ); a [ i ][ j ] = (( sta >> ID ) & 1 ); vis [ ID ] = a [ i ][ j ] ^ 1 ; } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( a [ i ][ j ] == 0 ) { for ( int k = 0 ; k < 2 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( valid ( ni , nj ) && a [ ni ][ nj ] == 0 ) { merge ( id ( i , j ), id ( ni , nj )); if ( sze [ find ( id ( i , j ))] > 1 ) return false ; } } } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( g [ i ][ j ] == 'o' ) { if ( sze [ find ( id ( i , j ))] > 1 ) { return false ; } } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( vis [ id ( i , j )] == 1 ) { for ( int k = 0 ; k < 4 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( ! valid ( ni , nj )) { vis [ find ( id ( i , j ))] = 0 ; vis [ id ( i , j )] = 0 ; break ; } } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( fa [ id ( i , j )] == -1 ) { cnt += vis [ id ( i , j )]; } } } return cnt == h ; } void bfs () { int res = 0 ; queue < ll > que ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( g [ i ][ j ] == '.' ) { ll x = 1l l << id ( i , j ); // dbg(i, j, x); que . push ( x ); mp [ x ] = 1 ; } } } while ( ! que . empty ()) { ll sta = que . front (); que . pop (); if ( __builtin_popcountll ( sta ) == K ) { // if (ok(sta)) dbg(sta); // for (int i = 1; i <= n; ++i) // printf(\"%s\\n\", g[i] + 1); res += ok ( sta ); continue ; } if ( __builtin_popcountll ( sta ) > K ) continue ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { int ID = id ( i , j ); if ( g [ i ][ j ] == '.' && (( sta >> ID ) & 1 ) == 0 ) { for ( int k = 0 ; k < 4 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( valid ( ni , nj ) && (( sta >> id ( ni , nj )) & 1 ) == 1 ) { ll nx = sta ^ ( 1l l << ID ); if ( mp . count ( nx ) == 0 ) { que . push ( nx ); mp [ nx ] = 1 ; } break ; } } } } } } printf ( \"%d \\n \" , res ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & K , & h ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , g [ i ] + 1 ); bfs (); return 0 ; }","title":"1019-Separate the Animals"},{"location":"PAT-Top-Level/1019-Separate%20the%20Animals/#1019-separate-the-animals","text":"","title":"1019 Separate the Animals"},{"location":"PAT-Top-Level/1019-Separate%20the%20Animals/#statement","text":"Metadata \u4f5c\u8005: LIU, Rujia \u5355\u4f4d: \u5317\u4eac\u5c14\u5b9c\u5c45\u79d1\u6280\u6709\u9650\u8d23\u4efb\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1500 ms \u5185\u5b58\u9650\u5236: 64 MB There are some animals in a zoo which can be described as a grid with N rows and M columns. Your task is to place some obstacles so that no pairs of animals can reach each other. Two animals can reach each other if and only if their cells are 4-connected . For example, in Figure 1, the central blue cell can be reached by the four red cells, and cannot be reached by the other four white cells. Figure 1 What is more, you must put obstacles in exactly K cells, which are 4-connected and form exactly H holes. Here a hole is defined as a 4-connected part with finitely many open cells while the zoo is placed in an infinite open grid. For example, there are 2 holes (the green and the yellow areas) in Figure 2. Figure 2 For the following grid with two animals: Figure 3 If K = 8 and H = 1, one way to separate them is the following: Figure 4 Figure 5 is illegal because it contains no hole. Figure 5 Figure 6 is also illegal because the obstacles are not 4-connected. Figure 6 Given some animals, you are supposed to count the number of different solutions. Input Specification Each input file contains one test case. For each case, the first line gives four integers: N, M, K, H (2 \\le \\le N, M \\le \\le 6; 1 \\le \\le K \\le \\le 12; 0 \\le \\le H \\le \\le 2). All the numbers are separated by spaces. Then N lines follow, each contains M characters, which are either . or O , representing an open cell or an animal, respectively. There will be at least 2 animals. Output Specification For each case, print a single line containing a single integer: the number of solutions. Sample Input 3 5 8 1 ...O. .O... ..... Sample Output 8","title":"Statement"},{"location":"PAT-Top-Level/1019-Separate%20the%20Animals/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n , m , K , h ; const int N = 15 ; char g [ N ][ N ]; int a [ N ][ N ], vis [ N * N ]; inline int id ( int x , int y ) { return ( x - 1 ) * m + y ; } unordered_map < ll , int > mp ; int fa [ N * N ], sze [ N * N ]; int find ( int x ) { return fa [ x ] == -1 ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; sze [ y ] += sze [ x ]; } } int Move [][ 2 ] = { -1 , 0 , 0 , -1 , 1 , 0 , 0 , 1 , }; inline bool valid ( int x , int y ) { if ( x < 1 || x > n || y < 1 || y > m ) return 0 ; return 1 ; } inline bool ok ( ll sta ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { int ID = id ( i , j ); fa [ ID ] = -1 ; sze [ ID ] = ( g [ i ][ j ] != '.' ); a [ i ][ j ] = (( sta >> ID ) & 1 ); vis [ ID ] = a [ i ][ j ] ^ 1 ; } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( a [ i ][ j ] == 0 ) { for ( int k = 0 ; k < 2 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( valid ( ni , nj ) && a [ ni ][ nj ] == 0 ) { merge ( id ( i , j ), id ( ni , nj )); if ( sze [ find ( id ( i , j ))] > 1 ) return false ; } } } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( g [ i ][ j ] == 'o' ) { if ( sze [ find ( id ( i , j ))] > 1 ) { return false ; } } } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( vis [ id ( i , j )] == 1 ) { for ( int k = 0 ; k < 4 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( ! valid ( ni , nj )) { vis [ find ( id ( i , j ))] = 0 ; vis [ id ( i , j )] = 0 ; break ; } } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( fa [ id ( i , j )] == -1 ) { cnt += vis [ id ( i , j )]; } } } return cnt == h ; } void bfs () { int res = 0 ; queue < ll > que ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( g [ i ][ j ] == '.' ) { ll x = 1l l << id ( i , j ); // dbg(i, j, x); que . push ( x ); mp [ x ] = 1 ; } } } while ( ! que . empty ()) { ll sta = que . front (); que . pop (); if ( __builtin_popcountll ( sta ) == K ) { // if (ok(sta)) dbg(sta); // for (int i = 1; i <= n; ++i) // printf(\"%s\\n\", g[i] + 1); res += ok ( sta ); continue ; } if ( __builtin_popcountll ( sta ) > K ) continue ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { int ID = id ( i , j ); if ( g [ i ][ j ] == '.' && (( sta >> ID ) & 1 ) == 0 ) { for ( int k = 0 ; k < 4 ; ++ k ) { int ni = i + Move [ k ][ 0 ]; int nj = j + Move [ k ][ 1 ]; if ( valid ( ni , nj ) && (( sta >> id ( ni , nj )) & 1 ) == 1 ) { ll nx = sta ^ ( 1l l << ID ); if ( mp . count ( nx ) == 0 ) { que . push ( nx ); mp [ nx ] = 1 ; } break ; } } } } } } printf ( \"%d \\n \" , res ); } int main () { scanf ( \"%d%d%d%d\" , & n , & m , & K , & h ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , g [ i ] + 1 ); bfs (); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1020-Delete%20At%20Most%20Two%20Characters/","text":"1020 Delete At Most Two Characters Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string which contains only lower case English letters, how many different strings you can get after deleting AT MOST TWO characters in it? Input Specification Each input file contains one test case, which gives the string whose length is in [3, 10^6] [3, 10^6] . Output Specification Print in a line the number of different strings you can get after deleting at most 2 characters. Sample Input ababcc Sample Output 15 Hint Deleting 0 character gets ababcc . Deleting 1 character gets babcc , aabcc , abbcc , abacc and ababc . Deleting 2 character gets abcc , bbcc , bacc , babc , aacc , aabc , abbc , abac and abab . Solution C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 1000010 int n ; char s [ N ]; int pos [ 220 ]; ll f [ N ][ 4 ]; int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { memset ( pos , -1 , sizeof pos ); n = strlen ( s + 1 ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int d = pos [ s [ i ]]; pos [ s [ i ]] = i ; f [ i ][ 0 ] = f [ i ][ 1 ] = 1 ; for ( int j = 1 ; j < 4 ; ++ j ) { f [ i ][ j ] += f [ i - 1 ][ j ]; f [ i ][ j + 1 ] = f [ i - 1 ][ j ]; if ( d != -1 && j - i + d >= 0 ) f [ i ][ j ] -= f [ d - 1 ][ j - i + d ]; } } printf ( \"%lld \\n \" , f [ n ][ 0 ] + f [ n ][ 1 ] + f [ n ][ 2 ]); } return 0 ; }","title":"1020-Delete At Most Two Characters"},{"location":"PAT-Top-Level/1020-Delete%20At%20Most%20Two%20Characters/#1020-delete-at-most-two-characters","text":"","title":"1020 Delete At Most Two Characters"},{"location":"PAT-Top-Level/1020-Delete%20At%20Most%20Two%20Characters/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 200 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string which contains only lower case English letters, how many different strings you can get after deleting AT MOST TWO characters in it? Input Specification Each input file contains one test case, which gives the string whose length is in [3, 10^6] [3, 10^6] . Output Specification Print in a line the number of different strings you can get after deleting at most 2 characters. Sample Input ababcc Sample Output 15 Hint Deleting 0 character gets ababcc . Deleting 1 character gets babcc , aabcc , abbcc , abacc and ababc . Deleting 2 character gets abcc , bbcc , bacc , babc , aacc , aabc , abbc , abac and abab .","title":"Statement"},{"location":"PAT-Top-Level/1020-Delete%20At%20Most%20Two%20Characters/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 1000010 int n ; char s [ N ]; int pos [ 220 ]; ll f [ N ][ 4 ]; int main () { while ( scanf ( \"%s\" , s + 1 ) != EOF ) { memset ( pos , -1 , sizeof pos ); n = strlen ( s + 1 ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int d = pos [ s [ i ]]; pos [ s [ i ]] = i ; f [ i ][ 0 ] = f [ i ][ 1 ] = 1 ; for ( int j = 1 ; j < 4 ; ++ j ) { f [ i ][ j ] += f [ i - 1 ][ j ]; f [ i ][ j + 1 ] = f [ i - 1 ][ j ]; if ( d != -1 && j - i + d >= 0 ) f [ i ][ j ] -= f [ d - 1 ][ j - i + d ]; } } printf ( \"%lld \\n \" , f [ n ][ 0 ] + f [ n ][ 1 ] + f [ n ][ 2 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1021-Safe%20Fruit/","text":"1021 Safe Fruit Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 4000 ms \u5185\u5b58\u9650\u5236: 64 MB There are a lot of tips telling us that some fruits must not be eaten with some other fruits, or we might get ourselves in serious trouble. For example, bananas can not be eaten with cantaloupe (\u54c8\u5bc6\u74dc), otherwise it will lead to kidney deficiency (\u80be\u865a). Now you are given a long list of such tips, and a big basket of fruits. You are supposed to pick up those fruits so that it is safe to eat any of them. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: N, the number of tips, and M, the number of fruits in the basket. both numbers are no more than 100. Then two blocks follow. The first block contains N pairs of fruits which must not be eaten together, each pair occupies a line and there is no duplicated tips; and the second one contains M fruits together with their prices, again each pair in a line. To make it simple, each fruit is represented by a 3-digit ID number. A price is a positive integer which is no more than 1000. All the numbers in a line are separated by spaces. Output Specification For each case, first print in a line the maximum number of safe fruits. Then in the next line list all the safe fruits, in increasing order of their ID's. The ID's must be separated by exactly one space, and there must be no extra space at the end of the line. Finally in the third line print the total price of the above fruits. Since there may be many different solutions, you are supposed to output the one with a maximum number of safe fruits. In case there is a tie, output the one with the lowest total price. It is guaranteed that such a solution is unique. Sample Input 16 20 001 002 003 004 004 005 005 006 006 007 007 008 008 003 009 010 009 011 009 012 009 013 010 014 011 015 012 016 012 017 013 018 020 99 019 99 018 4 017 2 016 3 015 6 014 5 013 1 012 1 011 1 010 1 009 10 008 1 007 2 006 5 005 3 004 4 003 6 002 1 001 2 Sample Output 12 002 004 006 008 009 014 015 016 017 018 019 020 239 Solution C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 110 ; int n , m , w [ N ]; int best , Val ; int x [ N ], path [ N ]; int num [ N ], val [ N ]; int g [ N ][ N ]; //\u70b9\u7684\u6807\u53f7[0, n - 1] void dfs ( int * adj , int total , int cnt , int cost ) { // total: \u4e0eu\u76f8\u8fde\u7684\u9876\u70b9\u6570\u91cf, cnt\u8868\u793a\u5f53\u524d\u56e2\u7684\u5927\u5c0f int i , j , k ; int t [ N ]; if ( total == 0 ) { if ( best < cnt || ( best == cnt && cost < Val )) { for ( i = 0 ; i < cnt ; i ++ ) path [ i ] = x [ i ]; best = cnt ; Val = cost ; } } for ( i = 0 ; i < total ; i ++ ) { if ( cnt + num [ adj [ i ]] < best || ( cnt + num [ adj [ i ]] == best && cost + val [ adj [ i ]] >= Val )) return ; x [ cnt ] = adj [ i ]; for ( k = 0 , j = i + 1 ; j < total ; j ++ ) { if ( g [ adj [ i ]][ adj [ j ]]) { t [ k ++ ] = adj [ j ]; } } dfs ( t , k , cnt + 1 , cost + w [ adj [ i ]]); } } int MaximumClique () { int i , j , k ; int adj [ N ]; best = 0 ; Val = 1e9 ; for ( i = n - 1 ; i >= 0 ; i -- ) { //\u4fdd\u5b58\u65b9\u6848 x [ 0 ] = i ; for ( k = 0 , j = i + 1 ; j < n ; j ++ ) // \u904d\u5386[i + 1, n]\u95f4\u9876\u70b9\uff0c if ( g [ i ][ j ]) adj [ k ++ ] = j ; dfs ( adj , k , 1 , w [ i ]); // *adj, total, cnt num [ i ] = best ; val [ i ] = Val ; } return best ; } map < int , int > id , fid ; int cntID ; int getID ( int d ) { if ( id . count ( d )) return id [ d ]; id [ d ] = cntID ; fid [ cntID ] = d ; ++ cntID ; return cntID - 1 ; } int main () { scanf ( \"%d%d\" , & m , & n ); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { g [ i ][ j ] = 1 ; } g [ i ][ i ] = 0 ; } cntID = 0 ; vector < pII > edge ; for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); edge . push_back ( pII ( u , v )); } for ( int i = 1 , u , _w ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & u , & _w ); u = getID ( u ); w [ u ] = _w ; } for ( auto & it : edge ) { int u = getID ( it . fi ), v = getID ( it . se ); if ( u >= n || v >= n ) continue ; g [ u ][ v ] = g [ v ][ u ] = 0 ; } MaximumClique (); vector < string > vec ; for ( int i = 0 ; i < best ; ++ i ) { string s = \"\" ; int x = fid [ path [ i ]]; while ( x ) { s . push_back ( x % 10 + '0' ); x /= 10 ; } while ( SZ ( s ) < 3 ) s . push_back ( '0' ); reverse ( s . begin (), s . end ()); vec . push_back ( s ); } sort ( vec . begin (), vec . end ()); cout << best << \" \\n \" ; for ( int i = 0 ; i < best ; ++ i ) cout << vec [ i ] << \" \\n \" [ i == best - 1 ]; cout << Val << endl ; return 0 ; }","title":"1021-Safe Fruit"},{"location":"PAT-Top-Level/1021-Safe%20Fruit/#1021-safe-fruit","text":"","title":"1021 Safe Fruit"},{"location":"PAT-Top-Level/1021-Safe%20Fruit/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 4000 ms \u5185\u5b58\u9650\u5236: 64 MB There are a lot of tips telling us that some fruits must not be eaten with some other fruits, or we might get ourselves in serious trouble. For example, bananas can not be eaten with cantaloupe (\u54c8\u5bc6\u74dc), otherwise it will lead to kidney deficiency (\u80be\u865a). Now you are given a long list of such tips, and a big basket of fruits. You are supposed to pick up those fruits so that it is safe to eat any of them. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers: N, the number of tips, and M, the number of fruits in the basket. both numbers are no more than 100. Then two blocks follow. The first block contains N pairs of fruits which must not be eaten together, each pair occupies a line and there is no duplicated tips; and the second one contains M fruits together with their prices, again each pair in a line. To make it simple, each fruit is represented by a 3-digit ID number. A price is a positive integer which is no more than 1000. All the numbers in a line are separated by spaces. Output Specification For each case, first print in a line the maximum number of safe fruits. Then in the next line list all the safe fruits, in increasing order of their ID's. The ID's must be separated by exactly one space, and there must be no extra space at the end of the line. Finally in the third line print the total price of the above fruits. Since there may be many different solutions, you are supposed to output the one with a maximum number of safe fruits. In case there is a tie, output the one with the lowest total price. It is guaranteed that such a solution is unique. Sample Input 16 20 001 002 003 004 004 005 005 006 006 007 007 008 008 003 009 010 009 011 009 012 009 013 010 014 011 015 012 016 012 017 013 018 020 99 019 99 018 4 017 2 016 3 015 6 014 5 013 1 012 1 011 1 010 1 009 10 008 1 007 2 006 5 005 3 004 4 003 6 002 1 001 2 Sample Output 12 002 004 006 008 009 014 015 016 017 018 019 020 239","title":"Statement"},{"location":"PAT-Top-Level/1021-Safe%20Fruit/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 110 ; int n , m , w [ N ]; int best , Val ; int x [ N ], path [ N ]; int num [ N ], val [ N ]; int g [ N ][ N ]; //\u70b9\u7684\u6807\u53f7[0, n - 1] void dfs ( int * adj , int total , int cnt , int cost ) { // total: \u4e0eu\u76f8\u8fde\u7684\u9876\u70b9\u6570\u91cf, cnt\u8868\u793a\u5f53\u524d\u56e2\u7684\u5927\u5c0f int i , j , k ; int t [ N ]; if ( total == 0 ) { if ( best < cnt || ( best == cnt && cost < Val )) { for ( i = 0 ; i < cnt ; i ++ ) path [ i ] = x [ i ]; best = cnt ; Val = cost ; } } for ( i = 0 ; i < total ; i ++ ) { if ( cnt + num [ adj [ i ]] < best || ( cnt + num [ adj [ i ]] == best && cost + val [ adj [ i ]] >= Val )) return ; x [ cnt ] = adj [ i ]; for ( k = 0 , j = i + 1 ; j < total ; j ++ ) { if ( g [ adj [ i ]][ adj [ j ]]) { t [ k ++ ] = adj [ j ]; } } dfs ( t , k , cnt + 1 , cost + w [ adj [ i ]]); } } int MaximumClique () { int i , j , k ; int adj [ N ]; best = 0 ; Val = 1e9 ; for ( i = n - 1 ; i >= 0 ; i -- ) { //\u4fdd\u5b58\u65b9\u6848 x [ 0 ] = i ; for ( k = 0 , j = i + 1 ; j < n ; j ++ ) // \u904d\u5386[i + 1, n]\u95f4\u9876\u70b9\uff0c if ( g [ i ][ j ]) adj [ k ++ ] = j ; dfs ( adj , k , 1 , w [ i ]); // *adj, total, cnt num [ i ] = best ; val [ i ] = Val ; } return best ; } map < int , int > id , fid ; int cntID ; int getID ( int d ) { if ( id . count ( d )) return id [ d ]; id [ d ] = cntID ; fid [ cntID ] = d ; ++ cntID ; return cntID - 1 ; } int main () { scanf ( \"%d%d\" , & m , & n ); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { g [ i ][ j ] = 1 ; } g [ i ][ i ] = 0 ; } cntID = 0 ; vector < pII > edge ; for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); edge . push_back ( pII ( u , v )); } for ( int i = 1 , u , _w ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & u , & _w ); u = getID ( u ); w [ u ] = _w ; } for ( auto & it : edge ) { int u = getID ( it . fi ), v = getID ( it . se ); if ( u >= n || v >= n ) continue ; g [ u ][ v ] = g [ v ][ u ] = 0 ; } MaximumClique (); vector < string > vec ; for ( int i = 0 ; i < best ; ++ i ) { string s = \"\" ; int x = fid [ path [ i ]]; while ( x ) { s . push_back ( x % 10 + '0' ); x /= 10 ; } while ( SZ ( s ) < 3 ) s . push_back ( '0' ); reverse ( s . begin (), s . end ()); vec . push_back ( s ); } sort ( vec . begin (), vec . end ()); cout << best << \" \\n \" ; for ( int i = 0 ; i < best ; ++ i ) cout << vec [ i ] << \" \\n \" [ i == best - 1 ]; cout << Val << endl ; return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1022-Werewolf/","text":"1022 Werewolf Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB Werewolf\uff08\u72fc\u4eba\u6740\uff09 is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: \"Player #2 is a werewolf.\"; player #2 said: \"Player #3 is a human.\"; player #3 said: \"Player #4 is a werewolf.\"; player #4 said: \"Player #5 is a human.\"; and player #5 said: \"Player #4 is a human.\". Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder vertion of this problem: given that there were N players, with M werewolves among them, at least one but not all the werewolves were lying, and there were exactly L liars. You are supposed to point out the werewolves. Input Specification Each input file contains one test case. For each case, the first line gives three positive integer N (5 \\le \\le N \\le \\le 100), M and L (2 \\le \\le M\uff0cL < < N). Then N lines follow and the i-th line gives the statement of the i-th player (1 \\le \\le i \\le \\le N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification If a solution exists, print in a line in descending order the indices of the M werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the largest solution sequence \u2013 that is, for two sequences A = { a[1], \u2026, a[M] } and B = { b[1], \u2026, b[M] }, if there exists 0 \\le \\le k < < M such that a[i] = b[i] (i \\le \\le k) and a[k+1] > > b[k+1], then A is said to be larger than B. In case there is no solution, simply print No Solution . Sample Input 1 5 2 2 -2 +3 -4 +5 +4 Sample Output 1 4 1 Sample Input 2 6 2 3 -2 +3 -4 +5 +4 -3 Sample Output 2 6 4 Sample Input 3 6 2 5 -2 +3 -4 +5 +4 +6 Sample Output 3 No Solution Solution C++ #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define SZ(x) (int((x).size())) const int N = 110 ; int n , m , l , tot , a [ N ], vis [ N ], f [ 2 ][ N ]; // f[0][i] i human num of liers // f[1][i] i warewolf num of liers vector < int > vec , res ; void dfs ( int cur , int cost , int fcost ) { // dbg(cur, cost, fcost); if ( cost > l ) return ; if ( SZ ( vec ) == m ) { if ( cost + tot - fcost == l ) { int cnt = 0 ; for ( int _ = 0 ; _ < m ; ++ _ ) { int i = vec [ _ ]; if ( a [ i ] < 0 && vis [ - a [ i ]] == 0 ) ++ cnt ; if ( a [ i ] > 0 && vis [ a [ i ]]) ++ cnt ; } if ( cnt == 0 || cnt == m ) return ; for ( int i = 0 ; i < m ; ++ i ) { printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == m - 1 ]); } exit ( 0 ); } return ; } if ( cur <= 0 ) return ; vis [ cur ] = 1 ; vec . push_back ( cur ); dfs ( cur - 1 , cost + f [ 1 ][ cur ], fcost + f [ 0 ][ cur ]); vec . pop_back (); vis [ cur ] = 0 ; dfs ( cur - 1 , cost , fcost ); } int main () { scanf ( \"%d%d%d\" , & n , & m , & l ); memset ( f , 0 , sizeof f ); tot = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( a [ i ] < 0 ) ++ f [ 0 ][ - a [ i ]]; else ++ f [ 1 ][ a [ i ]]; } for ( int i = 1 ; i <= n ; ++ i ) { tot += f [ 0 ][ i ]; } dfs ( n , 0 , 0 ); if ( res . empty ()) puts ( \"No Solution\" ); else { for ( int i = 0 ; i < m ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == m - 1 ]); } return 0 ; }","title":"1022-Werewolf"},{"location":"PAT-Top-Level/1022-Werewolf/#1022-werewolf","text":"","title":"1022 Werewolf"},{"location":"PAT-Top-Level/1022-Werewolf/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 100 ms \u5185\u5b58\u9650\u5236: 64 MB Werewolf\uff08\u72fc\u4eba\u6740\uff09 is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: \"Player #2 is a werewolf.\"; player #2 said: \"Player #3 is a human.\"; player #3 said: \"Player #4 is a werewolf.\"; player #4 said: \"Player #5 is a human.\"; and player #5 said: \"Player #4 is a human.\". Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder vertion of this problem: given that there were N players, with M werewolves among them, at least one but not all the werewolves were lying, and there were exactly L liars. You are supposed to point out the werewolves. Input Specification Each input file contains one test case. For each case, the first line gives three positive integer N (5 \\le \\le N \\le \\le 100), M and L (2 \\le \\le M\uff0cL < < N). Then N lines follow and the i-th line gives the statement of the i-th player (1 \\le \\le i \\le \\le N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output Specification If a solution exists, print in a line in descending order the indices of the M werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the largest solution sequence \u2013 that is, for two sequences A = { a[1], \u2026, a[M] } and B = { b[1], \u2026, b[M] }, if there exists 0 \\le \\le k < < M such that a[i] = b[i] (i \\le \\le k) and a[k+1] > > b[k+1], then A is said to be larger than B. In case there is no solution, simply print No Solution . Sample Input 1 5 2 2 -2 +3 -4 +5 +4 Sample Output 1 4 1 Sample Input 2 6 2 3 -2 +3 -4 +5 +4 -3 Sample Output 2 6 4 Sample Input 3 6 2 5 -2 +3 -4 +5 +4 +6 Sample Output 3 No Solution","title":"Statement"},{"location":"PAT-Top-Level/1022-Werewolf/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define SZ(x) (int((x).size())) const int N = 110 ; int n , m , l , tot , a [ N ], vis [ N ], f [ 2 ][ N ]; // f[0][i] i human num of liers // f[1][i] i warewolf num of liers vector < int > vec , res ; void dfs ( int cur , int cost , int fcost ) { // dbg(cur, cost, fcost); if ( cost > l ) return ; if ( SZ ( vec ) == m ) { if ( cost + tot - fcost == l ) { int cnt = 0 ; for ( int _ = 0 ; _ < m ; ++ _ ) { int i = vec [ _ ]; if ( a [ i ] < 0 && vis [ - a [ i ]] == 0 ) ++ cnt ; if ( a [ i ] > 0 && vis [ a [ i ]]) ++ cnt ; } if ( cnt == 0 || cnt == m ) return ; for ( int i = 0 ; i < m ; ++ i ) { printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == m - 1 ]); } exit ( 0 ); } return ; } if ( cur <= 0 ) return ; vis [ cur ] = 1 ; vec . push_back ( cur ); dfs ( cur - 1 , cost + f [ 1 ][ cur ], fcost + f [ 0 ][ cur ]); vec . pop_back (); vis [ cur ] = 0 ; dfs ( cur - 1 , cost , fcost ); } int main () { scanf ( \"%d%d%d\" , & n , & m , & l ); memset ( f , 0 , sizeof f ); tot = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( a [ i ] < 0 ) ++ f [ 0 ][ - a [ i ]]; else ++ f [ 1 ][ a [ i ]]; } for ( int i = 1 ; i <= n ; ++ i ) { tot += f [ 0 ][ i ]; } dfs ( n , 0 , 0 ); if ( res . empty ()) puts ( \"No Solution\" ); else { for ( int i = 0 ; i < m ; ++ i ) printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == m - 1 ]); } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1023-The%20Best%20Polygon/","text":"1023 The Best Polygon Statement Metadata \u4f5c\u8005: CHEN, Xiang \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1500 ms \u5185\u5b58\u9650\u5236: 64 MB An n n -gon is a polygon with n n sides. For example, a triangle is a 3-gon. Now you are asked to find the best n n -gon in a given convex N N -gon. The vertices of the n n -gon are selected from vertices of the N N -gon. The n n -gon you are supposed to find must have the largest area among all possible n n -gons, which means that it approximates the N N -gon the best. The figure below shows the best 6-gon (the shaded part) in a 10-gon. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 6 \\le N \\le 300 6 \\le N \\le 300 ) which is the total number of vertices of the convex N N -gon, and n n ( 6 \\le n \\le min(10, N) 6 \\le n \\le min(10, N) ) which is the total number of vertices of the approximating convex n n -gon. Then N N lines follow, the i i -th line gives the 2-D coordinates ( x x , y y ) of the i i -th vertex ( i = 0, \\cdots , N-1 i = 0, \\cdots , N-1 ). The x x and y y coordinates in a line are real numbers with their absolute values no more than 1000, and they are separated by a space. Output Specification Print in a line all the vertex indices of the best n n -gon in descending order. All the numbers are separated by a space and there must be no extra space at the beginning or the end of the line. It is guaranteed that the solution is unique. Sample Input 10 6 133.0 1.0 544.0 71.0 558.0 206.0 536.0 338.0 463.0 436.0 330.0 503.0 188.0 499.0 305.0 2.0 55.0 410.0 2.0 140.0 Sample Output 9 8 5 3 1 0 Solution C++ #include <bits/stdc++.h> using namespace std ; using db = double ; #define SZ(x) (int(x.size())) const int N = 610 ; const db eps = 1e-10 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } int n , m ; struct Point { db x , y ; int id ; Point ( db x = 0 , db y = 0 , int id = 0 ) : x ( x ), y ( y ), id ( id ) {} void scan () { scanf ( \"%lf%lf\" , & x , & y ); } void output () { printf ( \"%lf %lf \\n \" , x , y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } } p [ N ]; struct Polygon { vector < Point > p ; Polygon () { p . clear (); } Polygon ( int n ) { p . clear (); p . resize ( n ); } int sze () { return p . size (); } Point & operator []( int x ) { return p [( x + sze ()) % sze ()]; } void add ( Point q ) { p . push_back ( q ); } void scan ( int n = -1 ) { if ( n == -1 ) scanf ( \"%d\" , & n ); ( * this ) = Polygon ( n ); for ( int i = 0 ; i < n ; ++ i ) { p [ i ]. scan (); p [ i ]. id = i ; } } void output () { for ( int i = 0 ; i < SZ ( p ); ++ i ) p [ i ]. output (); } struct cmpNorm { Point p ; cmpNorm ( Point p ) : p ( p ) {} bool operator ()( Point a , Point b ) { int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . dis2 ( p ) - b . dis2 ( p ) < 0 ); } else { return d > 0 ; } } }; void norm () { Point mi = * p . begin (); for ( int i = 1 ; i < sze (); ++ i ) mi = min ( mi , p [ i ]); sort ( p . begin (), p . end (), cmpNorm ( mi )); } db getArea () { if ( p . empty ()) return -1 ; // norm(); db res = 0 ; for ( int i = 0 ; i < sze (); ++ i ) { int j = ( i + 1 ) % sze (); res += ( p [ i ] ^ p [ j ]); } return fabs ( res / 2 ); } }; Polygon f [ N ][ 15 ]; db g [ N ][ 15 ]; int main () { scanf ( \"%d%d\" , & n , & m ); Polygon po ; po . scan ( n ); po . norm (); // for (int i = 0; i < n; ++i) // po[i].output(); Polygon res = Polygon (); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i ; j < i + n ; ++ j ) { for ( int k = 1 ; k <= m ; ++ k ) { f [ j ][ k ] = Polygon (); g [ j ][ k ] = 0 ; } db tmp = po [ j ] ^ po [ i ]; for ( int k = i ; k < j ; ++ k ) { for ( int o = 1 ; o < min ( m , k - i + 2 ); ++ o ) { db ar = g [ k ][ o ] + ( po [ j ] ^ po [ k ]); if ( fabs ( ar + tmp ) > fabs ( g [ j ][ o + 1 ] + tmp )) { g [ j ][ o + 1 ] = ar ; f [ j ][ o + 1 ] = f [ k ][ o ]; } } } for ( int k = 1 ; k <= min ( m , j - i + 1 ); ++ k ) { f [ j ][ k ]. add ( po [ j ]); } if ( j - i + 1 >= m && f [ j ][ m ]. getArea () > res . getArea ()) res = f [ j ][ m ]; } } // cout << res.getArea() << endl; // res.output(); vector < int > vec ; for ( int i = 0 ; i < m ; ++ i ) vec . push_back ( res [ i ]. id ); sort ( vec . begin (), vec . end (), [ & ]( int x , int y ) { return x > y ; }); for ( int i = 0 ; i < m ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == m - 1 ]); return 0 ; }","title":"1023-The Best Polygon"},{"location":"PAT-Top-Level/1023-The%20Best%20Polygon/#1023-the-best-polygon","text":"","title":"1023 The Best Polygon"},{"location":"PAT-Top-Level/1023-The%20Best%20Polygon/#statement","text":"Metadata \u4f5c\u8005: CHEN, Xiang \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1500 ms \u5185\u5b58\u9650\u5236: 64 MB An n n -gon is a polygon with n n sides. For example, a triangle is a 3-gon. Now you are asked to find the best n n -gon in a given convex N N -gon. The vertices of the n n -gon are selected from vertices of the N N -gon. The n n -gon you are supposed to find must have the largest area among all possible n n -gons, which means that it approximates the N N -gon the best. The figure below shows the best 6-gon (the shaded part) in a 10-gon. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N ( 6 \\le N \\le 300 6 \\le N \\le 300 ) which is the total number of vertices of the convex N N -gon, and n n ( 6 \\le n \\le min(10, N) 6 \\le n \\le min(10, N) ) which is the total number of vertices of the approximating convex n n -gon. Then N N lines follow, the i i -th line gives the 2-D coordinates ( x x , y y ) of the i i -th vertex ( i = 0, \\cdots , N-1 i = 0, \\cdots , N-1 ). The x x and y y coordinates in a line are real numbers with their absolute values no more than 1000, and they are separated by a space. Output Specification Print in a line all the vertex indices of the best n n -gon in descending order. All the numbers are separated by a space and there must be no extra space at the beginning or the end of the line. It is guaranteed that the solution is unique. Sample Input 10 6 133.0 1.0 544.0 71.0 558.0 206.0 536.0 338.0 463.0 436.0 330.0 503.0 188.0 499.0 305.0 2.0 55.0 410.0 2.0 140.0 Sample Output 9 8 5 3 1 0","title":"Statement"},{"location":"PAT-Top-Level/1023-The%20Best%20Polygon/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using db = double ; #define SZ(x) (int(x.size())) const int N = 610 ; const db eps = 1e-10 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x < 0 ? -1 : 1 ; } int n , m ; struct Point { db x , y ; int id ; Point ( db x = 0 , db y = 0 , int id = 0 ) : x ( x ), y ( y ), id ( id ) {} void scan () { scanf ( \"%lf%lf\" , & x , & y ); } void output () { printf ( \"%lf %lf \\n \" , x , y ); } db dis2 ( Point b ) { return ( x - b . x ) * ( x - b . x ) + ( y - b . y ) * ( y - b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } bool operator < ( const Point & b ) const { return sgn ( x - b . x ) == 0 ? sgn ( y - b . y ) < 0 : x < b . x ; } } p [ N ]; struct Polygon { vector < Point > p ; Polygon () { p . clear (); } Polygon ( int n ) { p . clear (); p . resize ( n ); } int sze () { return p . size (); } Point & operator []( int x ) { return p [( x + sze ()) % sze ()]; } void add ( Point q ) { p . push_back ( q ); } void scan ( int n = -1 ) { if ( n == -1 ) scanf ( \"%d\" , & n ); ( * this ) = Polygon ( n ); for ( int i = 0 ; i < n ; ++ i ) { p [ i ]. scan (); p [ i ]. id = i ; } } void output () { for ( int i = 0 ; i < SZ ( p ); ++ i ) p [ i ]. output (); } struct cmpNorm { Point p ; cmpNorm ( Point p ) : p ( p ) {} bool operator ()( Point a , Point b ) { int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . dis2 ( p ) - b . dis2 ( p ) < 0 ); } else { return d > 0 ; } } }; void norm () { Point mi = * p . begin (); for ( int i = 1 ; i < sze (); ++ i ) mi = min ( mi , p [ i ]); sort ( p . begin (), p . end (), cmpNorm ( mi )); } db getArea () { if ( p . empty ()) return -1 ; // norm(); db res = 0 ; for ( int i = 0 ; i < sze (); ++ i ) { int j = ( i + 1 ) % sze (); res += ( p [ i ] ^ p [ j ]); } return fabs ( res / 2 ); } }; Polygon f [ N ][ 15 ]; db g [ N ][ 15 ]; int main () { scanf ( \"%d%d\" , & n , & m ); Polygon po ; po . scan ( n ); po . norm (); // for (int i = 0; i < n; ++i) // po[i].output(); Polygon res = Polygon (); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i ; j < i + n ; ++ j ) { for ( int k = 1 ; k <= m ; ++ k ) { f [ j ][ k ] = Polygon (); g [ j ][ k ] = 0 ; } db tmp = po [ j ] ^ po [ i ]; for ( int k = i ; k < j ; ++ k ) { for ( int o = 1 ; o < min ( m , k - i + 2 ); ++ o ) { db ar = g [ k ][ o ] + ( po [ j ] ^ po [ k ]); if ( fabs ( ar + tmp ) > fabs ( g [ j ][ o + 1 ] + tmp )) { g [ j ][ o + 1 ] = ar ; f [ j ][ o + 1 ] = f [ k ][ o ]; } } } for ( int k = 1 ; k <= min ( m , j - i + 1 ); ++ k ) { f [ j ][ k ]. add ( po [ j ]); } if ( j - i + 1 >= m && f [ j ][ m ]. getArea () > res . getArea ()) res = f [ j ][ m ]; } } // cout << res.getArea() << endl; // res.output(); vector < int > vec ; for ( int i = 0 ; i < m ; ++ i ) vec . push_back ( res [ i ]. id ); sort ( vec . begin (), vec . end (), [ & ]( int x , int y ) { return x > y ; }); for ( int i = 0 ; i < m ; ++ i ) printf ( \"%d%c\" , vec [ i ], \" \\n \" [ i == m - 1 ]); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1024-Currency%20Exchange%20Centers/","text":"1024 Currency Exchange Centers Statement Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB There are currently 168 internationally recognized unique national currencies in this world. But let us assume that we have business with other species in the entire universe\u2026 To change one currency to another, we need currency exchange centers, and they charge fees for it. Now given a list of informations of these centers, you are supposed to find a collection of the centers so that we can make change between any two currencies (directly or indirectly) through them. Since such a kind of collection may not be unique, you must find the one with the minimum total fees; and if there are still more than one solution, find the one with the minimum number of centers \u2013 it is guaranteed that such a solution is unique. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of currencies and the size of the list of currency exchange center informations, respectively. Then M M lines follow, each describes a piece of information in the following format: C1 C2 Center Fee where C1 and C2 are the indices (from 0 to N-1 N-1 ) of the two currencies; Center is a string of 3 capital English letters representing the name of a center; and Fee is a positive integer no more than 10^4 10^4 . It is guaranteed that at most one exchange center is given for each pair of different currencies. Output Specification Print in the first line the total number of currency exchange centered being collected, and the total amount of fees they charge, separated by a space. Then in the following lines, print the centers which must be collected in the same format as the input. The centers must be output in alphabetical order of their names, and if there is a tie, in ascending order of their fees. It is guaranteed that such a solution exists and is unique. Sample Input 6 9 4 3 CBC 32 1 5 HSB 43 1 0 HSB 32 0 2 CTB 28 4 2 CBC 19 2 3 CBC 28 0 4 ABC 28 1 2 ABC 32 3 1 CTB 19 Sample Output 3 137 4 2 CBC 19 2 3 CBC 28 3 1 CTB 19 0 2 CTB 28 1 5 HSB 43 Solution C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 1e4 + 10 ; set < string > se ; int n , m ; struct E { string name ; int u , v , w ; bool operator < ( const E & other ) const { if ( w == other . w ) return se . find ( name ) == se . end (); return w > other . w ; } } e [ N ]; struct UFS { int fa [ N ]; void init () { memset ( fa , 0 , sizeof fa ); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) return fa [ x ] = y , true ; return false ; } } ufs ; void out ( pII it , vector < E > & vec ) { cout << it . fi << \" \" << it . se << endl ; for ( auto & it : vec ) { cout << it . u << \" \" << it . v << \" \" << it . name << \" \" << it . w << \" \\n \" ; } } void gao () { vector < E > vec ; ufs . init (); int tot = 0 ; priority_queue < E > pq ; for ( int i = 1 ; i <= m ; ++ i ) pq . push ( e [ i ]); while ( ! pq . empty ()) { E e = pq . top (); pq . pop (); if ( ufs . merge ( e . u , e . v )) { tot += e . w ; vec . push_back ( e ); se . insert ( e . name ); } } sort ( vec . begin (), vec . end (), [ & ]( E x , E y ) { if ( x . name != y . name ) return x . name < y . name ; return x . w < y . w ; }); out ( pII ( SZ ( se ), tot ), vec ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; for ( int i = 1 ; i <= m ; ++ i ) { cin >> e [ i ]. u >> e [ i ]. v >> e [ i ]. name >> e [ i ]. w ; } gao (); return 0 ; }","title":"1024-Currency Exchange Centers"},{"location":"PAT-Top-Level/1024-Currency%20Exchange%20Centers/#1024-currency-exchange-centers","text":"","title":"1024 Currency Exchange Centers"},{"location":"PAT-Top-Level/1024-Currency%20Exchange%20Centers/#statement","text":"Metadata \u4f5c\u8005: CHEN, Yue \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 250 ms \u5185\u5b58\u9650\u5236: 64 MB There are currently 168 internationally recognized unique national currencies in this world. But let us assume that we have business with other species in the entire universe\u2026 To change one currency to another, we need currency exchange centers, and they charge fees for it. Now given a list of informations of these centers, you are supposed to find a collection of the centers so that we can make change between any two currencies (directly or indirectly) through them. Since such a kind of collection may not be unique, you must find the one with the minimum total fees; and if there are still more than one solution, find the one with the minimum number of centers \u2013 it is guaranteed that such a solution is unique. Input Specification Each input file contains one test case. For each case, the first line gives two positive integers N N and M M (both no more than 10^4 10^4 ), being the total numbers of currencies and the size of the list of currency exchange center informations, respectively. Then M M lines follow, each describes a piece of information in the following format: C1 C2 Center Fee where C1 and C2 are the indices (from 0 to N-1 N-1 ) of the two currencies; Center is a string of 3 capital English letters representing the name of a center; and Fee is a positive integer no more than 10^4 10^4 . It is guaranteed that at most one exchange center is given for each pair of different currencies. Output Specification Print in the first line the total number of currency exchange centered being collected, and the total amount of fees they charge, separated by a space. Then in the following lines, print the centers which must be collected in the same format as the input. The centers must be output in alphabetical order of their names, and if there is a tie, in ascending order of their fees. It is guaranteed that such a solution exists and is unique. Sample Input 6 9 4 3 CBC 32 1 5 HSB 43 1 0 HSB 32 0 2 CTB 28 4 2 CBC 19 2 3 CBC 28 0 4 ABC 28 1 2 ABC 32 3 1 CTB 19 Sample Output 3 137 4 2 CBC 19 2 3 CBC 28 3 1 CTB 19 0 2 CTB 28 1 5 HSB 43","title":"Statement"},{"location":"PAT-Top-Level/1024-Currency%20Exchange%20Centers/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 1e4 + 10 ; set < string > se ; int n , m ; struct E { string name ; int u , v , w ; bool operator < ( const E & other ) const { if ( w == other . w ) return se . find ( name ) == se . end (); return w > other . w ; } } e [ N ]; struct UFS { int fa [ N ]; void init () { memset ( fa , 0 , sizeof fa ); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) return fa [ x ] = y , true ; return false ; } } ufs ; void out ( pII it , vector < E > & vec ) { cout << it . fi << \" \" << it . se << endl ; for ( auto & it : vec ) { cout << it . u << \" \" << it . v << \" \" << it . name << \" \" << it . w << \" \\n \" ; } } void gao () { vector < E > vec ; ufs . init (); int tot = 0 ; priority_queue < E > pq ; for ( int i = 1 ; i <= m ; ++ i ) pq . push ( e [ i ]); while ( ! pq . empty ()) { E e = pq . top (); pq . pop (); if ( ufs . merge ( e . u , e . v )) { tot += e . w ; vec . push_back ( e ); se . insert ( e . name ); } } sort ( vec . begin (), vec . end (), [ & ]( E x , E y ) { if ( x . name != y . name ) return x . name < y . name ; return x . w < y . w ; }); out ( pII ( SZ ( se ), tot ), vec ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; for ( int i = 1 ; i <= m ; ++ i ) { cin >> e [ i ]. u >> e [ i ]. v >> e [ i ]. name >> e [ i ]. w ; } gao (); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1025-Keep%20at%20Most%20100%20Characters/","text":"1025 Keep at Most 100 Characters Statement Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string which contains only lower case letters, how many different non-empty strings you can get if you can keep AT MOST 100 characters in the original order? (Note: The string obtained is a \"sub-sequence\" of the original string.) Input Specification Each input file contains one test case, which is only one line containing the string whose length is no larger than 1000. Output Specification Output the number of different non-empty strings if you can only keep at most 100 characters. Since the answer might be super large, you only need to output the answer modulo 1000000007. Sample Input aabac Sample Output 19 Hint The strings are: a , b , c , aa , ab , ac , ba , bc , aab , aaa , aac , aba , abc , bac , aaba , aabc , abac , aaac , and aabac . Tutorial \u601d\u8def\uff1a f_{i, j} f_{i, j} \u8868\u793a\u524d i i \u4e2a\u5b57\u7b26\uff0c\u4fdd\u7559 j j \u4e2a\u5b57\u7b26\u6240\u5f62\u6210\u7684 sub-sequence \u6570\u91cf\u3002 \u8f6c\u79fb\u6709\uff1a f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} \u4f46\u662f\u8fd9\u6837\u4f1a\u6709\u91cd\u590d\uff0c\u6211\u4eec\u8003\u8651\u5f53\u524d\u5b57\u7b26 i i \uff0c\u5b83\u524d\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u662f k k \uff0c\u90a3\u4e48 f_{k - 1, j - 1} f_{k - 1, j - 1} \u7684\u8d21\u732e\u662f\u91cd\u590d\u7684\u3002 \u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u4fdd\u7559\u5f53\u524d\u5b57\u7b26\uff0c\u5e76\u4e14\u5728 [1, k - 1] [1, k - 1] \u7684\u4f4d\u7f6e\u4e2d\u4efb\u53d6 j - 1 j - 1 \u4e2a\u5b57\u7b26\u7684\u8d21\u732e\uff0c\u88ab\u7b97\u4e86\u4e24\u904d\u3002 Solution C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; constexpr int mod = 1e9 + 7 ; constexpr int N = 1e3 + 10 ; inline void chadd ( int & x , int y ) { x += y ; if ( x >= mod ) x -= mod ; } int n , pre [ 330 ]; int f [ N ][ N ]; char s [ N ]; int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); memset ( f , 0 , sizeof f ); memset ( pre , -1 , sizeof pre ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int ch = s [ i ] - 'a' ; for ( int j = 0 ; j < i ; ++ j ) { if ( pre [ ch ] == -1 ) { chadd ( f [ i ][ j + 1 ], ( f [ i - 1 ][ j + 1 ] + f [ i - 1 ][ j ]) % mod ); // if (j == 0) chadd(f[i][j + 1], 1); } else { chadd ( f [ i ][ j + 1 ], ( 1l l * f [ i - 1 ][ j + 1 ] + f [ i - 1 ][ j ] - f [ pre [ ch ] - 1 ][ j ] + mod ) % mod ); } } f [ i ][ 0 ] = 1 ; // if (pre[ch] == -1) chadd(f[i][1], 1); pre [ ch ] = i ; } int res = 0 ; for ( int i = 1 ; i <= 100 ; ++ i ) chadd ( res , f [ n ][ i ]); printf ( \"%d \\n \" , res ); return 0 ; }","title":"1025-Keep at Most 100 Characters"},{"location":"PAT-Top-Level/1025-Keep%20at%20Most%20100%20Characters/#1025-keep-at-most-100-characters","text":"","title":"1025 Keep at Most 100 Characters"},{"location":"PAT-Top-Level/1025-Keep%20at%20Most%20100%20Characters/#statement","text":"Metadata \u4f5c\u8005: CAO, Peng \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Given a string which contains only lower case letters, how many different non-empty strings you can get if you can keep AT MOST 100 characters in the original order? (Note: The string obtained is a \"sub-sequence\" of the original string.) Input Specification Each input file contains one test case, which is only one line containing the string whose length is no larger than 1000. Output Specification Output the number of different non-empty strings if you can only keep at most 100 characters. Since the answer might be super large, you only need to output the answer modulo 1000000007. Sample Input aabac Sample Output 19 Hint The strings are: a , b , c , aa , ab , ac , ba , bc , aab , aaa , aac , aba , abc , bac , aaba , aabc , abac , aaac , and aabac .","title":"Statement"},{"location":"PAT-Top-Level/1025-Keep%20at%20Most%20100%20Characters/#tutorial","text":"\u601d\u8def\uff1a f_{i, j} f_{i, j} \u8868\u793a\u524d i i \u4e2a\u5b57\u7b26\uff0c\u4fdd\u7559 j j \u4e2a\u5b57\u7b26\u6240\u5f62\u6210\u7684 sub-sequence \u6570\u91cf\u3002 \u8f6c\u79fb\u6709\uff1a f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} f_{i, j} = f_{i - 1, j} + f_{i - 1, j - 1} \u4f46\u662f\u8fd9\u6837\u4f1a\u6709\u91cd\u590d\uff0c\u6211\u4eec\u8003\u8651\u5f53\u524d\u5b57\u7b26 i i \uff0c\u5b83\u524d\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u662f k k \uff0c\u90a3\u4e48 f_{k - 1, j - 1} f_{k - 1, j - 1} \u7684\u8d21\u732e\u662f\u91cd\u590d\u7684\u3002 \u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u4fdd\u7559\u5f53\u524d\u5b57\u7b26\uff0c\u5e76\u4e14\u5728 [1, k - 1] [1, k - 1] \u7684\u4f4d\u7f6e\u4e2d\u4efb\u53d6 j - 1 j - 1 \u4e2a\u5b57\u7b26\u7684\u8d21\u732e\uff0c\u88ab\u7b97\u4e86\u4e24\u904d\u3002","title":"Tutorial"},{"location":"PAT-Top-Level/1025-Keep%20at%20Most%20100%20Characters/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; using ll = long long ; constexpr int mod = 1e9 + 7 ; constexpr int N = 1e3 + 10 ; inline void chadd ( int & x , int y ) { x += y ; if ( x >= mod ) x -= mod ; } int n , pre [ 330 ]; int f [ N ][ N ]; char s [ N ]; int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); memset ( f , 0 , sizeof f ); memset ( pre , -1 , sizeof pre ); f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int ch = s [ i ] - 'a' ; for ( int j = 0 ; j < i ; ++ j ) { if ( pre [ ch ] == -1 ) { chadd ( f [ i ][ j + 1 ], ( f [ i - 1 ][ j + 1 ] + f [ i - 1 ][ j ]) % mod ); // if (j == 0) chadd(f[i][j + 1], 1); } else { chadd ( f [ i ][ j + 1 ], ( 1l l * f [ i - 1 ][ j + 1 ] + f [ i - 1 ][ j ] - f [ pre [ ch ] - 1 ][ j ] + mod ) % mod ); } } f [ i ][ 0 ] = 1 ; // if (pre[ch] == -1) chadd(f[i][1], 1); pre [ ch ] = i ; } int res = 0 ; for ( int i = 1 ; i <= 100 ; ++ i ) chadd ( res , f [ n ][ i ]); printf ( \"%d \\n \" , res ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1026-String%20of%20Colorful%20Beads/","text":"1026 String of Colorful Beads Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to buy a string of beads with no repeated colors so she went to a small shop of which the owner had a very long string of beads. However the owner would only like to cut one piece at a time for his customer. With as many as ten thousand beads in the string, Eva needs your help to tell her how to obtain the longest piece of string that contains beads with all different colors. And more, each kind of these beads has a different value. If there are more than one way to get the longest piece, Eva would like to take the most valuable one. It is guaranteed that such a solution is unique. Input Specification Each input file contains one test case. Each case first gives in a line a positive integer N ( \\le \\le 10,000) which is the length of the original string in the shop. Then N positive numbers ( \\le \\le 100) are given in the next line, which are the values of the beads \u2013 here we assume that the types of the beads are numbered from 1 to N, and the i-th number is the value of the i-th type of beads. Finally the last line describes the original string by giving the types of the beads from left to right. All the numbers in a line are separated by spaces. Output Specification For each test case, print in a line the total value of the piece of string that Eva wants, together with the beginning and the ending indices of the piece (start from 0). All the numbers must be separated by a space and there must be no extra spaces at the beginning or the end of the line. Sample Input 8 18 20 2 97 23 12 8 5 3 3 5 8 1 5 2 1 Sample Output 66 3 6 Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , pre [ N ], a [ N ], b [ N ], f [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ), f [ i ] = a [ b [ i ]], f [ i ] += f [ i - 1 ]; memset ( pre , 0 , sizeof pre ); int Max = 0 , l = -1 , r = -1 ; int P = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { P = max ( P , pre [ b [ i ]]); pre [ b [ i ]] = i ; if ( f [ i ] - f [ P ] > Max ) { Max = f [ i ] - f [ P ]; l = P ; r = i - 1 ; } } printf ( \"%d %d %d \\n \" , Max , l , r ); return 0 ; }","title":"1026-String of Colorful Beads"},{"location":"PAT-Top-Level/1026-String%20of%20Colorful%20Beads/#1026-string-of-colorful-beads","text":"","title":"1026 String of Colorful Beads"},{"location":"PAT-Top-Level/1026-String%20of%20Colorful%20Beads/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 150 ms \u5185\u5b58\u9650\u5236: 64 MB Eva would like to buy a string of beads with no repeated colors so she went to a small shop of which the owner had a very long string of beads. However the owner would only like to cut one piece at a time for his customer. With as many as ten thousand beads in the string, Eva needs your help to tell her how to obtain the longest piece of string that contains beads with all different colors. And more, each kind of these beads has a different value. If there are more than one way to get the longest piece, Eva would like to take the most valuable one. It is guaranteed that such a solution is unique. Input Specification Each input file contains one test case. Each case first gives in a line a positive integer N ( \\le \\le 10,000) which is the length of the original string in the shop. Then N positive numbers ( \\le \\le 100) are given in the next line, which are the values of the beads \u2013 here we assume that the types of the beads are numbered from 1 to N, and the i-th number is the value of the i-th type of beads. Finally the last line describes the original string by giving the types of the beads from left to right. All the numbers in a line are separated by spaces. Output Specification For each test case, print in a line the total value of the piece of string that Eva wants, together with the beginning and the ending indices of the piece (start from 0). All the numbers must be separated by a space and there must be no extra spaces at the beginning or the end of the line. Sample Input 8 18 20 2 97 23 12 8 5 3 3 5 8 1 5 2 1 Sample Output 66 3 6","title":"Statement"},{"location":"PAT-Top-Level/1026-String%20of%20Colorful%20Beads/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , pre [ N ], a [ N ], b [ N ], f [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ), f [ i ] = a [ b [ i ]], f [ i ] += f [ i - 1 ]; memset ( pre , 0 , sizeof pre ); int Max = 0 , l = -1 , r = -1 ; int P = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { P = max ( P , pre [ b [ i ]]); pre [ b [ i ]] = i ; if ( f [ i ] - f [ P ] > Max ) { Max = f [ i ] - f [ P ]; l = P ; r = i - 1 ; } } printf ( \"%d %d %d \\n \" , Max , l , r ); return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1027-Larry%20and%20Inversions/","text":"1027 Larry and Inversions Statement Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Larry just studied the algorithm to count number of inversions. He's very interested in it. He's considering another problem: Given a permutation of integers from 1 to n n , how many inversions it has if we reverse one of its subarray? Formally speaking, given an integer array a a (indices are from 0 to n-1 n-1 ) which contains a permutation of integers from 1 to n n , two elements a[i] a[i] and a[j] a[j] form an inversion if a[i] > a[j] a[i] > a[j] and i < j i < j . Your job is to count, for each pair of 0 \\le i \\le j < n 0 \\le i \\le j < n , the number of inversions if we reverse the subarray from a[i] a[i] to a[j] a[j] . Input Specification Each input file contains one test case. Each case consists of a positive integer n n ( \\le 1,000 \\le 1,000 ) in the first line, and a permutation of integers from 1 to n n in the second line. The numbers in a line are separated by a single space. Output Specification For each test case, output n(n + 1) / 2 n(n + 1) / 2 integers in a single line. The results are for reversing subarray indicating by all possible pairs of indices 0 \\le i \\le j < n 0 \\le i \\le j < n in i i -major order \u2013 that is, the first n n results are for the reverse of subarrary [0..0], [0..1], \u2026[0.. n - 1 n - 1 ]; the next n - 1 n - 1 results are for the reverse of subarry [1..1], [1..2],\u2026, [1.. n - 1 n - 1 ] and so on. All the numbers in a line must be separated by a single space, with no extra space at the beginning or the end of the line. Sample Input 3 2 1 3 Sample Output 1 0 2 1 2 1 Hint: The original array is { 2, 1, 3 }. Reversing subarray [0..0] makes { 2, 1, 3 } which has 1 inversion. Reversing subarray [0..1] makes { 1, 2, 3 } which has 0 inversion. Reversing subarray [0..2] makes { 3, 1, 2 } which has 2 inversions. Reversing subarray [1..1] makes { 2, 1, 3 } which has 1 inversion. Reversing subarray [1..2] makes { 2, 3, 1 } which has 2 inversions. Reversing subarrays [2..2] makes { 2, 1, 3 } which has 1 inversion. Solution C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ]; struct BIT { int a [ N ], POS [ N ], pos ; void init () { pos = 0 ; memset ( a , 0 , sizeof a ); memset ( POS , 0 , sizeof POS ); } void update ( int x , int v ) { for (; x < N ; x += x & - x ) { if ( POS [ x ] == pos ) { a [ x ] += v ; } else { POS [ x ] = pos ; a [ x ] = v ; } } } int query ( int x ) { int res = 0 ; for (; x > 0 ; x -= x & - x ) { if ( POS [ x ] == pos ) { res += a [ x ]; } } return res ; } int query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } bit ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { int tot = 0 ; bit . init (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); bit . update ( a [ i ], 1 ); tot += bit . query ( a [ i ] + 1 , n ); } for ( int i = 1 ; i <= n ; ++ i ) { int now = 0 ; ++ bit . pos ; for ( int j = i ; j <= n ; ++ j ) { bit . update ( a [ j ], 1 ); now += bit . query ( a [ j ] + 1 , n ); // cout << i << \" \" << j << \" \" << now << endl; printf ( \"%d%c\" , tot - now * 2 + ( j - i ) * ( j - i + 1 ) / 2 , \" \\n \" [ i == n && j == n ]); } } } return 0 ; }","title":"1027-Larry and Inversions"},{"location":"PAT-Top-Level/1027-Larry%20and%20Inversions/#1027-larry-and-inversions","text":"","title":"1027 Larry and Inversions"},{"location":"PAT-Top-Level/1027-Larry%20and%20Inversions/#statement","text":"Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Larry just studied the algorithm to count number of inversions. He's very interested in it. He's considering another problem: Given a permutation of integers from 1 to n n , how many inversions it has if we reverse one of its subarray? Formally speaking, given an integer array a a (indices are from 0 to n-1 n-1 ) which contains a permutation of integers from 1 to n n , two elements a[i] a[i] and a[j] a[j] form an inversion if a[i] > a[j] a[i] > a[j] and i < j i < j . Your job is to count, for each pair of 0 \\le i \\le j < n 0 \\le i \\le j < n , the number of inversions if we reverse the subarray from a[i] a[i] to a[j] a[j] . Input Specification Each input file contains one test case. Each case consists of a positive integer n n ( \\le 1,000 \\le 1,000 ) in the first line, and a permutation of integers from 1 to n n in the second line. The numbers in a line are separated by a single space. Output Specification For each test case, output n(n + 1) / 2 n(n + 1) / 2 integers in a single line. The results are for reversing subarray indicating by all possible pairs of indices 0 \\le i \\le j < n 0 \\le i \\le j < n in i i -major order \u2013 that is, the first n n results are for the reverse of subarrary [0..0], [0..1], \u2026[0.. n - 1 n - 1 ]; the next n - 1 n - 1 results are for the reverse of subarry [1..1], [1..2],\u2026, [1.. n - 1 n - 1 ] and so on. All the numbers in a line must be separated by a single space, with no extra space at the beginning or the end of the line. Sample Input 3 2 1 3 Sample Output 1 0 2 1 2 1 Hint: The original array is { 2, 1, 3 }. Reversing subarray [0..0] makes { 2, 1, 3 } which has 1 inversion. Reversing subarray [0..1] makes { 1, 2, 3 } which has 0 inversion. Reversing subarray [0..2] makes { 3, 1, 2 } which has 2 inversions. Reversing subarray [1..1] makes { 2, 1, 3 } which has 1 inversion. Reversing subarray [1..2] makes { 2, 3, 1 } which has 2 inversions. Reversing subarrays [2..2] makes { 2, 1, 3 } which has 1 inversion.","title":"Statement"},{"location":"PAT-Top-Level/1027-Larry%20and%20Inversions/#solution","text":"C++ #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , a [ N ]; struct BIT { int a [ N ], POS [ N ], pos ; void init () { pos = 0 ; memset ( a , 0 , sizeof a ); memset ( POS , 0 , sizeof POS ); } void update ( int x , int v ) { for (; x < N ; x += x & - x ) { if ( POS [ x ] == pos ) { a [ x ] += v ; } else { POS [ x ] = pos ; a [ x ] = v ; } } } int query ( int x ) { int res = 0 ; for (; x > 0 ; x -= x & - x ) { if ( POS [ x ] == pos ) { res += a [ x ]; } } return res ; } int query ( int l , int r ) { if ( l > r ) return 0 ; return query ( r ) - query ( l - 1 ); } } bit ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { int tot = 0 ; bit . init (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); bit . update ( a [ i ], 1 ); tot += bit . query ( a [ i ] + 1 , n ); } for ( int i = 1 ; i <= n ; ++ i ) { int now = 0 ; ++ bit . pos ; for ( int j = i ; j <= n ; ++ j ) { bit . update ( a [ j ], 1 ); now += bit . query ( a [ j ] + 1 , n ); // cout << i << \" \" << j << \" \" << now << endl; printf ( \"%d%c\" , tot - now * 2 + ( j - i ) * ( j - i + 1 ) / 2 , \" \\n \" [ i == n && j == n ]); } } } return 0 ; }","title":"Solution"},{"location":"PAT-Top-Level/1028-Do%20All%20Roads%20Lead%20to%20Rome/","text":"1028 Do All Roads Lead to Rome Statement Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 700 ms \u5185\u5b58\u9650\u5236: 64 MB Indeed there are many different tourist routes from our city to Rome. Your job is to count the number of different routes from our city to Rome, and to check if ALL the routes lead to Rome \u2013 that is, whether or not all the routes from our city to Rome can cover every road on the routes from our city to anywhere. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2\\le N\\le 20 2\\le N\\le 20 ), the number of cities, and K K , the total number of roads between pairs of cities; followed by the name of the starting city. Then K K lines follow, each describes a road between two cities in the format City1 City2 . Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome. Output Specification For each test case, first print in a line Yes if all the routes from the starting city lead to ROM , or No if not. Then print in the next line the number of different routes from the starting city to ROM . Here a route is defined to be a simple path , that is, no city along the route will be visited more than once. It is guaranteed that this number is no more than 10^6 10^6 . By the way, it is assumed that ROM is our only destination \u2013 that is, once we reach ROM , we will stop traveling and stay there. Sample Input 1 7 8 HZH PKN HZH GDN ROM ROM HKG PRS PKN PRS BLN HKG PRS ROM BLN HZH GDN Sample Output 1 Yes 3 Sample Input 2 10 11 HZH PKN HZH GDN ROM ROM HKG PRS PKN PRS BLN HKG PRS ROM BLN HZH GDN GDN MAC MAC WWW MAC VVV Sample Output 2 No 3","title":"1028-Do All Roads Lead to Rome"},{"location":"PAT-Top-Level/1028-Do%20All%20Roads%20Lead%20to%20Rome/#1028-do-all-roads-lead-to-rome","text":"","title":"1028 Do All Roads Lead to Rome"},{"location":"PAT-Top-Level/1028-Do%20All%20Roads%20Lead%20to%20Rome/#statement","text":"Metadata \u4f5c\u8005: \u9648\u8d8a \u5355\u4f4d: \u6d59\u6c5f\u5927\u5b66 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 700 ms \u5185\u5b58\u9650\u5236: 64 MB Indeed there are many different tourist routes from our city to Rome. Your job is to count the number of different routes from our city to Rome, and to check if ALL the routes lead to Rome \u2013 that is, whether or not all the routes from our city to Rome can cover every road on the routes from our city to anywhere. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers N N ( 2\\le N\\le 20 2\\le N\\le 20 ), the number of cities, and K K , the total number of roads between pairs of cities; followed by the name of the starting city. Then K K lines follow, each describes a road between two cities in the format City1 City2 . Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome. Output Specification For each test case, first print in a line Yes if all the routes from the starting city lead to ROM , or No if not. Then print in the next line the number of different routes from the starting city to ROM . Here a route is defined to be a simple path , that is, no city along the route will be visited more than once. It is guaranteed that this number is no more than 10^6 10^6 . By the way, it is assumed that ROM is our only destination \u2013 that is, once we reach ROM , we will stop traveling and stay there. Sample Input 1 7 8 HZH PKN HZH GDN ROM ROM HKG PRS PKN PRS BLN HKG PRS ROM BLN HZH GDN Sample Output 1 Yes 3 Sample Input 2 10 11 HZH PKN HZH GDN ROM ROM HKG PRS PKN PRS BLN HKG PRS ROM BLN HZH GDN GDN MAC MAC WWW MAC VVV Sample Output 2 No 3","title":"Statement"},{"location":"PAT-Top-Level/1029-Array%20Cutting%20Score/","text":"1029 Array Cutting Score Statement Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer array of length n n , cut the array into m m ( \\le n \\le n ) subarrays by exactly (m-1) (m-1) cuts. Array cutting score is defined to be the product of all the sums of the subarray elements. Your job is to calculate the product of the scores of all the possible ways of array-cutting. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers n n and m m ( 1\\le m \\le n \\le 10^3 1\\le m \\le n \\le 10^3 ). The second line contains n n positive integers no larger than 10^9 10^9 separated by a single space.. Output Specification Output the product of the scores of all the possible ways of array-cutting in a single line. Since the answer might be too large, output the result modulo 1000000007 ( 10^9 + 7 10^9 + 7 ). Sample Input 5 2 5 1 2 3 4 Sample Output 6652800 Hint: The score of cut (5)(1 2 3 4) is 5 \\times (1+2+3+4) = 50 5 \\times (1+2+3+4) = 50 The score of cut (5 1)(2 3 4) is (5+1) \\times (2+3+4) = 54 (5+1) \\times (2+3+4) = 54 The score of cut (5 1 2)(3 4) is (5+1+2) \\times (3+4)= 56 (5+1+2) \\times (3+4)= 56 The score of cut (5 1 2 3)(4) is (5+1+2+3) \\times 4 = 44 (5+1+2+3) \\times 4 = 44 The final result is 50 \\times 54 \\times 56 \\times 44 = 6652800 50 \\times 54 \\times 56 \\times 44 = 6652800","title":"1029-Array Cutting Score"},{"location":"PAT-Top-Level/1029-Array%20Cutting%20Score/#1029-array-cutting-score","text":"","title":"1029 Array Cutting Score"},{"location":"PAT-Top-Level/1029-Array%20Cutting%20Score/#statement","text":"Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 400 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer array of length n n , cut the array into m m ( \\le n \\le n ) subarrays by exactly (m-1) (m-1) cuts. Array cutting score is defined to be the product of all the sums of the subarray elements. Your job is to calculate the product of the scores of all the possible ways of array-cutting. Input Specification Each input file contains one test case. For each case, the first line contains two positive integers n n and m m ( 1\\le m \\le n \\le 10^3 1\\le m \\le n \\le 10^3 ). The second line contains n n positive integers no larger than 10^9 10^9 separated by a single space.. Output Specification Output the product of the scores of all the possible ways of array-cutting in a single line. Since the answer might be too large, output the result modulo 1000000007 ( 10^9 + 7 10^9 + 7 ). Sample Input 5 2 5 1 2 3 4 Sample Output 6652800 Hint: The score of cut (5)(1 2 3 4) is 5 \\times (1+2+3+4) = 50 5 \\times (1+2+3+4) = 50 The score of cut (5 1)(2 3 4) is (5+1) \\times (2+3+4) = 54 (5+1) \\times (2+3+4) = 54 The score of cut (5 1 2)(3 4) is (5+1+2) \\times (3+4)= 56 (5+1+2) \\times (3+4)= 56 The score of cut (5 1 2 3)(4) is (5+1+2+3) \\times 4 = 44 (5+1+2+3) \\times 4 = 44 The final result is 50 \\times 54 \\times 56 \\times 44 = 6652800 50 \\times 54 \\times 56 \\times 44 = 6652800","title":"Statement"},{"location":"PAT-Top-Level/1030-Beautiful%20Subsequence/","text":"1030 Beautiful Subsequence Statement Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer m m , we consider a sequence (with at least 2 elements) as beautiful if it contains 2 neighbors with difference no larger than m m . Given an integer sequence with n n elements, your job is to calculate the number of beautiful subsequences in it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers n n and m m ( 2 \\le n \\le 10^5 2 \\le n \\le 10^5 , 1 \\le m \\le 10^3 1 \\le m \\le 10^3 ). Then n n positive integers follow in the next line, each no larger than 10^5 10^5 , indicating the sequence. All the numbers in a line are separated by a space. Output Specification Output the number of beautiful subsequences of the original sequence. Since the answer might be too large, output the result modulo 1000000007 ( 10^9 + 7 10^9 + 7 ). Sample Input 4 2 5 3 8 6 Sample Output 8 Hint The beautiful subsequences of the sample input are: (1) Indices {1, 2}, values {5, 3} (2) Indices {1, 4}, values {5, 6} (3) Indices {3, 4}, values {8, 6} (4) Indices {1, 2, 3}, values {5, 3, 8} (5) Indices {1, 2, 4}, values {5, 3, 6} (6) Indices {1, 3, 4}, values {5, 8, 6} (7) Indices {2, 3, 4}, values {3, 8, 6} (8) Indices {1, 2, 3, 4}, values {5, 3, 8, 6}","title":"1030-Beautiful Subsequence"},{"location":"PAT-Top-Level/1030-Beautiful%20Subsequence/#1030-beautiful-subsequence","text":"","title":"1030 Beautiful Subsequence"},{"location":"PAT-Top-Level/1030-Beautiful%20Subsequence/#statement","text":"Metadata \u4f5c\u8005: \u66f9\u9e4f \u5355\u4f4d: Google \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 1000 ms \u5185\u5b58\u9650\u5236: 64 MB Given an integer m m , we consider a sequence (with at least 2 elements) as beautiful if it contains 2 neighbors with difference no larger than m m . Given an integer sequence with n n elements, your job is to calculate the number of beautiful subsequences in it. Input Specification Each input file contains one test case. For each case, the first line contains 2 positive integers n n and m m ( 2 \\le n \\le 10^5 2 \\le n \\le 10^5 , 1 \\le m \\le 10^3 1 \\le m \\le 10^3 ). Then n n positive integers follow in the next line, each no larger than 10^5 10^5 , indicating the sequence. All the numbers in a line are separated by a space. Output Specification Output the number of beautiful subsequences of the original sequence. Since the answer might be too large, output the result modulo 1000000007 ( 10^9 + 7 10^9 + 7 ). Sample Input 4 2 5 3 8 6 Sample Output 8 Hint The beautiful subsequences of the sample input are: (1) Indices {1, 2}, values {5, 3} (2) Indices {1, 4}, values {5, 6} (3) Indices {3, 4}, values {8, 6} (4) Indices {1, 2, 3}, values {5, 3, 8} (5) Indices {1, 2, 4}, values {5, 3, 6} (6) Indices {1, 3, 4}, values {5, 8, 6} (7) Indices {2, 3, 4}, values {3, 8, 6} (8) Indices {1, 2, 3, 4}, values {5, 3, 8, 6}","title":"Statement"},{"location":"PAT-Top-Level/1031-Path%20to%20Infinity/","text":"1031 Path to Infinity Statement Metadata \u4f5c\u8005: W. Caizhi; D. Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB Path to Infinity is a never-ending math mini-game in the RPG Secrets of Grindea. In this mini-game, players are faced with a set of n n pressure plates marked with digits from 0 to 9, another set of (n-1) (n-1) pressure plates marked with operators '+' (addition), '-' (subtraction) or '*' (multiplication) and a target number m m shown in the flame of the green torch on the right. To proceed through this level, players have to step on the pressure plates in the correct order to form an expression whose value is exactly the same with the target number. All the pressure plates must be used exactly once. Note that in this mini-game, all the operators have the same priority and expression is calculated from left to right. For example, expression 1 + 2 * 2 1 + 2 * 2 will be figured out as 6 6 , not 5 5 . You are now presented with one level of such mini-game. How many different expressions can you build from the given digits and operators so that the value of the expression is exactly m m ? Two expressions are considered different if there exists an integer i i such that 1 \\le i \\le n 1 \\le i \\le n and the i i -th operand in the two expressions are different, or if there exists an integer j j such that 1 \\le j < n 1 \\le j < n and the j j -th operator in the two expressions are different. Input Specification There is only one test case. The first line of the input contains two integers n n and m m ( 2 \\le n \\le 10 2 \\le n \\le 10 , -10^9 \\le m \\le 10^9 -10^9 \\le m \\le 10^9 ), indicating the number of digit pressure plates and the target number. The second line of the input contains two strings s s and t t ( |s| = n |s| = n , |t| = n - 1 |t| = n - 1 ) separated by a space. String s s will only contain digits from 0 to 9, where the i i -th digit represents the digit marked on the i i -th digit pressure plate. String t t will only contain operators '+', '-' and '*', where the i i -th operator represents the operator marked on the i i -th operator pressure plate. Output Specification Output two lines. The first line contains an integer indicating the number of different expressions built from the given digits and operators so that its value is exactly m m . The second line contains a string without spaces indicating the desired expression with the smallest lexicographic order. Characters in the expressions are compared by their ASCII code. If one cannot build any desired expression, print \"Impossible\" on the second line instead. Sample Input 1 10 12 3321001233 +++---*** Sample Output 1 424007 0*0*1+2+2+3-1*3-3-3 Sample Input 2 3 2 111 ** Sample Output 2 0 Impossible","title":"1031-Path to Infinity"},{"location":"PAT-Top-Level/1031-Path%20to%20Infinity/#1031-path-to-infinity","text":"","title":"1031 Path to Infinity"},{"location":"PAT-Top-Level/1031-Path%20to%20Infinity/#statement","text":"Metadata \u4f5c\u8005: W. Caizhi; D. Longao \u5355\u4f4d: \u676d\u5dde\u767e\u817e\u6559\u80b2\u79d1\u6280\u6709\u9650\u516c\u53f8 \u4ee3\u7801\u957f\u5ea6\u9650\u5236: 16 KB \u65f6\u95f4\u9650\u5236: 2000 ms \u5185\u5b58\u9650\u5236: 64 MB Path to Infinity is a never-ending math mini-game in the RPG Secrets of Grindea. In this mini-game, players are faced with a set of n n pressure plates marked with digits from 0 to 9, another set of (n-1) (n-1) pressure plates marked with operators '+' (addition), '-' (subtraction) or '*' (multiplication) and a target number m m shown in the flame of the green torch on the right. To proceed through this level, players have to step on the pressure plates in the correct order to form an expression whose value is exactly the same with the target number. All the pressure plates must be used exactly once. Note that in this mini-game, all the operators have the same priority and expression is calculated from left to right. For example, expression 1 + 2 * 2 1 + 2 * 2 will be figured out as 6 6 , not 5 5 . You are now presented with one level of such mini-game. How many different expressions can you build from the given digits and operators so that the value of the expression is exactly m m ? Two expressions are considered different if there exists an integer i i such that 1 \\le i \\le n 1 \\le i \\le n and the i i -th operand in the two expressions are different, or if there exists an integer j j such that 1 \\le j < n 1 \\le j < n and the j j -th operator in the two expressions are different. Input Specification There is only one test case. The first line of the input contains two integers n n and m m ( 2 \\le n \\le 10 2 \\le n \\le 10 , -10^9 \\le m \\le 10^9 -10^9 \\le m \\le 10^9 ), indicating the number of digit pressure plates and the target number. The second line of the input contains two strings s s and t t ( |s| = n |s| = n , |t| = n - 1 |t| = n - 1 ) separated by a space. String s s will only contain digits from 0 to 9, where the i i -th digit represents the digit marked on the i i -th digit pressure plate. String t t will only contain operators '+', '-' and '*', where the i i -th operator represents the operator marked on the i i -th operator pressure plate. Output Specification Output two lines. The first line contains an integer indicating the number of different expressions built from the given digits and operators so that its value is exactly m m . The second line contains a string without spaces indicating the desired expression with the smallest lexicographic order. Characters in the expressions are compared by their ASCII code. If one cannot build any desired expression, print \"Impossible\" on the second line instead. Sample Input 1 10 12 3321001233 +++---*** Sample Output 1 424007 0*0*1+2+2+3-1*3-3-3 Sample Input 2 3 2 111 ** Sample Output 2 0 Impossible","title":"Statement"}]}